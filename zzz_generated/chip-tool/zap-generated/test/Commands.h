/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <commands/common/CommandInvoker.h>
#include <commands/tests/TestCommand.h>
#include <lib/core/Optional.h>
#include <system/SystemClock.h>

#include <math.h> // For INFINITY

class TestList : public Command
{
public:
    TestList() : Command("list"){};
    CHIP_ERROR Run() override
    {
        printf("Test_TC_BI_1_1\n");
        printf("Test_TC_BI_2_1\n");
        printf("Test_TC_BI_2_2\n");
        printf("Test_TC_BOOL_1_1\n");
        printf("Test_TC_BOOL_2_1\n");
        printf("Test_TC_CC_1_1\n");
        printf("Test_TC_CC_2_1\n");
        printf("Test_TC_CC_3_1\n");
        printf("Test_TC_CC_3_2\n");
        printf("Test_TC_CC_3_3\n");
        printf("Test_TC_CC_4_1\n");
        printf("Test_TC_CC_4_2\n");
        printf("Test_TC_CC_4_3\n");
        printf("Test_TC_CC_4_4\n");
        printf("Test_TC_CC_5_1\n");
        printf("Test_TC_CC_5_2\n");
        printf("Test_TC_CC_5_3\n");
        printf("Test_TC_CC_6_1\n");
        printf("Test_TC_CC_6_2\n");
        printf("Test_TC_CC_6_3\n");
        printf("Test_TC_CC_7_1\n");
        printf("Test_TC_CC_7_2\n");
        printf("Test_TC_CC_7_3\n");
        printf("Test_TC_CC_7_4\n");
        printf("Test_TC_CC_8_1\n");
        printf("Test_TC_CC_9_1\n");
        printf("Test_TC_CC_9_2\n");
        printf("Test_TC_CC_9_3\n");
        printf("Test_TC_DM_1_1\n");
        printf("Test_TC_DM_3_1\n");
        printf("Test_TC_DM_2_2\n");
        printf("Test_TC_EMR_1_1\n");
        printf("Test_TC_FLW_1_1\n");
        printf("Test_TC_FLW_2_1\n");
        printf("Test_TC_FLW_2_2\n");
        printf("Test_TC_ILL_1_1\n");
        printf("Test_TC_LVL_1_1\n");
        printf("Test_TC_LVL_2_1\n");
        printf("Test_TC_LVL_3_1\n");
        printf("Test_TC_LVL_4_1\n");
        printf("Test_TC_LVL_5_1\n");
        printf("Test_TC_MC_1_1\n");
        printf("Test_TC_MC_2_1\n");
        printf("Test_TC_MC_3_1\n");
        printf("Test_TC_MC_3_2\n");
        printf("Test_TC_MC_3_3\n");
        printf("Test_TC_MC_3_4\n");
        printf("Test_TC_MC_3_5\n");
        printf("Test_TC_MC_3_6\n");
        printf("Test_TC_MC_3_7\n");
        printf("Test_TC_MC_3_8\n");
        printf("Test_TC_MC_3_9\n");
        printf("Test_TC_MC_3_10\n");
        printf("Test_TC_MC_3_11\n");
        printf("Test_TC_OCC_1_1\n");
        printf("Test_TC_OCC_2_1\n");
        printf("Test_TC_OCC_2_2\n");
        printf("Test_TC_OO_1_1\n");
        printf("Test_TC_OO_2_1\n");
        printf("Test_TC_OO_2_2\n");
        printf("Test_TC_OO_2_3\n");
        printf("Test_TC_PRS_1_1\n");
        printf("Test_TC_PRS_2_1\n");
        printf("Test_TC_PCC_1_1\n");
        printf("Test_TC_PCC_2_1\n");
        printf("Test_TC_PCC_2_2\n");
        printf("Test_TC_PCC_2_3\n");
        printf("Test_TC_RH_1_1\n");
        printf("Test_TC_RH_2_1\n");
        printf("Test_TC_RH_2_2\n");
        printf("Test_TC_TM_1_1\n");
        printf("Test_TC_TM_2_1\n");
        printf("Test_TC_TM_2_2\n");
        printf("Test_TC_TSTAT_1_1\n");
        printf("Test_TC_TSTAT_2_1\n");
        printf("Test_TC_TSTAT_2_2\n");
        printf("Test_TC_TSUIC_1_1\n");
        printf("Test_TC_TSUIC_2_1\n");
        printf("Test_TC_TSUIC_2_2\n");
        printf("Test_TC_DIAGTH_1_1\n");
        printf("Test_TC_WNCV_1_1\n");
        printf("Test_TC_WNCV_2_1\n");
        printf("Test_TC_WNCV_2_2\n");
        printf("Test_TC_WNCV_2_4\n");
        printf("Test_TC_WNCV_2_5\n");
        printf("Test_TC_WNCV_3_1\n");
        printf("Test_TC_WNCV_3_2\n");
        printf("Test_TC_WNCV_3_3\n");
        printf("TV_TargetNavigatorCluster\n");
        printf("TV_AudioOutputCluster\n");
        printf("TV_ApplicationLauncherCluster\n");
        printf("TV_KeypadInputCluster\n");
        printf("TV_AccountLoginCluster\n");
        printf("TV_WakeOnLanCluster\n");
        printf("TV_ApplicationBasicCluster\n");
        printf("TV_MediaPlaybackCluster\n");
        printf("TV_TvChannelCluster\n");
        printf("TV_LowPowerCluster\n");
        printf("TV_MediaInputCluster\n");
        printf("TestCluster\n");
        printf("TestClusterComplexTypes\n");
        printf("TestConstraints\n");
        printf("TestDelayCommands\n");
        printf("TestLogCommands\n");
        printf("TestSaveAs\n");
        printf("TestDescriptorCluster\n");
        printf("TestBasicInformation\n");
        printf("TestIdentifyCluster\n");
        printf("TestGroupsCluster\n");
        printf("TestOperationalCredentialsCluster\n");
        printf("TestModeSelectCluster\n");
        printf("TestGroupMessaging\n");
        printf("Test_TC_DIAGSW_1_1\n");
        printf("Test_TC_DIAGSW_2_1\n");
        printf("Test_TC_DIAGSW_3_2\n");
        printf("TestSubscribe_OnOff\n");

        return CHIP_NO_ERROR;
    }
};

class Test_TC_BI_1_1 : public TestCommand
{
public:
    Test_TC_BI_1_1() : TestCommand("Test_TC_BI_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }
};

class Test_TC_BI_2_1 : public TestCommand
{
public:
    Test_TC_BI_2_1() : TestCommand("Test_TC_BI_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeOutOfService_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read mandatory non-global attribute constraints: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Write the default values to mandatory non-global attribute: OutOfService\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back the mandatory non-global attribute: OutOfService\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read mandatory non-global attribute constraints: PresentValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Write the default values to mandatory non-global attribute: PresentValue\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads back the mandatory non-global attribute: PresentValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributePresentValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read mandatory non-global attribute: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeStatusFlags_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read mandatory non-global attribute constraints: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_9();
            break;
        case 10:
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Write the default values to mandatory non-global attribute: StatusFlags\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads back the mandatory non-global attribute: StatusFlags\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_1(outOfService);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_2(outOfService);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_4(outOfService);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_5(presentValue);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_7(presentValue);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_8(statusFlags);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_9(statusFlags);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_11(statusFlags);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeOutOfService_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool outOfService)
    {
        VerifyOrReturn(CheckValue("outOfService", outOfService, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool outOfService)
    {
        VerifyOrReturn(CheckConstraintType("outOfService", "", "bool"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool outOfServiceArgument;
        outOfServiceArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            outOfServiceArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool outOfService)
    {
        VerifyOrReturn(CheckValue("outOfService", outOfService, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool presentValue)
    {
        VerifyOrReturn(CheckConstraintType("presentValue", "", "bool"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool presentValueArgument;
        presentValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            presentValueArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributePresentValue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool presentValue)
    {
        VerifyOrReturn(CheckValue("presentValue", presentValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStatusFlags_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckConstraintType("statusFlags", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("statusFlags", statusFlags, 15));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t statusFlagsArgument;
        statusFlagsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            statusFlagsArgument, this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_10() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }
};

class Test_TC_BI_2_2 : public TestCommand
{
public:
    Test_TC_BI_2_2() : TestCommand("Test_TC_BI_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads PresentValue attribute from DUT\n");
            err = TestReadsPresentValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads OutOfService attribute from DUT\n");
            err = TestReadsOutOfServiceAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads StatusFlags attribute from DUT\n");
            err = TestReadsStatusFlagsAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads PresentValue attribute from DUT\n");
            err = TestReadsPresentValueAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads OutOfService attribute from DUT\n");
            err = TestReadsOutOfServiceAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads StatusFlags attribute from DUT\n");
            err = TestReadsStatusFlagsAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads StatusFlags attribute from DUT\n");
            err = TestReadsStatusFlagsAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads StatusFlags attribute from DUT\n");
            err = TestReadsStatusFlagsAttributeFromDut_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_1(presentValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_2(outOfService);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_3(statusFlags);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_4(presentValue);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_5(outOfService);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_6(statusFlags);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_7(statusFlags);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_8(statusFlags);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsPresentValueAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool presentValue)
    {
        VerifyOrReturn(CheckValue("presentValue", presentValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOutOfServiceAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool outOfService)
    {
        VerifyOrReturn(CheckValue("outOfService", outOfService, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsPresentValueAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool presentValue)
    {
        VerifyOrReturn(CheckValue("presentValue", presentValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOutOfServiceAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool outOfService)
    {
        VerifyOrReturn(CheckValue("outOfService", outOfService, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue("statusFlags", statusFlags, 0));

        NextTest();
    }
};

class Test_TC_BOOL_1_1 : public TestCommand
{
public:
    Test_TC_BOOL_1_1() : TestCommand("Test_TC_BOOL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }
};

class Test_TC_BOOL_2_1 : public TestCommand
{
public:
    Test_TC_BOOL_2_1() : TestCommand("Test_TC_BOOL_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeStateValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read mandatory non-global attribute constraints: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStateValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Write the default value to mandatory non-global attribute: StateValue\n");
            err = TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back the mandatory non-global attribute: StateValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStateValue_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_1(stateValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_2(stateValue);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_4(stateValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStateValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                          OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool stateValue)
    {
        VerifyOrReturn(CheckValue("stateValue", stateValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStateValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                          OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool stateValue)
    {
        VerifyOrReturn(CheckConstraintType("stateValue", "", "bool"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool stateValueArgument;
        stateValueArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(
            stateValueArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStateValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                          OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool stateValue)
    {
        VerifyOrReturn(CheckValue("stateValue", stateValue, 0));

        NextTest();
    }
};

class Test_TC_CC_1_1 : public TestCommand
{
public:
    Test_TC_CC_1_1() : TestCommand("Test_TC_CC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints : ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_CC_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_CC_1_1 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }
};

class Test_TC_CC_2_1 : public TestCommand
{
public:
    Test_TC_CC_2_1() : TestCommand("Test_TC_CC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads mandatory attribute: CurrentHue\n");
            err = TestReadsMandatoryAttributeCurrentHue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Validate constraints of attribute: current hue\n");
            err = TestValidateConstraintsOfAttributeCurrentHue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write the default value to mandatory attribute: CurrentHue\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads back mandatory attribute: CurrentHue\n");
            err = TestReadsBackMandatoryAttributeCurrentHue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads mandatory attribute: CurrentSaturation\n");
            err = TestReadsMandatoryAttributeCurrentSaturation_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Validate constraints of attribute: CurrentSaturation\n");
            err = TestValidateConstraintsOfAttributeCurrentSaturation_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write the default value to mandatory attribute: CurrentSaturation\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads back mandatory attribute: CurrentSaturation\n");
            err = TestReadsBackMandatoryAttributeCurrentSaturation_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read the mandatory attribute: CurrentX\n");
            err = TestReadTheMandatoryAttributeCurrentX_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Validate constraints of attribute: CurrentX\n");
            err = TestValidateConstraintsOfAttributeCurrentX_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write the default value to mandatory attribute: CurrentX\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentX_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads back mandatory attribute: CurrentX\n");
            err = TestReadsBackMandatoryAttributeCurrentX_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read the mandatory attribute: CurrentY\n");
            err = TestReadTheMandatoryAttributeCurrentY_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Validate constraints of attribute: CurrentY\n");
            err = TestValidateConstraintsOfAttributeCurrentY_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write the default values to mandatory attribute: CurrentY\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads back mandatory attribute: CurrentY\n");
            err = TestReadsBackMandatoryAttributeCurrentY_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Validate constraints of attribute: ColorTemperatureMireds\n");
            err = TestValidateConstraintsOfAttributeColorTemperatureMireds_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Validate constraints of attribute: ColorMode\n");
            err = TestValidateConstraintsOfAttributeColorMode_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read the mandatory attribute: Options\n");
            err = TestReadTheMandatoryAttributeOptions_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Validate constraints of attribute: Options\n");
            err = TestValidateConstraintsOfAttributeOptions_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write the default values to mandatory attribute: Options\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeOptions_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads back mandatory attribute: Options\n");
            err = TestReadsBackMandatoryAttributeOptions_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read the mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadTheMandatoryAttributeEnhancedCurrentHue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Validate constraints of attribute: EnhancedCurrentHue\n");
            err = TestValidateConstraintsOfAttributeEnhancedCurrentHue_24();
            break;
        case 25:
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : Write the default values to mandatory attribute: EnhancedCurrentHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads back mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadsBackMandatoryAttributeEnhancedCurrentHue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Validate constraints of attribute: EnhancedColorMode\n");
            err = TestValidateConstraintsOfAttributeEnhancedColorMode_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read the mandatory attribute: ColorLoopActive\n");
            err = TestReadTheMandatoryAttributeColorLoopActive_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Validate constraints of attribute: ColorLoopActive\n");
            err = TestValidateConstraintsOfAttributeColorLoopActive_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Write the default values to mandatory attribute: ColorLoopActive\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads back mandatory attribute: ColorLoopActive\n");
            err = TestReadsBackMandatoryAttributeColorLoopActive_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read the mandatory attribute: ColorLoopDirection\n");
            err = TestReadTheMandatoryAttributeColorLoopDirection_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Validate constraints of attribute: ColorLoopDirection\n");
            err = TestValidateConstraintsOfAttributeColorLoopDirection_33();
            break;
        case 34:
            ChipLogProgress(chipTool,
                            " ***** Test Step 34 : Write the default values to mandatory attribute: ColorLoopDirection\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads back mandatory attribute: ColorLoopDirection\n");
            err = TestReadsBackMandatoryAttributeColorLoopDirection_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read the mandatory attribute: ColorLoopTime\n");
            err = TestReadTheMandatoryAttributeColorLoopTime_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Validate constraints of attribute: ColorLoopTime\n");
            err = TestValidateConstraintsOfAttributeColorLoopTime_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Write the default values to mandatory attribute: ColorLoopTime\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads back mandatory attribute: ColorLoopTime\n");
            err = TestReadsBackMandatoryAttributeColorLoopTime_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read the mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadTheMandatoryAttributeColorLoopStartEnhancedHue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Validate constraints of attribute: ColorLoopStartEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_41();
            break;
        case 42:
            ChipLogProgress(chipTool,
                            " ***** Test Step 42 : Write the default values to mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads back mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read the mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadTheMandatoryAttributeColorLoopStoredEnhancedHue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Validate constraints of attribute: ColorLoopStoredEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_45();
            break;
        case 46:
            ChipLogProgress(chipTool,
                            " ***** Test Step 46 : Write the default values to mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Reads back mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read the mandatory attribute: ColorCapabilities\n");
            err = TestReadTheMandatoryAttributeColorCapabilities_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Validate constraints of attribute: ColorCapabilities\n");
            err = TestValidateConstraintsOfAttributeColorCapabilities_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Write the default values to mandatory attribute: ColorCapabilities\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Reads back mandatory attribute: ColorCapabilities\n");
            err = TestReadsBackMandatoryAttributeColorCapabilities_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Read the mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadTheMandatoryAttributeColorTempPhysicalMinMireds_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Validate constraints of attribute: ColorTempPhysicalMinMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_53();
            break;
        case 54:
            ChipLogProgress(chipTool,
                            " ***** Test Step 54 : Write the default values to mandatory  attribute: ColorTempPhysicalMinMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Reads back mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read the mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadTheMandatoryAttributeColorTempPhysicalMaxMireds_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Validate constraints of attribute: ColorTempPhysicalMaxMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_57();
            break;
        case 58:
            ChipLogProgress(chipTool,
                            " ***** Test Step 58 : Write the default values to mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Reads back mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Read the optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_60();
            break;
        case 61:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 61 : Write the default values to optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Reads back optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read the optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadTheOptionalAttributeStartUpColorTemperatureMireds_63();
            break;
        case 64:
            ChipLogProgress(
                chipTool, " ***** Test Step 64 : Write the default values to optional attribute: StartUpColorTemperatureMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Reads back optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read the Optional attribute: RemainingTime\n");
            err = TestReadTheOptionalAttributeRemainingTime_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Validate constraints of attribute: RemainingTime\n");
            err = TestValidateConstraintsOfAttributeRemainingTime_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Write the default values to optional attribute: RemainingTime\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Reads back optional attribute: RemainingTime\n");
            err = TestReadsBackOptionalAttributeRemainingTime_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read the optional attribute: DriftCompensation\n");
            err = TestReadTheOptionalAttributeDriftCompensation_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Write the default values to optional attribute: DriftCompensation\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Reads back optional attribute: DriftCompensation\n");
            err = TestReadsBackOptionalAttributeDriftCompensation_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read the optional attribute: CompensationText\n");
            err = TestReadTheOptionalAttributeCompensationText_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadTheMandatoryAttributeNumberOfPrimaries_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write the default mandatory attribute: NumberOfPrimaries\n");
            err = TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read back the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadBackTheMandatoryAttributeNumberOfPrimaries_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Read the mandatory attribute: Primary1X\n");
            err = TestReadTheMandatoryAttributePrimary1X_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Write the default mandatory attribute: Primary1X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1X_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read back the mandatory attribute: Primary1X\n");
            err = TestReadBackTheMandatoryAttributePrimary1X_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Read the mandatory attribute: Primary1Y\n");
            err = TestReadTheMandatoryAttributePrimary1Y_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Write the default mandatory attribute: Primary1Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1Y_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read back the mandatory attribute: Primary1Y\n");
            err = TestReadBackTheMandatoryAttributePrimary1Y_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read the mandatory attribute: Primary1Intensity\n");
            err = TestReadTheMandatoryAttributePrimary1Intensity_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read the mandatory attribute: Primary2X\n");
            err = TestReadTheMandatoryAttributePrimary2X_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Write the default mandatory attribute: Primary2X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2X_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read back the mandatory attribute: Primary2X\n");
            err = TestReadBackTheMandatoryAttributePrimary2X_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read the mandatory attribute: Primary2Y\n");
            err = TestReadTheMandatoryAttributePrimary2Y_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Write the default mandatory attribute: Primary2Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2Y_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Read back the mandatory attribute: Primary2Y\n");
            err = TestReadBackTheMandatoryAttributePrimary2Y_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Validate constraints of attribute: Primary2Intensity\n");
            err = TestValidateConstraintsOfAttributePrimary2Intensity_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Read the mandatory attribute: Primary3X\n");
            err = TestReadTheMandatoryAttributePrimary3X_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Write the default mandatory attribute: Primary3X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3X_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read back the mandatory attribute: Primary3X\n");
            err = TestReadBackTheMandatoryAttributePrimary3X_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read the mandatory attribute: Primary3Y\n");
            err = TestReadTheMandatoryAttributePrimary3Y_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Write the default mandatory attribute: Primary3Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3Y_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read back the mandatory attribute: Primary3Y\n");
            err = TestReadBackTheMandatoryAttributePrimary3Y_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read the mandatory attribute: Primary3Intensity\n");
            err = TestReadTheMandatoryAttributePrimary3Intensity_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Read the mandatory attribute: Primary4X\n");
            err = TestReadTheMandatoryAttributePrimary4X_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Write the default mandatory attribute: Primary4X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4X_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Read back the mandatory attribute: Primary4X\n");
            err = TestReadBackTheMandatoryAttributePrimary4X_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Read the mandatory attribute: Primary4Y\n");
            err = TestReadTheMandatoryAttributePrimary4Y_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Write the default mandatory attribute: Primary4Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4Y_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Read back the mandatory attribute: Primary4Y\n");
            err = TestReadBackTheMandatoryAttributePrimary4Y_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read the mandatory attribute: Primary4Intensity\n");
            err = TestReadTheMandatoryAttributePrimary4Intensity_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Read the mandatory attribute: Primary5X\n");
            err = TestReadTheMandatoryAttributePrimary5X_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Write the default mandatory attribute: Primary5X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5X_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read back the mandatory attribute: Primary5X\n");
            err = TestReadBackTheMandatoryAttributePrimary5X_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Read the mandatory attribute: Primary5Y\n");
            err = TestReadTheMandatoryAttributePrimary5Y_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Write the default mandatory attribute: Primary5Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5Y_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Read back the mandatory attribute: Primary5Y\n");
            err = TestReadBackTheMandatoryAttributePrimary5Y_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read the mandatory attribute: Primary5Intensity\n");
            err = TestReadTheMandatoryAttributePrimary5Intensity_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Read the mandatory attribute: Primary6X\n");
            err = TestReadTheMandatoryAttributePrimary6X_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Write the default mandatory attribute: Primary6X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6X_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Read back the mandatory attribute: Primary6X\n");
            err = TestReadBackTheMandatoryAttributePrimary6X_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Read the mandatory attribute: Primary6Y\n");
            err = TestReadTheMandatoryAttributePrimary6Y_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Write the default mandatory attribute: Primary6Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6Y_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read back the mandatory attribute: Primary6Y\n");
            err = TestReadBackTheMandatoryAttributePrimary6Y_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Read the mandatory attribute: Primary6Intensity\n");
            err = TestReadTheMandatoryAttributePrimary6Intensity_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read the optional attribute: WhitePointX\n");
            err = TestReadTheOptionalAttributeWhitePointX_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Write the default optional attribute: WhitePointX\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointX_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read back the optional attribute: WhitePointX\n");
            err = TestReadBackTheOptionalAttributeWhitePointX_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Read the optional attribute: WhitePointY\n");
            err = TestReadTheOptionalAttributeWhitePointY_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Write the default optional attribute: WhitePointY\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointY_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Read back the optional attribute: WhitePointY\n");
            err = TestReadBackTheOptionalAttributeWhitePointY_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Read the optional attribute: ColorPointRX\n");
            err = TestReadTheOptionalAttributeColorPointRX_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Write the default optional attribute: ColorPointRX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRX_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read back the optional attribute: ColorPointRX\n");
            err = TestReadBackTheOptionalAttributeColorPointRX_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Read the optional attribute: ColorPointRY\n");
            err = TestReadTheOptionalAttributeColorPointRY_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Write the default optional attribute: ColorPointRY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRY_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Read back the optional attribute: ColorPointRY\n");
            err = TestReadBackTheOptionalAttributeColorPointRY_130();
            break;
        case 131:
            ChipLogProgress(chipTool, " ***** Test Step 131 : Read the optional attribute: ColorPointRIntensity\n");
            err = TestReadTheOptionalAttributeColorPointRIntensity_131();
            break;
        case 132:
            ChipLogProgress(chipTool, " ***** Test Step 132 : Read the optional attribute: ColorPointGX\n");
            err = TestReadTheOptionalAttributeColorPointGX_132();
            break;
        case 133:
            ChipLogProgress(chipTool, " ***** Test Step 133 : Write the default optional attribute: ColorPointGX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGX_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Read back the optional attribute: ColorPointGX\n");
            err = TestReadBackTheOptionalAttributeColorPointGX_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Read the optional attribute: ColorPointGY\n");
            err = TestReadTheOptionalAttributeColorPointGY_135();
            break;
        case 136:
            ChipLogProgress(chipTool, " ***** Test Step 136 : Write the default optional attribute: ColorPointGY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGY_136();
            break;
        case 137:
            ChipLogProgress(chipTool, " ***** Test Step 137 : Read back the optional attribute: ColorPointGY\n");
            err = TestReadBackTheOptionalAttributeColorPointGY_137();
            break;
        case 138:
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read the optional attribute: ColorPointGIntensity\n");
            err = TestReadTheOptionalAttributeColorPointGIntensity_138();
            break;
        case 139:
            ChipLogProgress(chipTool, " ***** Test Step 139 : Read the optional attribute: ColorPointBX\n");
            err = TestReadTheOptionalAttributeColorPointBX_139();
            break;
        case 140:
            ChipLogProgress(chipTool, " ***** Test Step 140 : Write the default optional attribute: ColorPointBX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBX_140();
            break;
        case 141:
            ChipLogProgress(chipTool, " ***** Test Step 141 : Read back the optional attribute: ColorPointBX\n");
            err = TestReadBackTheOptionalAttributeColorPointBX_141();
            break;
        case 142:
            ChipLogProgress(chipTool, " ***** Test Step 142 : Read the optional attribute: ColorPointBY\n");
            err = TestReadTheOptionalAttributeColorPointBY_142();
            break;
        case 143:
            ChipLogProgress(chipTool, " ***** Test Step 143 : Write the default optional attribute: ColorPointBY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBY_143();
            break;
        case 144:
            ChipLogProgress(chipTool, " ***** Test Step 144 : Read back the optional attribute: ColorPointBY\n");
            err = TestReadBackTheOptionalAttributeColorPointBY_144();
            break;
        case 145:
            ChipLogProgress(chipTool, " ***** Test Step 145 : Read the optional attribute: ColorPointBIntensity\n");
            err = TestReadTheOptionalAttributeColorPointBIntensity_145();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 146;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_1(currentHue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_2(currentHue);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_4(currentHue);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_5(currentSaturation);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_6(currentSaturation);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_8(currentSaturation);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_9(currentX);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_10(currentX);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_12(currentX);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_13(currentY);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_14(currentY);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_16(currentY);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, uint16_t colorTemperature)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_17(colorTemperature);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, uint8_t colorMode)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_18(colorMode);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_19(colorControlOptions);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_20(colorControlOptions);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_21(); }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_22(colorControlOptions);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_23(enhancedCurrentHue);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_24(enhancedCurrentHue);
    }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_25(); }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_26(enhancedCurrentHue);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context, uint8_t enhancedColorMode)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_27(enhancedColorMode);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_28(colorLoopActive);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_29(colorLoopActive);
    }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_30(); }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_31(colorLoopActive);
    }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_32(colorLoopDirection);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_33(colorLoopDirection);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_34(); }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_35(colorLoopDirection);
    }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_36(colorLoopTime);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_37(colorLoopTime);
    }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_38(); }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_39(colorLoopTime);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_40(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_41(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_43(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_44(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_45(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_46(); }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_47(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_48(colorCapabilities);
    }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_49(colorCapabilities);
    }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_50(); }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_51(colorCapabilities);
    }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_52(colorTempPhysicalMin);
    }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_53(colorTempPhysicalMin);
    }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_54(); }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_55(colorTempPhysicalMin);
    }

    static void OnFailureCallback_56(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_56(chip::to_underlying(status));
    }

    static void OnSuccessCallback_56(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_56(colorTempPhysicalMax);
    }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_57(colorTempPhysicalMax);
    }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_58(); }

    static void OnFailureCallback_59(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_59(chip::to_underlying(status));
    }

    static void OnSuccessCallback_59(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_59(colorTempPhysicalMax);
    }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context, uint16_t coupleColorTempToLevelMinMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_60(coupleColorTempToLevelMinMireds);
    }

    static void OnFailureCallback_61(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_61(chip::to_underlying(status));
    }

    static void OnSuccessCallback_61(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_61(); }

    static void OnFailureCallback_62(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_62(chip::to_underlying(status));
    }

    static void OnSuccessCallback_62(void * context, uint16_t coupleColorTempToLevelMinMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_62(coupleColorTempToLevelMinMireds);
    }

    static void OnFailureCallback_63(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_63(chip::to_underlying(status));
    }

    static void OnSuccessCallback_63(void * context, uint16_t startUpColorTemperatureMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_63(startUpColorTemperatureMireds);
    }

    static void OnFailureCallback_64(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_64(chip::to_underlying(status));
    }

    static void OnSuccessCallback_64(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_64(); }

    static void OnFailureCallback_65(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_65(chip::to_underlying(status));
    }

    static void OnSuccessCallback_65(void * context, uint16_t startUpColorTemperatureMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_65(startUpColorTemperatureMireds);
    }

    static void OnFailureCallback_66(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_66(chip::to_underlying(status));
    }

    static void OnSuccessCallback_66(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_66(remainingTime);
    }

    static void OnFailureCallback_67(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_67(chip::to_underlying(status));
    }

    static void OnSuccessCallback_67(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_67(remainingTime);
    }

    static void OnFailureCallback_68(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_68(chip::to_underlying(status));
    }

    static void OnSuccessCallback_68(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_68(); }

    static void OnFailureCallback_69(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_69(chip::to_underlying(status));
    }

    static void OnSuccessCallback_69(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_69(remainingTime);
    }

    static void OnFailureCallback_70(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_70(chip::to_underlying(status));
    }

    static void OnSuccessCallback_70(void * context, uint8_t driftCompensation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_70(driftCompensation);
    }

    static void OnFailureCallback_71(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_71(chip::to_underlying(status));
    }

    static void OnSuccessCallback_71(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_71(); }

    static void OnFailureCallback_72(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_72(chip::to_underlying(status));
    }

    static void OnSuccessCallback_72(void * context, uint8_t driftCompensation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_72(driftCompensation);
    }

    static void OnFailureCallback_73(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_73(chip::to_underlying(status));
    }

    static void OnSuccessCallback_73(void * context, chip::CharSpan compensationText)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_73(compensationText);
    }

    static void OnFailureCallback_74(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_74(chip::to_underlying(status));
    }

    static void OnSuccessCallback_74(void * context, uint8_t numberOfPrimaries)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_74(numberOfPrimaries);
    }

    static void OnFailureCallback_75(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_75(chip::to_underlying(status));
    }

    static void OnSuccessCallback_75(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_75(); }

    static void OnFailureCallback_76(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_76(chip::to_underlying(status));
    }

    static void OnSuccessCallback_76(void * context, uint8_t numberOfPrimaries)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_76(numberOfPrimaries);
    }

    static void OnFailureCallback_77(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_77(chip::to_underlying(status));
    }

    static void OnSuccessCallback_77(void * context, uint16_t primary1X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_77(primary1X);
    }

    static void OnFailureCallback_78(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_78(chip::to_underlying(status));
    }

    static void OnSuccessCallback_78(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_78(); }

    static void OnFailureCallback_79(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_79(chip::to_underlying(status));
    }

    static void OnSuccessCallback_79(void * context, uint16_t primary1X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_79(primary1X);
    }

    static void OnFailureCallback_80(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_80(chip::to_underlying(status));
    }

    static void OnSuccessCallback_80(void * context, uint16_t primary1Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_80(primary1Y);
    }

    static void OnFailureCallback_81(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_81(chip::to_underlying(status));
    }

    static void OnSuccessCallback_81(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_81(); }

    static void OnFailureCallback_82(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_82(chip::to_underlying(status));
    }

    static void OnSuccessCallback_82(void * context, uint16_t primary1Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_82(primary1Y);
    }

    static void OnFailureCallback_83(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_83(chip::to_underlying(status));
    }

    static void OnSuccessCallback_83(void * context, uint8_t primary1Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_83(primary1Intensity);
    }

    static void OnFailureCallback_84(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_84(chip::to_underlying(status));
    }

    static void OnSuccessCallback_84(void * context, uint16_t primary2X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_84(primary2X);
    }

    static void OnFailureCallback_85(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_85(chip::to_underlying(status));
    }

    static void OnSuccessCallback_85(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_85(); }

    static void OnFailureCallback_86(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_86(chip::to_underlying(status));
    }

    static void OnSuccessCallback_86(void * context, uint16_t primary2X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_86(primary2X);
    }

    static void OnFailureCallback_87(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_87(chip::to_underlying(status));
    }

    static void OnSuccessCallback_87(void * context, uint16_t primary2Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_87(primary2Y);
    }

    static void OnFailureCallback_88(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_88(chip::to_underlying(status));
    }

    static void OnSuccessCallback_88(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_88(); }

    static void OnFailureCallback_89(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_89(chip::to_underlying(status));
    }

    static void OnSuccessCallback_89(void * context, uint16_t primary2Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_89(primary2Y);
    }

    static void OnFailureCallback_90(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_90(chip::to_underlying(status));
    }

    static void OnSuccessCallback_90(void * context, uint8_t primary2Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_90(primary2Intensity);
    }

    static void OnFailureCallback_91(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_91(chip::to_underlying(status));
    }

    static void OnSuccessCallback_91(void * context, uint16_t primary3X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_91(primary3X);
    }

    static void OnFailureCallback_92(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_92(chip::to_underlying(status));
    }

    static void OnSuccessCallback_92(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_92(); }

    static void OnFailureCallback_93(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_93(chip::to_underlying(status));
    }

    static void OnSuccessCallback_93(void * context, uint16_t primary3X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_93(primary3X);
    }

    static void OnFailureCallback_94(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_94(chip::to_underlying(status));
    }

    static void OnSuccessCallback_94(void * context, uint16_t primary3Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_94(primary3Y);
    }

    static void OnFailureCallback_95(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_95(chip::to_underlying(status));
    }

    static void OnSuccessCallback_95(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_95(); }

    static void OnFailureCallback_96(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_96(chip::to_underlying(status));
    }

    static void OnSuccessCallback_96(void * context, uint16_t primary3Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_96(primary3Y);
    }

    static void OnFailureCallback_97(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_97(chip::to_underlying(status));
    }

    static void OnSuccessCallback_97(void * context, uint8_t primary3Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_97(primary3Intensity);
    }

    static void OnFailureCallback_98(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_98(chip::to_underlying(status));
    }

    static void OnSuccessCallback_98(void * context, uint16_t primary4X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_98(primary4X);
    }

    static void OnFailureCallback_99(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_99(chip::to_underlying(status));
    }

    static void OnSuccessCallback_99(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_99(); }

    static void OnFailureCallback_100(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_100(chip::to_underlying(status));
    }

    static void OnSuccessCallback_100(void * context, uint16_t primary4X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_100(primary4X);
    }

    static void OnFailureCallback_101(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_101(chip::to_underlying(status));
    }

    static void OnSuccessCallback_101(void * context, uint16_t primary4Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_101(primary4Y);
    }

    static void OnFailureCallback_102(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_102(chip::to_underlying(status));
    }

    static void OnSuccessCallback_102(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_102(); }

    static void OnFailureCallback_103(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_103(chip::to_underlying(status));
    }

    static void OnSuccessCallback_103(void * context, uint16_t primary4Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_103(primary4Y);
    }

    static void OnFailureCallback_104(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_104(chip::to_underlying(status));
    }

    static void OnSuccessCallback_104(void * context, uint8_t primary4Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_104(primary4Intensity);
    }

    static void OnFailureCallback_105(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_105(chip::to_underlying(status));
    }

    static void OnSuccessCallback_105(void * context, uint16_t primary5X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_105(primary5X);
    }

    static void OnFailureCallback_106(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_106(chip::to_underlying(status));
    }

    static void OnSuccessCallback_106(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_106(); }

    static void OnFailureCallback_107(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_107(chip::to_underlying(status));
    }

    static void OnSuccessCallback_107(void * context, uint16_t primary5X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_107(primary5X);
    }

    static void OnFailureCallback_108(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_108(chip::to_underlying(status));
    }

    static void OnSuccessCallback_108(void * context, uint16_t primary5Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_108(primary5Y);
    }

    static void OnFailureCallback_109(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_109(chip::to_underlying(status));
    }

    static void OnSuccessCallback_109(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_109(); }

    static void OnFailureCallback_110(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_110(chip::to_underlying(status));
    }

    static void OnSuccessCallback_110(void * context, uint16_t primary5Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_110(primary5Y);
    }

    static void OnFailureCallback_111(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_111(chip::to_underlying(status));
    }

    static void OnSuccessCallback_111(void * context, uint8_t primary5Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_111(primary5Intensity);
    }

    static void OnFailureCallback_112(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_112(chip::to_underlying(status));
    }

    static void OnSuccessCallback_112(void * context, uint16_t primary6X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_112(primary6X);
    }

    static void OnFailureCallback_113(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_113(chip::to_underlying(status));
    }

    static void OnSuccessCallback_113(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_113(); }

    static void OnFailureCallback_114(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_114(chip::to_underlying(status));
    }

    static void OnSuccessCallback_114(void * context, uint16_t primary6X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_114(primary6X);
    }

    static void OnFailureCallback_115(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_115(chip::to_underlying(status));
    }

    static void OnSuccessCallback_115(void * context, uint16_t primary6Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_115(primary6Y);
    }

    static void OnFailureCallback_116(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_116(chip::to_underlying(status));
    }

    static void OnSuccessCallback_116(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_116(); }

    static void OnFailureCallback_117(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_117(chip::to_underlying(status));
    }

    static void OnSuccessCallback_117(void * context, uint16_t primary6Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_117(primary6Y);
    }

    static void OnFailureCallback_118(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_118(chip::to_underlying(status));
    }

    static void OnSuccessCallback_118(void * context, uint8_t primary6Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_118(primary6Intensity);
    }

    static void OnFailureCallback_119(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_119(chip::to_underlying(status));
    }

    static void OnSuccessCallback_119(void * context, uint16_t whitePointX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_119(whitePointX);
    }

    static void OnFailureCallback_120(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_120(chip::to_underlying(status));
    }

    static void OnSuccessCallback_120(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_120(); }

    static void OnFailureCallback_121(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_121(chip::to_underlying(status));
    }

    static void OnSuccessCallback_121(void * context, uint16_t whitePointX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_121(whitePointX);
    }

    static void OnFailureCallback_122(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_122(chip::to_underlying(status));
    }

    static void OnSuccessCallback_122(void * context, uint16_t whitePointY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_122(whitePointY);
    }

    static void OnFailureCallback_123(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_123(chip::to_underlying(status));
    }

    static void OnSuccessCallback_123(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_123(); }

    static void OnFailureCallback_124(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_124(chip::to_underlying(status));
    }

    static void OnSuccessCallback_124(void * context, uint16_t whitePointY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_124(whitePointY);
    }

    static void OnFailureCallback_125(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_125(chip::to_underlying(status));
    }

    static void OnSuccessCallback_125(void * context, uint16_t colorPointRX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_125(colorPointRX);
    }

    static void OnFailureCallback_126(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_126(chip::to_underlying(status));
    }

    static void OnSuccessCallback_126(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_126(); }

    static void OnFailureCallback_127(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_127(chip::to_underlying(status));
    }

    static void OnSuccessCallback_127(void * context, uint16_t colorPointRX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_127(colorPointRX);
    }

    static void OnFailureCallback_128(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_128(chip::to_underlying(status));
    }

    static void OnSuccessCallback_128(void * context, uint16_t colorPointRY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_128(colorPointRY);
    }

    static void OnFailureCallback_129(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_129(chip::to_underlying(status));
    }

    static void OnSuccessCallback_129(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_129(); }

    static void OnFailureCallback_130(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_130(chip::to_underlying(status));
    }

    static void OnSuccessCallback_130(void * context, uint16_t colorPointRY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_130(colorPointRY);
    }

    static void OnFailureCallback_131(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_131(chip::to_underlying(status));
    }

    static void OnSuccessCallback_131(void * context, uint8_t colorPointRIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_131(colorPointRIntensity);
    }

    static void OnFailureCallback_132(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_132(chip::to_underlying(status));
    }

    static void OnSuccessCallback_132(void * context, uint16_t colorPointGX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_132(colorPointGX);
    }

    static void OnFailureCallback_133(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_133(chip::to_underlying(status));
    }

    static void OnSuccessCallback_133(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_133(); }

    static void OnFailureCallback_134(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_134(chip::to_underlying(status));
    }

    static void OnSuccessCallback_134(void * context, uint16_t colorPointGX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_134(colorPointGX);
    }

    static void OnFailureCallback_135(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_135(chip::to_underlying(status));
    }

    static void OnSuccessCallback_135(void * context, uint16_t colorPointGY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_135(colorPointGY);
    }

    static void OnFailureCallback_136(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_136(chip::to_underlying(status));
    }

    static void OnSuccessCallback_136(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_136(); }

    static void OnFailureCallback_137(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_137(chip::to_underlying(status));
    }

    static void OnSuccessCallback_137(void * context, uint16_t colorPointGY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_137(colorPointGY);
    }

    static void OnFailureCallback_138(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_138(chip::to_underlying(status));
    }

    static void OnSuccessCallback_138(void * context, uint8_t colorPointGIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_138(colorPointGIntensity);
    }

    static void OnFailureCallback_139(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_139(chip::to_underlying(status));
    }

    static void OnSuccessCallback_139(void * context, uint16_t colorPointBX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_139(colorPointBX);
    }

    static void OnFailureCallback_140(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_140(chip::to_underlying(status));
    }

    static void OnSuccessCallback_140(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_140(); }

    static void OnFailureCallback_141(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_141(chip::to_underlying(status));
    }

    static void OnSuccessCallback_141(void * context, uint16_t colorPointBX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_141(colorPointBX);
    }

    static void OnFailureCallback_142(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_142(chip::to_underlying(status));
    }

    static void OnSuccessCallback_142(void * context, uint16_t colorPointBY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_142(colorPointBY);
    }

    static void OnFailureCallback_143(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_143(chip::to_underlying(status));
    }

    static void OnSuccessCallback_143(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_143(); }

    static void OnFailureCallback_144(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_144(chip::to_underlying(status));
    }

    static void OnSuccessCallback_144(void * context, uint16_t colorPointBY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_144(colorPointBY);
    }

    static void OnFailureCallback_145(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_145(chip::to_underlying(status));
    }

    static void OnSuccessCallback_145(void * context, uint8_t colorPointBIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_145(colorPointBIntensity);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsMandatoryAttributeCurrentHue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                          OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t currentHue)
    {
        VerifyOrReturn(CheckValue("currentHue", currentHue, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentHue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                          OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t currentHue)
    {
        VerifyOrReturn(CheckConstraintType("currentHue", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentHue", currentHue, 254));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t currentHueArgument;
        currentHueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(
            currentHueArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentHue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                          OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t currentHue)
    {
        VerifyOrReturn(CheckValue("currentHue", currentHue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeCurrentSaturation_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckValue("currentSaturation", currentSaturation, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentSaturation_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckConstraintType("currentSaturation", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentSaturation", currentSaturation, 254));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t currentSaturationArgument;
        currentSaturationArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            currentSaturationArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentSaturation_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckValue("currentSaturation", currentSaturation, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCurrentX_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(this, OnSuccessCallback_9,
                                                                                                        OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint16_t currentX)
    {
        VerifyOrReturn(CheckValue("currentX", currentX, 24939U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentX_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(this, OnSuccessCallback_10,
                                                                                                        OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint16_t currentX)
    {
        VerifyOrReturn(CheckConstraintType("currentX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentX", currentX, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentX_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t currentXArgument;
        currentXArgument = 24939U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(
            currentXArgument, this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_11() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentX_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(this, OnSuccessCallback_12,
                                                                                                        OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint16_t currentX)
    {
        VerifyOrReturn(CheckValue("currentX", currentX, 24939U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCurrentY_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(this, OnSuccessCallback_13,
                                                                                                        OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint16_t currentY)
    {
        VerifyOrReturn(CheckValue("currentY", currentY, 24701U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentY_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(this, OnSuccessCallback_14,
                                                                                                        OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint16_t currentY)
    {
        VerifyOrReturn(CheckConstraintType("currentY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentY", currentY, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t currentYArgument;
        currentYArgument = 24701U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(
            currentYArgument, this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_15() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentY_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(this, OnSuccessCallback_16,
                                                                                                        OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t currentY)
    {
        VerifyOrReturn(CheckValue("currentY", currentY, 24701U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTemperatureMireds_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTemperature::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint16_t colorTemperature)
    {
        VerifyOrReturn(CheckConstraintType("colorTemperature", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTemperature", colorTemperature, 65279));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorMode_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorMode::TypeInfo>(this, OnSuccessCallback_18,
                                                                                                         OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint8_t colorMode)
    {
        VerifyOrReturn(CheckConstraintType("colorMode", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("colorMode", colorMode, 2));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeOptions_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckValue("colorControlOptions", colorControlOptions, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeOptions_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckConstraintType("colorControlOptions", "", "map8"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeOptions_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorControlOptionsArgument;
        colorControlOptionsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            colorControlOptionsArgument, this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOptions_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckValue("colorControlOptions", colorControlOptions, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEnhancedCurrentHue_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedCurrentHue_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enhancedCurrentHueArgument;
        enhancedCurrentHueArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            enhancedCurrentHueArgument, this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_25() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeEnhancedCurrentHue_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedColorMode_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedColorMode::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint8_t enhancedColorMode)
    {
        VerifyOrReturn(CheckConstraintType("enhancedColorMode", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopActive_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopActive_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopActive", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorLoopActiveArgument;
        colorLoopActiveArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            colorLoopActiveArgument, this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_30() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopActive_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopDirection_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopDirection_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopDirection", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t colorLoopDirectionArgument;
        colorLoopDirectionArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            colorLoopDirectionArgument, this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_34() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopDirection_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopTime_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 25U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopTime_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopTime", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorLoopTimeArgument;
        colorLoopTimeArgument = 25U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            colorLoopTimeArgument, this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_38() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopTime_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 25U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopStartEnhancedHue_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 8960U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStartEnhancedHue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorLoopStartEnhancedHueArgument;
        colorLoopStartEnhancedHueArgument = 8960U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            colorLoopStartEnhancedHueArgument, this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_42() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 8960U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopStoredEnhancedHue_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorLoopStoredEnhancedHueArgument;
        colorLoopStoredEnhancedHueArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            colorLoopStoredEnhancedHueArgument, this, OnSuccessCallback_46, OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_46() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorCapabilities_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckValue("colorCapabilities", colorCapabilities, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorCapabilities_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_49, OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckConstraintType("colorCapabilities", "", "map16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorCapabilities", colorCapabilities, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorCapabilitiesArgument;
        colorCapabilitiesArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            colorCapabilitiesArgument, this, OnSuccessCallback_50, OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_50() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorCapabilities_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckValue("colorCapabilities", colorCapabilities, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorTempPhysicalMinMireds_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_52, OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckValue("colorTempPhysicalMin", colorTempPhysicalMin, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_53, OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckConstraintType("colorTempPhysicalMin", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorTempPhysicalMinArgument;
        colorTempPhysicalMinArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            colorTempPhysicalMinArgument, this, OnSuccessCallback_54, OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_54() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_55()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_55, OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckValue("colorTempPhysicalMin", colorTempPhysicalMin, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorTempPhysicalMaxMireds_56()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_56, OnFailureCallback_56);
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckValue("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_57()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_57, OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_57(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckConstraintType("colorTempPhysicalMax", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_58()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorTempPhysicalMaxArgument;
        colorTempPhysicalMaxArgument = 65279U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            colorTempPhysicalMaxArgument, this, OnSuccessCallback_58, OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_58() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_59()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_59, OnFailureCallback_59);
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckValue("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_60()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
            this, OnSuccessCallback_60, OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_60(uint16_t coupleColorTempToLevelMinMireds)
    {
        VerifyOrReturn(CheckConstraintType("coupleColorTempToLevelMinMireds", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_61()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t coupleColorTempToLevelMinMiredsArgument;
        coupleColorTempToLevelMinMiredsArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
            coupleColorTempToLevelMinMiredsArgument, this, OnSuccessCallback_61, OnFailureCallback_61);
    }

    void OnFailureResponse_61(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_61() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_62()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
            this, OnSuccessCallback_62, OnFailureCallback_62);
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62(uint16_t coupleColorTempToLevelMinMireds)
    {
        VerifyOrReturn(CheckValue("coupleColorTempToLevelMinMireds", coupleColorTempToLevelMinMireds, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeStartUpColorTemperatureMireds_63()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
            this, OnSuccessCallback_63, OnFailureCallback_63);
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63(uint16_t startUpColorTemperatureMireds)
    {
        VerifyOrReturn(CheckConstraintType("startUpColorTemperatureMireds", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_64()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t startUpColorTemperatureMiredsArgument;
        startUpColorTemperatureMiredsArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
            startUpColorTemperatureMiredsArgument, this, OnSuccessCallback_64, OnFailureCallback_64);
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64() { NextTest(); }

    CHIP_ERROR TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_65()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
            this, OnSuccessCallback_65, OnFailureCallback_65);
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65(uint16_t startUpColorTemperatureMireds)
    {
        VerifyOrReturn(CheckValue("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeRemainingTime_66()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_66, OnFailureCallback_66);
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue("remainingTime", remainingTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeRemainingTime_67()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_67, OnFailureCallback_67);
    }

    void OnFailureResponse_67(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_67(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckConstraintType("remainingTime", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("remainingTime", remainingTime, 254));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_68()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t remainingTimeArgument;
        remainingTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            remainingTimeArgument, this, OnSuccessCallback_68, OnFailureCallback_68);
    }

    void OnFailureResponse_68(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_68() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeRemainingTime_69()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_69, OnFailureCallback_69);
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue("remainingTime", remainingTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeDriftCompensation_70()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            this, OnSuccessCallback_70, OnFailureCallback_70);
    }

    void OnFailureResponse_70(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_70(uint8_t driftCompensation)
    {
        VerifyOrReturn(CheckConstraintType("driftCompensation", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("driftCompensation", driftCompensation, 4));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_71()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t driftCompensationArgument;
        driftCompensationArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            driftCompensationArgument, this, OnSuccessCallback_71, OnFailureCallback_71);
    }

    void OnFailureResponse_71(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_71() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeDriftCompensation_72()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            this, OnSuccessCallback_72, OnFailureCallback_72);
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72(uint8_t driftCompensation)
    {
        VerifyOrReturn(CheckValue("driftCompensation", driftCompensation, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeCompensationText_73()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CompensationText::TypeInfo>(
            this, OnSuccessCallback_73, OnFailureCallback_73);
    }

    void OnFailureResponse_73(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_73(chip::CharSpan compensationText)
    {
        VerifyOrReturn(CheckConstraintType("compensationText", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("compensationText", compensationText.size(), 254));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeNumberOfPrimaries_74()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            this, OnSuccessCallback_74, OnFailureCallback_74);
    }

    void OnFailureResponse_74(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_74(uint8_t numberOfPrimaries)
    {
        VerifyOrReturn(CheckConstraintType("numberOfPrimaries", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("numberOfPrimaries", numberOfPrimaries, 6));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_75()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t numberOfPrimariesArgument;
        numberOfPrimariesArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            numberOfPrimariesArgument, this, OnSuccessCallback_75, OnFailureCallback_75);
    }

    void OnFailureResponse_75(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_75() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributeNumberOfPrimaries_76()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            this, OnSuccessCallback_76, OnFailureCallback_76);
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76(uint8_t numberOfPrimaries)
    {
        VerifyOrReturn(CheckValue("numberOfPrimaries", numberOfPrimaries, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1X_77()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(this, OnSuccessCallback_77,
                                                                                                         OnFailureCallback_77);
    }

    void OnFailureResponse_77(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_77(uint16_t primary1X)
    {
        VerifyOrReturn(CheckConstraintType("primary1X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1X", primary1X, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1X_78()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary1XArgument;
        primary1XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(
            primary1XArgument, this, OnSuccessCallback_78, OnFailureCallback_78);
    }

    void OnFailureResponse_78(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_78() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1X_79()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(this, OnSuccessCallback_79,
                                                                                                         OnFailureCallback_79);
    }

    void OnFailureResponse_79(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_79(uint16_t primary1X)
    {
        VerifyOrReturn(CheckValue("primary1X", primary1X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Y_80()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(this, OnSuccessCallback_80,
                                                                                                         OnFailureCallback_80);
    }

    void OnFailureResponse_80(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_80(uint16_t primary1Y)
    {
        VerifyOrReturn(CheckConstraintType("primary1Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1Y", primary1Y, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1Y_81()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary1YArgument;
        primary1YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(
            primary1YArgument, this, OnSuccessCallback_81, OnFailureCallback_81);
    }

    void OnFailureResponse_81(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_81() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1Y_82()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(this, OnSuccessCallback_82,
                                                                                                         OnFailureCallback_82);
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82(uint16_t primary1Y)
    {
        VerifyOrReturn(CheckValue("primary1Y", primary1Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Intensity_83()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Intensity::TypeInfo>(
            this, OnSuccessCallback_83, OnFailureCallback_83);
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83(uint8_t primary1Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary1Intensity", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2X_84()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(this, OnSuccessCallback_84,
                                                                                                         OnFailureCallback_84);
    }

    void OnFailureResponse_84(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_84(uint16_t primary2X)
    {
        VerifyOrReturn(CheckConstraintType("primary2X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2X", primary2X, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2X_85()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary2XArgument;
        primary2XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(
            primary2XArgument, this, OnSuccessCallback_85, OnFailureCallback_85);
    }

    void OnFailureResponse_85(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_85() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2X_86()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(this, OnSuccessCallback_86,
                                                                                                         OnFailureCallback_86);
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86(uint16_t primary2X)
    {
        VerifyOrReturn(CheckValue("primary2X", primary2X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2Y_87()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(this, OnSuccessCallback_87,
                                                                                                         OnFailureCallback_87);
    }

    void OnFailureResponse_87(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_87(uint16_t primary2Y)
    {
        VerifyOrReturn(CheckConstraintType("primary2Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2Y", primary2Y, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2Y_88()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary2YArgument;
        primary2YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(
            primary2YArgument, this, OnSuccessCallback_88, OnFailureCallback_88);
    }

    void OnFailureResponse_88(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_88() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2Y_89()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(this, OnSuccessCallback_89,
                                                                                                         OnFailureCallback_89);
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89(uint16_t primary2Y)
    {
        VerifyOrReturn(CheckValue("primary2Y", primary2Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributePrimary2Intensity_90()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Intensity::TypeInfo>(
            this, OnSuccessCallback_90, OnFailureCallback_90);
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90(uint8_t primary2Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary2Intensity", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3X_91()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(this, OnSuccessCallback_91,
                                                                                                         OnFailureCallback_91);
    }

    void OnFailureResponse_91(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_91(uint16_t primary3X)
    {
        VerifyOrReturn(CheckConstraintType("primary3X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3X", primary3X, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3X_92()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary3XArgument;
        primary3XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(
            primary3XArgument, this, OnSuccessCallback_92, OnFailureCallback_92);
    }

    void OnFailureResponse_92(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_92() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3X_93()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(this, OnSuccessCallback_93,
                                                                                                         OnFailureCallback_93);
    }

    void OnFailureResponse_93(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_93(uint16_t primary3X)
    {
        VerifyOrReturn(CheckValue("primary3X", primary3X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Y_94()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(this, OnSuccessCallback_94,
                                                                                                         OnFailureCallback_94);
    }

    void OnFailureResponse_94(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_94(uint16_t primary3Y)
    {
        VerifyOrReturn(CheckConstraintType("primary3Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3Y", primary3Y, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3Y_95()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary3YArgument;
        primary3YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(
            primary3YArgument, this, OnSuccessCallback_95, OnFailureCallback_95);
    }

    void OnFailureResponse_95(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_95() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3Y_96()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(this, OnSuccessCallback_96,
                                                                                                         OnFailureCallback_96);
    }

    void OnFailureResponse_96(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_96(uint16_t primary3Y)
    {
        VerifyOrReturn(CheckValue("primary3Y", primary3Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Intensity_97()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Intensity::TypeInfo>(
            this, OnSuccessCallback_97, OnFailureCallback_97);
    }

    void OnFailureResponse_97(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_97(uint8_t primary3Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary3Intensity", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4X_98()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(this, OnSuccessCallback_98,
                                                                                                         OnFailureCallback_98);
    }

    void OnFailureResponse_98(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_98(uint16_t primary4X)
    {
        VerifyOrReturn(CheckConstraintType("primary4X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4X", primary4X, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4X_99()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary4XArgument;
        primary4XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(
            primary4XArgument, this, OnSuccessCallback_99, OnFailureCallback_99);
    }

    void OnFailureResponse_99(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_99() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4X_100()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(
            this, OnSuccessCallback_100, OnFailureCallback_100);
    }

    void OnFailureResponse_100(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_100(uint16_t primary4X)
    {
        VerifyOrReturn(CheckValue("primary4X", primary4X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Y_101()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            this, OnSuccessCallback_101, OnFailureCallback_101);
    }

    void OnFailureResponse_101(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_101(uint16_t primary4Y)
    {
        VerifyOrReturn(CheckConstraintType("primary4Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4Y", primary4Y, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4Y_102()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary4YArgument;
        primary4YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            primary4YArgument, this, OnSuccessCallback_102, OnFailureCallback_102);
    }

    void OnFailureResponse_102(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_102() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4Y_103()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            this, OnSuccessCallback_103, OnFailureCallback_103);
    }

    void OnFailureResponse_103(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_103(uint16_t primary4Y)
    {
        VerifyOrReturn(CheckValue("primary4Y", primary4Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Intensity_104()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Intensity::TypeInfo>(
            this, OnSuccessCallback_104, OnFailureCallback_104);
    }

    void OnFailureResponse_104(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_104(uint8_t primary4Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary4Intensity", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5X_105()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            this, OnSuccessCallback_105, OnFailureCallback_105);
    }

    void OnFailureResponse_105(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_105(uint16_t primary5X)
    {
        VerifyOrReturn(CheckConstraintType("primary5X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5X", primary5X, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5X_106()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary5XArgument;
        primary5XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            primary5XArgument, this, OnSuccessCallback_106, OnFailureCallback_106);
    }

    void OnFailureResponse_106(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_106() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5X_107()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            this, OnSuccessCallback_107, OnFailureCallback_107);
    }

    void OnFailureResponse_107(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_107(uint16_t primary5X)
    {
        VerifyOrReturn(CheckValue("primary5X", primary5X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Y_108()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            this, OnSuccessCallback_108, OnFailureCallback_108);
    }

    void OnFailureResponse_108(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_108(uint16_t primary5Y)
    {
        VerifyOrReturn(CheckConstraintType("primary5Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5Y", primary5Y, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5Y_109()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary5YArgument;
        primary5YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            primary5YArgument, this, OnSuccessCallback_109, OnFailureCallback_109);
    }

    void OnFailureResponse_109(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_109() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5Y_110()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            this, OnSuccessCallback_110, OnFailureCallback_110);
    }

    void OnFailureResponse_110(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_110(uint16_t primary5Y)
    {
        VerifyOrReturn(CheckValue("primary5Y", primary5Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Intensity_111()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Intensity::TypeInfo>(
            this, OnSuccessCallback_111, OnFailureCallback_111);
    }

    void OnFailureResponse_111(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_111(uint8_t primary5Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary5Intensity", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6X_112()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            this, OnSuccessCallback_112, OnFailureCallback_112);
    }

    void OnFailureResponse_112(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_112(uint16_t primary6X)
    {
        VerifyOrReturn(CheckConstraintType("primary6X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6X", primary6X, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6X_113()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary6XArgument;
        primary6XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            primary6XArgument, this, OnSuccessCallback_113, OnFailureCallback_113);
    }

    void OnFailureResponse_113(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_113() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6X_114()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            this, OnSuccessCallback_114, OnFailureCallback_114);
    }

    void OnFailureResponse_114(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_114(uint16_t primary6X)
    {
        VerifyOrReturn(CheckValue("primary6X", primary6X, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Y_115()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            this, OnSuccessCallback_115, OnFailureCallback_115);
    }

    void OnFailureResponse_115(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_115(uint16_t primary6Y)
    {
        VerifyOrReturn(CheckConstraintType("primary6Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6Y", primary6Y, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6Y_116()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t primary6YArgument;
        primary6YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            primary6YArgument, this, OnSuccessCallback_116, OnFailureCallback_116);
    }

    void OnFailureResponse_116(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_116() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6Y_117()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            this, OnSuccessCallback_117, OnFailureCallback_117);
    }

    void OnFailureResponse_117(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_117(uint16_t primary6Y)
    {
        VerifyOrReturn(CheckValue("primary6Y", primary6Y, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Intensity_118()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Intensity::TypeInfo>(
            this, OnSuccessCallback_118, OnFailureCallback_118);
    }

    void OnFailureResponse_118(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_118(uint8_t primary6Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary6Intensity", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointX_119()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            this, OnSuccessCallback_119, OnFailureCallback_119);
    }

    void OnFailureResponse_119(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_119(uint16_t whitePointX)
    {
        VerifyOrReturn(CheckConstraintType("whitePointX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointX", whitePointX, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointX_120()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t whitePointXArgument;
        whitePointXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            whitePointXArgument, this, OnSuccessCallback_120, OnFailureCallback_120);
    }

    void OnFailureResponse_120(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_120() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointX_121()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            this, OnSuccessCallback_121, OnFailureCallback_121);
    }

    void OnFailureResponse_121(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_121(uint16_t whitePointX)
    {
        VerifyOrReturn(CheckValue("whitePointX", whitePointX, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointY_122()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            this, OnSuccessCallback_122, OnFailureCallback_122);
    }

    void OnFailureResponse_122(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_122(uint16_t whitePointY)
    {
        VerifyOrReturn(CheckConstraintType("whitePointY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointY", whitePointY, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointY_123()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t whitePointYArgument;
        whitePointYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            whitePointYArgument, this, OnSuccessCallback_123, OnFailureCallback_123);
    }

    void OnFailureResponse_123(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_123() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointY_124()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            this, OnSuccessCallback_124, OnFailureCallback_124);
    }

    void OnFailureResponse_124(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_124(uint16_t whitePointY)
    {
        VerifyOrReturn(CheckValue("whitePointY", whitePointY, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRX_125()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            this, OnSuccessCallback_125, OnFailureCallback_125);
    }

    void OnFailureResponse_125(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_125(uint16_t colorPointRX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRX", colorPointRX, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRX_126()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointRXArgument;
        colorPointRXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            colorPointRXArgument, this, OnSuccessCallback_126, OnFailureCallback_126);
    }

    void OnFailureResponse_126(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_126() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRX_127()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            this, OnSuccessCallback_127, OnFailureCallback_127);
    }

    void OnFailureResponse_127(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_127(uint16_t colorPointRX)
    {
        VerifyOrReturn(CheckValue("colorPointRX", colorPointRX, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRY_128()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            this, OnSuccessCallback_128, OnFailureCallback_128);
    }

    void OnFailureResponse_128(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_128(uint16_t colorPointRY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRY", colorPointRY, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRY_129()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointRYArgument;
        colorPointRYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            colorPointRYArgument, this, OnSuccessCallback_129, OnFailureCallback_129);
    }

    void OnFailureResponse_129(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_129() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRY_130()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            this, OnSuccessCallback_130, OnFailureCallback_130);
    }

    void OnFailureResponse_130(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_130(uint16_t colorPointRY)
    {
        VerifyOrReturn(CheckValue("colorPointRY", colorPointRY, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRIntensity_131()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRIntensity::TypeInfo>(
            this, OnSuccessCallback_131, OnFailureCallback_131);
    }

    void OnFailureResponse_131(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_131(uint8_t colorPointRIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRIntensity", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGX_132()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            this, OnSuccessCallback_132, OnFailureCallback_132);
    }

    void OnFailureResponse_132(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_132(uint16_t colorPointGX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGX", colorPointGX, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGX_133()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointGXArgument;
        colorPointGXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            colorPointGXArgument, this, OnSuccessCallback_133, OnFailureCallback_133);
    }

    void OnFailureResponse_133(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_133() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGX_134()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            this, OnSuccessCallback_134, OnFailureCallback_134);
    }

    void OnFailureResponse_134(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_134(uint16_t colorPointGX)
    {
        VerifyOrReturn(CheckValue("colorPointGX", colorPointGX, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGY_135()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            this, OnSuccessCallback_135, OnFailureCallback_135);
    }

    void OnFailureResponse_135(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_135(uint16_t colorPointGY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGY", colorPointGY, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGY_136()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointGYArgument;
        colorPointGYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            colorPointGYArgument, this, OnSuccessCallback_136, OnFailureCallback_136);
    }

    void OnFailureResponse_136(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_136() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGY_137()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            this, OnSuccessCallback_137, OnFailureCallback_137);
    }

    void OnFailureResponse_137(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_137(uint16_t colorPointGY)
    {
        VerifyOrReturn(CheckValue("colorPointGY", colorPointGY, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGIntensity_138()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGIntensity::TypeInfo>(
            this, OnSuccessCallback_138, OnFailureCallback_138);
    }

    void OnFailureResponse_138(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_138(uint8_t colorPointGIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGIntensity", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBX_139()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            this, OnSuccessCallback_139, OnFailureCallback_139);
    }

    void OnFailureResponse_139(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_139(uint16_t colorPointBX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBX", colorPointBX, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBX_140()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointBXArgument;
        colorPointBXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            colorPointBXArgument, this, OnSuccessCallback_140, OnFailureCallback_140);
    }

    void OnFailureResponse_140(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_140() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBX_141()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            this, OnSuccessCallback_141, OnFailureCallback_141);
    }

    void OnFailureResponse_141(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_141(uint16_t colorPointBX)
    {
        VerifyOrReturn(CheckValue("colorPointBX", colorPointBX, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBY_142()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            this, OnSuccessCallback_142, OnFailureCallback_142);
    }

    void OnFailureResponse_142(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_142(uint16_t colorPointBY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBY", colorPointBY, 65279));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBY_143()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t colorPointBYArgument;
        colorPointBYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            colorPointBYArgument, this, OnSuccessCallback_143, OnFailureCallback_143);
    }

    void OnFailureResponse_143(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_143() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBY_144()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            this, OnSuccessCallback_144, OnFailureCallback_144);
    }

    void OnFailureResponse_144(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_144(uint16_t colorPointBY)
    {
        VerifyOrReturn(CheckValue("colorPointBY", colorPointBY, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBIntensity_145()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBIntensity::TypeInfo>(
            this, OnSuccessCallback_145, OnFailureCallback_145);
    }

    void OnFailureResponse_145(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_145(uint8_t colorPointBIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBIntensity", "", "uint8"));

        NextTest();
    }
};

class Test_TC_CC_3_1 : public TestCommand
{
public:
    Test_TC_CC_3_1() : TestCommand("Test_TC_CC_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to hue shortest distance command\n");
            err = TestMoveToHueShortestDistanceCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move to hue longest distance command\n");
            err = TestMoveToHueLongestDistanceCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move to hue up command\n");
            err = TestMoveToHueUpCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move to hue down command\n");
            err = TestMoveToHueDownCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_8(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToHueShortestDistanceCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 150;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveToHueLongestDistanceCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 200;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveToHueUpCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 250;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestMoveToHueDownCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 225;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_8,
                                                                                              OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_3_2 : public TestCommand
{
public:
    Test_TC_CC_3_2() : TestCommand("Test_TC_CC_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move hue up command\n");
            err = TestMoveHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move hue stop command\n");
            err = TestMoveHueStopCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move hue down command\n");
            err = TestMoveHueDownCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move hue stop command\n");
            err = TestMoveHueStopCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_8(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveHueUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveHueDownCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_8,
                                                                                              OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_3_3 : public TestCommand
{
public:
    Test_TC_CC_3_3() : TestCommand("Test_TC_CC_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step hue up command\n");
            err = TestStepHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step hue down command\n");
            err = TestStepHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestStepHueUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStepHueDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_4_1 : public TestCommand
{
public:
    Test_TC_CC_4_1() : TestCommand("Test_TC_CC_4_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to saturation command\n");
            err = TestMoveToSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToSaturationCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type;

        RequestType request;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_4_2 : public TestCommand
{
public:
    Test_TC_CC_4_2() : TestCommand("Test_TC_CC_4_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Move saturation stop command\n");
            err = TestMoveSaturationStopCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Move saturation stop command\n");
            err = TestMoveSaturationStopCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_10(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveSaturationUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveSaturationDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveSaturationUpCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestMoveSaturationStopCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(0);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestMoveSaturationDownCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestMoveSaturationStopCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(0);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_10,
                                                                                              OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_4_3 : public TestCommand
{
public:
    Test_TC_CC_4_3() : TestCommand("Test_TC_CC_4_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step saturation up command\n");
            err = TestStepSaturationUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step saturation down command\n");
            err = TestStepSaturationDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestStepSaturationUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(1);
        request.stepSize        = 15;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStepSaturationDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(3);
        request.stepSize        = 20;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_4_4 : public TestCommand
{
public:
    Test_TC_CC_4_4() : TestCommand("Test_TC_CC_4_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move To current hue and saturation command\n");
            err = TestMoveToCurrentHueAndSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToCurrentHueAndSaturationCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type;

        RequestType request;
        request.hue             = 40;
        request.saturation      = 160;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_5_1 : public TestCommand
{
public:
    Test_TC_CC_5_1() : TestCommand("Test_TC_CC_5_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to Color command\n");
            err = TestMoveToColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToColorCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToColor::Type;

        RequestType request;
        request.colorX          = 200U;
        request.colorY          = 300U;
        request.transitionTime  = 20U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_5_2 : public TestCommand
{
public:
    Test_TC_CC_5_2() : TestCommand("Test_TC_CC_5_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move Color command\n");
            err = TestMoveColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Stop Move Step command\n");
            err = TestStopMoveStepCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveColorCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColor::Type;

        RequestType request;
        request.rateX           = 15;
        request.rateY           = 20;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStopMoveStepCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type;

        RequestType request;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_5_3 : public TestCommand
{
public:
    Test_TC_CC_5_3() : TestCommand("Test_TC_CC_5_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step Color command\n");
            err = TestStepColorCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestStepColorCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColor::Type;

        RequestType request;
        request.stepX           = 15;
        request.stepY           = 20;
        request.transitionTime  = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_6_1 : public TestCommand
{
public:
    Test_TC_CC_6_1() : TestCommand("Test_TC_CC_6_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move To Color Temperature command\n");
            err = TestMoveToColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveToColorTemperatureCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type;

        RequestType request;
        request.colorTemperature = 100U;
        request.transitionTime   = 10U;
        request.optionsMask      = 0;
        request.optionsOverride  = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_6_2 : public TestCommand
{
public:
    Test_TC_CC_6_2() : TestCommand("Test_TC_CC_6_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move up color temperature command\n");
            err = TestMoveUpColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Stop Color Temperature command\n");
            err = TestStopColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move down color temperature command\n");
            err = TestMoveDownColorTemperatureCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestMoveUpColorTemperatureCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStopColorTemperatureCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveDownColorTemperatureCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate                    = 20U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_7,
                                                                                              OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_6_3 : public TestCommand
{
public:
    Test_TC_CC_6_3() : TestCommand("Test_TC_CC_6_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step up color temperature command\n");
            err = TestStepUpColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Step down color temperature command\n");
            err = TestStepDownColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestStepUpColorTemperatureCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;

        RequestType request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestStepDownColorTemperatureCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;

        RequestType request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_7_1 : public TestCommand
{
public:
    Test_TC_CC_7_1() : TestCommand("Test_TC_CC_7_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_3();
            break;
        case 4:
            ChipLogProgress(
                chipTool, " ***** Test Step 4 : Check Remaining time attribute value matched the value sent by the last command\n");
            err = TestCheckRemainingTimeAttributeValueMatchedTheValueSentByTheLastCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_4(remainingTime);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 1025U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckRemainingTimeAttributeValueMatchedTheValueSentByTheLastCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue("remainingTime", remainingTime, 1U));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_7_2 : public TestCommand
{
public:
    Test_TC_CC_7_2() : TestCommand("Test_TC_CC_7_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Move Hue Down command \n");
            err = TestEnhancedMoveHueDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move Hue Up command\n");
            err = TestEnhancedMoveHueUpCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_8(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveHueDownCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 5U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueUpCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_8,
                                                                                              OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_7_3 : public TestCommand
{
public:
    Test_TC_CC_7_3() : TestCommand("Test_TC_CC_7_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Step Hue Up command\n");
            err = TestEnhancedStepHueUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Step Hue Down command\n");
            err = TestEnhancedStepHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestEnhancedStepHueUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(0);
        request.stepSize        = 50U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestEnhancedStepHueDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 75U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_7_4 : public TestCommand
{
public:
    Test_TC_CC_7_4() : TestCommand("Test_TC_CC_7_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced move to hue and saturation command\n");
            err = TestEnhancedMoveToHueAndSaturationCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueAndSaturationCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type;

        RequestType request;
        request.enhancedHue     = 1200U;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_8_1 : public TestCommand
{
public:
    Test_TC_CC_8_1() : TestCommand("Test_TC_CC_8_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_8_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_8_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Color Loop Set Command - Set all Attributs\n");
            err = TestColorLoopSetCommandSetAllAttributs_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check ColorLoopStartEnhancedHue Value\n");
            err = TestCheckColorLoopStartEnhancedHueValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Color Loop Set Command - Set direction and time while running\n");
            err = TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Color Loop Set Command - Set direction while running\n");
            err = TestColorLoopSetCommandSetDirectionWhileRunning_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_16();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 17;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_4(colorLoopDirection);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_5(colorLoopTime);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_6(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_7(colorLoopActive);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_9(colorLoopActive);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_11(colorLoopDirection);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_12(colorLoopTime);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_14(colorLoopDirection);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_16(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributs_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(14);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 100U;
        request.startHue        = 500U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 100U));

        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopStartEnhancedHueValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 500U));

        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopActiveValue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopActiveValue_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(6);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 3500U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 3500U));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionWhileRunning_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_13(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_15(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_16,
                                                                                              OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_CC_9_1 : public TestCommand
{
public:
    Test_TC_CC_9_1() : TestCommand("Test_TC_CC_9_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition : Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read ColorLoopTime attribute from DUT\n");
            err = TestReadColorLoopTimeAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read ColorLoopStartEnhancedHue attribute from DUT\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Enhanced Move To Hue command 10\n");
            err = TestEnhancedMoveToHueCommand10_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Wait 2000ms\n");
            err = TestWait2000ms_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read EnhancedCurrentHue attribute from DUT\n");
            err = TestReadEnhancedCurrentHueAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Turn Off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_36();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 37;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_4(colorLoopActive);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_6(colorLoopDirection);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_8(colorLoopTime);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_10(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_12(colorLoopActive);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_14(colorLoopActive);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_16(colorLoopDirection);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_18(colorLoopActive);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_20(colorLoopActive);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_23(enhancedCurrentHue);
    }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_25(colorLoopDirection);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_27(colorLoopActive);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_29(colorLoopActive);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_31(colorLoopDirection);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_33(colorLoopActive);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_35(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 30U));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(8);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_13(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_15(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_17();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_17(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_19();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_19(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand10_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 40960U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_21();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_21(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestWait2000ms_22()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(2000);
    }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue("enhancedCurrentHue", enhancedCurrentHue, 40960U));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_24();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_24(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_26();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_26(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_28();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_28(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_30();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_30(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_32();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_32(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_34();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_34(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_36();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_36(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36() { NextTest(); }
};

class Test_TC_CC_9_2 : public TestCommand
{
public:
    Test_TC_CC_9_2() : TestCommand("Test_TC_CC_9_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Set all Attributes\n");
            err = TestColorLoopSetCommandSetAllAttributes_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopActive attribute from DUT.\n");
            err = TestReadColorLoopActiveAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_4(colorLoopActive);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_5(colorLoopDirection);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_6(colorLoopTime);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_7(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_9(colorLoopActive);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_11(colorLoopDirection);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_13(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 30U));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 1));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_14(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }
};

class Test_TC_CC_9_3 : public TestCommand
{
public:
    Test_TC_CC_9_3() : TestCommand("Test_TC_CC_9_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Color Loop Set Command - Set all Attributes\n");
            err = TestColorLoopSetCommandSetAllAttributes_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopActive attribute from DUT.\n");
            err = TestReadColorLoopActiveAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_4(colorLoopActive);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_5(colorLoopDirection);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_6(colorLoopTime);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_7(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_9(colorLoopActive);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_11(colorLoopTime);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_13(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue("colorLoopDirection", colorLoopDirection, 0));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 30U));

        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 1));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 60U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue("colorLoopTime", colorLoopTime, 60U));

        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue("colorLoopActive", colorLoopActive, 0));

        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_14(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }
};

class Test_TC_DM_1_1 : public TestCommand
{
public:
    Test_TC_DM_1_1() : TestCommand("Test_TC_DM_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Interaction Model Version\n");
            err = TestQueryInteractionModelVersion_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Vendor Name\n");
            err = TestQueryVendorName_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query VendorID\n");
            err = TestQueryVendorID_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query Product Name\n");
            err = TestQueryProductName_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Query ProductID\n");
            err = TestQueryProductID_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Query Node Label\n");
            err = TestQueryNodeLabel_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Query User Location\n");
            err = TestQueryUserLocation_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Query HardwareVersion\n");
            err = TestQueryHardwareVersion_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Query HardwareVersionString\n");
            err = TestQueryHardwareVersionString_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Query SoftwareVersion\n");
            err = TestQuerySoftwareVersion_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Query SoftwareVersionString\n");
            err = TestQuerySoftwareVersionString_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Query ManufacturingDate\n");
            err = ShouldSkip("MANF_DATE") ? CHIP_NO_ERROR : TestQueryManufacturingDate_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Query PartNumber\n");
            err = ShouldSkip("PART_NUM") ? CHIP_NO_ERROR : TestQueryPartNumber_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Query ProductURL\n");
            err = TestQueryProductURL_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Query ProductLabel\n");
            err = TestQueryProductLabel_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Query SerialNumber\n");
            err = TestQuerySerialNumber_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Query LocalConfigDisabled\n");
            err = TestQueryLocalConfigDisabled_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Query Reachable\n");
            err = TestQueryReachable_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Query UniqueID\n");
            err = TestQueryUniqueID_19();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 20;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t interactionModelVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_1(interactionModelVersion);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, chip::CharSpan vendorName)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_2(vendorName);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint16_t vendorID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_3(vendorID);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, chip::CharSpan productName)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_4(productName);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint16_t productID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_5(productID);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, chip::CharSpan nodeLabel)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_6(nodeLabel);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, chip::CharSpan location)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_7(location);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint16_t hardwareVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_8(hardwareVersion);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, chip::CharSpan hardwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_9(hardwareVersionString);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint32_t softwareVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_10(softwareVersion);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, chip::CharSpan softwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_11(softwareVersionString);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, chip::CharSpan manufacturingDate)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_12(manufacturingDate);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, chip::CharSpan partNumber)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_13(partNumber);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, chip::CharSpan productURL)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_14(productURL);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, chip::CharSpan productLabel)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_15(productLabel);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, chip::CharSpan serialNumber)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_16(serialNumber);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, bool localConfigDisabled)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_17(localConfigDisabled);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, bool reachable)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_18(reachable);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, chip::CharSpan uniqueID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_19(uniqueID);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestQueryInteractionModelVersion_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::InteractionModelVersion::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t interactionModelVersion)
    {
        VerifyOrReturn(CheckConstraintType("interactionModelVersion", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestQueryVendorName_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::VendorName::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                   OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::CharSpan vendorName)
    {
        VerifyOrReturn(CheckConstraintType("vendorName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("vendorName", vendorName.size(), 32));

        NextTest();
    }

    CHIP_ERROR TestQueryVendorID_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::VendorID::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                 OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t vendorID)
    {
        VerifyOrReturn(CheckConstraintType("vendorID", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestQueryProductName_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductName::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                    OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(chip::CharSpan productName)
    {
        VerifyOrReturn(CheckConstraintType("productName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productName", productName.size(), 32));

        NextTest();
    }

    CHIP_ERROR TestQueryProductID_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductID::TypeInfo>(this, OnSuccessCallback_5,
                                                                                                  OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t productID)
    {
        VerifyOrReturn(CheckConstraintType("productID", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestQueryNodeLabel_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::NodeLabel::TypeInfo>(this, OnSuccessCallback_6,
                                                                                                  OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(chip::CharSpan nodeLabel)
    {
        VerifyOrReturn(CheckConstraintType("nodeLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("nodeLabel", nodeLabel.size(), 32));

        NextTest();
    }

    CHIP_ERROR TestQueryUserLocation_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_7,
                                                                                                 OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(chip::CharSpan location)
    {
        VerifyOrReturn(CheckConstraintType("location", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("location", "", "ISO 3166-1 alpha-2"));
        VerifyOrReturn(CheckConstraintMaxLength("location", location.size(), 2));

        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersion_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::HardwareVersion::TypeInfo>(this, OnSuccessCallback_8,
                                                                                                        OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint16_t hardwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersion", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersionString_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::HardwareVersionString::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(chip::CharSpan hardwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintMinLength("hardwareVersionString", hardwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("hardwareVersionString", hardwareVersionString.size(), 64));

        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersion_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SoftwareVersion::TypeInfo>(this, OnSuccessCallback_10,
                                                                                                        OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint32_t softwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersion", "", "uint32"));

        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersionString_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SoftwareVersionString::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(chip::CharSpan softwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("softwareVersionString", "", "ASCII"));
        VerifyOrReturn(CheckConstraintMinLength("softwareVersionString", softwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("softwareVersionString", softwareVersionString.size(), 64));

        NextTest();
    }

    CHIP_ERROR TestQueryManufacturingDate_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ManufacturingDate::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_12(chip::CharSpan manufacturingDate)
    {
        VerifyOrReturn(CheckConstraintType("manufacturingDate", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("manufacturingDate", "", "ISO 8601"));
        VerifyOrReturn(CheckConstraintMinLength("manufacturingDate", manufacturingDate.size(), 8));
        VerifyOrReturn(CheckConstraintMaxLength("manufacturingDate", manufacturingDate.size(), 16));

        NextTest();
    }

    CHIP_ERROR TestQueryPartNumber_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::PartNumber::TypeInfo>(this, OnSuccessCallback_13,
                                                                                                   OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_13(chip::CharSpan partNumber)
    {
        VerifyOrReturn(CheckConstraintType("partNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("partNumber", partNumber.size(), 32));

        NextTest();
    }

    CHIP_ERROR TestQueryProductURL_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductURL::TypeInfo>(this, OnSuccessCallback_14,
                                                                                                   OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_14(chip::CharSpan productURL)
    {
        VerifyOrReturn(CheckConstraintType("productURL", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("productURL", "", "RFC3986"));
        VerifyOrReturn(CheckConstraintMaxLength("productURL", productURL.size(), 256));

        NextTest();
    }

    CHIP_ERROR TestQueryProductLabel_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductLabel::TypeInfo>(this, OnSuccessCallback_15,
                                                                                                     OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_15(chip::CharSpan productLabel)
    {
        VerifyOrReturn(CheckConstraintType("productLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productLabel", productLabel.size(), 64));

        NextTest();
    }

    CHIP_ERROR TestQuerySerialNumber_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SerialNumber::TypeInfo>(this, OnSuccessCallback_16,
                                                                                                     OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_16(chip::CharSpan serialNumber)
    {
        VerifyOrReturn(CheckConstraintType("serialNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("serialNumber", serialNumber.size(), 32));

        NextTest();
    }

    CHIP_ERROR TestQueryLocalConfigDisabled_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::LocalConfigDisabled::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_17(bool localConfigDisabled)
    {
        VerifyOrReturn(CheckConstraintType("localConfigDisabled", "", "boolean"));

        NextTest();
    }

    CHIP_ERROR TestQueryReachable_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Reachable::TypeInfo>(this, OnSuccessCallback_18,
                                                                                                  OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_18(bool reachable)
    {
        VerifyOrReturn(CheckConstraintType("reachable", "", "boolean"));

        NextTest();
    }

    CHIP_ERROR TestQueryUniqueID_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::UniqueID::TypeInfo>(this, OnSuccessCallback_19,
                                                                                                 OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_19(chip::CharSpan uniqueID)
    {
        VerifyOrReturn(CheckConstraintType("uniqueID", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("uniqueID", uniqueID.size(), 32));

        NextTest();
    }
};

class Test_TC_DM_3_1 : public TestCommand
{
public:
    Test_TC_DM_3_1() : TestCommand("Test_TC_DM_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_DM_2_2 : public TestCommand
{
public:
    Test_TC_DM_2_2() : TestCommand("Test_TC_DM_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query fabrics list\n");
            err = TestQueryFabricsList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Supported Fabrics\n");
            err = TestQuerySupportedFabrics_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query Commissioned Fabrics\n");
            err = TestQueryCommissionedFabrics_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query User Trusted Root Certificates\n");
            err = TestQueryUserTrustedRootCertificates_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void
    OnSuccessCallback_1(void * context,
                        const chip::app::DataModel::DecodableList<
                            chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabricsList)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_1(fabricsList);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t supportedFabrics)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_2(supportedFabrics);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_3(commissionedFabrics);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context,
                                    const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_4(trustedRootCertificates);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestQueryFabricsList_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::FabricsList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(const chip::app::DataModel::DecodableList<
                             chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabricsList)
    {
        auto iter = fabricsList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(fabricsList)>("fabricsList", iter, 0));
        VerifyOrReturn(CheckNoMoreListItems<decltype(fabricsList)>("fabricsList", iter, 1));

        NextTest();
    }

    CHIP_ERROR TestQuerySupportedFabrics_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::SupportedFabrics::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckValue("supportedFabrics", supportedFabrics, 16));

        NextTest();
    }

    CHIP_ERROR TestQueryCommissionedFabrics_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckValue("commissionedFabrics", commissionedFabrics, 1));

        NextTest();
    }

    CHIP_ERROR TestQueryUserTrustedRootCertificates_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::TrustedRootCertificates::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)
    {
        VerifyOrReturn(CheckConstraintType("trustedRootCertificates", "", "list"));

        NextTest();
    }
};

class Test_TC_EMR_1_1 : public TestCommand
{
public:
    Test_TC_EMR_1_1() : TestCommand("Test_TC_EMR_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_EMR_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_EMR_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 3U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 3U));

        NextTest();
    }
};

class Test_TC_FLW_1_1 : public TestCommand
{
public:
    Test_TC_FLW_1_1() : TestCommand("Test_TC_FLW_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_FLW_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_FLW_1_1 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }
};

class Test_TC_FLW_2_1 : public TestCommand
{
public:
    Test_TC_FLW_2_1() : TestCommand("Test_TC_FLW_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default value to optional attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : write the default value to optional attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_2(minMeasuredValue);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_3(maxMeasuredValue);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_6(measuredValue);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_7(minMeasuredValue);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_8(maxMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minMeasuredValueArgument;
        minMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            minMeasuredValueArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxMeasuredValueArgument;
        maxMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            maxMeasuredValueArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));

        NextTest();
    }
};

class Test_TC_FLW_2_2 : public TestCommand
{
public:
    Test_TC_FLW_2_2() : TestCommand("Test_TC_FLW_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnSuccessResponse_2(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }
};

class Test_TC_ILL_1_1 : public TestCommand
{
public:
    Test_TC_ILL_1_1() : TestCommand("Test_TC_ILL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ILL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ILL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_ILL_1_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 2U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 2U));

        NextTest();
    }
};

class Test_TC_LVL_1_1 : public TestCommand
{
public:
    Test_TC_LVL_1_1() : TestCommand("Test_TC_LVL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_LVL_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_LVL_1_1 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        return cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }
};

class Test_TC_LVL_2_1 : public TestCommand
{
public:
    Test_TC_LVL_2_1() : TestCommand("Test_TC_LVL_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 100ms\n");
            err = TestWait100ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 200ms\n");
            err = TestWait200ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : reads On Off Transition Time attribute from DUT\n");
            err = TestReadsOnOffTransitionTimeAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 10ms\n");
            err = TestWait10ms_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reset level to 0\n");
            err = TestResetLevelTo0_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Wait 100ms\n");
            err = TestWait100ms_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_1(currentLevel);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_4(currentLevel);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_7(currentLevel);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint16_t onOffTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_8(onOffTransitionTime);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_11(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 64;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWait100ms_3()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 64));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 128;
        request.transitionTime = 1U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWait200ms_6()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(200);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 128));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffTransitionTimeAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint16_t onOffTransitionTime)
    {
        VerifyOrReturn(CheckValue("onOffTransitionTime", onOffTransitionTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 254;
        request.transitionTime = 65535U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWait10ms_10()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(10);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 254));

        NextTest();
    }

    CHIP_ERROR TestResetLevelTo0_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 0;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestWait100ms_13()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }
};

class Test_TC_LVL_3_1 : public TestCommand
{
public:
    Test_TC_LVL_3_1() : TestCommand("Test_TC_LVL_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads max level attribute from DUT\n");
            err = TestReadsMaxLevelAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : sends a Move up command\n");
            err = TestSendsAMoveUpCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Wait 3000ms\n");
            err = TestWait3000ms_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads min level attribute from DUT\n");
            err = TestReadsMinLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : sends a Move down command\n");
            err = TestSendsAMoveDownCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait 3000ms\n");
            err = TestWait3000ms_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write default move rate attribute from DUT\n");
            err = TestWriteDefaultMoveRateAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads default move rate attribute from DUT\n");
            err = TestReadsDefaultMoveRateAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : sends a Move up command at default move rate\n");
            err = TestSendsAMoveUpCommandAtDefaultMoveRate_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Wait 100ms\n");
            err = TestWait100ms_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_1(currentLevel);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t maxLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_2(maxLevel);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_5(currentLevel);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t minLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_6(minLevel);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_9(currentLevel);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_11(defaultMoveRate);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_14(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsMaxLevelAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                        OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t maxLevel)
    {
        VerifyOrReturn(CheckValue("maxLevel", maxLevel, 255));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 200;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWait3000ms_4()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 255));

        NextTest();
    }

    CHIP_ERROR TestReadsMinLevelAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo>(this, OnSuccessCallback_6,
                                                                                                        OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t minLevel)
    {
        VerifyOrReturn(CheckValue("minLevel", minLevel, 0));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveDownCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 250;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWait3000ms_8()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteDefaultMoveRateAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> defaultMoveRateArgument;
        defaultMoveRateArgument.SetNonNull() = 20;

        return cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            defaultMoveRateArgument, this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadsDefaultMoveRateAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(const chip::app::DataModel::Nullable<uint8_t> & defaultMoveRate)
    {
        VerifyOrReturn(CheckValueNonNull("defaultMoveRate", defaultMoveRate));
        VerifyOrReturn(CheckValue("defaultMoveRate.Value()", defaultMoveRate.Value(), 20));

        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommandAtDefaultMoveRate_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 255;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestWait100ms_13()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckConstraintNotValue("currentLevel", currentLevel, 255));

        NextTest();
    }
};

class Test_TC_LVL_4_1 : public TestCommand
{
public:
    Test_TC_LVL_4_1() : TestCommand("Test_TC_LVL_4_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sending on command\n");
            err = TestSendingOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: DUT level is set to 0x80\n");
            err = TestPreconditionDutLevelIsSetTo0x80_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 3000ms\n");
            err = TestWait3000ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends step down command to DUT\n");
            err = TestSendsStepDownCommandToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 3000ms\n");
            err = TestWait3000ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Sends a Step up command\n");
            err = TestSendsAStepUpCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 3000ms\n");
            err = TestWait3000ms_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Sending off command\n");
            err = TestSendingOffCommand_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_4(currentLevel);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_7(currentLevel);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_10(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendingOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestPreconditionDutLevelIsSetTo0x80_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 128;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWait3000ms_3()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 128));

        NextTest();
    }

    CHIP_ERROR TestSendsStepDownCommandToDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
        request.stepSize       = 64;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWait3000ms_6()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 64));

        NextTest();
    }

    CHIP_ERROR TestSendsAStepUpCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 64;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWait3000ms_9()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue("currentLevel", currentLevel, 128));

        NextTest();
    }

    CHIP_ERROR TestSendingOffCommand_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }
};

class Test_TC_LVL_5_1 : public TestCommand
{
public:
    Test_TC_LVL_5_1() : TestCommand("Test_TC_LVL_5_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sending on command\n");
            err = TestSendingOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Precondition: DUT level is set to 0x80\n");
            err = TestPreconditionDutLevelIsSetTo0x80_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 3000ms\n");
            err = TestWait3000ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Sends a move up command to DUT\n");
            err = TestSendsAMoveUpCommandToDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 3000ms\n");
            err = TestWait3000ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Sends stop command to DUT\n");
            err = TestSendsStopCommandToDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sending off command\n");
            err = TestSendingOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendingOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestPreconditionDutLevelIsSetTo0x80_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 128;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWait3000ms_3()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestSendsAMoveUpCommandToDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 1;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait3000ms_5()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(3000);
    }

    CHIP_ERROR TestSendsStopCommandToDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Stop::Type;

        RequestType request;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestSendingOffCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }
};

class Test_TC_MC_1_1 : public TestCommand
{
public:
    Test_TC_MC_1_1() : TestCommand("Test_TC_MC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_MC_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_MC_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_MC_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_MC_1_1 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::MediaInput::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }
};

class Test_TC_MC_2_1 : public TestCommand
{
public:
    Test_TC_MC_2_1() : TestCommand("Test_TC_MC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Put the device into low power mode\n");
            err = TestPutTheDeviceIntoLowPowerMode_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestPutTheDeviceIntoLowPowerMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LowPower::Commands::Sleep::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_MC_2_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_MC_2_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }
};

class Test_TC_MC_3_1 : public TestCommand
{
public:
    Test_TC_MC_3_1() : TestCommand("Test_TC_MC_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_2 : public TestCommand
{
public:
    Test_TC_MC_3_2() : TestCommand("Test_TC_MC_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_3 : public TestCommand
{
public:
    Test_TC_MC_3_3() : TestCommand("Test_TC_MC_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_4 : public TestCommand
{
public:
    Test_TC_MC_3_4() : TestCommand("Test_TC_MC_3_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_5 : public TestCommand
{
public:
    Test_TC_MC_3_5() : TestCommand("Test_TC_MC_3_5"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_6 : public TestCommand
{
public:
    Test_TC_MC_3_6() : TestCommand("Test_TC_MC_3_6"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_7 : public TestCommand
{
public:
    Test_TC_MC_3_7() : TestCommand("Test_TC_MC_3_7"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_8 : public TestCommand
{
public:
    Test_TC_MC_3_8() : TestCommand("Test_TC_MC_3_8"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_9 : public TestCommand
{
public:
    Test_TC_MC_3_9() : TestCommand("Test_TC_MC_3_9"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_10 : public TestCommand
{
public:
    Test_TC_MC_3_10() : TestCommand("Test_TC_MC_3_10"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_10\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_MC_3_11 : public TestCommand
{
public:
    Test_TC_MC_3_11() : TestCommand("Test_TC_MC_3_11"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_11\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_11\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_OCC_1_1 : public TestCommand
{
public:
    Test_TC_OCC_1_1() : TestCommand("Test_TC_OCC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_3(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 2U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }
};

class Test_TC_OCC_2_1 : public TestCommand
{
public:
    Test_TC_OCC_2_1() : TestCommand("Test_TC_OCC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads mandatory attribute constrains: Occupancy\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancy_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Writes the respective default value to mandatory attribute: Occupancy\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: Occupancy\n");
            err = TestReadsBackMandatoryAttributeOccupancy_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads mandatory attribute constrains: OccupancySensorType\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorType_4();
            break;
        case 5:
            ChipLogProgress(
                chipTool, " ***** Test Step 5 : Writes the respective default value to mandatory attribute: OccupancySensorType\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: OccupancySensorType\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorType_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads mandatory attribute constrains: OccupancySensorTypeBitmap\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_7();
            break;
        case 8:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : Writes the respective default value to mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_1(occupancy);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_3(occupancy);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t occupancySensorType)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_4(occupancySensorType);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t occupancySensorType)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_6(occupancySensorType);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t occupancySensorTypeBitmap)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_7(occupancySensorTypeBitmap);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t occupancySensorTypeBitmap)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_9(occupancySensorTypeBitmap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancy_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancy", occupancy, 1));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t occupancyArgument;
        occupancyArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            occupancyArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancy_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t occupancy)
    {
        VerifyOrReturn(CheckValue("occupancy", occupancy, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorType_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t occupancySensorType)
    {
        VerifyOrReturn(CheckConstraintType("occupancySensorType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorType", occupancySensorType, 3));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t occupancySensorTypeArgument;
        occupancySensorTypeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
            occupancySensorTypeArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorType_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t occupancySensorType)
    {
        VerifyOrReturn(CheckValue("occupancySensorType", occupancySensorType, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t occupancySensorTypeBitmap)
    {
        VerifyOrReturn(CheckConstraintType("occupancySensorTypeBitmap", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 1));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 7));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t occupancySensorTypeBitmapArgument;
        occupancySensorTypeBitmapArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
            occupancySensorTypeBitmapArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t occupancySensorTypeBitmap)
    {
        VerifyOrReturn(CheckValue("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 1));

        NextTest();
    }
};

class Test_TC_OCC_2_2 : public TestCommand
{
public:
    Test_TC_OCC_2_2() : TestCommand("Test_TC_OCC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Occupancy attribute from DUT\n");
            err = TestReadsOccupancyAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads Occupancy attribute from DUT\n");
            err = TestReadsOccupancyAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnSuccessResponse_1(occupancy);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnSuccessResponse_2(occupancy);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));

        NextTest();
    }

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));

        NextTest();
    }
};

class Test_TC_OO_1_1 : public TestCommand
{
public:
    Test_TC_OO_1_1() : TestCommand("Test_TC_OO_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read the optional global attribute : FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default values to optional global attribute: FeatureMap\n");
            err = TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads back optional global attribute: FeatureMap\n");
            err = TestReadsBackOptionalGlobalAttributeFeatureMap_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_3(clusterRevision);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_5(clusterRevision);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_6(featureMap);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_7(featureMap);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_9(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_1()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                        OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 4U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                        OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(this, OnSuccessCallback_5,
                                                                                                        OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 4U));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(this, OnSuccessCallback_6,
                                                                                                   OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue("featureMap", featureMap, 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(this, OnSuccessCallback_7,
                                                                                                   OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t featureMapArgument;
        featureMapArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(
            featureMapArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalGlobalAttributeFeatureMap_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(this, OnSuccessCallback_9,
                                                                                                   OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue("featureMap", featureMap, 0UL));

        NextTest();
    }
};

class Test_TC_OO_2_1 : public TestCommand
{
public:
    Test_TC_OO_2_1() : TestCommand("Test_TC_OO_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: OnOff\n");
            err = TestReadTheMandatoryAttributeOnOff_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back mandatory attribute: OnOff\n");
            err = TestReadsBackMandatoryAttributeOnOff_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read LT attribute: GlobalSceneControl\n");
            err = TestReadLtAttributeGlobalSceneControl_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read LT attribute: OnTime\n");
            err = TestReadLtAttributeOnTime_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read LT attribute: OffWaitTime\n");
            err = TestReadLtAttributeOffWaitTime_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read LT attribute: StartUpOnOff\n");
            err = TestReadLtAttributeStartUpOnOff_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write the default value to LT attribute: OnTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOnTime_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default value to LT attribute: OffWaitTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOffWaitTime_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : write the default value to LT attribute: StartUpOnOff\n");
            err = TestWriteTheDefaultValueToLtAttributeStartUpOnOff_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads back LT attribute: OnTime\n");
            err = TestReadsBackLtAttributeOnTime_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads back LT attribute: OffWaitTime\n");
            err = TestReadsBackLtAttributeOffWaitTime_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : reads back LT attribute: StartUpOnOff\n");
            err = TestReadsBackLtAttributeStartUpOnOff_12();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 13;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_3(globalSceneControl);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_4(onTime);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_5(offWaitTime);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_6(startUpOnOff);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_10(onTime);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_11(offWaitTime);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_12(startUpOnOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeOnOff_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeOnOff_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeGlobalSceneControl_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOnTime_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_4,
                                                                                               OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOffWaitTime_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_5,
                                                                                                    OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeStartUpOnOff_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                                     OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue("startUpOnOff", startUpOnOff, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOnTime_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t onTimeArgument;
        onTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            onTimeArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOffWaitTime_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t offWaitTimeArgument;
        offWaitTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            offWaitTimeArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeStartUpOnOff_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t startUpOnOffArgument;
        startUpOnOffArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(
            startUpOnOffArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadsBackLtAttributeOnTime_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_10,
                                                                                               OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeOffWaitTime_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_11,
                                                                                                    OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeStartUpOnOff_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(this, OnSuccessCallback_12,
                                                                                                     OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue("startUpOnOff", startUpOnOff, 0));

        NextTest();
    }
};

class Test_TC_OO_2_2 : public TestCommand
{
public:
    Test_TC_OO_2_2() : TestCommand("Test_TC_OO_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Off Command\n");
            err = TestSendOffCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send On Command\n");
            err = TestSendOnCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send Off Command\n");
            err = TestSendOffCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Send Toggle Command\n");
            err = TestSendToggleCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check on/off attribute value is true after toggle command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send Toggle Command\n");
            err = TestSendToggleCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check on/off attribute value is false after toggle command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Send On Command\n");
            err = TestSendOnCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Send Off Command\n");
            err = TestSendOffCommand_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_4(onOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_6(onOff);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_8(onOff);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_10(onOff);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_12(onOff);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_14(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendOffCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_4,
                                                                                              OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Toggle::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_8,
                                                                                              OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Toggle::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_10,
                                                                                              OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_12,
                                                                                              OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_13(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_14,
                                                                                              OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }
};

class Test_TC_OO_2_3 : public TestCommand
{
public:
    Test_TC_OO_2_3() : TestCommand("Test_TC_OO_2_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send On Command\n");
            err = TestSendOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 1000ms\n");
            err = TestWait1000ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send On Command\n");
            err = TestSendOnCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Wait 1000ms\n");
            err = TestWait1000ms_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send On Command\n");
            err = TestSendOnCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Wait 1000ms\n");
            err = TestWait1000ms_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Send On Command\n");
            err = TestSendOnCommand_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Send Off Command\n");
            err = TestSendOffCommand_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Send On Command\n");
            err = TestSendOnCommand_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Send Off Command\n");
            err = TestSendOffCommand_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Send On Command\n");
            err = TestSendOnCommand_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Send Off Command\n");
            err = TestSendOffCommand_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Send Off Command\n");
            err = TestSendOffCommand_46();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 47;

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_3(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_4(globalSceneControl);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_7(onOff);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_8(globalSceneControl);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_11(onOff);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_12(globalSceneControl);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_13(onTime);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_14(offWaitTime);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_16(onOff);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_17(onTime);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_18(offWaitTime);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_20(onOff);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_21(onTime);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_22(onOff);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_23(onTime);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_24(offWaitTime);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_26(onTime);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_27(offWaitTime);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_29(onOff);
    }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_30(onTime);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_31(onOff);
    }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_32(onTime);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_34(onOff);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_35(onTime);
    }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_36(offWaitTime);
    }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_38(onOff);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_39(onTime);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_40(onOff);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_41(onTime);
    }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_42(offWaitTime);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_43(onOff);
    }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_44(onTime);
    }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_45(offWaitTime);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait1000ms_2()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_3,
                                                                                              OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWait1000ms_6()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_7,
                                                                                              OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWait1000ms_10()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(1000);
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_11,
                                                                                              OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue("globalSceneControl", globalSceneControl, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_13,
                                                                                               OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_14,
                                                                                                    OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_15();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_15(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_16,
                                                                                              OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_17,
                                                                                               OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_18,
                                                                                                    OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_19();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_19(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_20,
                                                                                              OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_21,
                                                                                               OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_22,
                                                                                              OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_23,
                                                                                               OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_24,
                                                                                                    OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_25();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_25(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_26,
                                                                                               OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_27,
                                                                                                    OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_28();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_28(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_29,
                                                                                              OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_30,
                                                                                               OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_31,
                                                                                              OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_32,
                                                                                               OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_33();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_33(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_34,
                                                                                              OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_35,
                                                                                               OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_36,
                                                                                                    OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_37();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_37(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_38,
                                                                                              OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_39,
                                                                                               OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_40,
                                                                                              OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_41,
                                                                                               OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_42,
                                                                                                    OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_43,
                                                                                              OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(bool onOff)
    {
        VerifyOrReturn(CheckValue("onOff", onOff, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_44,
                                                                                               OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue("onTime", onTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_45,
                                                                                                    OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue("offWaitTime", offWaitTime, 0U));

        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_46();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_46(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46() { NextTest(); }
};

class Test_TC_PRS_1_1 : public TestCommand
{
public:
    Test_TC_PRS_1_1() : TestCommand("Test_TC_PRS_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }
};

class Test_TC_PRS_2_1 : public TestCommand
{
public:
    Test_TC_PRS_2_1() : TestCommand("Test_TC_PRS_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the mandatory attribute constraints: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write the default values to mandatory attribute: MeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: MeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read the mandatory attribute constraints: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write the default values to mandatory attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back mandatory attribute: MinMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMinMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read the mandatory attribute constraints: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write the default values to mandatory attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads back mandatory attribute: MaxMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMaxMeasuredValue_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_3(measuredValue);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_4(minMeasuredValue);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_6(minMeasuredValue);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_7(maxMeasuredValue);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_9(maxMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t measuredValueArgument;
        measuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            measuredValueArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMeasuredValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t measuredValue)
    {
        VerifyOrReturn(CheckValue("measuredValue", measuredValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "int16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minMeasuredValueArgument;
        minMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            minMeasuredValueArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMinMeasuredValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckValue("minMeasuredValue", minMeasuredValue, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "int16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxMeasuredValueArgument;
        maxMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            maxMeasuredValueArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMaxMeasuredValue_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckValue("maxMeasuredValue", maxMeasuredValue, 0));

        NextTest();
    }
};

class Test_TC_PCC_1_1 : public TestCommand
{
public:
    Test_TC_PCC_1_1() : TestCommand("Test_TC_PCC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PCC_1_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnSuccessResponse_3(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));

        NextTest();
    }
};

class Test_TC_PCC_2_1 : public TestCommand
{
public:
    Test_TC_PCC_2_1() : TestCommand("Test_TC_PCC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_1(maxPressure);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_2(effectiveOperationMode);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_3(effectiveControlMode);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_4(capacity);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_5(maxPressure);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_6(effectiveOperationMode);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_7(effectiveControlMode);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_8(capacity);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Capacity::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Capacity::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));

        NextTest();
    }
};

class Test_TC_PCC_2_2 : public TestCommand
{
public:
    Test_TC_PCC_2_2() : TestCommand("Test_TC_PCC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 1 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite1ToTheOperationModeAttributeToDutOperationMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write 2 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite2ToTheOperationModeAttributeToDutOperationMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write 3 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite3ToTheOperationModeAttributeToDutOperationMode_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_3(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestWrite1ToTheOperationModeAttributeToDutOperationMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWrite2ToTheOperationModeAttributeToDutOperationMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(2);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWrite3ToTheOperationModeAttributeToDutOperationMode_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(3);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }
};

class Test_TC_PCC_2_3 : public TestCommand
{
public:
    Test_TC_PCC_2_3() : TestCommand("Test_TC_PCC_2_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 0 to the OperationMode attribute to DUT\n");
            err = TestWrite0ToTheOperationModeAttributeToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads the attribute: EffectiveOperationMode\n");
            err = TestReadsTheAttributeEffectiveOperationMode_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_PCC_2_3 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnSuccessResponse_2(effectiveOperationMode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestWrite0ToTheOperationModeAttributeToDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadsTheAttributeEffectiveOperationMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckValue("effectiveOperationMode", effectiveOperationMode, 0));

        NextTest();
    }
};

class Test_TC_RH_1_1 : public TestCommand
{
public:
    Test_TC_RH_1_1() : TestCommand("Test_TC_RH_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_RH_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_RH_1_1 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }
};

class Test_TC_RH_2_1 : public TestCommand
{
public:
    Test_TC_RH_2_1() : TestCommand("Test_TC_RH_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads constraints of attribute: MeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads constraints of attribute: MinMeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMinMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t minMeasuredValue)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnSuccessResponse_2(minMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeMinMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("minMeasuredValue", minMeasuredValue, 9999));

        NextTest();
    }
};

class Test_TC_RH_2_2 : public TestCommand
{
public:
    Test_TC_RH_2_2() : TestCommand("Test_TC_RH_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads MeasuredValue attribute from DUT\n");
            err = TestReadsMeasuredValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnSuccessResponse_2(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }
};

class Test_TC_TM_1_1 : public TestCommand
{
public:
    Test_TC_TM_1_1() : TestCommand("Test_TC_TM_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 3U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 3U));

        NextTest();
    }
};

class Test_TC_TM_2_1 : public TestCommand
{
public:
    Test_TC_TM_2_1() : TestCommand("Test_TC_TM_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_1 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));

        NextTest();
    }
};

class Test_TC_TM_2_2 : public TestCommand
{
public:
    Test_TC_TM_2_2() : TestCommand("Test_TC_TM_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads MeasuredValue attribute from DUT\n");
            err = TestReadsMeasuredValueAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnSuccessResponse_2(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));

        NextTest();
    }
};

class Test_TC_TSTAT_1_1 : public TestCommand
{
public:
    Test_TC_TSTAT_1_1() : TestCommand("Test_TC_TSTAT_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the optional global attribute constraints: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeConstraintsFeatureMap_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnSuccessResponse_3(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 5U;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeConstraintsFeatureMap_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::FeatureMap::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                        OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "map32"));

        NextTest();
    }
};

class Test_TC_TSTAT_2_1 : public TestCommand
{
public:
    Test_TC_TSTAT_2_1() : TestCommand("Test_TC_TSTAT_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Reads constraints of mandatory attributes from DUT: LocalTemperature\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutLocalTemperature_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMinHeatSetpointLimit_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Reads constraints of mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinHeatSetpointLimit_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMinHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinHeatSetpointLimit_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read back mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMinHeatSetpointLimit_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_6();
            break;
        case 7:
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : Reads constraints of mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMaxHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxHeatSetpointLimit_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read back mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMinCoolSetpointLimit_10();
            break;
        case 11:
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : Reads constraints of mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinCoolSetpointLimit_11();
            break;
        case 12:
            ChipLogProgress(chipTool,
                            " ***** Test Step 12 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMinCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinCoolSetpointLimit_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read back mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMinCoolSetpointLimit_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Reads mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_14();
            break;
        case 15:
            ChipLogProgress(chipTool,
                            " ***** Test Step 15 : Reads constraints of mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMaxCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxCoolSetpointLimit_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read back mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Reads mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadsMandatoryAttributesFromDutOccupiedCoolingSetpoint_18();
            break;
        case 19:
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : Reads constraints of mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedCoolingSetpoint_19();
            break;
        case 20:
            ChipLogProgress(chipTool,
                            " ***** Test Step 20 : Writes the respective default value to mandatory attributes to DUT: "
                            "OccupiedCoolingSetpoint\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedCoolingSetpoint_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read back mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadBackMandatoryAttributesFromDutOccupiedCoolingSetpoint_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadsMandatoryAttributesFromDutOccupiedHeatingSetpoint_22();
            break;
        case 23:
            ChipLogProgress(chipTool,
                            " ***** Test Step 23 : Reads constraints of mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedHeatingSetpoint_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : Writes the respective default value to mandatory attributes to DUT: "
                            "OccupiedHeatingSetpoint\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedHeatingSetpoint_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read back mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadBackMandatoryAttributesFromDutOccupiedHeatingSetpoint_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMinHeatSetpointLimit_26();
            break;
        case 27:
            ChipLogProgress(chipTool,
                            " ***** Test Step 27 : Reads constraints of mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMinHeatSetpointLimit_27();
            break;
        case 28:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 28 : Writes the respective default value to mandatory attributes to DUT: MinHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinHeatSetpointLimit_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read back mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMinHeatSetpointLimit_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMaxHeatSetpointLimit_30();
            break;
        case 31:
            ChipLogProgress(chipTool,
                            " ***** Test Step 31 : Reads constraints of mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMaxHeatSetpointLimit_31();
            break;
        case 32:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 32 : Writes the respective default value to mandatory attributes to DUT: MaxHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxHeatSetpointLimit_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read back mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMaxHeatSetpointLimit_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMinCoolSetpointLimit_34();
            break;
        case 35:
            ChipLogProgress(chipTool,
                            " ***** Test Step 35 : Reads constraints of mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMinCoolSetpointLimit_35();
            break;
        case 36:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 36 : Writes the respective default value to mandatory attributes to DUT: MinCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinCoolSetpointLimit_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read back mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMinCoolSetpointLimit_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMaxCoolSetpointLimit_38();
            break;
        case 39:
            ChipLogProgress(chipTool,
                            " ***** Test Step 39 : Reads constraints of mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMaxCoolSetpointLimit_39();
            break;
        case 40:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 40 : Writes the respective default value to mandatory attributes to DUT: MaxCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxCoolSetpointLimit_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read back mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMaxCoolSetpointLimit_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadsMandatoryAttributesFromDutControlSequenceOfOperation_42();
            break;
        case 43:
            ChipLogProgress(
                chipTool, " ***** Test Step 43 : Reads constraints of mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutControlSequenceOfOperation_43();
            break;
        case 44:
            ChipLogProgress(chipTool,
                            " ***** Test Step 44 : Writes the respective default value to mandatory attributes to DUT: "
                            "ControlSequenceOfOperation\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutControlSequenceOfOperation_44();
            break;
        case 45:
            ChipLogProgress(chipTool,
                            " ***** Test Step 45 : Read back mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadBackMandatoryAttributesFromDutControlSequenceOfOperation_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reads mandatory attributes from DUT: SystemMode\n");
            err = TestReadsMandatoryAttributesFromDutSystemMode_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Reads constraints of mandatory attributes from DUT: SystemMode\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutSystemMode_47();
            break;
        case 48:
            ChipLogProgress(
                chipTool, " ***** Test Step 48 : Writes the respective default value to mandatory attributes to DUT: SystemMode\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutSystemMode_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read back mandatory attributes from DUT: SystemMode\n");
            err = TestReadBackMandatoryAttributesFromDutSystemMode_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Reads optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadsOptionalAttributesFromDutMinSetpointDeadBand_50();
            break;
        case 51:
            ChipLogProgress(chipTool,
                            " ***** Test Step 51 : Reads constraints of optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutMinSetpointDeadBand_51();
            break;
        case 52:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 52 : Writes the respective default value to optional attributes to DUT: MinSetpointDeadBand\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutMinSetpointDeadBand_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read back optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadBackOptionalAttributesFromDutMinSetpointDeadBand_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Reads constraints of optional attributes from DUT: StartOfWeek\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutStartOfWeek_54();
            break;
        case 55:
            ChipLogProgress(
                chipTool, " ***** Test Step 55 : Writes the respective default value to optional attributes to DUT: StartOfWeek\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutStartOfWeek_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read back optional attributes from DUT: StartOfWeek\n");
            err = TestReadBackOptionalAttributesFromDutStartOfWeek_56();
            break;
        case 57:
            ChipLogProgress(chipTool,
                            " ***** Test Step 57 : Reads constraints of optional attributes from DUT: NumberOfWeeklyTransitions\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutNumberOfWeeklyTransitions_57();
            break;
        case 58:
            ChipLogProgress(chipTool,
                            " ***** Test Step 58 : Writes the respective default value to optional attributes to DUT: "
                            "NumberOfWeeklyTransitions\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfWeeklyTransitions_58();
            break;
        case 59:
            ChipLogProgress(chipTool,
                            " ***** Test Step 59 : Reads constraints of optional attributes from DUT: NumberOfDailyTransitions\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutNumberOfDailyTransitions_59();
            break;
        case 60:
            ChipLogProgress(chipTool,
                            " ***** Test Step 60 : Writes the respective default value to optional attributes to DUT: "
                            "NumberOfDailyTransitions\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfDailyTransitions_60();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 61;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t localTemperature)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_1(localTemperature);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_2(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_3(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_5(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_6(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_7(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_9(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_10(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_11(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_13(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_14(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_15(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_16(); }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_17(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_18(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_19(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_21(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_22(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_23(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_25(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_26(minHeatSetpointLimit);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_27(minHeatSetpointLimit);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_28(); }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_29(minHeatSetpointLimit);
    }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_30(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_31(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_33(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_34(minCoolSetpointLimit);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_35(minCoolSetpointLimit);
    }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_36(); }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_37(minCoolSetpointLimit);
    }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_38(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_39(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_40(); }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_41(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_42(controlSequenceOfOperation);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_43(controlSequenceOfOperation);
    }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_45(controlSequenceOfOperation);
    }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_46(systemMode);
    }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_47(systemMode);
    }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_48(); }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_49(systemMode);
    }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_50(minSetpointDeadBand);
    }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_51(minSetpointDeadBand);
    }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_52(); }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_53(minSetpointDeadBand);
    }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context, uint8_t startOfWeek)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_54(startOfWeek);
    }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_55(); }

    static void OnFailureCallback_56(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_56(chip::to_underlying(status));
    }

    static void OnSuccessCallback_56(void * context, uint8_t startOfWeek)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_56(startOfWeek);
    }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context, uint8_t numberOfWeeklyTransitions)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_57(numberOfWeeklyTransitions);
    }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_58(); }

    static void OnFailureCallback_59(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_59(chip::to_underlying(status));
    }

    static void OnSuccessCallback_59(void * context, uint8_t numberOfDailyTransitions)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_59(numberOfDailyTransitions);
    }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_60(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutLocalTemperature_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::LocalTemperature::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t localTemperature)
    {
        VerifyOrReturn(CheckConstraintType("localTemperature", "", "int16"));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMinHeatSetpointLimit_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinHeatSetpointLimit_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMinHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinHeatSetpointLimit_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t absMinHeatSetpointLimitArgument;
        absMinHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            absMinHeatSetpointLimitArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMinHeatSetpointLimit_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMaxHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxHeatSetpointLimit_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t absMaxHeatSetpointLimitArgument;
        absMaxHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            absMaxHeatSetpointLimitArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMinCoolSetpointLimit_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinCoolSetpointLimit_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMinCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinCoolSetpointLimit_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t absMinCoolSetpointLimitArgument;
        absMinCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            absMinCoolSetpointLimitArgument, this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_12() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMinCoolSetpointLimit_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMaxCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxCoolSetpointLimit_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t absMaxCoolSetpointLimitArgument;
        absMaxCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            absMaxCoolSetpointLimitArgument, this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_16() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutOccupiedCoolingSetpoint_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedCoolingSetpoint_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckConstraintType("occupiedCoolingSetpoint", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedCoolingSetpoint_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutOccupiedCoolingSetpoint_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutOccupiedHeatingSetpoint_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedHeatingSetpoint_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckConstraintType("occupiedHeatingSetpoint", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2600));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedHeatingSetpoint_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutOccupiedHeatingSetpoint_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMinHeatSetpointLimit_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minHeatSetpointLimit", minHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMinHeatSetpointLimit_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("minHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinHeatSetpointLimit_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMinHeatSetpointLimit_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minHeatSetpointLimit", minHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMaxHeatSetpointLimit_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMaxHeatSetpointLimit_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("maxHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxHeatSetpointLimit_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMaxHeatSetpointLimit_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMinCoolSetpointLimit_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minCoolSetpointLimit", minCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMinCoolSetpointLimit_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("minCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinCoolSetpointLimit_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMinCoolSetpointLimit_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minCoolSetpointLimit", minCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMaxCoolSetpointLimit_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMaxCoolSetpointLimit_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("maxCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxCoolSetpointLimit_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMaxCoolSetpointLimit_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutControlSequenceOfOperation_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue("controlSequenceOfOperation", controlSequenceOfOperation, 4));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutControlSequenceOfOperation_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckConstraintType("controlSequenceOfOperation", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 5));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutControlSequenceOfOperation_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlSequenceOfOperationArgument;
        controlSequenceOfOperationArgument = static_cast<uint8_t>(4);

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            controlSequenceOfOperationArgument, this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutControlSequenceOfOperation_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue("controlSequenceOfOperation", controlSequenceOfOperation, 4));

        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutSystemMode_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(this, OnSuccessCallback_46,
                                                                                                        OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(uint8_t systemMode)
    {
        VerifyOrReturn(CheckValue("systemMode", systemMode, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutSystemMode_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(this, OnSuccessCallback_47,
                                                                                                        OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47(uint8_t systemMode)
    {
        VerifyOrReturn(CheckConstraintType("systemMode", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("systemMode", systemMode, 9));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutSystemMode_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t systemModeArgument;
        systemModeArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(
            systemModeArgument, this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutSystemMode_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(this, OnSuccessCallback_49,
                                                                                                        OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49(uint8_t systemMode)
    {
        VerifyOrReturn(CheckValue("systemMode", systemMode, 1));

        NextTest();
    }

    CHIP_ERROR TestReadsOptionalAttributesFromDutMinSetpointDeadBand_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_50, OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckValue("minSetpointDeadBand", minSetpointDeadBand, 25));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutMinSetpointDeadBand_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckConstraintType("minSetpointDeadBand", "", "int8"));
        VerifyOrReturn(CheckConstraintMaxValue<int8_t>("minSetpointDeadBand", minSetpointDeadBand, 25));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutMinSetpointDeadBand_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t minSetpointDeadBandArgument;
        minSetpointDeadBandArgument = 25;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            minSetpointDeadBandArgument, this, OnSuccessCallback_52, OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52() { NextTest(); }

    CHIP_ERROR TestReadBackOptionalAttributesFromDutMinSetpointDeadBand_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_53, OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckValue("minSetpointDeadBand", minSetpointDeadBand, 25));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutStartOfWeek_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(this, OnSuccessCallback_54,
                                                                                                         OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(uint8_t startOfWeek)
    {
        VerifyOrReturn(CheckConstraintType("startOfWeek", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("startOfWeek", startOfWeek, 6));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutStartOfWeek_55()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t startOfWeekArgument;
        startOfWeekArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(
            startOfWeekArgument, this, OnSuccessCallback_55, OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_55() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackOptionalAttributesFromDutStartOfWeek_56()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(this, OnSuccessCallback_56,
                                                                                                         OnFailureCallback_56);
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(uint8_t startOfWeek)
    {
        VerifyOrReturn(CheckValue("startOfWeek", startOfWeek, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutNumberOfWeeklyTransitions_57()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo>(
            this, OnSuccessCallback_57, OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_57(uint8_t numberOfWeeklyTransitions)
    {
        VerifyOrReturn(CheckConstraintType("numberOfWeeklyTransitions", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfWeeklyTransitions_58()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t numberOfWeeklyTransitionsArgument;
        numberOfWeeklyTransitionsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo>(
            numberOfWeeklyTransitionsArgument, this, OnSuccessCallback_58, OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_58() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutNumberOfDailyTransitions_59()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo>(
            this, OnSuccessCallback_59, OnFailureCallback_59);
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59(uint8_t numberOfDailyTransitions)
    {
        VerifyOrReturn(CheckConstraintType("numberOfDailyTransitions", "", "uint8"));

        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfDailyTransitions_60()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t numberOfDailyTransitionsArgument;
        numberOfDailyTransitionsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo>(
            numberOfDailyTransitionsArgument, this, OnSuccessCallback_60, OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_60() { ThrowSuccessResponse(); }
};

class Test_TC_TSTAT_2_2 : public TestCommand
{
public:
    Test_TC_TSTAT_2_2() : TestCommand("Test_TC_TSTAT_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Reads OccupiedCoolingSetpoint attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsOccupiedCoolingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 2 : Writes a value back that is different but valid for OccupiedCoolingSetpoint attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForOccupiedCoolingSetpointAttribute_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 3 : Reads it back again to confirm the successful write of OccupiedCoolingSetpoint attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedCoolingSetpointAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Writes the limit of MinCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            err = TestWritesTheLimitOfMinCoolSetpointLimitToOccupiedCoolingSetpointAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Writes the limit of MaxCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToOccupiedCoolingSetpointAttribute_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Reads OccupiedHeatingSetpoint attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsOccupiedHeatingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 7 : Writes a value back that is different but valid for OccupiedHeatingSetpoint attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForOccupiedHeatingSetpointAttribute_7();
            break;
        case 8:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 8 : Reads it back again to confirm the successful write of OccupiedHeatingSetpoint attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedHeatingSetpointAttribute_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes the limit of MinHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            err = TestWritesTheLimitOfMinHeatSetpointLimitToOccupiedHeatingSetpointAttribute_9();
            break;
        case 10:
            ChipLogProgress(
                chipTool, " ***** Test Step 10 : Writes the limit of MaxHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            err = TestWritesTheLimitOfMaxHeatSetpointLimitToOccupiedHeatingSetpointAttribute_10();
            break;
        case 11:
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : Reads MinHeatSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsMinHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_11();
            break;
        case 12:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 12 : Writes a value back that is different but valid for MinHeatSetpointLimit attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForMinHeatSetpointLimitAttribute_12();
            break;
        case 13:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 13 : Reads it back again to confirm the successful write of MinHeatSetpointLimit attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinHeatSetpointLimitAttribute_13();
            break;
        case 14:
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : Writes the limit of AbsMinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_14();
            break;
        case 15:
            ChipLogProgress(
                chipTool, " ***** Test Step 15 : Writes the limit of AbsMaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : Reads MaxHeatSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsMaxHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_16();
            break;
        case 17:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : Writes a value back that is different but valid for MaxHeatSetpointLimit attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForMaxHeatSetpointLimitAttribute_17();
            break;
        case 18:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 18 : Reads it back again to confirm the successful write of MaxHeatSetpointLimit attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxHeatSetpointLimitAttribute_18();
            break;
        case 19:
            ChipLogProgress(
                chipTool, " ***** Test Step 19 : Writes the limit of AbsMinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_19();
            break;
        case 20:
            ChipLogProgress(
                chipTool, " ***** Test Step 20 : Writes the limit of AbsMaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_20();
            break;
        case 21:
            ChipLogProgress(chipTool,
                            " ***** Test Step 21 : Reads MinCoolSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsMinCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_21();
            break;
        case 22:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 22 : Writes a value back that is different but valid for MinCoolSetpointLimit attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForMinCoolSetpointLimitAttribute_22();
            break;
        case 23:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 23 : Reads it back again to confirm the successful write of MinCoolSetpointLimit attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinCoolSetpointLimitAttribute_23();
            break;
        case 24:
            ChipLogProgress(
                chipTool, " ***** Test Step 24 : Writes the limit of AbsMinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_24();
            break;
        case 25:
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : Writes the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_25();
            break;
        case 26:
            ChipLogProgress(chipTool,
                            " ***** Test Step 26 : Reads MaxCoolSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsMaxCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_26();
            break;
        case 27:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 27 : Writes a value back that is different but valid for MaxCoolSetpointLimit attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForMaxCoolSetpointLimitAttribute_27();
            break;
        case 28:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 28 : Reads it back again to confirm the successful write of MaxCoolSetpointLimit attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxCoolSetpointLimitAttribute_28();
            break;
        case 29:
            ChipLogProgress(
                chipTool, " ***** Test Step 29 : Writes the limit of AbsMinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_29();
            break;
        case 30:
            ChipLogProgress(chipTool,
                            " ***** Test Step 30 : Writes the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_30();
            break;
        case 31:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 31 : Writes (sets back) the limit of MinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_31();
            break;
        case 32:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 32 : Writes (sets back) the limit of MaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_32();
            break;
        case 33:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 33 : Writes (sets back) the limit of MinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_33();
            break;
        case 34:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 34 : Writes (sets back) the limit of MaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_34();
            break;
        case 35:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 35 : Writes (sets back) the limit of MinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_35();
            break;
        case 36:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 36 : Writes (sets back) the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_36();
            break;
        case 37:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 37 : Writes (sets back) the limit of MinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_37();
            break;
        case 38:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 38 : Writes (sets back) the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_38();
            break;
        case 39:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 39 : Reads ControlSequenceOfOperation from Server DUT and verifies that the value is valid\n");
            err = TestReadsControlSequenceOfOperationFromServerDutAndVerifiesThatTheValueIsValid_39();
            break;
        case 40:
            ChipLogProgress(
                chipTool, " ***** Test Step 40 : Write Attribute command for ControlSequenceOfOperation with a new valid value\n");
            err = TestWriteAttributeCommandForControlSequenceOfOperationWithANewValidValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read it back again to confirm the successful write\n");
            err = TestReadItBackAgainToConfirmTheSuccessfulWrite_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Sets OccupiedHeatingSetpoint to default value\n");
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Sets OccupiedHeatingSetpoint to default value\n");
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Sets OccupiedCoolingSetpoint to default value\n");
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Sets OccupiedCoolingSetpoint to default value\n");
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Sets OccupiedCoolingSetpoint to default value\n");
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Sets OccupiedHeatingSetpoint to default value\n");
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Sets OccupiedCoolingSetpoint to default value\n");
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Sets OccupiedHeatingSetpoint to default value\n");
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_49();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 50;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_1(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_3(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_6(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_8(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_11(minHeatSetpointLimit);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_13(minHeatSetpointLimit);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_16(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_18(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_19(); }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_21(minCoolSetpointLimit);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_22(); }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_23(minCoolSetpointLimit);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_25(); }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_26(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_27(); }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_28(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_30(); }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_31(); }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_33(); }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_34(); }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_36(); }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_38(); }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_39(controlSequenceOfOperation);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_40(); }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_41(controlSequenceOfOperation);
    }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_43(); }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_45(); }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_46(); }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_48(); }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_49(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsOccupiedCoolingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));

        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForOccupiedCoolingSetpointAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedCoolingSetpointAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfMinCoolSetpointLimitToOccupiedCoolingSetpointAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToOccupiedCoolingSetpointAttribute_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadsOccupiedHeatingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForOccupiedHeatingSetpointAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2100;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedHeatingSetpointAttribute_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2100));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfMinHeatSetpointLimitToOccupiedHeatingSetpointAttribute_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxHeatSetpointLimitToOccupiedHeatingSetpointAttribute_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadsMinHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minHeatSetpointLimit", minHeatSetpointLimit, 700));

        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMinHeatSetpointLimitAttribute_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinHeatSetpointLimitAttribute_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minHeatSetpointLimit", minHeatSetpointLimit, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadsMaxHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));

        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMaxHeatSetpointLimitAttribute_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxHeatSetpointLimitAttribute_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxHeatSetpointLimit", maxHeatSetpointLimit, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadsMinCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minCoolSetpointLimit", minCoolSetpointLimit, 1600));

        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMinCoolSetpointLimitAttribute_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinCoolSetpointLimitAttribute_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("minCoolSetpointLimit", minCoolSetpointLimit, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadsMaxCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));

        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMaxCoolSetpointLimitAttribute_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxCoolSetpointLimitAttribute_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue("maxCoolSetpointLimit", maxCoolSetpointLimit, 2000));

        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38() { NextTest(); }

    CHIP_ERROR TestReadsControlSequenceOfOperationFromServerDutAndVerifiesThatTheValueIsValid_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue("controlSequenceOfOperation", controlSequenceOfOperation, 4));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCommandForControlSequenceOfOperationWithANewValidValue_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t controlSequenceOfOperationArgument;
        controlSequenceOfOperationArgument = static_cast<uint8_t>(2);

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            controlSequenceOfOperationArgument, this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40() { NextTest(); }

    CHIP_ERROR TestReadItBackAgainToConfirmTheSuccessfulWrite_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue("controlSequenceOfOperation", controlSequenceOfOperation, 2));

        NextTest();
    }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_46, OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_49, OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49() { NextTest(); }
};

class Test_TC_TSUIC_1_1 : public TestCommand
{
public:
    Test_TC_TSUIC_1_1() : TestCommand("Test_TC_TSUIC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }
};

class Test_TC_TSUIC_2_1 : public TestCommand
{
public:
    Test_TC_TSUIC_2_1() : TestCommand("Test_TC_TSUIC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : write to the mandatory attribute: TemperatureDisplayMode\n");
            err = TestWriteToTheMandatoryAttributeTemperatureDisplayMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write to the mandatory attribute: KeypadLockout\n");
            err = TestWriteToTheMandatoryAttributeKeypadLockout_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : write to the mandatory attribute: ScheduleProgrammingVisibility\n");
            err = TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_1(temperatureDisplayMode);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_2(temperatureDisplayMode);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_4(temperatureDisplayMode);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_5(temperatureDisplayMode);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_6(keypadLockout);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_7(keypadLockout);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_9(keypadLockout);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_10(keypadLockout);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_11(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_12(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_13(); }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_14(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_15(scheduleProgrammingVisibility);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue("temperatureDisplayMode", temperatureDisplayMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeTemperatureDisplayMode_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue("temperatureDisplayMode", temperatureDisplayMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue("keypadLockout", keypadLockout, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeKeypadLockout_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(0);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue("keypadLockout", keypadLockout, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));

        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));

        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));

        NextTest();
    }
};

class Test_TC_TSUIC_2_2 : public TestCommand
{
public:
    Test_TC_TSUIC_2_2() : TestCommand("Test_TC_TSUIC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Writes a value of 0 to TemperatureDisplayMode attribute of DUT\n");
            err = TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Writes a value of 1 to TemperatureDisplayMode attribute of DUT\n");
            err = TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Writes a value of 0 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Writes a value of 1 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Writes a value of 2 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Writes a value of 3 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes a value of 4 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Writes a value of 5 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes a value of 0 to ScheduleProgrammingVisibility attribute of DUT\n");
            err = TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Writes a value of 1 to ScheduleProgrammingVisibility attribute of DUT\n");
            err = TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_10(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(0);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(1);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(2);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(3);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(4);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(5);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }
};

class Test_TC_DIAGTH_1_1 : public TestCommand
{
public:
    Test_TC_DIAGTH_1_1() : TestCommand("Test_TC_DIAGTH_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGTH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGTH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_4(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));

        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue("clusterRevision", clusterRevision, 1U));

        NextTest();
    }
};

class Test_TC_WNCV_1_1 : public TestCommand
{
public:
    Test_TC_WNCV_1_1() : TestCommand("Test_TC_WNCV_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2: read the global attribute: ClusterRevision\n");
            err = Test2ReadTheGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : 3a: write a value into the RO mandatory global attribute: ClusterRevision\n");
            err = Test3aWriteAValueIntoTheRoMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3b: reads back global attribute: ClusterRevision\n");
            err = Test3bReadsBackGlobalAttributeClusterRevision_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 2: read the global attribute: FeatureMap\n");
            err = Test2ReadTheGlobalAttributeFeatureMap_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : 3a: write the default value to optional global attribute: FeatureMap\n");
            err = Test3aWriteTheDefaultValueToOptionalGlobalAttributeFeatureMap_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : 3b: reads back global attribute: FeatureMap\n");
            err = Test3bReadsBackGlobalAttributeFeatureMap_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_3(clusterRevision);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_4(featureMap);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_6(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR Test2ReadTheGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        VerifyOrReturn(CheckConstraintMinValue<uint16_t>("clusterRevision", clusterRevision, 5));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("clusterRevision", clusterRevision, 200));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 201U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        VerifyOrReturn(CheckConstraintNotValue("clusterRevision", clusterRevision, 201U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheGlobalAttributeFeatureMap_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "uint32"));
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("featureMap", featureMap, 32768));

        NextTest();
    }

    CHIP_ERROR Test3aWriteTheDefaultValueToOptionalGlobalAttributeFeatureMap_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t featureMapArgument;
        featureMapArgument = 32769UL;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::FeatureMap::TypeInfo>(
            featureMapArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackGlobalAttributeFeatureMap_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint32_t featureMap)
    {
        VerifyOrReturn(CheckConstraintType("featureMap", "", "uint32"));
        VerifyOrReturn(CheckConstraintNotValue("featureMap", featureMap, 32769UL));

        NextTest();
    }
};

class Test_TC_WNCV_2_1 : public TestCommand
{
public:
    Test_TC_WNCV_2_1() : TestCommand("Test_TC_WNCV_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2: read the RO mandatory attribute default: Type\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultType_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: write a value into the RO mandatory attribute: Type\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeType_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3b: reads back the RO mandatory attribute: Type\n");
            err = Test3bReadsBackTheRoMandatoryAttributeType_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : 2: read the RO mandatory attribute default: ConfigStatus\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultConfigStatus_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : 3a: write a value into the RO mandatory attribute: ConfigStatus\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeConfigStatus_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : 3b: reads back the RO mandatory attribute: ConfigStatus\n");
            err = Test3bReadsBackTheRoMandatoryAttributeConfigStatus_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : 2: read the RO mandatory attribute default: OperationalStatus\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultOperationalStatus_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : 3a: write a value into the RO mandatory attribute: OperationalStatus\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeOperationalStatus_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : 3b: reads back the RO mandatory attribute: OperationalStatus\n");
            err = Test3bReadsBackTheRoMandatoryAttributeOperationalStatus_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : 2: read the RO mandatory attribute default: EndProductType\n");
            err = Test2ReadTheRoMandatoryAttributeDefaultEndProductType_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : 3a: write a value into the RO mandatory attribute: EndProductType\n");
            err = Test3aWriteAValueIntoTheRoMandatoryAttributeEndProductType_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : 3b: reads back the RO mandatory attribute: EndProductType\n");
            err = Test3bReadsBackTheRoMandatoryAttributeEndProductType_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : 2: read the RW mandatory attribute default: Mode\n");
            err = Test2ReadTheRwMandatoryAttributeDefaultMode_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : 3a: write a value into the RW mandatory attribute:: Mode\n");
            err = Test3aWriteAValueIntoTheRwMandatoryAttributeMode_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : 3b: reads back the RW mandatory attribute: Mode\n");
            err = Test3bReadsBackTheRwMandatoryAttributeMode_15();
            break;
        case 16:
            ChipLogProgress(chipTool,
                            " ***** Test Step 16 : 2: read the RO optional attribute default: TargetPositionLiftPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultTargetPositionLiftPercent100ths_16();
            break;
        case 17:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : 3a: write a value into the RO optional attribute: TargetPositionLiftPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionLiftPercent100ths_17();
            break;
        case 18:
            ChipLogProgress(chipTool,
                            " ***** Test Step 18 : 3b: reads back the RO optional attribute: TargetPositionLiftPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeTargetPositionLiftPercent100ths_18();
            break;
        case 19:
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : 2: read the RO optional attribute default: TargetPositionTiltPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultTargetPositionTiltPercent100ths_19();
            break;
        case 20:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 20 : 3a: write a value into the RO optional attribute: TargetPositionTiltPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionTiltPercent100ths_20();
            break;
        case 21:
            ChipLogProgress(chipTool,
                            " ***** Test Step 21 : 3b: reads back the RO optional attribute: TargetPositionTiltPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeTargetPositionTiltPercent100ths_21();
            break;
        case 22:
            ChipLogProgress(chipTool,
                            " ***** Test Step 22 : 2: read the RO optional attribute default: CurrentPositionLiftPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercent100ths_22();
            break;
        case 23:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 23 : 3a: write a value into the RO optional attribute: CurrentPositionLiftPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercent100ths_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : 3b: reads back the RO optional attribute: CurrentPositionLiftPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercent100ths_24();
            break;
        case 25:
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : 2: read the RO optional attribute default: CurrentPositionTiltPercent100ths\n");
            err = Test2ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercent100ths_25();
            break;
        case 26:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 26 : 3a: write a value into the RO optional attribute: CurrentPositionTiltPercent100ths\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercent100ths_26();
            break;
        case 27:
            ChipLogProgress(chipTool,
                            " ***** Test Step 27 : 3b: reads back the RO optional attribute: CurrentPositionTiltPercent100ths\n");
            err = Test3bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercent100ths_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : 2: read the RO optional attribute default: InstalledOpenLimitLift\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitLift_28();
            break;
        case 29:
            ChipLogProgress(chipTool,
                            " ***** Test Step 29 : 3a: write a value into the RO optional attribute: InstalledOpenLimitLift\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitLift_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : 3b: reads back the RO optional attribute: InstalledOpenLimitLift\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitLift_30();
            break;
        case 31:
            ChipLogProgress(chipTool,
                            " ***** Test Step 31 : 2: read the RO optional attribute default: InstalledClosedLimitLift\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitLift_31();
            break;
        case 32:
            ChipLogProgress(chipTool,
                            " ***** Test Step 32 : 3a: write a value into the RO optional attribute: InstalledClosedLimitLift\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitLift_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : 3b: reads back the RO optional attribute: InstalledClosedLimitLift\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitLift_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : 2: read the RO optional attribute default: InstalledOpenLimitTilt\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitTilt_34();
            break;
        case 35:
            ChipLogProgress(chipTool,
                            " ***** Test Step 35 : 3a: write a value into the RO optional attribute: InstalledOpenLimitTilt\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitTilt_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : 3b: reads back the RO optional attribute: InstalledOpenLimitTilt\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitTilt_36();
            break;
        case 37:
            ChipLogProgress(chipTool,
                            " ***** Test Step 37 : 2: read the RO optional attribute default: InstalledClosedLimitTilt\n");
            err = Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitTilt_37();
            break;
        case 38:
            ChipLogProgress(chipTool,
                            " ***** Test Step 38 : 3a: write a value into the RO optional attribute: InstalledClosedLimitTilt\n");
            err = Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitTilt_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : 3b: reads back the RO optional attribute: InstalledClosedLimitTilt\n");
            err = Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitTilt_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : 4: read the RO mandatory attribute default: SafetyStatus\n");
            err = Test4ReadTheRoMandatoryAttributeDefaultSafetyStatus_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : 5a: write a value into the RO mandatory attribute: SafetyStatus\n");
            err = Test5aWriteAValueIntoTheRoMandatoryAttributeSafetyStatus_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : 5b: reads back the RO mandatory attribute: SafetyStatus\n");
            err = Test5bReadsBackTheRoMandatoryAttributeSafetyStatus_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : 4: read the RO optional attribute default: CurrentPositionLift\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLift_43();
            break;
        case 44:
            ChipLogProgress(chipTool,
                            " ***** Test Step 44 : 5a: write a value into the RO optional attribute: CurrentPositionLift\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLift_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : 5b: reads back the RO optional attribute: CurrentPositionLift\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionLift_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : 4: read the RO optional attribute default: CurrentPositionTilt\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTilt_46();
            break;
        case 47:
            ChipLogProgress(chipTool,
                            " ***** Test Step 47 : 5a: write a value into the RO optional attribute: CurrentPositionTilt\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTilt_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : 5b: reads back the RO optional attribute: CurrentPositionTilt\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionTilt_48();
            break;
        case 49:
            ChipLogProgress(chipTool,
                            " ***** Test Step 49 : 4: read the RO optional attribute default: CurrentPositionLiftPercentage\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercentage_49();
            break;
        case 50:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 50 : 5a: write a value into the RO optional attribute: CurrentPositionLiftPercentage\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercentage_50();
            break;
        case 51:
            ChipLogProgress(chipTool,
                            " ***** Test Step 51 : 5b: reads back the RO optional attribute: CurrentPositionLiftPercentage\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercentage_51();
            break;
        case 52:
            ChipLogProgress(chipTool,
                            " ***** Test Step 52 : 4: read the RO optional attribute default: CurrentPositionTiltPercentage\n");
            err = Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercentage_52();
            break;
        case 53:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 53 : 5a: write a value into the RO optional attribute: CurrentPositionTiltPercentage\n");
            err = Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercentage_53();
            break;
        case 54:
            ChipLogProgress(chipTool,
                            " ***** Test Step 54 : 5b: reads back the RO optional attribute: CurrentPositionTiltPercentage\n");
            err = Test5bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercentage_54();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 55;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_1(type);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_3(type);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_4(configStatus);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_6(configStatus);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_7(operationalStatus);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_9(operationalStatus);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_10(endProductType);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_12(endProductType);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_13(mode);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_15(mode);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, uint16_t targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_16(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, uint16_t targetPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_18(targetPositionLiftPercent100ths);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, uint16_t targetPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_19(targetPositionTiltPercent100ths);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, uint16_t targetPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_21(targetPositionTiltPercent100ths);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, uint16_t currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_22(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_23(); }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context, uint16_t currentPositionLiftPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_24(currentPositionLiftPercent100ths);
    }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, uint16_t currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_25(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_26(); }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context, uint16_t currentPositionTiltPercent100ths)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_27(currentPositionTiltPercent100ths);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, uint16_t installedOpenLimitLift)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_28(installedOpenLimitLift);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, uint16_t installedOpenLimitLift)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_30(installedOpenLimitLift);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, uint16_t installedClosedLimitLift)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_31(installedClosedLimitLift);
    }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context, uint16_t installedClosedLimitLift)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_33(installedClosedLimitLift);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, uint16_t installedOpenLimitTilt)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_34(installedOpenLimitTilt);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context, uint16_t installedOpenLimitTilt)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_36(installedOpenLimitTilt);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context, uint16_t installedClosedLimitTilt)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_37(installedClosedLimitTilt);
    }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_38(); }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, uint16_t installedClosedLimitTilt)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_39(installedClosedLimitTilt);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, uint16_t safetyStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_40(safetyStatus);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_41(); }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context, uint16_t safetyStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_42(safetyStatus);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context, uint16_t currentPositionLift)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_43(currentPositionLift);
    }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context, uint16_t currentPositionLift)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_45(currentPositionLift);
    }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context, uint16_t currentPositionTilt)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_46(currentPositionTilt);
    }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context, uint16_t currentPositionTilt)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_48(currentPositionTilt);
    }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context, uint8_t currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_49(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_50(); }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context, uint8_t currentPositionLiftPercentage)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_51(currentPositionLiftPercentage);
    }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context, uint8_t currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_52(currentPositionTiltPercentage);
    }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_53(); }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context, uint8_t currentPositionTiltPercentage)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_54(currentPositionTiltPercentage);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultType_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                      OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t type)
    {
        VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("type", type, 9));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeType_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t typeArgument;
        typeArgument = static_cast<uint8_t>(250);

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(
            typeArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeType_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                      OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t type)
    {
        VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
        VerifyOrReturn(CheckConstraintNotValue("type", type, 250));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultConfigStatus_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t configStatus)
    {
        VerifyOrReturn(CheckConstraintType("configStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("configStatus", configStatus, 63));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeConfigStatus_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t configStatusArgument;
        configStatusArgument = 128;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::TypeInfo>(
            configStatusArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_5() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeConfigStatus_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t configStatus)
    {
        VerifyOrReturn(CheckConstraintType("configStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintNotValue("configStatus", configStatus, 128));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultOperationalStatus_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("operationalStatus", operationalStatus, 63));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeOperationalStatus_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t operationalStatusArgument;
        operationalStatusArgument = 128;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            operationalStatusArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeOperationalStatus_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckConstraintType("operationalStatus", "", "map8"));
        VerifyOrReturn(CheckConstraintNotValue("operationalStatus", operationalStatus, 128));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoMandatoryAttributeDefaultEndProductType_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t endProductType)
    {
        VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("endProductType", endProductType, 23));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoMandatoryAttributeEndProductType_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t endProductTypeArgument;
        endProductTypeArgument = static_cast<uint8_t>(250);

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            endProductTypeArgument, this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_11() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoMandatoryAttributeEndProductType_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t endProductType)
    {
        VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
        VerifyOrReturn(CheckConstraintNotValue("endProductType", endProductType, 250));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRwMandatoryAttributeDefaultMode_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(this, OnSuccessCallback_13,
                                                                                                      OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t mode)
    {
        VerifyOrReturn(CheckConstraintType("mode", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("mode", mode, 15));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRwMandatoryAttributeMode_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t modeArgument;
        modeArgument = 8;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(
            modeArgument, this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR Test3bReadsBackTheRwMandatoryAttributeMode_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(this, OnSuccessCallback_15,
                                                                                                      OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint8_t mode)
    {
        VerifyOrReturn(CheckValue("mode", mode, 8));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultTargetPositionLiftPercent100ths_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t targetPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMaxValue<uint16_t>("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths, 10000));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionLiftPercent100ths_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t targetPositionLiftPercent100thsArgument;
        targetPositionLiftPercent100thsArgument = 20000U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
            targetPositionLiftPercent100thsArgument, this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_17() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeTargetPositionLiftPercent100ths_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint16_t targetPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(CheckConstraintNotValue("targetPositionLiftPercent100ths", targetPositionLiftPercent100ths, 20000U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultTargetPositionTiltPercent100ths_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint16_t targetPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMaxValue<uint16_t>("targetPositionTiltPercent100ths", targetPositionTiltPercent100ths, 10000));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeTargetPositionTiltPercent100ths_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t targetPositionTiltPercent100thsArgument;
        targetPositionTiltPercent100thsArgument = 20000U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
            targetPositionTiltPercent100thsArgument, this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_20() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeTargetPositionTiltPercent100ths_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(uint16_t targetPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("targetPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(CheckConstraintNotValue("targetPositionTiltPercent100ths", targetPositionTiltPercent100ths, 20000U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercent100ths_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint16_t currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMaxValue<uint16_t>("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 10000));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercent100ths_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t currentPositionLiftPercent100thsArgument;
        currentPositionLiftPercent100thsArgument = 20000U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
            currentPositionLiftPercent100thsArgument, this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_23() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercent100ths_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::TypeInfo>(
            this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint16_t currentPositionLiftPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercent100ths", "", "uint16"));
        VerifyOrReturn(CheckConstraintNotValue("currentPositionLiftPercent100ths", currentPositionLiftPercent100ths, 20000U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercent100ths_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint16_t currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(
            CheckConstraintMaxValue<uint16_t>("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 10000));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercent100ths_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t currentPositionTiltPercent100thsArgument;
        currentPositionTiltPercent100thsArgument = 20000U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
            currentPositionTiltPercent100thsArgument, this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_26() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercent100ths_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint16_t currentPositionTiltPercent100ths)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercent100ths", "", "uint16"));
        VerifyOrReturn(CheckConstraintNotValue("currentPositionTiltPercent100ths", currentPositionTiltPercent100ths, 20000U));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitLift_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint16_t installedOpenLimitLift)
    {
        VerifyOrReturn(CheckConstraintType("installedOpenLimitLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitLift", installedOpenLimitLift, 65535));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitLift_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t installedOpenLimitLiftArgument;
        installedOpenLimitLiftArgument = 255U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo>(
            installedOpenLimitLiftArgument, this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_29() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitLift_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitLift::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint16_t installedOpenLimitLift)
    {
        VerifyOrReturn(CheckConstraintType("installedOpenLimitLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitLift", installedOpenLimitLift, 65535));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitLift_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint16_t installedClosedLimitLift)
    {
        VerifyOrReturn(CheckConstraintType("installedClosedLimitLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitLift", installedClosedLimitLift, 65535));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitLift_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t installedClosedLimitLiftArgument;
        installedClosedLimitLiftArgument = 255U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo>(
            installedClosedLimitLiftArgument, this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_32() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitLift_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitLift::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(uint16_t installedClosedLimitLift)
    {
        VerifyOrReturn(CheckConstraintType("installedClosedLimitLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitLift", installedClosedLimitLift, 65535));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledOpenLimitTilt_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint16_t installedOpenLimitTilt)
    {
        VerifyOrReturn(CheckConstraintType("installedOpenLimitTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitTilt", installedOpenLimitTilt, 65535));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledOpenLimitTilt_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t installedOpenLimitTiltArgument;
        installedOpenLimitTiltArgument = 255U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo>(
            installedOpenLimitTiltArgument, this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_35() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledOpenLimitTilt_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitTilt::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(uint16_t installedOpenLimitTilt)
    {
        VerifyOrReturn(CheckConstraintType("installedOpenLimitTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedOpenLimitTilt", installedOpenLimitTilt, 65535));

        NextTest();
    }

    CHIP_ERROR Test2ReadTheRoOptionalAttributeDefaultInstalledClosedLimitTilt_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo>(
            this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(uint16_t installedClosedLimitTilt)
    {
        VerifyOrReturn(CheckConstraintType("installedClosedLimitTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitTilt", installedClosedLimitTilt, 65535));

        NextTest();
    }

    CHIP_ERROR Test3aWriteAValueIntoTheRoOptionalAttributeInstalledClosedLimitTilt_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t installedClosedLimitTiltArgument;
        installedClosedLimitTiltArgument = 255U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo>(
            installedClosedLimitTiltArgument, this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_38() { ThrowSuccessResponse(); }

    CHIP_ERROR Test3bReadsBackTheRoOptionalAttributeInstalledClosedLimitTilt_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitTilt::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint16_t installedClosedLimitTilt)
    {
        VerifyOrReturn(CheckConstraintType("installedClosedLimitTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("installedClosedLimitTilt", installedClosedLimitTilt, 65535));

        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoMandatoryAttributeDefaultSafetyStatus_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::SafetyStatus::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint16_t safetyStatus)
    {
        VerifyOrReturn(CheckConstraintType("safetyStatus", "", "map16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("safetyStatus", safetyStatus, 2047));

        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoMandatoryAttributeSafetyStatus_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t safetyStatusArgument;
        safetyStatusArgument = 4096U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::SafetyStatus::TypeInfo>(
            safetyStatusArgument, this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_41() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoMandatoryAttributeSafetyStatus_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::SafetyStatus::TypeInfo>(
            this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint16_t safetyStatus)
    {
        VerifyOrReturn(CheckConstraintType("safetyStatus", "", "map16"));
        VerifyOrReturn(CheckConstraintNotValue("safetyStatus", safetyStatus, 4096U));

        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLift_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLift::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint16_t currentPositionLift)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionLift", currentPositionLift, 65535));

        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLift_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t currentPositionLiftArgument;
        currentPositionLiftArgument = 255U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLift::TypeInfo>(
            currentPositionLiftArgument, this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_44() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionLift_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLift::TypeInfo>(
            this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint16_t currentPositionLift)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLift", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionLift", currentPositionLift, 65535));

        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTilt_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTilt::TypeInfo>(
            this, OnSuccessCallback_46, OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(uint16_t currentPositionTilt)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionTilt", currentPositionTilt, 65535));

        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTilt_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t currentPositionTiltArgument;
        currentPositionTiltArgument = 255U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTilt::TypeInfo>(
            currentPositionTiltArgument, this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_47() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionTilt_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTilt::TypeInfo>(
            this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(uint16_t currentPositionTilt)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTilt", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentPositionTilt", currentPositionTilt, 65535));

        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionLiftPercentage_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
            this, OnSuccessCallback_49, OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49(uint8_t currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentPositionLiftPercentage", currentPositionLiftPercentage, 100));

        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionLiftPercentage_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t currentPositionLiftPercentageArgument;
        currentPositionLiftPercentageArgument = 200;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
            currentPositionLiftPercentageArgument, this, OnSuccessCallback_50, OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_50() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionLiftPercentage_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51(uint8_t currentPositionLiftPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionLiftPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintNotValue("currentPositionLiftPercentage", currentPositionLiftPercentage, 200));

        NextTest();
    }

    CHIP_ERROR Test4ReadTheRoOptionalAttributeDefaultCurrentPositionTiltPercentage_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
            this, OnSuccessCallback_52, OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(uint8_t currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentPositionTiltPercentage", currentPositionTiltPercentage, 100));

        NextTest();
    }

    CHIP_ERROR Test5aWriteAValueIntoTheRoOptionalAttributeCurrentPositionTiltPercentage_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t currentPositionTiltPercentageArgument;
        currentPositionTiltPercentageArgument = 200;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
            currentPositionTiltPercentageArgument, this, OnSuccessCallback_53, OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
        NextTest();
    }

    void OnSuccessResponse_53() { ThrowSuccessResponse(); }

    CHIP_ERROR Test5bReadsBackTheRoOptionalAttributeCurrentPositionTiltPercentage_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::TypeInfo>(
            this, OnSuccessCallback_54, OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(uint8_t currentPositionTiltPercentage)
    {
        VerifyOrReturn(CheckConstraintType("currentPositionTiltPercentage", "", "uint8"));
        VerifyOrReturn(CheckConstraintNotValue("currentPositionTiltPercentage", currentPositionTiltPercentage, 200));

        NextTest();
    }
};

class Test_TC_WNCV_2_2 : public TestCommand
{
public:
    Test_TC_WNCV_2_2() : TestCommand("Test_TC_WNCV_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class Test_TC_WNCV_2_4 : public TestCommand
{
public:
    Test_TC_WNCV_2_4() : TestCommand("Test_TC_WNCV_2_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Type attribute from DUT\n");
            err = TestReadsTypeAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads Type attribute constraints\n");
            err = TestReadsTypeAttributeConstraints_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_4 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_4 *>(context))->OnSuccessResponse_1(type);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_4 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_4 *>(context))->OnSuccessResponse_2(type);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsTypeAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                      OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t type)
    {
        VerifyOrReturn(CheckValue("type", type, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsTypeAttributeConstraints_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                      OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t type)
    {
        VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("type", type, 9));

        NextTest();
    }
};

class Test_TC_WNCV_2_5 : public TestCommand
{
public:
    Test_TC_WNCV_2_5() : TestCommand("Test_TC_WNCV_2_5"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads EndProductType attribute from DUT\n");
            err = TestReadsEndProductTypeAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads EndProductType attribute constraints from DUT\n");
            err = TestReadsEndProductTypeAttributeConstraintsFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnSuccessResponse_1(endProductType);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnSuccessResponse_2(endProductType);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsEndProductTypeAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue("endProductType", endProductType, 0));

        NextTest();
    }

    CHIP_ERROR TestReadsEndProductTypeAttributeConstraintsFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t endProductType)
    {
        VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("endProductType", endProductType, 23));

        NextTest();
    }
};

class Test_TC_WNCV_3_1 : public TestCommand
{
public:
    Test_TC_WNCV_3_1() : TestCommand("Test_TC_WNCV_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 1a: TH adjusts the the DUT to a non-open position\n");
            err = Test1aThAdjustsTheTheDutToANonOpenPosition_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 2a: TH sends UpOrOpen command to DUT\n");
            err = Test2aThSendsUpOrOpenCommandToDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3a: TH reads OperationalStatus attribute from DUT\n");
            err = Test3aThReadsOperationalStatusAttributeFromDut_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_3(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonOpenPosition_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test2aThSendsUpOrOpenCommandToDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR Test3aThReadsOperationalStatusAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue("operationalStatus", operationalStatus, 0));

        NextTest();
    }
};

class Test_TC_WNCV_3_2 : public TestCommand
{
public:
    Test_TC_WNCV_3_2() : TestCommand("Test_TC_WNCV_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 1a: TH adjusts the the DUT to a non-closed position\n");
            err = Test1aThAdjustsTheTheDutToANonClosedPosition_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 2a: TH sends DownOrClose command to DUT\n");
            err = Test2aThSendsDownOrCloseCommandToDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 3a: TH reads OperationalStatus attribute from DUT\n");
            err = Test3aThReadsOperationalStatusAttributeFromDut_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_3(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonClosedPosition_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test2aThSendsDownOrCloseCommandToDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR Test3aThReadsOperationalStatusAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue("operationalStatus", operationalStatus, 0));

        NextTest();
    }
};

class Test_TC_WNCV_3_3 : public TestCommand
{
public:
    Test_TC_WNCV_3_3() : TestCommand("Test_TC_WNCV_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 1a: TH adjusts the the DUT to a non-open position\n");
            err = Test1aThAdjustsTheTheDutToANonOpenPosition_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 2a: TH sends StopMotion command to DUT\n");
            err = Test2aThSendsStopMotionCommandToDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : 2b: TH reads OperationalStatus attribute from DUT\n");
            err = Test2bThReadsOperationalStatusAttributeFromDut_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_3(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonOpenPosition_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test2aThSendsStopMotionCommandToDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::StopMotion::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR Test2bThReadsOperationalStatusAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue("operationalStatus", operationalStatus, 0));

        NextTest();
    }
};

class TV_TargetNavigatorCluster : public TestCommand
{
public:
    TV_TargetNavigatorCluster() : TestCommand("TV_TargetNavigatorCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TargetNavigatorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TargetNavigatorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Target Navigator list\n");
            err = TestReadAttributeTargetNavigatorList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Navigate Target Command\n");
            err = TestNavigateTargetCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TV_TargetNavigatorCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)
    {
        (static_cast<TV_TargetNavigatorCluster *>(context))->OnSuccessResponse_1(targetNavigatorList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadAttributeTargetNavigatorList_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TargetNavigator::Attributes::TargetNavigatorList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)
    {
        auto iter = targetNavigatorList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(targetNavigatorList)>("targetNavigatorList", iter, 0));
        VerifyOrReturn(CheckValue("targetNavigatorList[0].identifier", iter.GetValue().identifier, 1));
        VerifyOrReturn(CheckValueAsString("targetNavigatorList[0].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(targetNavigatorList)>("targetNavigatorList", iter, 1));
        VerifyOrReturn(CheckValue("targetNavigatorList[1].identifier", iter.GetValue().identifier, 2));
        VerifyOrReturn(CheckValueAsString("targetNavigatorList[1].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(targetNavigatorList)>("targetNavigatorList", iter, 2));

        NextTest();
    }

    CHIP_ERROR TestNavigateTargetCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type;

        RequestType request;
        request.target = 1;
        request.data   = chip::Span<const char>("1garbage: not in length on purpose", 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_TargetNavigatorCluster *>(context))->OnSuccessResponse_2(data.status, data.data);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TargetNavigatorCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::app::Clusters::TargetNavigator::NavigateTargetStatus status, chip::CharSpan data) { NextTest(); }
};

class TV_AudioOutputCluster : public TestCommand
{
public:
    TV_AudioOutputCluster() : TestCommand("TV_AudioOutputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AudioOutputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AudioOutputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Audio Output list\n");
            err = TestReadAttributeAudioOutputList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Select Output Command\n");
            err = TestSelectOutputCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Rename Output Command\n");
            err = TestRenameOutputCommand_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)
    {
        (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_1(audioOutputList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadAttributeAudioOutputList_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 2;
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::AudioOutput::Attributes::AudioOutputList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)
    {
        auto iter = audioOutputList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 0));
        VerifyOrReturn(CheckValue("audioOutputList[0].index", iter.GetValue().index, 1));
        VerifyOrReturn(CheckValue("audioOutputList[0].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[0].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 1));
        VerifyOrReturn(CheckValue("audioOutputList[1].index", iter.GetValue().index, 2));
        VerifyOrReturn(CheckValue("audioOutputList[1].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[1].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 2));
        VerifyOrReturn(CheckValue("audioOutputList[2].index", iter.GetValue().index, 3));
        VerifyOrReturn(CheckValue("audioOutputList[2].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[2].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(audioOutputList)>("audioOutputList", iter, 3));

        NextTest();
    }

    CHIP_ERROR TestSelectOutputCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 2;
        using RequestType               = chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type;

        RequestType request;
        request.index = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestRenameOutputCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 2;
        using RequestType               = chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type;

        RequestType request;
        request.index = 1;
        request.name  = chip::Span<const char>("exampleNamegarbage: not in length on purpose", 11);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }
};

class TV_ApplicationLauncherCluster : public TestCommand
{
public:
    TV_ApplicationLauncherCluster() : TestCommand("TV_ApplicationLauncherCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationLauncherCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationLauncherCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Application Launcher list\n");
            err = TestReadAttributeApplicationLauncherList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Launch App Command\n");
            err = TestLaunchAppCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute catalog vendor id\n");
            err = TestReadAttributeCatalogVendorId_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute application id\n");
            err = TestReadAttributeApplicationId_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_1(applicationLauncherList);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t catalogVendorId)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_3(catalogVendorId);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t applicationId)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_4(applicationId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadAttributeApplicationLauncherList_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationLauncher::Attributes::ApplicationLauncherList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)
    {
        auto iter = applicationLauncherList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(applicationLauncherList)>("applicationLauncherList", iter, 0));
        VerifyOrReturn(CheckValue("applicationLauncherList[0]", iter.GetValue(), 123U));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(applicationLauncherList)>("applicationLauncherList", iter, 1));
        VerifyOrReturn(CheckValue("applicationLauncherList[1]", iter.GetValue(), 456U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(applicationLauncherList)>("applicationLauncherList", iter, 2));

        NextTest();
    }

    CHIP_ERROR TestLaunchAppCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type;

        RequestType request;
        request.data            = chip::Span<const char>("exampleDatagarbage: not in length on purpose", 11);
        request.catalogVendorId = 1U;
        request.applicationId   = chip::Span<const char>("appIdgarbage: not in length on purpose", 5);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_2(data.status, data.data);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::app::Clusters::ApplicationLauncher::ApplicationLauncherStatus status, chip::CharSpan data)
    {

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCatalogVendorId_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogVendorId::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t catalogVendorId)
    {
        VerifyOrReturn(CheckValue("catalogVendorId", catalogVendorId, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationId_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationLauncher::Attributes::ApplicationId::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t applicationId)
    {
        VerifyOrReturn(CheckValue("applicationId", applicationId, 0));

        NextTest();
    }
};

class TV_KeypadInputCluster : public TestCommand
{
public:
    TV_KeypadInputCluster() : TestCommand("TV_KeypadInputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_KeypadInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_KeypadInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Key Command\n");
            err = TestSendKeyCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendKeyCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::KeypadInput::Commands::SendKey::Type;

        RequestType request;
        request.keyCode = static_cast<chip::app::Clusters::KeypadInput::KeypadInputCecKeyCode>(3);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_KeypadInputCluster *>(context))->OnSuccessResponse_1(data.status);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_KeypadInputCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::KeypadInput::KeypadInputStatus status) { NextTest(); }
};

class TV_AccountLoginCluster : public TestCommand
{
public:
    TV_AccountLoginCluster() : TestCommand("TV_AccountLoginCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AccountLoginCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AccountLoginCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Get Setup PIN Command\n");
            err = TestGetSetupPinCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Login Command\n");
            err = TestLoginCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestGetSetupPinCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type;

        RequestType request;
        request.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnSuccessResponse_1(data.setupPIN);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::CharSpan setupPIN) { NextTest(); }

    CHIP_ERROR TestLoginCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::AccountLogin::Commands::Login::Type;

        RequestType request;
        request.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);
        request.setupPIN              = chip::Span<const char>("tempPin123garbage: not in length on purpose", 10);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class TV_WakeOnLanCluster : public TestCommand
{
public:
    TV_WakeOnLanCluster() : TestCommand("TV_WakeOnLanCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_WakeOnLanCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_WakeOnLanCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mac address\n");
            err = TestReadMacAddress_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TV_WakeOnLanCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan wakeOnLanMacAddress)
    {
        (static_cast<TV_WakeOnLanCluster *>(context))->OnSuccessResponse_1(wakeOnLanMacAddress);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadMacAddress_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WakeOnLanClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WakeOnLan::Attributes::WakeOnLanMacAddress::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::CharSpan wakeOnLanMacAddress)
    {
        VerifyOrReturn(CheckValueAsString("wakeOnLanMacAddress", wakeOnLanMacAddress, chip::CharSpan("00:00:00:00:00", 14)));

        NextTest();
    }
};

class TV_ApplicationBasicCluster : public TestCommand
{
public:
    TV_ApplicationBasicCluster() : TestCommand("TV_ApplicationBasicCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationBasicCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationBasicCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Change Status Command\n");
            err = TestChangeStatusCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute vendor id\n");
            err = TestReadAttributeVendorId_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute product id\n");
            err = TestReadAttributeProductId_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute catalog vendor id\n");
            err = TestReadAttributeCatalogVendorId_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t vendorId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_2(vendorId);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint16_t productId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_3(productId);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t catalogVendorId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_4(catalogVendorId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestChangeStatusCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type;

        RequestType request;
        request.status = static_cast<chip::app::Clusters::ApplicationBasic::ApplicationBasicStatus>(1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorId_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::VendorId::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeProductId_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::ProductId::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t productId)
    {
        VerifyOrReturn(CheckValue("productId", productId, 1U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCatalogVendorId_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::CatalogVendorId::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t catalogVendorId)
    {
        VerifyOrReturn(CheckValue("catalogVendorId", catalogVendorId, 1U));

        NextTest();
    }
};

class TV_MediaPlaybackCluster : public TestCommand
{
public:
    TV_MediaPlaybackCluster() : TestCommand("TV_MediaPlaybackCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaPlaybackCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaPlaybackCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Media Playback Play Command\n");
            err = TestMediaPlaybackPlayCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Media Playback Pause Command\n");
            err = TestMediaPlaybackPauseCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Media Playback Stop Command\n");
            err = TestMediaPlaybackStopCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Media Playback Start Over Command\n");
            err = TestMediaPlaybackStartOverCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Media Playback Previous Command\n");
            err = TestMediaPlaybackPreviousCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Media Playback Next Command\n");
            err = TestMediaPlaybackNextCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Media Playback Rewind Command\n");
            err = TestMediaPlaybackRewindCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Media Playback Fast Forward Command\n");
            err = TestMediaPlaybackFastForwardCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Media Playback Skip Forward Command\n");
            err = TestMediaPlaybackSkipForwardCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Media Playback Skip Backward Command\n");
            err = TestMediaPlaybackSkipBackwardCommand_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Media Playback Seek Command\n");
            err = TestMediaPlaybackSeekCommand_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestMediaPlaybackPlayCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_1(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPauseCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_2(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStopCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_3(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStartOverCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_4(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPreviousCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_5(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackNextCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_6(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackRewindCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_7(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackFastForwardCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_8(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipForwardCommand_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type;

        RequestType request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_9(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipBackwardCommand_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type;

        RequestType request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_10(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSeekCommand_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type;

        RequestType request;
        request.position = 100ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_11(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue("mediaPlaybackStatus", mediaPlaybackStatus, 0));

        NextTest();
    }
};

class TV_TvChannelCluster : public TestCommand
{
public:
    TV_TvChannelCluster() : TestCommand("TV_TvChannelCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TvChannelCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TvChannelCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute TV Channel list\n");
            err = TestReadAttributeTvChannelList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Change Channel By Number Command\n");
            err = TestChangeChannelByNumberCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Skip Channel Command\n");
            err = TestSkipChannelCommand_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> &
            tvChannelList)
    {
        (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_1(tvChannelList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadAttributeTvChannelList_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TvChannelClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TvChannel::Attributes::TvChannelList::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                          OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> &
            tvChannelList)
    {
        auto iter = tvChannelList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(tvChannelList)>("tvChannelList", iter, 0));
        VerifyOrReturn(CheckValue("tvChannelList[0].majorNumber", iter.GetValue().majorNumber, 1U));
        VerifyOrReturn(CheckValue("tvChannelList[0].minorNumber", iter.GetValue().minorNumber, 2U));
        VerifyOrReturn(CheckValueAsString("tvChannelList[0].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(
            CheckValueAsString("tvChannelList[0].callSign", iter.GetValue().callSign, chip::CharSpan("exampleCSign", 12)));
        VerifyOrReturn(CheckValueAsString("tvChannelList[0].affiliateCallSign", iter.GetValue().affiliateCallSign,
                                          chip::CharSpan("exampleASign", 12)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(tvChannelList)>("tvChannelList", iter, 1));
        VerifyOrReturn(CheckValue("tvChannelList[1].majorNumber", iter.GetValue().majorNumber, 2U));
        VerifyOrReturn(CheckValue("tvChannelList[1].minorNumber", iter.GetValue().minorNumber, 3U));
        VerifyOrReturn(CheckValueAsString("tvChannelList[1].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(
            CheckValueAsString("tvChannelList[1].callSign", iter.GetValue().callSign, chip::CharSpan("exampleCSign", 12)));
        VerifyOrReturn(CheckValueAsString("tvChannelList[1].affiliateCallSign", iter.GetValue().affiliateCallSign,
                                          chip::CharSpan("exampleASign", 12)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(tvChannelList)>("tvChannelList", iter, 2));

        NextTest();
    }

    CHIP_ERROR TestChangeChannelByNumberCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type;

        RequestType request;
        request.majorNumber = 1U;
        request.minorNumber = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestSkipChannelCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TvChannel::Commands::SkipChannel::Type;

        RequestType request;
        request.count = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }
};

class TV_LowPowerCluster : public TestCommand
{
public:
    TV_LowPowerCluster() : TestCommand("TV_LowPowerCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_LowPowerCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_LowPowerCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Sleep Input Status Command\n");
            err = TestSleepInputStatusCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSleepInputStatusCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LowPower::Commands::Sleep::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_LowPowerCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_LowPowerCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }
};

class TV_MediaInputCluster : public TestCommand
{
public:
    TV_MediaInputCluster() : TestCommand("TV_MediaInputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute media input list\n");
            err = TestReadAttributeMediaInputList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Select Input Command\n");
            err = TestSelectInputCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read current input list\n");
            err = TestReadCurrentInputList_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Hide Input Status Command\n");
            err = TestHideInputStatusCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Show Input Status Command\n");
            err = TestShowInputStatusCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Rename Input Command\n");
            err = TestRenameInputCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_1(mediaInputList);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentMediaInput)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_3(currentMediaInput);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadAttributeMediaInputList_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::MediaInputList::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)
    {
        auto iter = mediaInputList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(mediaInputList)>("mediaInputList", iter, 0));
        VerifyOrReturn(CheckValue("mediaInputList[0].index", iter.GetValue().index, 1));
        VerifyOrReturn(CheckValue("mediaInputList[0].inputType", iter.GetValue().inputType, 4));
        VerifyOrReturn(CheckValueAsString("mediaInputList[0].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckValueAsString("mediaInputList[0].description", iter.GetValue().description,
                                          chip::CharSpan("exampleDescription", 18)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(mediaInputList)>("mediaInputList", iter, 1));
        VerifyOrReturn(CheckValue("mediaInputList[1].index", iter.GetValue().index, 2));
        VerifyOrReturn(CheckValue("mediaInputList[1].inputType", iter.GetValue().inputType, 4));
        VerifyOrReturn(CheckValueAsString("mediaInputList[1].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckValueAsString("mediaInputList[1].description", iter.GetValue().description,
                                          chip::CharSpan("exampleDescription", 18)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(mediaInputList)>("mediaInputList", iter, 2));

        NextTest();
    }

    CHIP_ERROR TestSelectInputCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::SelectInput::Type;

        RequestType request;
        request.index = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadCurrentInputList_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::CurrentMediaInput::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t currentMediaInput)
    {
        VerifyOrReturn(CheckValue("currentMediaInput", currentMediaInput, 1));

        NextTest();
    }

    CHIP_ERROR TestHideInputStatusCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestShowInputStatusCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestRenameInputCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::RenameInput::Type;

        RequestType request;
        request.index = 1;
        request.name  = chip::Span<const char>("newNamegarbage: not in length on purpose", 7);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }
};

class TestCluster : public TestCommand
{
public:
    TestCluster() : TestCommand("TestCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command\n");
            err = TestSendTestCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Not Handled Command\n");
            err = TestSendTestNotHandledCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Specific Command\n");
            err = TestSendTestSpecificCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Send failing Test Add Arguments Command\n");
            err = TestSendFailingTestAddArgumentsCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute BOOLEAN True\n");
            err = TestWriteAttributeBooleanTrue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute BOOLEAN True\n");
            err = TestReadAttributeBooleanTrue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write attribute BOOLEAN False\n");
            err = TestWriteAttributeBooleanFalse_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute BITMAP8 Max Value\n");
            err = TestWriteAttributeBitmap8MaxValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute BITMAP8 Max Value\n");
            err = TestReadAttributeBitmap8MaxValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Write attribute BITMAP8 Min Value\n");
            err = TestWriteAttributeBitmap8MinValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute BITMAP8 Min Value\n");
            err = TestReadAttributeBitmap8MinValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute BITMAP16 Max Value\n");
            err = TestWriteAttributeBitmap16MaxValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute BITMAP16 Max Value\n");
            err = TestReadAttributeBitmap16MaxValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Write attribute BITMAP16 Min Value\n");
            err = TestWriteAttributeBitmap16MinValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute BITMAP16 Min Value\n");
            err = TestReadAttributeBitmap16MinValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Write attribute BITMAP32 Max Value\n");
            err = TestWriteAttributeBitmap32MaxValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read attribute BITMAP32 Max Value\n");
            err = TestReadAttributeBitmap32MaxValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Write attribute BITMAP32 Min Value\n");
            err = TestWriteAttributeBitmap32MinValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read attribute BITMAP32 Min Value\n");
            err = TestReadAttributeBitmap32MinValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute BITMAP64 Max Value\n");
            err = TestWriteAttributeBitmap64MaxValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute BITMAP64 Max Value\n");
            err = TestReadAttributeBitmap64MaxValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Write attribute BITMAP64 Min Value\n");
            err = TestWriteAttributeBitmap64MinValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read attribute BITMAP64 Min Value\n");
            err = TestReadAttributeBitmap64MinValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Write attribute INT8U Max Value\n");
            err = TestWriteAttributeInt8uMaxValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read attribute INT8U Max Value\n");
            err = TestReadAttributeInt8uMaxValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Write attribute INT8U Min Value\n");
            err = TestWriteAttributeInt8uMinValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read attribute INT8U Min Value\n");
            err = TestReadAttributeInt8uMinValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute INT16U Max Value\n");
            err = TestWriteAttributeInt16uMaxValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute INT16U Max Value\n");
            err = TestReadAttributeInt16uMaxValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Write attribute INT16U Min Value\n");
            err = TestWriteAttributeInt16uMinValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read attribute INT16U Min Value\n");
            err = TestReadAttributeInt16uMinValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Write attribute INT32U Max Value\n");
            err = TestWriteAttributeInt32uMaxValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read attribute INT32U Max Value\n");
            err = TestReadAttributeInt32uMaxValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Write attribute INT32U Min Value\n");
            err = TestWriteAttributeInt32uMinValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read attribute INT32U Min Value\n");
            err = TestReadAttributeInt32uMinValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute INT64U Max Value\n");
            err = TestWriteAttributeInt64uMaxValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute INT64U Max Value\n");
            err = TestReadAttributeInt64uMaxValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Write attribute INT64U Min Value\n");
            err = TestWriteAttributeInt64uMinValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read attribute INT64U Min Value\n");
            err = TestReadAttributeInt64uMinValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Write attribute INT8S Max Value\n");
            err = TestWriteAttributeInt8sMaxValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read attribute INT8S Max Value\n");
            err = TestReadAttributeInt8sMaxValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Write attribute INT8S Min Value\n");
            err = TestWriteAttributeInt8sMinValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Read attribute INT8S Min Value\n");
            err = TestReadAttributeInt8sMinValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Write attribute INT16S Max Value\n");
            err = TestWriteAttributeInt16sMaxValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Read attribute INT16S Max Value\n");
            err = TestReadAttributeInt16sMaxValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Write attribute INT16S Min Value\n");
            err = TestWriteAttributeInt16sMinValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Read attribute INT16S Min Value\n");
            err = TestReadAttributeInt16sMinValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Write attribute INT32S Max Value\n");
            err = TestWriteAttributeInt32sMaxValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Read attribute INT32S Max Value\n");
            err = TestReadAttributeInt32sMaxValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Write attribute INT32S Min Value\n");
            err = TestWriteAttributeInt32sMinValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read attribute INT32S Min Value\n");
            err = TestReadAttributeInt32sMinValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Write attribute INT64S Max Value\n");
            err = TestWriteAttributeInt64sMaxValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute INT64S Max Value\n");
            err = TestReadAttributeInt64sMaxValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute INT64S Min Value\n");
            err = TestWriteAttributeInt64sMinValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute INT64S Min Value\n");
            err = TestReadAttributeInt64sMinValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read attribute SINGLE Default Value\n");
            err = TestReadAttributeSingleDefaultValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write attribute SINGLE medium Value\n");
            err = TestWriteAttributeSingleMediumValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read attribute SINGLE medium Value\n");
            err = TestReadAttributeSingleMediumValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write attribute SINGLE large Value\n");
            err = TestWriteAttributeSingleLargeValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute SINGLE large Value\n");
            err = TestReadAttributeSingleLargeValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write attribute SINGLE small Value\n");
            err = TestWriteAttributeSingleSmallValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read attribute SINGLE small Value\n");
            err = TestReadAttributeSingleSmallValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Write attribute SINGLE Default Value\n");
            err = TestWriteAttributeSingleDefaultValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read attribute SINGLE Default Value\n");
            err = TestReadAttributeSingleDefaultValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute DOUBLE Default Value\n");
            err = TestReadAttributeDoubleDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write attribute DOUBLE medium Value\n");
            err = TestWriteAttributeDoubleMediumValue_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read attribute DOUBLE medium Value\n");
            err = TestReadAttributeDoubleMediumValue_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write attribute DOUBLE large Value\n");
            err = TestWriteAttributeDoubleLargeValue_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read attribute DOUBLE large Value\n");
            err = TestReadAttributeDoubleLargeValue_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write attribute DOUBLE small Value\n");
            err = TestWriteAttributeDoubleSmallValue_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute DOUBLE small Value\n");
            err = TestReadAttributeDoubleSmallValue_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Write attribute DOUBLE Default Value\n");
            err = TestWriteAttributeDoubleDefaultValue_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read attribute DOUBLE Default Value\n");
            err = TestReadAttributeDoubleDefaultValue_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Write attribute ENUM8 Max Value\n");
            err = TestWriteAttributeEnum8MaxValue_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read attribute ENUM8 Max Value\n");
            err = TestReadAttributeEnum8MaxValue_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Write attribute ENUM8 Min Value\n");
            err = TestWriteAttributeEnum8MinValue_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Read attribute ENUM8 Min Value\n");
            err = TestReadAttributeEnum8MinValue_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write attribute ENUM16 Max Value\n");
            err = TestWriteAttributeEnum16MaxValue_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read attribute ENUM16 Max Value\n");
            err = TestReadAttributeEnum16MaxValue_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write attribute ENUM16 Min Value\n");
            err = TestWriteAttributeEnum16MinValue_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read attribute ENUM16 Min Value\n");
            err = TestReadAttributeEnum16MinValue_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read attribute OCTET_STRING Default Value\n");
            err = TestReadAttributeOctetStringDefaultValue_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Write attribute OCTET_STRING with embedded null\n");
            err = TestWriteAttributeOctetStringWithEmbeddedNull_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read attribute OCTET_STRING with embedded null\n");
            err = TestReadAttributeOctetStringWithEmbeddedNull_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Read attribute LONG_OCTET_STRING Default Value\n");
            err = TestReadAttributeLongOctetStringDefaultValue_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read attribute LONG_OCTET_STRING\n");
            err = TestReadAttributeLongOctetString_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read attribute CHAR_STRING Default Value\n");
            err = TestReadAttributeCharStringDefaultValue_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Write attribute CHAR_STRING\n");
            err = TestWriteAttributeCharString_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read attribute CHAR_STRING\n");
            err = TestReadAttributeCharString_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write attribute CHAR_STRING - Value too long\n");
            err = TestWriteAttributeCharStringValueTooLong_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read attribute CHAR_STRING\n");
            err = TestReadAttributeCharString_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Write attribute CHAR_STRING - Empty\n");
            err = TestWriteAttributeCharStringEmpty_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Read attribute LONG_CHAR_STRING Default Value\n");
            err = TestReadAttributeLongCharStringDefaultValue_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read attribute LONG_CHAR_STRING\n");
            err = TestReadAttributeLongCharString_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Write attribute EPOCH_US Max Value\n");
            err = TestWriteAttributeEpochUsMaxValue_130();
            break;
        case 131:
            ChipLogProgress(chipTool, " ***** Test Step 131 : Read attribute EPOCH_US Max Value\n");
            err = TestReadAttributeEpochUsMaxValue_131();
            break;
        case 132:
            ChipLogProgress(chipTool, " ***** Test Step 132 : Write attribute EPOCH_US Min Value\n");
            err = TestWriteAttributeEpochUsMinValue_132();
            break;
        case 133:
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read attribute EPOCH_US Min Value\n");
            err = TestReadAttributeEpochUsMinValue_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Write attribute EPOCH_S Max Value\n");
            err = TestWriteAttributeEpochSMaxValue_135();
            break;
        case 136:
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read attribute EPOCH_S Max Value\n");
            err = TestReadAttributeEpochSMaxValue_136();
            break;
        case 137:
            ChipLogProgress(chipTool, " ***** Test Step 137 : Write attribute EPOCH_S Min Value\n");
            err = TestWriteAttributeEpochSMinValue_137();
            break;
        case 138:
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read attribute EPOCH_S Min Value\n");
            err = TestReadAttributeEpochSMinValue_138();
            break;
        case 139:
            ChipLogProgress(chipTool, " ***** Test Step 139 : Read attribute UNSUPPORTED\n");
            err = TestReadAttributeUnsupported_139();
            break;
        case 140:
            ChipLogProgress(chipTool, " ***** Test Step 140 : Writeattribute UNSUPPORTED\n");
            err = TestWriteattributeUnsupported_140();
            break;
        case 141:
            ChipLogProgress(chipTool, " ***** Test Step 141 : Send Test Command to unsupported endpoint\n");
            err = TestSendTestCommandToUnsupportedEndpoint_141();
            break;
        case 142:
            ChipLogProgress(chipTool, " ***** Test Step 142 : Send Test Command to unsupported cluster\n");
            err = TestSendTestCommandToUnsupportedCluster_142();
            break;
        case 143:
            ChipLogProgress(chipTool, " ***** Test Step 143 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_143();
            break;
        case 144:
            ChipLogProgress(chipTool, " ***** Test Step 144 : Write attribute vendor_id\n");
            err = TestWriteAttributeVendorId_144();
            break;
        case 145:
            ChipLogProgress(chipTool, " ***** Test Step 145 : Read attribute vendor_id\n");
            err = TestReadAttributeVendorId_145();
            break;
        case 146:
            ChipLogProgress(chipTool, " ***** Test Step 146 : Restore attribute vendor_id\n");
            err = TestRestoreAttributeVendorId_146();
            break;
        case 147:
            ChipLogProgress(chipTool, " ***** Test Step 147 : Send a command with a vendor_id and enum\n");
            err = TestSendACommandWithAVendorIdAndEnum_147();
            break;
        case 148:
            ChipLogProgress(chipTool, " ***** Test Step 148 : Send Test Command With Struct Argument and arg1.b is true\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsTrue_148();
            break;
        case 149:
            ChipLogProgress(chipTool, " ***** Test Step 149 : Send Test Command With Struct Argument and arg1.b is false\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsFalse_149();
            break;
        case 150:
            ChipLogProgress(chipTool,
                            " ***** Test Step 150 : Send Test Command With Nested Struct Argument and arg1.c.b is true\n");
            err = TestSendTestCommandWithNestedStructArgumentAndArg1cbIsTrue_150();
            break;
        case 151:
            ChipLogProgress(chipTool, " ***** Test Step 151 : Send Test Command With Nested Struct Argument arg1.c.b is false\n");
            err = TestSendTestCommandWithNestedStructArgumentArg1cbIsFalse_151();
            break;
        case 152:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 152 : Send Test Command With Nested Struct List Argument and all fields b of arg1.d are true\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndAllFieldsBOfArg1dAreTrue_152();
            break;
        case 153:
            ChipLogProgress(chipTool,
                            " ***** Test Step 153 : Send Test Command With Nested Struct List Argument and some fields b of arg1.d "
                            "are false\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfArg1dAreFalse_153();
            break;
        case 154:
            ChipLogProgress(chipTool, " ***** Test Step 154 : Send Test Command With Struct Argument and see what we get back\n");
            err = TestSendTestCommandWithStructArgumentAndSeeWhatWeGetBack_154();
            break;
        case 155:
            ChipLogProgress(chipTool, " ***** Test Step 155 : Send Test Command With List of INT8U and none of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_155();
            break;
        case 156:
            ChipLogProgress(chipTool, " ***** Test Step 156 : Send Test Command With List of INT8U and one of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_156();
            break;
        case 157:
            ChipLogProgress(chipTool, " ***** Test Step 157 : Send Test Command With List of INT8U and get it reversed\n");
            err = TestSendTestCommandWithListOfInt8uAndGetItReversed_157();
            break;
        case 158:
            ChipLogProgress(chipTool,
                            " ***** Test Step 158 : Send Test Command With empty List of INT8U and get an empty list back\n");
            err = TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_158();
            break;
        case 159:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 159 : Send Test Command With List of Struct Argument and arg1.b of first item is true\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_159();
            break;
        case 160:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 160 : Send Test Command With List of Struct Argument and arg1.b of first item is false\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_160();
            break;
        case 161:
            ChipLogProgress(chipTool,
                            " ***** Test Step 161 : Send Test Command With List of Nested Struct List Argument and all fields b of "
                            "elements of arg1.d are true\n");
            err = TestSendTestCommandWithListOfNestedStructListArgumentAndAllFieldsBOfElementsOfArg1dAreTrue_161();
            break;
        case 162:
            ChipLogProgress(chipTool,
                            " ***** Test Step 162 : Send Test Command With Nested Struct List Argument and some fields b of "
                            "elements of arg1.d are false\n");
            err = TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfElementsOfArg1dAreFalse_162();
            break;
        case 163:
            ChipLogProgress(chipTool,
                            " ***** Test Step 163 : Write attribute LIST With List of INT8U and none of them is set to 0\n");
            err = TestWriteAttributeListWithListOfInt8uAndNoneOfThemIsSetTo0_163();
            break;
        case 164:
            ChipLogProgress(chipTool, " ***** Test Step 164 : Read attribute LIST With List of INT8U\n");
            err = TestReadAttributeListWithListOfInt8u_164();
            break;
        case 165:
            ChipLogProgress(chipTool, " ***** Test Step 165 : Write attribute LIST With List of OCTET_STRING\n");
            err = TestWriteAttributeListWithListOfOctetString_165();
            break;
        case 166:
            ChipLogProgress(chipTool, " ***** Test Step 166 : Read attribute LIST With List of OCTET_STRING\n");
            err = TestReadAttributeListWithListOfOctetString_166();
            break;
        case 167:
            ChipLogProgress(chipTool, " ***** Test Step 167 : Write attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            err = TestWriteAttributeListWithListOfListStructOctetString_167();
            break;
        case 168:
            ChipLogProgress(chipTool, " ***** Test Step 168 : Read attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            err = TestReadAttributeListWithListOfListStructOctetString_168();
            break;
        case 169:
            ChipLogProgress(chipTool, " ***** Test Step 169 : Send Test Command with optional arg set.\n");
            err = TestSendTestCommandWithOptionalArgSet_169();
            break;
        case 170:
            ChipLogProgress(chipTool, " ***** Test Step 170 : Send Test Command without its optional arg.\n");
            err = TestSendTestCommandWithoutItsOptionalArg_170();
            break;
        case 171:
            ChipLogProgress(chipTool, " ***** Test Step 171 : Write attribute NULLABLE_BOOLEAN null\n");
            err = TestWriteAttributeNullableBooleanNull_171();
            break;
        case 172:
            ChipLogProgress(chipTool, " ***** Test Step 172 : Read attribute NULLABLE_BOOLEAN null\n");
            err = TestReadAttributeNullableBooleanNull_172();
            break;
        case 173:
            ChipLogProgress(chipTool, " ***** Test Step 173 : Write attribute NULLABLE_BOOLEAN True\n");
            err = TestWriteAttributeNullableBooleanTrue_173();
            break;
        case 174:
            ChipLogProgress(chipTool, " ***** Test Step 174 : Read attribute NULLABLE_BOOLEAN True\n");
            err = TestReadAttributeNullableBooleanTrue_174();
            break;
        case 175:
            ChipLogProgress(chipTool, " ***** Test Step 175 : Write attribute NULLABLE_BITMAP8 Max Value\n");
            err = TestWriteAttributeNullableBitmap8MaxValue_175();
            break;
        case 176:
            ChipLogProgress(chipTool, " ***** Test Step 176 : Read attribute NULLABLE_BITMAP8 Max Value\n");
            err = TestReadAttributeNullableBitmap8MaxValue_176();
            break;
        case 177:
            ChipLogProgress(chipTool, " ***** Test Step 177 : Write attribute NULLABLE_BITMAP8 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap8InvalidValue_177();
            break;
        case 178:
            ChipLogProgress(chipTool, " ***** Test Step 178 : Read attribute NULLABLE_BITMAP8 unchanged Value\n");
            err = TestReadAttributeNullableBitmap8UnchangedValue_178();
            break;
        case 179:
            ChipLogProgress(chipTool, " ***** Test Step 179 : Write attribute NULLABLE_BITMAP8 null Value\n");
            err = TestWriteAttributeNullableBitmap8NullValue_179();
            break;
        case 180:
            ChipLogProgress(chipTool, " ***** Test Step 180 : Read attribute NULLABLE_BITMAP8 null Value\n");
            err = TestReadAttributeNullableBitmap8NullValue_180();
            break;
        case 181:
            ChipLogProgress(chipTool, " ***** Test Step 181 : Write attribute NULLABLE_BITMAP16 Max Value\n");
            err = TestWriteAttributeNullableBitmap16MaxValue_181();
            break;
        case 182:
            ChipLogProgress(chipTool, " ***** Test Step 182 : Read attribute NULLABLE_BITMAP16 Max Value\n");
            err = TestReadAttributeNullableBitmap16MaxValue_182();
            break;
        case 183:
            ChipLogProgress(chipTool, " ***** Test Step 183 : Write attribute NULLABLE_BITMAP16 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap16InvalidValue_183();
            break;
        case 184:
            ChipLogProgress(chipTool, " ***** Test Step 184 : Read attribute NULLABLE_BITMAP16 unchanged Value\n");
            err = TestReadAttributeNullableBitmap16UnchangedValue_184();
            break;
        case 185:
            ChipLogProgress(chipTool, " ***** Test Step 185 : Write attribute NULLABLE_BITMAP16 null Value\n");
            err = TestWriteAttributeNullableBitmap16NullValue_185();
            break;
        case 186:
            ChipLogProgress(chipTool, " ***** Test Step 186 : Read attribute NULLABLE_BITMAP16 null Value\n");
            err = TestReadAttributeNullableBitmap16NullValue_186();
            break;
        case 187:
            ChipLogProgress(chipTool, " ***** Test Step 187 : Write attribute NULLABLE_BITMAP32 Max Value\n");
            err = TestWriteAttributeNullableBitmap32MaxValue_187();
            break;
        case 188:
            ChipLogProgress(chipTool, " ***** Test Step 188 : Read attribute NULLABLE_BITMAP32 Max Value\n");
            err = TestReadAttributeNullableBitmap32MaxValue_188();
            break;
        case 189:
            ChipLogProgress(chipTool, " ***** Test Step 189 : Write attribute NULLABLE_BITMAP32 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap32InvalidValue_189();
            break;
        case 190:
            ChipLogProgress(chipTool, " ***** Test Step 190 : Read attribute NULLABLE_BITMAP32 unchanged Value\n");
            err = TestReadAttributeNullableBitmap32UnchangedValue_190();
            break;
        case 191:
            ChipLogProgress(chipTool, " ***** Test Step 191 : Write attribute NULLABLE_BITMAP32 null Value\n");
            err = TestWriteAttributeNullableBitmap32NullValue_191();
            break;
        case 192:
            ChipLogProgress(chipTool, " ***** Test Step 192 : Read attribute NULLABLE_BITMAP32 null Value\n");
            err = TestReadAttributeNullableBitmap32NullValue_192();
            break;
        case 193:
            ChipLogProgress(chipTool, " ***** Test Step 193 : Write attribute NULLABLE_BITMAP64 Max Value\n");
            err = TestWriteAttributeNullableBitmap64MaxValue_193();
            break;
        case 194:
            ChipLogProgress(chipTool, " ***** Test Step 194 : Read attribute NULLABLE_BITMAP64 Max Value\n");
            err = TestReadAttributeNullableBitmap64MaxValue_194();
            break;
        case 195:
            ChipLogProgress(chipTool, " ***** Test Step 195 : Write attribute NULLABLE_BITMAP64 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap64InvalidValue_195();
            break;
        case 196:
            ChipLogProgress(chipTool, " ***** Test Step 196 : Read attribute NULLABLE_BITMAP64 unchanged Value\n");
            err = TestReadAttributeNullableBitmap64UnchangedValue_196();
            break;
        case 197:
            ChipLogProgress(chipTool, " ***** Test Step 197 : Write attribute NULLABLE_BITMAP64 null Value\n");
            err = TestWriteAttributeNullableBitmap64NullValue_197();
            break;
        case 198:
            ChipLogProgress(chipTool, " ***** Test Step 198 : Read attribute NULLABLE_BITMAP64 null Value\n");
            err = TestReadAttributeNullableBitmap64NullValue_198();
            break;
        case 199:
            ChipLogProgress(chipTool, " ***** Test Step 199 : Write attribute NULLABLE_INT8U Max Value\n");
            err = TestWriteAttributeNullableInt8uMaxValue_199();
            break;
        case 200:
            ChipLogProgress(chipTool, " ***** Test Step 200 : Read attribute NULLABLE_INT8U Max Value\n");
            err = TestReadAttributeNullableInt8uMaxValue_200();
            break;
        case 201:
            ChipLogProgress(chipTool, " ***** Test Step 201 : Write attribute NULLABLE_INT8U Invalid Value\n");
            err = TestWriteAttributeNullableInt8uInvalidValue_201();
            break;
        case 202:
            ChipLogProgress(chipTool, " ***** Test Step 202 : Read attribute NULLABLE_INT8U unchanged Value\n");
            err = TestReadAttributeNullableInt8uUnchangedValue_202();
            break;
        case 203:
            ChipLogProgress(chipTool, " ***** Test Step 203 : Write attribute NULLABLE_INT8U null Value\n");
            err = TestWriteAttributeNullableInt8uNullValue_203();
            break;
        case 204:
            ChipLogProgress(chipTool, " ***** Test Step 204 : Read attribute NULLABLE_INT8U null Value\n");
            err = TestReadAttributeNullableInt8uNullValue_204();
            break;
        case 205:
            ChipLogProgress(chipTool, " ***** Test Step 205 : Write attribute NULLABLE_INT16U Max Value\n");
            err = TestWriteAttributeNullableInt16uMaxValue_205();
            break;
        case 206:
            ChipLogProgress(chipTool, " ***** Test Step 206 : Read attribute NULLABLE_INT16U Max Value\n");
            err = TestReadAttributeNullableInt16uMaxValue_206();
            break;
        case 207:
            ChipLogProgress(chipTool, " ***** Test Step 207 : Write attribute NULLABLE_INT16U Invalid Value\n");
            err = TestWriteAttributeNullableInt16uInvalidValue_207();
            break;
        case 208:
            ChipLogProgress(chipTool, " ***** Test Step 208 : Read attribute NULLABLE_INT16U unchanged Value\n");
            err = TestReadAttributeNullableInt16uUnchangedValue_208();
            break;
        case 209:
            ChipLogProgress(chipTool, " ***** Test Step 209 : Write attribute NULLABLE_INT16U null Value\n");
            err = TestWriteAttributeNullableInt16uNullValue_209();
            break;
        case 210:
            ChipLogProgress(chipTool, " ***** Test Step 210 : Read attribute NULLABLE_INT16U null Value\n");
            err = TestReadAttributeNullableInt16uNullValue_210();
            break;
        case 211:
            ChipLogProgress(chipTool, " ***** Test Step 211 : Write attribute NULLABLE_INT32U Max Value\n");
            err = TestWriteAttributeNullableInt32uMaxValue_211();
            break;
        case 212:
            ChipLogProgress(chipTool, " ***** Test Step 212 : Read attribute NULLABLE_INT32U Max Value\n");
            err = TestReadAttributeNullableInt32uMaxValue_212();
            break;
        case 213:
            ChipLogProgress(chipTool, " ***** Test Step 213 : Write attribute NULLABLE_INT32U Invalid Value\n");
            err = TestWriteAttributeNullableInt32uInvalidValue_213();
            break;
        case 214:
            ChipLogProgress(chipTool, " ***** Test Step 214 : Read attribute NULLABLE_INT32U unchanged Value\n");
            err = TestReadAttributeNullableInt32uUnchangedValue_214();
            break;
        case 215:
            ChipLogProgress(chipTool, " ***** Test Step 215 : Write attribute NULLABLE_INT32U null Value\n");
            err = TestWriteAttributeNullableInt32uNullValue_215();
            break;
        case 216:
            ChipLogProgress(chipTool, " ***** Test Step 216 : Read attribute NULLABLE_INT32U null Value\n");
            err = TestReadAttributeNullableInt32uNullValue_216();
            break;
        case 217:
            ChipLogProgress(chipTool, " ***** Test Step 217 : Write attribute NULLABLE_INT64U Max Value\n");
            err = TestWriteAttributeNullableInt64uMaxValue_217();
            break;
        case 218:
            ChipLogProgress(chipTool, " ***** Test Step 218 : Read attribute NULLABLE_INT64U Max Value\n");
            err = TestReadAttributeNullableInt64uMaxValue_218();
            break;
        case 219:
            ChipLogProgress(chipTool, " ***** Test Step 219 : Write attribute NULLABLE_INT64U Invalid Value\n");
            err = TestWriteAttributeNullableInt64uInvalidValue_219();
            break;
        case 220:
            ChipLogProgress(chipTool, " ***** Test Step 220 : Read attribute NULLABLE_INT64U unchanged Value\n");
            err = TestReadAttributeNullableInt64uUnchangedValue_220();
            break;
        case 221:
            ChipLogProgress(chipTool, " ***** Test Step 221 : Write attribute NULLABLE_INT64U null Value\n");
            err = TestWriteAttributeNullableInt64uNullValue_221();
            break;
        case 222:
            ChipLogProgress(chipTool, " ***** Test Step 222 : Read attribute NULLABLE_INT64U null Value\n");
            err = TestReadAttributeNullableInt64uNullValue_222();
            break;
        case 223:
            ChipLogProgress(chipTool, " ***** Test Step 223 : Write attribute NULLABLE_INT8S Min Value\n");
            err = TestWriteAttributeNullableInt8sMinValue_223();
            break;
        case 224:
            ChipLogProgress(chipTool, " ***** Test Step 224 : Read attribute NULLABLE_INT8S Min Value\n");
            err = TestReadAttributeNullableInt8sMinValue_224();
            break;
        case 225:
            ChipLogProgress(chipTool, " ***** Test Step 225 : Write attribute NULLABLE_INT8S Invalid Value\n");
            err = TestWriteAttributeNullableInt8sInvalidValue_225();
            break;
        case 226:
            ChipLogProgress(chipTool, " ***** Test Step 226 : Read attribute NULLABLE_INT8S unchanged Value\n");
            err = TestReadAttributeNullableInt8sUnchangedValue_226();
            break;
        case 227:
            ChipLogProgress(chipTool, " ***** Test Step 227 : Write attribute NULLABLE_INT8S null Value\n");
            err = TestWriteAttributeNullableInt8sNullValue_227();
            break;
        case 228:
            ChipLogProgress(chipTool, " ***** Test Step 228 : Read attribute NULLABLE_INT8S null Value\n");
            err = TestReadAttributeNullableInt8sNullValue_228();
            break;
        case 229:
            ChipLogProgress(chipTool, " ***** Test Step 229 : Write attribute NULLABLE_INT16S Min Value\n");
            err = TestWriteAttributeNullableInt16sMinValue_229();
            break;
        case 230:
            ChipLogProgress(chipTool, " ***** Test Step 230 : Read attribute NULLABLE_INT16S Min Value\n");
            err = TestReadAttributeNullableInt16sMinValue_230();
            break;
        case 231:
            ChipLogProgress(chipTool, " ***** Test Step 231 : Write attribute NULLABLE_INT16S Invalid Value\n");
            err = TestWriteAttributeNullableInt16sInvalidValue_231();
            break;
        case 232:
            ChipLogProgress(chipTool, " ***** Test Step 232 : Read attribute NULLABLE_INT16S unchanged Value\n");
            err = TestReadAttributeNullableInt16sUnchangedValue_232();
            break;
        case 233:
            ChipLogProgress(chipTool, " ***** Test Step 233 : Write attribute NULLABLE_INT16S null Value\n");
            err = TestWriteAttributeNullableInt16sNullValue_233();
            break;
        case 234:
            ChipLogProgress(chipTool, " ***** Test Step 234 : Read attribute NULLABLE_INT16S null Value\n");
            err = TestReadAttributeNullableInt16sNullValue_234();
            break;
        case 235:
            ChipLogProgress(chipTool, " ***** Test Step 235 : Write attribute NULLABLE_INT32S Min Value\n");
            err = TestWriteAttributeNullableInt32sMinValue_235();
            break;
        case 236:
            ChipLogProgress(chipTool, " ***** Test Step 236 : Read attribute NULLABLE_INT32S Min Value\n");
            err = TestReadAttributeNullableInt32sMinValue_236();
            break;
        case 237:
            ChipLogProgress(chipTool, " ***** Test Step 237 : Write attribute NULLABLE_INT32S Invalid Value\n");
            err = TestWriteAttributeNullableInt32sInvalidValue_237();
            break;
        case 238:
            ChipLogProgress(chipTool, " ***** Test Step 238 : Read attribute NULLABLE_INT32S unchanged Value\n");
            err = TestReadAttributeNullableInt32sUnchangedValue_238();
            break;
        case 239:
            ChipLogProgress(chipTool, " ***** Test Step 239 : Write attribute NULLABLE_INT32S null Value\n");
            err = TestWriteAttributeNullableInt32sNullValue_239();
            break;
        case 240:
            ChipLogProgress(chipTool, " ***** Test Step 240 : Read attribute NULLABLE_INT32S null Value\n");
            err = TestReadAttributeNullableInt32sNullValue_240();
            break;
        case 241:
            ChipLogProgress(chipTool, " ***** Test Step 241 : Write attribute NULLABLE_INT64S Min Value\n");
            err = TestWriteAttributeNullableInt64sMinValue_241();
            break;
        case 242:
            ChipLogProgress(chipTool, " ***** Test Step 242 : Read attribute NULLABLE_INT64S Min Value\n");
            err = TestReadAttributeNullableInt64sMinValue_242();
            break;
        case 243:
            ChipLogProgress(chipTool, " ***** Test Step 243 : Write attribute NULLABLE_INT64S Invalid Value\n");
            err = TestWriteAttributeNullableInt64sInvalidValue_243();
            break;
        case 244:
            ChipLogProgress(chipTool, " ***** Test Step 244 : Read attribute NULLABLE_INT64S unchanged Value\n");
            err = TestReadAttributeNullableInt64sUnchangedValue_244();
            break;
        case 245:
            ChipLogProgress(chipTool, " ***** Test Step 245 : Write attribute NULLABLE_INT64S null Value\n");
            err = TestWriteAttributeNullableInt64sNullValue_245();
            break;
        case 246:
            ChipLogProgress(chipTool, " ***** Test Step 246 : Read attribute NULLABLE_INT64S null Value\n");
            err = TestReadAttributeNullableInt64sNullValue_246();
            break;
        case 247:
            ChipLogProgress(chipTool, " ***** Test Step 247 : Write attribute NULLABLE_SINGLE medium Value\n");
            err = TestWriteAttributeNullableSingleMediumValue_247();
            break;
        case 248:
            ChipLogProgress(chipTool, " ***** Test Step 248 : Read attribute NULLABLE_SINGLE medium Value\n");
            err = TestReadAttributeNullableSingleMediumValue_248();
            break;
        case 249:
            ChipLogProgress(chipTool, " ***** Test Step 249 : Write attribute NULLABLE_SINGLE largest Value\n");
            err = TestWriteAttributeNullableSingleLargestValue_249();
            break;
        case 250:
            ChipLogProgress(chipTool, " ***** Test Step 250 : Read attribute NULLABLE_SINGLE largest Value\n");
            err = TestReadAttributeNullableSingleLargestValue_250();
            break;
        case 251:
            ChipLogProgress(chipTool, " ***** Test Step 251 : Write attribute NULLABLE_SINGLE smallest Value\n");
            err = TestWriteAttributeNullableSingleSmallestValue_251();
            break;
        case 252:
            ChipLogProgress(chipTool, " ***** Test Step 252 : Read attribute NULLABLE_SINGLE smallest Value\n");
            err = TestReadAttributeNullableSingleSmallestValue_252();
            break;
        case 253:
            ChipLogProgress(chipTool, " ***** Test Step 253 : Write attribute NULLABLE_SINGLE null Value\n");
            err = TestWriteAttributeNullableSingleNullValue_253();
            break;
        case 254:
            ChipLogProgress(chipTool, " ***** Test Step 254 : Read attribute NULLABLE_SINGLE null Value\n");
            err = TestReadAttributeNullableSingleNullValue_254();
            break;
        case 255:
            ChipLogProgress(chipTool, " ***** Test Step 255 : Write attribute NULLABLE_SINGLE 0 Value\n");
            err = TestWriteAttributeNullableSingle0Value_255();
            break;
        case 256:
            ChipLogProgress(chipTool, " ***** Test Step 256 : Read attribute NULLABLE_SINGLE 0 Value\n");
            err = TestReadAttributeNullableSingle0Value_256();
            break;
        case 257:
            ChipLogProgress(chipTool, " ***** Test Step 257 : Write attribute NULLABLE_DOUBLE medium Value\n");
            err = TestWriteAttributeNullableDoubleMediumValue_257();
            break;
        case 258:
            ChipLogProgress(chipTool, " ***** Test Step 258 : Read attribute NULLABLE_DOUBLE medium Value\n");
            err = TestReadAttributeNullableDoubleMediumValue_258();
            break;
        case 259:
            ChipLogProgress(chipTool, " ***** Test Step 259 : Write attribute NULLABLE_DOUBLE largest Value\n");
            err = TestWriteAttributeNullableDoubleLargestValue_259();
            break;
        case 260:
            ChipLogProgress(chipTool, " ***** Test Step 260 : Read attribute NULLABLE_DOUBLE largest Value\n");
            err = TestReadAttributeNullableDoubleLargestValue_260();
            break;
        case 261:
            ChipLogProgress(chipTool, " ***** Test Step 261 : Write attribute NULLABLE_DOUBLE smallest Value\n");
            err = TestWriteAttributeNullableDoubleSmallestValue_261();
            break;
        case 262:
            ChipLogProgress(chipTool, " ***** Test Step 262 : Read attribute NULLABLE_DOUBLE smallest Value\n");
            err = TestReadAttributeNullableDoubleSmallestValue_262();
            break;
        case 263:
            ChipLogProgress(chipTool, " ***** Test Step 263 : Write attribute NULLABLE_DOUBLE null Value\n");
            err = TestWriteAttributeNullableDoubleNullValue_263();
            break;
        case 264:
            ChipLogProgress(chipTool, " ***** Test Step 264 : Read attribute NULLABLE_DOUBLE null Value\n");
            err = TestReadAttributeNullableDoubleNullValue_264();
            break;
        case 265:
            ChipLogProgress(chipTool, " ***** Test Step 265 : Write attribute NULLABLE_DOUBLE 0 Value\n");
            err = TestWriteAttributeNullableDouble0Value_265();
            break;
        case 266:
            ChipLogProgress(chipTool, " ***** Test Step 266 : Read attribute NULLABLE_DOUBLE 0 Value\n");
            err = TestReadAttributeNullableDouble0Value_266();
            break;
        case 267:
            ChipLogProgress(chipTool, " ***** Test Step 267 : Write attribute NULLABLE_ENUM8 Max Value\n");
            err = TestWriteAttributeNullableEnum8MaxValue_267();
            break;
        case 268:
            ChipLogProgress(chipTool, " ***** Test Step 268 : Read attribute NULLABLE_ENUM8 Max Value\n");
            err = TestReadAttributeNullableEnum8MaxValue_268();
            break;
        case 269:
            ChipLogProgress(chipTool, " ***** Test Step 269 : Write attribute NULLABLE_ENUM8 Invalid Value\n");
            err = TestWriteAttributeNullableEnum8InvalidValue_269();
            break;
        case 270:
            ChipLogProgress(chipTool, " ***** Test Step 270 : Read attribute NULLABLE_ENUM8 unchanged Value\n");
            err = TestReadAttributeNullableEnum8UnchangedValue_270();
            break;
        case 271:
            ChipLogProgress(chipTool, " ***** Test Step 271 : Write attribute NULLABLE_ENUM8 null Value\n");
            err = TestWriteAttributeNullableEnum8NullValue_271();
            break;
        case 272:
            ChipLogProgress(chipTool, " ***** Test Step 272 : Read attribute NULLABLE_ENUM8 null Value\n");
            err = TestReadAttributeNullableEnum8NullValue_272();
            break;
        case 273:
            ChipLogProgress(chipTool, " ***** Test Step 273 : Write attribute NULLABLE_ENUM16 Max Value\n");
            err = TestWriteAttributeNullableEnum16MaxValue_273();
            break;
        case 274:
            ChipLogProgress(chipTool, " ***** Test Step 274 : Read attribute NULLABLE_ENUM16 Max Value\n");
            err = TestReadAttributeNullableEnum16MaxValue_274();
            break;
        case 275:
            ChipLogProgress(chipTool, " ***** Test Step 275 : Write attribute NULLABLE_ENUM16 Invalid Value\n");
            err = TestWriteAttributeNullableEnum16InvalidValue_275();
            break;
        case 276:
            ChipLogProgress(chipTool, " ***** Test Step 276 : Read attribute NULLABLE_ENUM16 unchanged Value\n");
            err = TestReadAttributeNullableEnum16UnchangedValue_276();
            break;
        case 277:
            ChipLogProgress(chipTool, " ***** Test Step 277 : Write attribute NULLABLE_ENUM16 null Value\n");
            err = TestWriteAttributeNullableEnum16NullValue_277();
            break;
        case 278:
            ChipLogProgress(chipTool, " ***** Test Step 278 : Read attribute NULLABLE_ENUM16 null Value\n");
            err = TestReadAttributeNullableEnum16NullValue_278();
            break;
        case 279:
            ChipLogProgress(chipTool, " ***** Test Step 279 : Read attribute NULLABLE_OCTET_STRING Default Value\n");
            err = TestReadAttributeNullableOctetStringDefaultValue_279();
            break;
        case 280:
            ChipLogProgress(chipTool, " ***** Test Step 280 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_280();
            break;
        case 281:
            ChipLogProgress(chipTool, " ***** Test Step 281 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_281();
            break;
        case 282:
            ChipLogProgress(chipTool, " ***** Test Step 282 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_282();
            break;
        case 283:
            ChipLogProgress(chipTool, " ***** Test Step 283 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_283();
            break;
        case 284:
            ChipLogProgress(chipTool, " ***** Test Step 284 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_284();
            break;
        case 285:
            ChipLogProgress(chipTool, " ***** Test Step 285 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_285();
            break;
        case 286:
            ChipLogProgress(chipTool, " ***** Test Step 286 : Read attribute NULLABLE_CHAR_STRING Default Value\n");
            err = TestReadAttributeNullableCharStringDefaultValue_286();
            break;
        case 287:
            ChipLogProgress(chipTool, " ***** Test Step 287 : Write attribute NULLABLE_CHAR_STRING\n");
            err = TestWriteAttributeNullableCharString_287();
            break;
        case 288:
            ChipLogProgress(chipTool, " ***** Test Step 288 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_288();
            break;
        case 289:
            ChipLogProgress(chipTool, " ***** Test Step 289 : Write attribute NULLABLE_CHAR_STRING - Value too long\n");
            err = TestWriteAttributeNullableCharStringValueTooLong_289();
            break;
        case 290:
            ChipLogProgress(chipTool, " ***** Test Step 290 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_290();
            break;
        case 291:
            ChipLogProgress(chipTool, " ***** Test Step 291 : Write attribute NULLABLE_CHAR_STRING - Empty\n");
            err = TestWriteAttributeNullableCharStringEmpty_291();
            break;
        case 292:
            ChipLogProgress(chipTool, " ***** Test Step 292 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_292();
            break;
        case 293:
            ChipLogProgress(chipTool, " ***** Test Step 293 : Read attribute from nonexistent endpoint.\n");
            err = TestReadAttributeFromNonexistentEndpoint_293();
            break;
        case 294:
            ChipLogProgress(chipTool, " ***** Test Step 294 : Read attribute from nonexistent cluster.\n");
            err = TestReadAttributeFromNonexistentCluster_294();
            break;
        case 295:
            ChipLogProgress(chipTool,
                            " ***** Test Step 295 : Send a command that takes an optional parameter but do not set it.\n");
            err = TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_295();
            break;
        case 296:
            ChipLogProgress(chipTool,
                            " ***** Test Step 296 : Send a command that takes an optional parameter but do not set it.\n");
            err = TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_296();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 297;

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_6(boolean);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_8(boolean);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_10(boolean);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_11(bitmap8);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_13(bitmap8);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_15(bitmap8);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_16(bitmap16);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_18(bitmap16);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_19(); }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_20(bitmap16);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_21(bitmap32);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_22(); }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_23(bitmap32);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_25(bitmap32);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_26(bitmap64);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_27(); }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_28(bitmap64);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_30(bitmap64);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_31(int8u);
    }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_33(int8u);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_34(); }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_35(int8u);
    }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_36(int16u);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_38(int16u);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_39(); }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_40(int16u);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_41(int32u);
    }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_43(int32u);
    }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_45(int32u);
    }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_46(int64u);
    }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_48(int64u);
    }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_49(); }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_50(int64u);
    }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_51(int8s);
    }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_52(); }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_53(int8s);
    }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_54(); }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_55(int8s);
    }

    static void OnFailureCallback_56(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_56(chip::to_underlying(status));
    }

    static void OnSuccessCallback_56(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_56(); }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_57(int8s);
    }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_58(int16s);
    }

    static void OnFailureCallback_59(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_59(chip::to_underlying(status));
    }

    static void OnSuccessCallback_59(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_59(); }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_60(int16s);
    }

    static void OnFailureCallback_61(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_61(chip::to_underlying(status));
    }

    static void OnSuccessCallback_61(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_61(); }

    static void OnFailureCallback_62(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_62(chip::to_underlying(status));
    }

    static void OnSuccessCallback_62(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_62(int16s);
    }

    static void OnFailureCallback_63(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_63(chip::to_underlying(status));
    }

    static void OnSuccessCallback_63(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_63(); }

    static void OnFailureCallback_64(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_64(chip::to_underlying(status));
    }

    static void OnSuccessCallback_64(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_64(int16s);
    }

    static void OnFailureCallback_65(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_65(chip::to_underlying(status));
    }

    static void OnSuccessCallback_65(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_65(int32s);
    }

    static void OnFailureCallback_66(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_66(chip::to_underlying(status));
    }

    static void OnSuccessCallback_66(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_66(); }

    static void OnFailureCallback_67(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_67(chip::to_underlying(status));
    }

    static void OnSuccessCallback_67(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_67(int32s);
    }

    static void OnFailureCallback_68(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_68(chip::to_underlying(status));
    }

    static void OnSuccessCallback_68(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_68(); }

    static void OnFailureCallback_69(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_69(chip::to_underlying(status));
    }

    static void OnSuccessCallback_69(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_69(int32s);
    }

    static void OnFailureCallback_70(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_70(chip::to_underlying(status));
    }

    static void OnSuccessCallback_70(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_70(); }

    static void OnFailureCallback_71(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_71(chip::to_underlying(status));
    }

    static void OnSuccessCallback_71(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_71(int32s);
    }

    static void OnFailureCallback_72(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_72(chip::to_underlying(status));
    }

    static void OnSuccessCallback_72(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_72(int64s);
    }

    static void OnFailureCallback_73(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_73(chip::to_underlying(status));
    }

    static void OnSuccessCallback_73(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_73(); }

    static void OnFailureCallback_74(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_74(chip::to_underlying(status));
    }

    static void OnSuccessCallback_74(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_74(int64s);
    }

    static void OnFailureCallback_75(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_75(chip::to_underlying(status));
    }

    static void OnSuccessCallback_75(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_75(); }

    static void OnFailureCallback_76(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_76(chip::to_underlying(status));
    }

    static void OnSuccessCallback_76(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_76(int64s);
    }

    static void OnFailureCallback_77(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_77(chip::to_underlying(status));
    }

    static void OnSuccessCallback_77(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_77(); }

    static void OnFailureCallback_78(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_78(chip::to_underlying(status));
    }

    static void OnSuccessCallback_78(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_78(int64s);
    }

    static void OnFailureCallback_79(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_79(chip::to_underlying(status));
    }

    static void OnSuccessCallback_79(void * context, float floatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_79(floatSingle);
    }

    static void OnFailureCallback_80(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_80(chip::to_underlying(status));
    }

    static void OnSuccessCallback_80(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_80(); }

    static void OnFailureCallback_81(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_81(chip::to_underlying(status));
    }

    static void OnSuccessCallback_81(void * context, float floatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_81(floatSingle);
    }

    static void OnFailureCallback_82(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_82(chip::to_underlying(status));
    }

    static void OnSuccessCallback_82(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_82(); }

    static void OnFailureCallback_83(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_83(chip::to_underlying(status));
    }

    static void OnSuccessCallback_83(void * context, float floatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_83(floatSingle);
    }

    static void OnFailureCallback_84(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_84(chip::to_underlying(status));
    }

    static void OnSuccessCallback_84(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_84(); }

    static void OnFailureCallback_85(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_85(chip::to_underlying(status));
    }

    static void OnSuccessCallback_85(void * context, float floatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_85(floatSingle);
    }

    static void OnFailureCallback_86(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_86(chip::to_underlying(status));
    }

    static void OnSuccessCallback_86(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_86(); }

    static void OnFailureCallback_87(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_87(chip::to_underlying(status));
    }

    static void OnSuccessCallback_87(void * context, float floatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_87(floatSingle);
    }

    static void OnFailureCallback_88(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_88(chip::to_underlying(status));
    }

    static void OnSuccessCallback_88(void * context, double floatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_88(floatDouble);
    }

    static void OnFailureCallback_89(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_89(chip::to_underlying(status));
    }

    static void OnSuccessCallback_89(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_89(); }

    static void OnFailureCallback_90(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_90(chip::to_underlying(status));
    }

    static void OnSuccessCallback_90(void * context, double floatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_90(floatDouble);
    }

    static void OnFailureCallback_91(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_91(chip::to_underlying(status));
    }

    static void OnSuccessCallback_91(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_91(); }

    static void OnFailureCallback_92(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_92(chip::to_underlying(status));
    }

    static void OnSuccessCallback_92(void * context, double floatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_92(floatDouble);
    }

    static void OnFailureCallback_93(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_93(chip::to_underlying(status));
    }

    static void OnSuccessCallback_93(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_93(); }

    static void OnFailureCallback_94(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_94(chip::to_underlying(status));
    }

    static void OnSuccessCallback_94(void * context, double floatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_94(floatDouble);
    }

    static void OnFailureCallback_95(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_95(chip::to_underlying(status));
    }

    static void OnSuccessCallback_95(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_95(); }

    static void OnFailureCallback_96(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_96(chip::to_underlying(status));
    }

    static void OnSuccessCallback_96(void * context, double floatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_96(floatDouble);
    }

    static void OnFailureCallback_97(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_97(chip::to_underlying(status));
    }

    static void OnSuccessCallback_97(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_97(enum8);
    }

    static void OnFailureCallback_98(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_98(chip::to_underlying(status));
    }

    static void OnSuccessCallback_98(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_98(); }

    static void OnFailureCallback_99(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_99(chip::to_underlying(status));
    }

    static void OnSuccessCallback_99(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_99(enum8);
    }

    static void OnFailureCallback_100(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_100(chip::to_underlying(status));
    }

    static void OnSuccessCallback_100(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_100(); }

    static void OnFailureCallback_101(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_101(chip::to_underlying(status));
    }

    static void OnSuccessCallback_101(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_101(enum8);
    }

    static void OnFailureCallback_102(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_102(chip::to_underlying(status));
    }

    static void OnSuccessCallback_102(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_102(enum16);
    }

    static void OnFailureCallback_103(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_103(chip::to_underlying(status));
    }

    static void OnSuccessCallback_103(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_103(); }

    static void OnFailureCallback_104(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_104(chip::to_underlying(status));
    }

    static void OnSuccessCallback_104(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_104(enum16);
    }

    static void OnFailureCallback_105(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_105(chip::to_underlying(status));
    }

    static void OnSuccessCallback_105(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_105(); }

    static void OnFailureCallback_106(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_106(chip::to_underlying(status));
    }

    static void OnSuccessCallback_106(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_106(enum16);
    }

    static void OnFailureCallback_107(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_107(chip::to_underlying(status));
    }

    static void OnSuccessCallback_107(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_107(octetString);
    }

    static void OnFailureCallback_108(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_108(chip::to_underlying(status));
    }

    static void OnSuccessCallback_108(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_108(); }

    static void OnFailureCallback_109(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_109(chip::to_underlying(status));
    }

    static void OnSuccessCallback_109(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_109(octetString);
    }

    static void OnFailureCallback_110(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_110(chip::to_underlying(status));
    }

    static void OnSuccessCallback_110(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_110(); }

    static void OnFailureCallback_111(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_111(chip::to_underlying(status));
    }

    static void OnSuccessCallback_111(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_111(octetString);
    }

    static void OnFailureCallback_112(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_112(chip::to_underlying(status));
    }

    static void OnSuccessCallback_112(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_112(); }

    static void OnFailureCallback_113(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_113(chip::to_underlying(status));
    }

    static void OnSuccessCallback_113(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_113(octetString);
    }

    static void OnFailureCallback_114(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_114(chip::to_underlying(status));
    }

    static void OnSuccessCallback_114(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_114(); }

    static void OnFailureCallback_115(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_115(chip::to_underlying(status));
    }

    static void OnSuccessCallback_115(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_115(longOctetString);
    }

    static void OnFailureCallback_116(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_116(chip::to_underlying(status));
    }

    static void OnSuccessCallback_116(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_116(); }

    static void OnFailureCallback_117(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_117(chip::to_underlying(status));
    }

    static void OnSuccessCallback_117(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_117(longOctetString);
    }

    static void OnFailureCallback_118(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_118(chip::to_underlying(status));
    }

    static void OnSuccessCallback_118(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_118(); }

    static void OnFailureCallback_119(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_119(chip::to_underlying(status));
    }

    static void OnSuccessCallback_119(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_119(charString);
    }

    static void OnFailureCallback_120(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_120(chip::to_underlying(status));
    }

    static void OnSuccessCallback_120(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_120(); }

    static void OnFailureCallback_121(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_121(chip::to_underlying(status));
    }

    static void OnSuccessCallback_121(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_121(charString);
    }

    static void OnFailureCallback_122(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_122(chip::to_underlying(status));
    }

    static void OnSuccessCallback_122(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_122(); }

    static void OnFailureCallback_123(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_123(chip::to_underlying(status));
    }

    static void OnSuccessCallback_123(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_123(charString);
    }

    static void OnFailureCallback_124(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_124(chip::to_underlying(status));
    }

    static void OnSuccessCallback_124(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_124(); }

    static void OnFailureCallback_125(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_125(chip::to_underlying(status));
    }

    static void OnSuccessCallback_125(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_125(longCharString);
    }

    static void OnFailureCallback_126(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_126(chip::to_underlying(status));
    }

    static void OnSuccessCallback_126(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_126(); }

    static void OnFailureCallback_127(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_127(chip::to_underlying(status));
    }

    static void OnSuccessCallback_127(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_127(longCharString);
    }

    static void OnFailureCallback_128(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_128(chip::to_underlying(status));
    }

    static void OnSuccessCallback_128(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_128(); }

    static void OnFailureCallback_129(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_129(chip::to_underlying(status));
    }

    static void OnSuccessCallback_129(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_129(epochUs);
    }

    static void OnFailureCallback_130(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_130(chip::to_underlying(status));
    }

    static void OnSuccessCallback_130(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_130(); }

    static void OnFailureCallback_131(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_131(chip::to_underlying(status));
    }

    static void OnSuccessCallback_131(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_131(epochUs);
    }

    static void OnFailureCallback_132(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_132(chip::to_underlying(status));
    }

    static void OnSuccessCallback_132(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_132(); }

    static void OnFailureCallback_133(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_133(chip::to_underlying(status));
    }

    static void OnSuccessCallback_133(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_133(epochUs);
    }

    static void OnFailureCallback_134(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_134(chip::to_underlying(status));
    }

    static void OnSuccessCallback_134(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_134(epochS);
    }

    static void OnFailureCallback_135(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_135(chip::to_underlying(status));
    }

    static void OnSuccessCallback_135(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_135(); }

    static void OnFailureCallback_136(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_136(chip::to_underlying(status));
    }

    static void OnSuccessCallback_136(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_136(epochS);
    }

    static void OnFailureCallback_137(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_137(chip::to_underlying(status));
    }

    static void OnSuccessCallback_137(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_137(); }

    static void OnFailureCallback_138(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_138(chip::to_underlying(status));
    }

    static void OnSuccessCallback_138(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_138(epochS);
    }

    static void OnFailureCallback_139(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_139(chip::to_underlying(status));
    }

    static void OnSuccessCallback_139(void * context, bool unsupported)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_139(unsupported);
    }

    static void OnFailureCallback_140(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_140(chip::to_underlying(status));
    }

    static void OnSuccessCallback_140(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_140(); }

    static void OnFailureCallback_143(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_143(chip::to_underlying(status));
    }

    static void OnSuccessCallback_143(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_143(vendorId);
    }

    static void OnFailureCallback_144(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_144(chip::to_underlying(status));
    }

    static void OnSuccessCallback_144(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_144(); }

    static void OnFailureCallback_145(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_145(chip::to_underlying(status));
    }

    static void OnSuccessCallback_145(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_145(vendorId);
    }

    static void OnFailureCallback_146(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_146(chip::to_underlying(status));
    }

    static void OnSuccessCallback_146(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_146(); }

    static void OnFailureCallback_163(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_163(chip::to_underlying(status));
    }

    static void OnSuccessCallback_163(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_163(); }

    static void OnFailureCallback_164(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_164(chip::to_underlying(status));
    }

    static void OnSuccessCallback_164(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_164(listInt8u);
    }

    static void OnFailureCallback_165(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_165(chip::to_underlying(status));
    }

    static void OnSuccessCallback_165(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_165(); }

    static void OnFailureCallback_166(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_166(chip::to_underlying(status));
    }

    static void OnSuccessCallback_166(void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_166(listOctetString);
    }

    static void OnFailureCallback_167(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_167(chip::to_underlying(status));
    }

    static void OnSuccessCallback_167(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_167(); }

    static void OnFailureCallback_168(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_168(chip::to_underlying(status));
    }

    static void OnSuccessCallback_168(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_168(listStructOctetString);
    }

    static void OnFailureCallback_171(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_171(chip::to_underlying(status));
    }

    static void OnSuccessCallback_171(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_171(); }

    static void OnFailureCallback_172(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_172(chip::to_underlying(status));
    }

    static void OnSuccessCallback_172(void * context, const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_172(nullableBoolean);
    }

    static void OnFailureCallback_173(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_173(chip::to_underlying(status));
    }

    static void OnSuccessCallback_173(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_173(); }

    static void OnFailureCallback_174(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_174(chip::to_underlying(status));
    }

    static void OnSuccessCallback_174(void * context, const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_174(nullableBoolean);
    }

    static void OnFailureCallback_175(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_175(chip::to_underlying(status));
    }

    static void OnSuccessCallback_175(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_175(); }

    static void OnFailureCallback_176(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_176(chip::to_underlying(status));
    }

    static void OnSuccessCallback_176(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_176(nullableBitmap8);
    }

    static void OnFailureCallback_177(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_177(chip::to_underlying(status));
    }

    static void OnSuccessCallback_177(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_177(); }

    static void OnFailureCallback_178(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_178(chip::to_underlying(status));
    }

    static void OnSuccessCallback_178(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_178(nullableBitmap8);
    }

    static void OnFailureCallback_179(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_179(chip::to_underlying(status));
    }

    static void OnSuccessCallback_179(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_179(); }

    static void OnFailureCallback_180(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_180(chip::to_underlying(status));
    }

    static void OnSuccessCallback_180(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_180(nullableBitmap8);
    }

    static void OnFailureCallback_181(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_181(chip::to_underlying(status));
    }

    static void OnSuccessCallback_181(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_181(); }

    static void OnFailureCallback_182(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_182(chip::to_underlying(status));
    }

    static void OnSuccessCallback_182(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_182(nullableBitmap16);
    }

    static void OnFailureCallback_183(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_183(chip::to_underlying(status));
    }

    static void OnSuccessCallback_183(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_183(); }

    static void OnFailureCallback_184(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_184(chip::to_underlying(status));
    }

    static void OnSuccessCallback_184(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_184(nullableBitmap16);
    }

    static void OnFailureCallback_185(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_185(chip::to_underlying(status));
    }

    static void OnSuccessCallback_185(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_185(); }

    static void OnFailureCallback_186(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_186(chip::to_underlying(status));
    }

    static void OnSuccessCallback_186(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_186(nullableBitmap16);
    }

    static void OnFailureCallback_187(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_187(chip::to_underlying(status));
    }

    static void OnSuccessCallback_187(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_187(); }

    static void OnFailureCallback_188(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_188(chip::to_underlying(status));
    }

    static void OnSuccessCallback_188(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_188(nullableBitmap32);
    }

    static void OnFailureCallback_189(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_189(chip::to_underlying(status));
    }

    static void OnSuccessCallback_189(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_189(); }

    static void OnFailureCallback_190(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_190(chip::to_underlying(status));
    }

    static void OnSuccessCallback_190(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_190(nullableBitmap32);
    }

    static void OnFailureCallback_191(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_191(chip::to_underlying(status));
    }

    static void OnSuccessCallback_191(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_191(); }

    static void OnFailureCallback_192(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_192(chip::to_underlying(status));
    }

    static void OnSuccessCallback_192(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_192(nullableBitmap32);
    }

    static void OnFailureCallback_193(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_193(chip::to_underlying(status));
    }

    static void OnSuccessCallback_193(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_193(); }

    static void OnFailureCallback_194(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_194(chip::to_underlying(status));
    }

    static void OnSuccessCallback_194(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_194(nullableBitmap64);
    }

    static void OnFailureCallback_195(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_195(chip::to_underlying(status));
    }

    static void OnSuccessCallback_195(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_195(); }

    static void OnFailureCallback_196(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_196(chip::to_underlying(status));
    }

    static void OnSuccessCallback_196(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_196(nullableBitmap64);
    }

    static void OnFailureCallback_197(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_197(chip::to_underlying(status));
    }

    static void OnSuccessCallback_197(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_197(); }

    static void OnFailureCallback_198(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_198(chip::to_underlying(status));
    }

    static void OnSuccessCallback_198(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_198(nullableBitmap64);
    }

    static void OnFailureCallback_199(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_199(chip::to_underlying(status));
    }

    static void OnSuccessCallback_199(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_199(); }

    static void OnFailureCallback_200(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_200(chip::to_underlying(status));
    }

    static void OnSuccessCallback_200(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_200(nullableInt8u);
    }

    static void OnFailureCallback_201(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_201(chip::to_underlying(status));
    }

    static void OnSuccessCallback_201(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_201(); }

    static void OnFailureCallback_202(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_202(chip::to_underlying(status));
    }

    static void OnSuccessCallback_202(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_202(nullableInt8u);
    }

    static void OnFailureCallback_203(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_203(chip::to_underlying(status));
    }

    static void OnSuccessCallback_203(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_203(); }

    static void OnFailureCallback_204(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_204(chip::to_underlying(status));
    }

    static void OnSuccessCallback_204(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_204(nullableInt8u);
    }

    static void OnFailureCallback_205(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_205(chip::to_underlying(status));
    }

    static void OnSuccessCallback_205(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_205(); }

    static void OnFailureCallback_206(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_206(chip::to_underlying(status));
    }

    static void OnSuccessCallback_206(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_206(nullableInt16u);
    }

    static void OnFailureCallback_207(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_207(chip::to_underlying(status));
    }

    static void OnSuccessCallback_207(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_207(); }

    static void OnFailureCallback_208(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_208(chip::to_underlying(status));
    }

    static void OnSuccessCallback_208(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_208(nullableInt16u);
    }

    static void OnFailureCallback_209(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_209(chip::to_underlying(status));
    }

    static void OnSuccessCallback_209(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_209(); }

    static void OnFailureCallback_210(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_210(chip::to_underlying(status));
    }

    static void OnSuccessCallback_210(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_210(nullableInt16u);
    }

    static void OnFailureCallback_211(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_211(chip::to_underlying(status));
    }

    static void OnSuccessCallback_211(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_211(); }

    static void OnFailureCallback_212(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_212(chip::to_underlying(status));
    }

    static void OnSuccessCallback_212(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_212(nullableInt32u);
    }

    static void OnFailureCallback_213(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_213(chip::to_underlying(status));
    }

    static void OnSuccessCallback_213(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_213(); }

    static void OnFailureCallback_214(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_214(chip::to_underlying(status));
    }

    static void OnSuccessCallback_214(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_214(nullableInt32u);
    }

    static void OnFailureCallback_215(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_215(chip::to_underlying(status));
    }

    static void OnSuccessCallback_215(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_215(); }

    static void OnFailureCallback_216(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_216(chip::to_underlying(status));
    }

    static void OnSuccessCallback_216(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_216(nullableInt32u);
    }

    static void OnFailureCallback_217(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_217(chip::to_underlying(status));
    }

    static void OnSuccessCallback_217(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_217(); }

    static void OnFailureCallback_218(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_218(chip::to_underlying(status));
    }

    static void OnSuccessCallback_218(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_218(nullableInt64u);
    }

    static void OnFailureCallback_219(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_219(chip::to_underlying(status));
    }

    static void OnSuccessCallback_219(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_219(); }

    static void OnFailureCallback_220(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_220(chip::to_underlying(status));
    }

    static void OnSuccessCallback_220(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_220(nullableInt64u);
    }

    static void OnFailureCallback_221(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_221(chip::to_underlying(status));
    }

    static void OnSuccessCallback_221(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_221(); }

    static void OnFailureCallback_222(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_222(chip::to_underlying(status));
    }

    static void OnSuccessCallback_222(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_222(nullableInt64u);
    }

    static void OnFailureCallback_223(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_223(chip::to_underlying(status));
    }

    static void OnSuccessCallback_223(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_223(); }

    static void OnFailureCallback_224(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_224(chip::to_underlying(status));
    }

    static void OnSuccessCallback_224(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_224(nullableInt8s);
    }

    static void OnFailureCallback_225(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_225(chip::to_underlying(status));
    }

    static void OnSuccessCallback_225(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_225(); }

    static void OnFailureCallback_226(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_226(chip::to_underlying(status));
    }

    static void OnSuccessCallback_226(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_226(nullableInt8s);
    }

    static void OnFailureCallback_227(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_227(chip::to_underlying(status));
    }

    static void OnSuccessCallback_227(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_227(); }

    static void OnFailureCallback_228(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_228(chip::to_underlying(status));
    }

    static void OnSuccessCallback_228(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_228(nullableInt8s);
    }

    static void OnFailureCallback_229(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_229(chip::to_underlying(status));
    }

    static void OnSuccessCallback_229(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_229(); }

    static void OnFailureCallback_230(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_230(chip::to_underlying(status));
    }

    static void OnSuccessCallback_230(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_230(nullableInt16s);
    }

    static void OnFailureCallback_231(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_231(chip::to_underlying(status));
    }

    static void OnSuccessCallback_231(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_231(); }

    static void OnFailureCallback_232(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_232(chip::to_underlying(status));
    }

    static void OnSuccessCallback_232(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_232(nullableInt16s);
    }

    static void OnFailureCallback_233(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_233(chip::to_underlying(status));
    }

    static void OnSuccessCallback_233(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_233(); }

    static void OnFailureCallback_234(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_234(chip::to_underlying(status));
    }

    static void OnSuccessCallback_234(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_234(nullableInt16s);
    }

    static void OnFailureCallback_235(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_235(chip::to_underlying(status));
    }

    static void OnSuccessCallback_235(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_235(); }

    static void OnFailureCallback_236(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_236(chip::to_underlying(status));
    }

    static void OnSuccessCallback_236(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_236(nullableInt32s);
    }

    static void OnFailureCallback_237(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_237(chip::to_underlying(status));
    }

    static void OnSuccessCallback_237(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_237(); }

    static void OnFailureCallback_238(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_238(chip::to_underlying(status));
    }

    static void OnSuccessCallback_238(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_238(nullableInt32s);
    }

    static void OnFailureCallback_239(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_239(chip::to_underlying(status));
    }

    static void OnSuccessCallback_239(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_239(); }

    static void OnFailureCallback_240(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_240(chip::to_underlying(status));
    }

    static void OnSuccessCallback_240(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_240(nullableInt32s);
    }

    static void OnFailureCallback_241(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_241(chip::to_underlying(status));
    }

    static void OnSuccessCallback_241(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_241(); }

    static void OnFailureCallback_242(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_242(chip::to_underlying(status));
    }

    static void OnSuccessCallback_242(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_242(nullableInt64s);
    }

    static void OnFailureCallback_243(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_243(chip::to_underlying(status));
    }

    static void OnSuccessCallback_243(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_243(); }

    static void OnFailureCallback_244(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_244(chip::to_underlying(status));
    }

    static void OnSuccessCallback_244(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_244(nullableInt64s);
    }

    static void OnFailureCallback_245(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_245(chip::to_underlying(status));
    }

    static void OnSuccessCallback_245(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_245(); }

    static void OnFailureCallback_246(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_246(chip::to_underlying(status));
    }

    static void OnSuccessCallback_246(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_246(nullableInt64s);
    }

    static void OnFailureCallback_247(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_247(chip::to_underlying(status));
    }

    static void OnSuccessCallback_247(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_247(); }

    static void OnFailureCallback_248(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_248(chip::to_underlying(status));
    }

    static void OnSuccessCallback_248(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_248(nullableFloatSingle);
    }

    static void OnFailureCallback_249(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_249(chip::to_underlying(status));
    }

    static void OnSuccessCallback_249(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_249(); }

    static void OnFailureCallback_250(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_250(chip::to_underlying(status));
    }

    static void OnSuccessCallback_250(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_250(nullableFloatSingle);
    }

    static void OnFailureCallback_251(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_251(chip::to_underlying(status));
    }

    static void OnSuccessCallback_251(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_251(); }

    static void OnFailureCallback_252(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_252(chip::to_underlying(status));
    }

    static void OnSuccessCallback_252(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_252(nullableFloatSingle);
    }

    static void OnFailureCallback_253(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_253(chip::to_underlying(status));
    }

    static void OnSuccessCallback_253(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_253(); }

    static void OnFailureCallback_254(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_254(chip::to_underlying(status));
    }

    static void OnSuccessCallback_254(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_254(nullableFloatSingle);
    }

    static void OnFailureCallback_255(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_255(chip::to_underlying(status));
    }

    static void OnSuccessCallback_255(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_255(); }

    static void OnFailureCallback_256(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_256(chip::to_underlying(status));
    }

    static void OnSuccessCallback_256(void * context, const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_256(nullableFloatSingle);
    }

    static void OnFailureCallback_257(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_257(chip::to_underlying(status));
    }

    static void OnSuccessCallback_257(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_257(); }

    static void OnFailureCallback_258(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_258(chip::to_underlying(status));
    }

    static void OnSuccessCallback_258(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_258(nullableFloatDouble);
    }

    static void OnFailureCallback_259(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_259(chip::to_underlying(status));
    }

    static void OnSuccessCallback_259(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_259(); }

    static void OnFailureCallback_260(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_260(chip::to_underlying(status));
    }

    static void OnSuccessCallback_260(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_260(nullableFloatDouble);
    }

    static void OnFailureCallback_261(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_261(chip::to_underlying(status));
    }

    static void OnSuccessCallback_261(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_261(); }

    static void OnFailureCallback_262(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_262(chip::to_underlying(status));
    }

    static void OnSuccessCallback_262(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_262(nullableFloatDouble);
    }

    static void OnFailureCallback_263(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_263(chip::to_underlying(status));
    }

    static void OnSuccessCallback_263(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_263(); }

    static void OnFailureCallback_264(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_264(chip::to_underlying(status));
    }

    static void OnSuccessCallback_264(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_264(nullableFloatDouble);
    }

    static void OnFailureCallback_265(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_265(chip::to_underlying(status));
    }

    static void OnSuccessCallback_265(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_265(); }

    static void OnFailureCallback_266(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_266(chip::to_underlying(status));
    }

    static void OnSuccessCallback_266(void * context, const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_266(nullableFloatDouble);
    }

    static void OnFailureCallback_267(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_267(chip::to_underlying(status));
    }

    static void OnSuccessCallback_267(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_267(); }

    static void OnFailureCallback_268(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_268(chip::to_underlying(status));
    }

    static void OnSuccessCallback_268(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_268(nullableEnum8);
    }

    static void OnFailureCallback_269(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_269(chip::to_underlying(status));
    }

    static void OnSuccessCallback_269(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_269(); }

    static void OnFailureCallback_270(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_270(chip::to_underlying(status));
    }

    static void OnSuccessCallback_270(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_270(nullableEnum8);
    }

    static void OnFailureCallback_271(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_271(chip::to_underlying(status));
    }

    static void OnSuccessCallback_271(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_271(); }

    static void OnFailureCallback_272(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_272(chip::to_underlying(status));
    }

    static void OnSuccessCallback_272(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_272(nullableEnum8);
    }

    static void OnFailureCallback_273(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_273(chip::to_underlying(status));
    }

    static void OnSuccessCallback_273(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_273(); }

    static void OnFailureCallback_274(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_274(chip::to_underlying(status));
    }

    static void OnSuccessCallback_274(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_274(nullableEnum16);
    }

    static void OnFailureCallback_275(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_275(chip::to_underlying(status));
    }

    static void OnSuccessCallback_275(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_275(); }

    static void OnFailureCallback_276(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_276(chip::to_underlying(status));
    }

    static void OnSuccessCallback_276(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_276(nullableEnum16);
    }

    static void OnFailureCallback_277(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_277(chip::to_underlying(status));
    }

    static void OnSuccessCallback_277(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_277(); }

    static void OnFailureCallback_278(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_278(chip::to_underlying(status));
    }

    static void OnSuccessCallback_278(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_278(nullableEnum16);
    }

    static void OnFailureCallback_279(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_279(chip::to_underlying(status));
    }

    static void OnSuccessCallback_279(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_279(nullableOctetString);
    }

    static void OnFailureCallback_280(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_280(chip::to_underlying(status));
    }

    static void OnSuccessCallback_280(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_280(); }

    static void OnFailureCallback_281(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_281(chip::to_underlying(status));
    }

    static void OnSuccessCallback_281(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_281(nullableOctetString);
    }

    static void OnFailureCallback_282(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_282(chip::to_underlying(status));
    }

    static void OnSuccessCallback_282(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_282(); }

    static void OnFailureCallback_283(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_283(chip::to_underlying(status));
    }

    static void OnSuccessCallback_283(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_283(nullableOctetString);
    }

    static void OnFailureCallback_284(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_284(chip::to_underlying(status));
    }

    static void OnSuccessCallback_284(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_284(); }

    static void OnFailureCallback_285(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_285(chip::to_underlying(status));
    }

    static void OnSuccessCallback_285(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_285(nullableOctetString);
    }

    static void OnFailureCallback_286(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_286(chip::to_underlying(status));
    }

    static void OnSuccessCallback_286(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_286(nullableCharString);
    }

    static void OnFailureCallback_287(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_287(chip::to_underlying(status));
    }

    static void OnSuccessCallback_287(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_287(); }

    static void OnFailureCallback_288(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_288(chip::to_underlying(status));
    }

    static void OnSuccessCallback_288(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_288(nullableCharString);
    }

    static void OnFailureCallback_289(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_289(chip::to_underlying(status));
    }

    static void OnSuccessCallback_289(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_289(); }

    static void OnFailureCallback_290(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_290(chip::to_underlying(status));
    }

    static void OnSuccessCallback_290(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_290(nullableCharString);
    }

    static void OnFailureCallback_291(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_291(chip::to_underlying(status));
    }

    static void OnSuccessCallback_291(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_291(); }

    static void OnFailureCallback_292(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_292(chip::to_underlying(status));
    }

    static void OnSuccessCallback_292(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_292(nullableCharString);
    }

    static void OnFailureCallback_293(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_293(chip::to_underlying(status));
    }

    static void OnSuccessCallback_293(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_293(listInt8u);
    }

    static void OnFailureCallback_294(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_294(chip::to_underlying(status));
    }

    static void OnSuccessCallback_294(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_294(listInt8u);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendTestCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestSendTestNotHandledCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestSpecificCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestSpecific::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_3(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, 7));

        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_4(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, 20));

        NextTest();
    }

    CHIP_ERROR TestSendFailingTestAddArgumentsCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 250;
        request.arg2 = 6;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_5(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_INVALID_COMMAND));
        NextTest();
    }

    void OnSuccessResponse_5(uint8_t returnValue) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_6,
                                                                                                      OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanTrue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanTrue_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_8,
                                                                                                      OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, 1));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanFalse_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanFalse_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_10,
                                                                                                      OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_11,
                                                                                                      OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MaxValue_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MaxValue_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_13,
                                                                                                      OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, 255));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MinValue_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MinValue_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_15,
                                                                                                      OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_16,
                                                                                                       OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MaxValue_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MaxValue_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_18,
                                                                                                       OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, 65535U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MinValue_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MinValue_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_20,
                                                                                                       OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_21,
                                                                                                       OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, 0UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MaxValue_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MaxValue_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_23,
                                                                                                       OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, 4294967295UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MinValue_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MinValue_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_25,
                                                                                                       OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_26,
                                                                                                       OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MaxValue_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MaxValue_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_28,
                                                                                                       OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, 18446744073709551615ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MinValue_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MinValue_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_30,
                                                                                                       OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_31,
                                                                                                    OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMaxValue_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t int8uArgument;
        int8uArgument = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMaxValue_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_33,
                                                                                                    OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, 255));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMinValue_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t int8uArgument;
        int8uArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMinValue_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_35,
                                                                                                    OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_36,
                                                                                                     OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMaxValue_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t int16uArgument;
        int16uArgument = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMaxValue_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_38,
                                                                                                     OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, 65535U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMinValue_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t int16uArgument;
        int16uArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMinValue_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_40,
                                                                                                     OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_41,
                                                                                                     OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, 0UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMaxValue_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMaxValue_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_43,
                                                                                                     OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, 4294967295UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMinValue_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMinValue_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_45,
                                                                                                     OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_46,
                                                                                                     OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMaxValue_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t int64uArgument;
        int64uArgument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMaxValue_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_48,
                                                                                                     OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, 18446744073709551615ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMinValue_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t int64uArgument;
        int64uArgument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_49, OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMinValue_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_50,
                                                                                                     OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_51,
                                                                                                    OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMaxValue_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = 127;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_52, OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMaxValue_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_53,
                                                                                                    OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, 127));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMinValue_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = -128;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_54, OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMinValue_55()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_55,
                                                                                                    OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, -128));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_56()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_56, OnFailureCallback_56);
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_57()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_57,
                                                                                                    OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_57(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_58()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_58,
                                                                                                     OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMaxValue_59()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = 32767;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_59, OnFailureCallback_59);
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMaxValue_60()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_60,
                                                                                                     OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_60(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, 32767));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMinValue_61()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = -32768;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_61, OnFailureCallback_61);
    }

    void OnFailureResponse_61(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_61() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMinValue_62()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_62,
                                                                                                     OnFailureCallback_62);
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, -32768));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_63()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_63, OnFailureCallback_63);
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_64()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_64,
                                                                                                     OnFailureCallback_64);
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_65()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_65,
                                                                                                     OnFailureCallback_65);
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, 0L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMaxValue_66()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = 2147483647L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_66, OnFailureCallback_66);
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMaxValue_67()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_67,
                                                                                                     OnFailureCallback_67);
    }

    void OnFailureResponse_67(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_67(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, 2147483647L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMinValue_68()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = -2147483648L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_68, OnFailureCallback_68);
    }

    void OnFailureResponse_68(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_68() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMinValue_69()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_69,
                                                                                                     OnFailureCallback_69);
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, -2147483648L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_70()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = 0L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_70, OnFailureCallback_70);
    }

    void OnFailureResponse_70(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_70() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_71()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_71,
                                                                                                     OnFailureCallback_71);
    }

    void OnFailureResponse_71(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_71(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, 0L));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_72()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_72,
                                                                                                     OnFailureCallback_72);
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, 0LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMaxValue_73()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = 9223372036854775807LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_73, OnFailureCallback_73);
    }

    void OnFailureResponse_73(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_73() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMaxValue_74()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_74,
                                                                                                     OnFailureCallback_74);
    }

    void OnFailureResponse_74(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_74(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, 9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMinValue_75()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = -9223372036854775807LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_75, OnFailureCallback_75);
    }

    void OnFailureResponse_75(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_75() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMinValue_76()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_76,
                                                                                                     OnFailureCallback_76);
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, -9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_77()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = 0LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_77, OnFailureCallback_77);
    }

    void OnFailureResponse_77(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_77() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_78()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_78,
                                                                                                     OnFailureCallback_78);
    }

    void OnFailureResponse_78(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_78(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, 0LL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeSingleDefaultValue_79()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_79, OnFailureCallback_79);
    }

    void OnFailureResponse_79(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_79(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 0.0f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeSingleMediumValue_80()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        float floatSingleArgument;
        floatSingleArgument = 0.1f;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            floatSingleArgument, this, OnSuccessCallback_80, OnFailureCallback_80);
    }

    void OnFailureResponse_80(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_80() { NextTest(); }

    CHIP_ERROR TestReadAttributeSingleMediumValue_81()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_81, OnFailureCallback_81);
    }

    void OnFailureResponse_81(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_81(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 0.1f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeSingleLargeValue_82()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        float floatSingleArgument;
        floatSingleArgument = 17000000000.0f;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            floatSingleArgument, this, OnSuccessCallback_82, OnFailureCallback_82);
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82() { NextTest(); }

    CHIP_ERROR TestReadAttributeSingleLargeValue_83()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_83, OnFailureCallback_83);
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 17000000000.0f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeSingleSmallValue_84()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        float floatSingleArgument;
        floatSingleArgument = 1.7e-10f;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            floatSingleArgument, this, OnSuccessCallback_84, OnFailureCallback_84);
    }

    void OnFailureResponse_84(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_84() { NextTest(); }

    CHIP_ERROR TestReadAttributeSingleSmallValue_85()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_85, OnFailureCallback_85);
    }

    void OnFailureResponse_85(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_85(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 1.7e-10f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeSingleDefaultValue_86()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        float floatSingleArgument;
        floatSingleArgument = 0.0f;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            floatSingleArgument, this, OnSuccessCallback_86, OnFailureCallback_86);
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86() { NextTest(); }

    CHIP_ERROR TestReadAttributeSingleDefaultValue_87()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatSingle::TypeInfo>(
            this, OnSuccessCallback_87, OnFailureCallback_87);
    }

    void OnFailureResponse_87(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_87(float floatSingle)
    {
        VerifyOrReturn(CheckValue("floatSingle", floatSingle, 0.0f));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeDoubleDefaultValue_88()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_88, OnFailureCallback_88);
    }

    void OnFailureResponse_88(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_88(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeDoubleMediumValue_89()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        double floatDoubleArgument;
        floatDoubleArgument = 0.1234567890123;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            floatDoubleArgument, this, OnSuccessCallback_89, OnFailureCallback_89);
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89() { NextTest(); }

    CHIP_ERROR TestReadAttributeDoubleMediumValue_90()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_90, OnFailureCallback_90);
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 0.1234567890123));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeDoubleLargeValue_91()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        double floatDoubleArgument;
        floatDoubleArgument = 1.7e+200;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            floatDoubleArgument, this, OnSuccessCallback_91, OnFailureCallback_91);
    }

    void OnFailureResponse_91(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_91() { NextTest(); }

    CHIP_ERROR TestReadAttributeDoubleLargeValue_92()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_92, OnFailureCallback_92);
    }

    void OnFailureResponse_92(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_92(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 1.7e+200));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeDoubleSmallValue_93()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        double floatDoubleArgument;
        floatDoubleArgument = 1.7e-200;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            floatDoubleArgument, this, OnSuccessCallback_93, OnFailureCallback_93);
    }

    void OnFailureResponse_93(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_93() { NextTest(); }

    CHIP_ERROR TestReadAttributeDoubleSmallValue_94()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_94, OnFailureCallback_94);
    }

    void OnFailureResponse_94(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_94(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 1.7e-200));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeDoubleDefaultValue_95()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        double floatDoubleArgument;
        floatDoubleArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            floatDoubleArgument, this, OnSuccessCallback_95, OnFailureCallback_95);
    }

    void OnFailureResponse_95(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_95() { NextTest(); }

    CHIP_ERROR TestReadAttributeDoubleDefaultValue_96()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::FloatDouble::TypeInfo>(
            this, OnSuccessCallback_96, OnFailureCallback_96);
    }

    void OnFailureResponse_96(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_96(double floatDouble)
    {
        VerifyOrReturn(CheckValue("floatDouble", floatDouble, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_97()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_97,
                                                                                                    OnFailureCallback_97);
    }

    void OnFailureResponse_97(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_97(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MaxValue_98()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t enum8Argument;
        enum8Argument = static_cast<uint8_t>(255);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_98, OnFailureCallback_98);
    }

    void OnFailureResponse_98(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_98() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MaxValue_99()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_99,
                                                                                                    OnFailureCallback_99);
    }

    void OnFailureResponse_99(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_99(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, 255));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MinValue_100()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t enum8Argument;
        enum8Argument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_100, OnFailureCallback_100);
    }

    void OnFailureResponse_100(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_100() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MinValue_101()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_101,
                                                                                                    OnFailureCallback_101);
    }

    void OnFailureResponse_101(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_101(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_102()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_102,
                                                                                                     OnFailureCallback_102);
    }

    void OnFailureResponse_102(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_102(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MaxValue_103()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enum16Argument;
        enum16Argument = static_cast<uint16_t>(65535);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_103, OnFailureCallback_103);
    }

    void OnFailureResponse_103(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_103() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MaxValue_104()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_104,
                                                                                                     OnFailureCallback_104);
    }

    void OnFailureResponse_104(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_104(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, 65535U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MinValue_105()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enum16Argument;
        enum16Argument = static_cast<uint16_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_105, OnFailureCallback_105);
    }

    void OnFailureResponse_105(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_105() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MinValue_106()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_106,
                                                                                                     OnFailureCallback_106);
    }

    void OnFailureResponse_106(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_106(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, 0U));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValue_107()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_107, OnFailureCallback_107);
    }

    void OnFailureResponse_107(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_107(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetStringWithEmbeddedNull_108()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("Tes\x00ti\x00nggarbage: not in length on purpose"), 9);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_108, OnFailureCallback_108);
    }

    void OnFailureResponse_108(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_108() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetStringWithEmbeddedNull_109()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_109, OnFailureCallback_109);
    }

    void OnFailureResponse_109(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_109(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("Tes\x00ti\x00ng"), 9)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_110()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_110, OnFailureCallback_110);
    }

    void OnFailureResponse_110(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_110() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetString_111()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_111, OnFailureCallback_111);
    }

    void OnFailureResponse_111(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_111(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_112()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValueLongerThan10garbage: not in length on purpose"), 21);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_112, OnFailureCallback_112);
    }

    void OnFailureResponse_112(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_112() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeOctetString_113()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_113, OnFailureCallback_113);
    }

    void OnFailureResponse_113(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_113(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_114()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_114, OnFailureCallback_114);
    }

    void OnFailureResponse_114(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_114() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetStringDefaultValue_115()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            this, OnSuccessCallback_115, OnFailureCallback_115);
    }

    void OnFailureResponse_115(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_115(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString("longOctetString", longOctetString, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_116()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan longOctetStringArgument;
        longOctetStringArgument = chip::ByteSpan(
            chip::Uint8::from_const_char(
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111garbage: not in length on purpose"),
            300);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            longOctetStringArgument, this, OnSuccessCallback_116, OnFailureCallback_116);
    }

    void OnFailureResponse_116(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_116() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetString_117()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            this, OnSuccessCallback_117, OnFailureCallback_117);
    }

    void OnFailureResponse_117(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_117(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longOctetString", longOctetString,
            chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111"),
                300)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_118()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::ByteSpan longOctetStringArgument;
        longOctetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            longOctetStringArgument, this, OnSuccessCallback_118, OnFailureCallback_118);
    }

    void OnFailureResponse_118(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_118() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringDefaultValue_119()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_119, OnFailureCallback_119);
    }

    void OnFailureResponse_119(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_119(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharString_120()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("Tgarbage: not in length on purpose", 7);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_120, OnFailureCallback_120);
    }

    void OnFailureResponse_120(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_120() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharString_121()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_121, OnFailureCallback_121);
    }

    void OnFailureResponse_121(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_121(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("T", 7)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValueTooLong_122()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("TestValueLongerThan10garbage: not in length on purpose", 27);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_122, OnFailureCallback_122);
    }

    void OnFailureResponse_122(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_122() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeCharString_123()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_123, OnFailureCallback_123);
    }

    void OnFailureResponse_123(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_123(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("T", 7)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringEmpty_124()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_124, OnFailureCallback_124);
    }

    void OnFailureResponse_124(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_124() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharStringDefaultValue_125()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            this, OnSuccessCallback_125, OnFailureCallback_125);
    }

    void OnFailureResponse_125(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_125(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString("longCharString", longCharString, chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_126()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan longCharStringArgument;
        longCharStringArgument = chip::Span<const char>(
            ""
            ""
            "garbage: not in length on purpose",
            900);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            longCharStringArgument, this, OnSuccessCallback_126, OnFailureCallback_126);
    }

    void OnFailureResponse_126(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_126() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharString_127()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            this, OnSuccessCallback_127, OnFailureCallback_127);
    }

    void OnFailureResponse_127(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_127(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longCharString", longCharString,
            chip::CharSpan(""
                           ""
                           "",
                           900)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_128()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan longCharStringArgument;
        longCharStringArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            longCharStringArgument, this, OnSuccessCallback_128, OnFailureCallback_128);
    }

    void OnFailureResponse_128(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_128() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_129()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_129,
                                                                                                      OnFailureCallback_129);
    }

    void OnFailureResponse_129(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_129(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMaxValue_130()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_130, OnFailureCallback_130);
    }

    void OnFailureResponse_130(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_130() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMaxValue_131()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_131,
                                                                                                      OnFailureCallback_131);
    }

    void OnFailureResponse_131(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_131(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, 18446744073709551615ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMinValue_132()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_132, OnFailureCallback_132);
    }

    void OnFailureResponse_132(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_132() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMinValue_133()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_133,
                                                                                                      OnFailureCallback_133);
    }

    void OnFailureResponse_133(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_133(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, 0ULL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_134()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_134,
                                                                                                     OnFailureCallback_134);
    }

    void OnFailureResponse_134(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_134(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, 0UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMaxValue_135()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t epochSArgument;
        epochSArgument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_135, OnFailureCallback_135);
    }

    void OnFailureResponse_135(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_135() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMaxValue_136()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_136,
                                                                                                     OnFailureCallback_136);
    }

    void OnFailureResponse_136(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_136(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, 4294967295UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMinValue_137()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t epochSArgument;
        epochSArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_137, OnFailureCallback_137);
    }

    void OnFailureResponse_137(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_137() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMinValue_138()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_138,
                                                                                                     OnFailureCallback_138);
    }

    void OnFailureResponse_138(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_138(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, 0UL));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeUnsupported_139()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo>(
            this, OnSuccessCallback_139, OnFailureCallback_139);
    }

    void OnFailureResponse_139(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_139(bool unsupported)
    {
        VerifyOrReturn(CheckValue("unsupported", unsupported, 0));

        NextTest();
    }

    CHIP_ERROR TestWriteattributeUnsupported_140()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool unsupportedArgument;
        unsupportedArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo>(
            unsupportedArgument, this, OnSuccessCallback_140, OnFailureCallback_140);
    }

    void OnFailureResponse_140(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_140() { NextTest(); }

    CHIP_ERROR TestSendTestCommandToUnsupportedEndpoint_141()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 200;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_141();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_141(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_141(uint8_t status)
    {
        VerifyOrReturn(CheckConstraintNotValue("status", status, 0));
        NextTest();
    }

    void OnSuccessResponse_141() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestCommandToUnsupportedCluster_142()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_142();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_142(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_142(uint8_t status)
    {
        VerifyOrReturn(CheckConstraintNotValue("status", status, 0));
        NextTest();
    }

    void OnSuccessResponse_142() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_143()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(this, OnSuccessCallback_143,
                                                                                                       OnFailureCallback_143);
    }

    void OnFailureResponse_143(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_143(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, 0U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeVendorId_144()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(17);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_144, OnFailureCallback_144);
    }

    void OnFailureResponse_144(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_144() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorId_145()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(this, OnSuccessCallback_145,
                                                                                                       OnFailureCallback_145);
    }

    void OnFailureResponse_145(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_145(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, 17U));

        NextTest();
    }

    CHIP_ERROR TestRestoreAttributeVendorId_146()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_146, OnFailureCallback_146);
    }

    void OnFailureResponse_146(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_146() { NextTest(); }

    CHIP_ERROR TestSendACommandWithAVendorIdAndEnum_147()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type;

        RequestType request;
        request.arg1 = static_cast<chip::VendorId>(20003);
        request.arg2 = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(101);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_147(data.arg1, data.arg2);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_147(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_147(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_147(chip::VendorId arg1, chip::app::Clusters::TestCluster::SimpleEnum arg2)
    {
        VerifyOrReturn(CheckValue("arg1", arg1, 20003U));

        VerifyOrReturn(CheckValue("arg2", arg2, 101));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsTrue_148()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.g = 0.0f;
        request.arg1.h = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_148(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_148(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_148(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_148(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsFalse_149()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = false;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.g = 0.0f;
        request.arg1.h = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_149(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_149(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_149(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_149(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructArgumentAndArg1cbIsTrue_150()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;

        request.arg1.c.a = 0;
        request.arg1.c.b = true;
        request.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.c.g = 0.0f;
        request.arg1.c.h = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_150(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_150(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_150(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_150(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructArgumentArg1cbIsFalse_151()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;

        request.arg1.c.a = 0;
        request.arg1.c.b = false;
        request.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.c.g = 0.0f;
        request.arg1.c.h = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_151(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_151(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_151(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_151(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndAllFieldsBOfArg1dAreTrue_152()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;

        request.arg1.c.a = 0;
        request.arg1.c.b = true;
        request.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.c.g = 0.0f;
        request.arg1.c.h = 0;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type dList[2];

        dList[0].a = 1;
        dList[0].b = true;
        dList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        dList[0].d = chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
        dList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
        dList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        dList[0].g = 0.0f;
        dList[0].h = 0;

        dList[1].a = 2;
        dList[1].b = true;
        dList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        dList[1].d = chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
        dList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
        dList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        dList[1].g = 0.0f;
        dList[1].h = 0;

        request.arg1.d = dList;

        uint32_t eList[3];
        eList[0]       = 1UL;
        eList[1]       = 2UL;
        eList[2]       = 3UL;
        request.arg1.e = eList;

        chip::ByteSpan fList[3];
        fList[0]       = chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
        fList[1]       = chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
        fList[2]       = chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
        request.arg1.f = fList;

        uint8_t gList[2];
        gList[0]       = 0;
        gList[1]       = 255;
        request.arg1.g = gList;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_152(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_152(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_152(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_152(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfArg1dAreFalse_153()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;

        request.arg1.c.a = 0;
        request.arg1.c.b = true;
        request.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.c.g = 0.0f;
        request.arg1.c.h = 0;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type dList[2];

        dList[0].a = 1;
        dList[0].b = true;
        dList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        dList[0].d = chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
        dList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
        dList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        dList[0].g = 0.0f;
        dList[0].h = 0;

        dList[1].a = 2;
        dList[1].b = false;
        dList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        dList[1].d = chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
        dList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
        dList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        dList[1].g = 0.0f;
        dList[1].h = 0;

        request.arg1.d = dList;

        uint32_t eList[3];
        eList[0]       = 1UL;
        eList[1]       = 2UL;
        eList[2]       = 3UL;
        request.arg1.e = eList;

        chip::ByteSpan fList[3];
        fList[0]       = chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
        fList[1]       = chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
        fList[2]       = chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
        request.arg1.f = fList;

        uint8_t gList[2];
        gList[0]       = 0;
        gList[1]       = 255;
        request.arg1.g = gList;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_153(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_153(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_153(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_153(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndSeeWhatWeGetBack_154()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::SimpleStructEchoRequest::Type;

        RequestType request;

        request.arg1.a = 17;
        request.arg1.b = false;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        request.arg1.g = 0.1f;
        request.arg1.h = 0.1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_154(data.arg1);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_154(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_154(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_154(const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType & arg1)
    {
        VerifyOrReturn(CheckValue("arg1.a", arg1.a, 17));
        VerifyOrReturn(CheckValue("arg1.b", arg1.b, false));
        VerifyOrReturn(CheckValue("arg1.c", arg1.c, 2));
        VerifyOrReturn(CheckValueAsString("arg1.d", arg1.d, chip::ByteSpan(chip::Uint8::from_const_char("octet_string"), 12)));
        VerifyOrReturn(CheckValueAsString("arg1.e", arg1.e, chip::CharSpan("char_string", 11)));
        VerifyOrReturn(CheckValue("arg1.f", arg1.f, 1));
        VerifyOrReturn(CheckValue("arg1.g", arg1.g, 0.1f));
        VerifyOrReturn(CheckValue("arg1.h", arg1.h, 0.1));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_155()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;

        RequestType request;

        uint8_t arg1List[9];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_155(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_155(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_155(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_155(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_156()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;

        RequestType request;

        uint8_t arg1List[10];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        arg1List[9]  = 0;
        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_156(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_156(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_156(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_156(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndGetItReversed_157()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;

        RequestType request;

        uint8_t arg1List[9];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_157(data.arg1);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_157(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_157(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_157(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        auto iter = arg1.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 0));
        VerifyOrReturn(CheckValue("arg1[0]", iter.GetValue(), 9));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 1));
        VerifyOrReturn(CheckValue("arg1[1]", iter.GetValue(), 8));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 2));
        VerifyOrReturn(CheckValue("arg1[2]", iter.GetValue(), 7));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 3));
        VerifyOrReturn(CheckValue("arg1[3]", iter.GetValue(), 6));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 4));
        VerifyOrReturn(CheckValue("arg1[4]", iter.GetValue(), 5));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 5));
        VerifyOrReturn(CheckValue("arg1[5]", iter.GetValue(), 4));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 6));
        VerifyOrReturn(CheckValue("arg1[6]", iter.GetValue(), 3));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 7));
        VerifyOrReturn(CheckValue("arg1[7]", iter.GetValue(), 2));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 8));
        VerifyOrReturn(CheckValue("arg1[8]", iter.GetValue(), 1));
        VerifyOrReturn(CheckNoMoreListItems<decltype(arg1)>("arg1", iter, 9));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_158()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;

        RequestType request;

        request.arg1 = chip::app::DataModel::List<uint8_t>();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_158(data.arg1);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_158(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_158(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_158(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        auto iter = arg1.begin();
        VerifyOrReturn(CheckNoMoreListItems<decltype(arg1)>("arg1", iter, 0));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_159()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;

        RequestType request;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type arg1List[2];

        arg1List[0].a = 0;
        arg1List[0].b = true;
        arg1List[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[0].d = chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
        arg1List[0].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
        arg1List[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        arg1List[0].g = 0.0f;
        arg1List[0].h = 0;

        arg1List[1].a = 1;
        arg1List[1].b = true;
        arg1List[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        arg1List[1].d = chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
        arg1List[1].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
        arg1List[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        arg1List[1].g = 0.0f;
        arg1List[1].h = 0;

        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_159(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_159(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_159(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_159(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_160()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;

        RequestType request;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type arg1List[2];

        arg1List[0].a = 1;
        arg1List[0].b = true;
        arg1List[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        arg1List[0].d = chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
        arg1List[0].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
        arg1List[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        arg1List[0].g = 0.0f;
        arg1List[0].h = 0;

        arg1List[1].a = 0;
        arg1List[1].b = false;
        arg1List[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[1].d = chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
        arg1List[1].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
        arg1List[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        arg1List[1].g = 0.0f;
        arg1List[1].h = 0;

        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_160(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_160(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_160(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_160(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfNestedStructListArgumentAndAllFieldsBOfElementsOfArg1dAreTrue_161()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type;

        RequestType request;

        chip::app::Clusters::TestCluster::Structs::NestedStructList::Type arg1List[1];

        arg1List[0].a = 0;
        arg1List[0].b = true;

        arg1List[0].c.a = 0;
        arg1List[0].c.b = true;
        arg1List[0].c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[0].c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        arg1List[0].c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        arg1List[0].c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        arg1List[0].c.g = 0.0f;
        arg1List[0].c.h = 0;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type dList[2];

        dList[0].a = 1;
        dList[0].b = true;
        dList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        dList[0].d = chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
        dList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
        dList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        dList[0].g = 0.0f;
        dList[0].h = 0;

        dList[1].a = 2;
        dList[1].b = true;
        dList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        dList[1].d = chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
        dList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
        dList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        dList[1].g = 0.0f;
        dList[1].h = 0;

        arg1List[0].d = dList;

        uint32_t eList[3];
        eList[0]      = 1UL;
        eList[1]      = 2UL;
        eList[2]      = 3UL;
        arg1List[0].e = eList;

        chip::ByteSpan fList[3];
        fList[0]      = chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
        fList[1]      = chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
        fList[2]      = chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
        arg1List[0].f = fList;

        uint8_t gList[2];
        gList[0]      = 0;
        gList[1]      = 255;
        arg1List[0].g = gList;

        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_161(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_161(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_161(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_161(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, true));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithNestedStructListArgumentAndSomeFieldsBOfElementsOfArg1dAreFalse_162()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type;

        RequestType request;

        chip::app::Clusters::TestCluster::Structs::NestedStructList::Type arg1List[1];

        arg1List[0].a = 0;
        arg1List[0].b = true;

        arg1List[0].c.a = 0;
        arg1List[0].c.b = true;
        arg1List[0].c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[0].c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        arg1List[0].c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        arg1List[0].c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        arg1List[0].c.g = 0.0f;
        arg1List[0].c.h = 0;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type dList[2];

        dList[0].a = 1;
        dList[0].b = true;
        dList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        dList[0].d = chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
        dList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
        dList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        dList[0].g = 0.0f;
        dList[0].h = 0;

        dList[1].a = 2;
        dList[1].b = false;
        dList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        dList[1].d = chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
        dList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
        dList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
        dList[1].g = 0.0f;
        dList[1].h = 0;

        arg1List[0].d = dList;

        uint32_t eList[3];
        eList[0]      = 1UL;
        eList[1]      = 2UL;
        eList[2]      = 3UL;
        arg1List[0].e = eList;

        chip::ByteSpan fList[3];
        fList[0]      = chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
        fList[1]      = chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
        fList[2]      = chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
        arg1List[0].f = fList;

        uint8_t gList[2];
        gList[0]      = 0;
        gList[1]      = 255;
        arg1List[0].g = gList;

        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_162(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_162(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_162(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_162(bool value)
    {
        VerifyOrReturn(CheckValue("value", value, false));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfInt8uAndNoneOfThemIsSetTo0_163()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::List<const uint8_t> listInt8uArgument;

        uint8_t listInt8uList[4];
        listInt8uList[0]  = 1;
        listInt8uList[1]  = 2;
        listInt8uList[2]  = 3;
        listInt8uList[3]  = 4;
        listInt8uArgument = listInt8uList;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(
            listInt8uArgument, this, OnSuccessCallback_163, OnFailureCallback_163);
    }

    void OnFailureResponse_163(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_163() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfInt8u_164()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(this, OnSuccessCallback_164,
                                                                                                        OnFailureCallback_164);
    }

    void OnFailureResponse_164(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_164(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        auto iter = listInt8u.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 0));
        VerifyOrReturn(CheckValue("listInt8u[0]", iter.GetValue(), 1));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 1));
        VerifyOrReturn(CheckValue("listInt8u[1]", iter.GetValue(), 2));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 2));
        VerifyOrReturn(CheckValue("listInt8u[2]", iter.GetValue(), 3));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 3));
        VerifyOrReturn(CheckValue("listInt8u[3]", iter.GetValue(), 4));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listInt8u)>("listInt8u", iter, 4));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfOctetString_165()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::List<const chip::ByteSpan> listOctetStringArgument;

        chip::ByteSpan listOctetStringList[4];
        listOctetStringList[0]  = chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);
        listOctetStringList[1]  = chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);
        listOctetStringList[2]  = chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);
        listOctetStringList[3]  = chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);
        listOctetStringArgument = listOctetStringList;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListOctetString::TypeInfo>(
            listOctetStringArgument, this, OnSuccessCallback_165, OnFailureCallback_165);
    }

    void OnFailureResponse_165(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_165() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfOctetString_166()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListOctetString::TypeInfo>(
            this, OnSuccessCallback_166, OnFailureCallback_166);
    }

    void OnFailureResponse_166(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_166(const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        auto iter = listOctetString.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 0));
        VerifyOrReturn(
            CheckValueAsString("listOctetString[0]", iter.GetValue(), chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 1));
        VerifyOrReturn(
            CheckValueAsString("listOctetString[1]", iter.GetValue(), chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 2));
        VerifyOrReturn(
            CheckValueAsString("listOctetString[2]", iter.GetValue(), chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 3));
        VerifyOrReturn(
            CheckValueAsString("listOctetString[3]", iter.GetValue(), chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listOctetString)>("listOctetString", iter, 4));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfListStructOctetString_167()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>
            listStructOctetStringArgument;

        chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type listStructOctetStringList[4];

        listStructOctetStringList[0].fabricIndex = 0ULL;
        listStructOctetStringList[0].operationalCert =
            chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);

        listStructOctetStringList[1].fabricIndex = 1ULL;
        listStructOctetStringList[1].operationalCert =
            chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);

        listStructOctetStringList[2].fabricIndex = 2ULL;
        listStructOctetStringList[2].operationalCert =
            chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);

        listStructOctetStringList[3].fabricIndex = 3ULL;
        listStructOctetStringList[3].operationalCert =
            chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);

        listStructOctetStringArgument = listStructOctetStringList;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListStructOctetString::TypeInfo>(
            listStructOctetStringArgument, this, OnSuccessCallback_167, OnFailureCallback_167);
    }

    void OnFailureResponse_167(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_167() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfListStructOctetString_168()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListStructOctetString::TypeInfo>(
            this, OnSuccessCallback_168, OnFailureCallback_168);
    }

    void OnFailureResponse_168(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_168(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        auto iter = listStructOctetString.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 0));
        VerifyOrReturn(CheckValue("listStructOctetString[0].fabricIndex", iter.GetValue().fabricIndex, 0ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[0].operationalCert", iter.GetValue().operationalCert,
                                          chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 1));
        VerifyOrReturn(CheckValue("listStructOctetString[1].fabricIndex", iter.GetValue().fabricIndex, 1ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[1].operationalCert", iter.GetValue().operationalCert,
                                          chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 2));
        VerifyOrReturn(CheckValue("listStructOctetString[2].fabricIndex", iter.GetValue().fabricIndex, 2ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[2].operationalCert", iter.GetValue().operationalCert,
                                          chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 3));
        VerifyOrReturn(CheckValue("listStructOctetString[3].fabricIndex", iter.GetValue().fabricIndex, 3ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[3].operationalCert", iter.GetValue().operationalCert,
                                          chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listStructOctetString)>("listStructOctetString", iter, 4));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithOptionalArgSet_169()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;
        request.arg1.Emplace().SetNonNull() = 5;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))
                ->OnSuccessResponse_169(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_169(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_169(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_169(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                               const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue("wasPresent", wasPresent, true));

        VerifyOrReturn(CheckValuePresent("wasNull", wasNull));
        VerifyOrReturn(CheckValue("wasNull.Value()", wasNull.Value(), false));

        VerifyOrReturn(CheckValuePresent("value", value));
        VerifyOrReturn(CheckValue("value.Value()", value.Value(), 5));

        VerifyOrReturn(CheckValuePresent("originalValue", originalValue));
        VerifyOrReturn(CheckValueNonNull("originalValue.Value()", originalValue.Value()));
        VerifyOrReturn(CheckValue("originalValue.Value().Value()", originalValue.Value().Value(), 5));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithoutItsOptionalArg_170()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))
                ->OnSuccessResponse_170(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_170(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_170(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_170(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                               const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue("wasPresent", wasPresent, false));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBooleanNull_171()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<bool> nullableBooleanArgument;
        nullableBooleanArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            nullableBooleanArgument, this, OnSuccessCallback_171, OnFailureCallback_171);
    }

    void OnFailureResponse_171(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_171() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBooleanNull_172()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            this, OnSuccessCallback_172, OnFailureCallback_172);
    }

    void OnFailureResponse_172(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_172(const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        VerifyOrReturn(CheckValueNull("nullableBoolean", nullableBoolean));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBooleanTrue_173()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<bool> nullableBooleanArgument;
        nullableBooleanArgument.SetNonNull() = true;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            nullableBooleanArgument, this, OnSuccessCallback_173, OnFailureCallback_173);
    }

    void OnFailureResponse_173(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_173() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBooleanTrue_174()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            this, OnSuccessCallback_174, OnFailureCallback_174);
    }

    void OnFailureResponse_174(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_174(const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBoolean", nullableBoolean));
        VerifyOrReturn(CheckValue("nullableBoolean.Value()", nullableBoolean.Value(), true));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8MaxValue_175()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNonNull() = 254;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_175, OnFailureCallback_175);
    }

    void OnFailureResponse_175(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_175() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8MaxValue_176()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_176, OnFailureCallback_176);
    }

    void OnFailureResponse_176(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_176(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap8", nullableBitmap8));
        VerifyOrReturn(CheckValue("nullableBitmap8.Value()", nullableBitmap8.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8InvalidValue_177()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNonNull() = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_177, OnFailureCallback_177);
    }

    void OnFailureResponse_177(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_177() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8UnchangedValue_178()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_178, OnFailureCallback_178);
    }

    void OnFailureResponse_178(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_178(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap8", nullableBitmap8));
        VerifyOrReturn(CheckValue("nullableBitmap8.Value()", nullableBitmap8.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8NullValue_179()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_179, OnFailureCallback_179);
    }

    void OnFailureResponse_179(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_179() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8NullValue_180()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_180, OnFailureCallback_180);
    }

    void OnFailureResponse_180(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_180(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap8", nullableBitmap8));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16MaxValue_181()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNonNull() = 65534U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_181, OnFailureCallback_181);
    }

    void OnFailureResponse_181(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_181() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16MaxValue_182()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_182, OnFailureCallback_182);
    }

    void OnFailureResponse_182(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_182(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap16", nullableBitmap16));
        VerifyOrReturn(CheckValue("nullableBitmap16.Value()", nullableBitmap16.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16InvalidValue_183()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNonNull() = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_183, OnFailureCallback_183);
    }

    void OnFailureResponse_183(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_183() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16UnchangedValue_184()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_184, OnFailureCallback_184);
    }

    void OnFailureResponse_184(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_184(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap16", nullableBitmap16));
        VerifyOrReturn(CheckValue("nullableBitmap16.Value()", nullableBitmap16.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16NullValue_185()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_185, OnFailureCallback_185);
    }

    void OnFailureResponse_185(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_185() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16NullValue_186()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_186, OnFailureCallback_186);
    }

    void OnFailureResponse_186(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_186(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap16", nullableBitmap16));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32MaxValue_187()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNonNull() = 4294967294UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_187, OnFailureCallback_187);
    }

    void OnFailureResponse_187(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_187() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32MaxValue_188()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_188, OnFailureCallback_188);
    }

    void OnFailureResponse_188(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_188(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap32", nullableBitmap32));
        VerifyOrReturn(CheckValue("nullableBitmap32.Value()", nullableBitmap32.Value(), 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32InvalidValue_189()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNonNull() = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_189, OnFailureCallback_189);
    }

    void OnFailureResponse_189(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_189() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32UnchangedValue_190()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_190, OnFailureCallback_190);
    }

    void OnFailureResponse_190(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_190(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap32", nullableBitmap32));
        VerifyOrReturn(CheckValue("nullableBitmap32.Value()", nullableBitmap32.Value(), 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32NullValue_191()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_191, OnFailureCallback_191);
    }

    void OnFailureResponse_191(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_191() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32NullValue_192()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_192, OnFailureCallback_192);
    }

    void OnFailureResponse_192(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_192(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap32", nullableBitmap32));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64MaxValue_193()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNonNull() = 18446744073709551614ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_193, OnFailureCallback_193);
    }

    void OnFailureResponse_193(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_193() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64MaxValue_194()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_194, OnFailureCallback_194);
    }

    void OnFailureResponse_194(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_194(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap64", nullableBitmap64));
        VerifyOrReturn(CheckValue("nullableBitmap64.Value()", nullableBitmap64.Value(), 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64InvalidValue_195()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNonNull() = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_195, OnFailureCallback_195);
    }

    void OnFailureResponse_195(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_195() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64UnchangedValue_196()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_196, OnFailureCallback_196);
    }

    void OnFailureResponse_196(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_196(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap64", nullableBitmap64));
        VerifyOrReturn(CheckValue("nullableBitmap64.Value()", nullableBitmap64.Value(), 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64NullValue_197()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_197, OnFailureCallback_197);
    }

    void OnFailureResponse_197(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_197() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64NullValue_198()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_198, OnFailureCallback_198);
    }

    void OnFailureResponse_198(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_198(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap64", nullableBitmap64));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uMaxValue_199()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNonNull() = 254;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_199, OnFailureCallback_199);
    }

    void OnFailureResponse_199(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_199() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8uMaxValue_200()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_200, OnFailureCallback_200);
    }

    void OnFailureResponse_200(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_200(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8u", nullableInt8u));
        VerifyOrReturn(CheckValue("nullableInt8u.Value()", nullableInt8u.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uInvalidValue_201()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNonNull() = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_201, OnFailureCallback_201);
    }

    void OnFailureResponse_201(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_201() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt8uUnchangedValue_202()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_202, OnFailureCallback_202);
    }

    void OnFailureResponse_202(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_202(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8u", nullableInt8u));
        VerifyOrReturn(CheckValue("nullableInt8u.Value()", nullableInt8u.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uNullValue_203()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_203, OnFailureCallback_203);
    }

    void OnFailureResponse_203(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_203() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8uNullValue_204()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_204, OnFailureCallback_204);
    }

    void OnFailureResponse_204(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_204(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt8u", nullableInt8u));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uMaxValue_205()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNonNull() = 65534U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_205, OnFailureCallback_205);
    }

    void OnFailureResponse_205(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_205() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16uMaxValue_206()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_206, OnFailureCallback_206);
    }

    void OnFailureResponse_206(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_206(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16u", nullableInt16u));
        VerifyOrReturn(CheckValue("nullableInt16u.Value()", nullableInt16u.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uInvalidValue_207()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNonNull() = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_207, OnFailureCallback_207);
    }

    void OnFailureResponse_207(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_207() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt16uUnchangedValue_208()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_208, OnFailureCallback_208);
    }

    void OnFailureResponse_208(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_208(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16u", nullableInt16u));
        VerifyOrReturn(CheckValue("nullableInt16u.Value()", nullableInt16u.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uNullValue_209()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_209, OnFailureCallback_209);
    }

    void OnFailureResponse_209(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_209() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16uNullValue_210()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_210, OnFailureCallback_210);
    }

    void OnFailureResponse_210(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_210(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt16u", nullableInt16u));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uMaxValue_211()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNonNull() = 4294967294UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_211, OnFailureCallback_211);
    }

    void OnFailureResponse_211(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_211() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32uMaxValue_212()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_212, OnFailureCallback_212);
    }

    void OnFailureResponse_212(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_212(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32u", nullableInt32u));
        VerifyOrReturn(CheckValue("nullableInt32u.Value()", nullableInt32u.Value(), 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uInvalidValue_213()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNonNull() = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_213, OnFailureCallback_213);
    }

    void OnFailureResponse_213(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_213() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt32uUnchangedValue_214()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_214, OnFailureCallback_214);
    }

    void OnFailureResponse_214(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_214(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32u", nullableInt32u));
        VerifyOrReturn(CheckValue("nullableInt32u.Value()", nullableInt32u.Value(), 4294967294UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uNullValue_215()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_215, OnFailureCallback_215);
    }

    void OnFailureResponse_215(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_215() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32uNullValue_216()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_216, OnFailureCallback_216);
    }

    void OnFailureResponse_216(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_216(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt32u", nullableInt32u));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uMaxValue_217()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNonNull() = 18446744073709551614ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_217, OnFailureCallback_217);
    }

    void OnFailureResponse_217(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_217() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64uMaxValue_218()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_218, OnFailureCallback_218);
    }

    void OnFailureResponse_218(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_218(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64u", nullableInt64u));
        VerifyOrReturn(CheckValue("nullableInt64u.Value()", nullableInt64u.Value(), 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uInvalidValue_219()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNonNull() = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_219, OnFailureCallback_219);
    }

    void OnFailureResponse_219(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_219() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt64uUnchangedValue_220()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_220, OnFailureCallback_220);
    }

    void OnFailureResponse_220(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_220(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64u", nullableInt64u));
        VerifyOrReturn(CheckValue("nullableInt64u.Value()", nullableInt64u.Value(), 18446744073709551614ULL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uNullValue_221()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_221, OnFailureCallback_221);
    }

    void OnFailureResponse_221(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_221() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64uNullValue_222()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_222, OnFailureCallback_222);
    }

    void OnFailureResponse_222(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_222(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt64u", nullableInt64u));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sMinValue_223()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNonNull() = -127;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_223, OnFailureCallback_223);
    }

    void OnFailureResponse_223(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_223() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8sMinValue_224()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_224, OnFailureCallback_224);
    }

    void OnFailureResponse_224(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_224(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8s", nullableInt8s));
        VerifyOrReturn(CheckValue("nullableInt8s.Value()", nullableInt8s.Value(), -127));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sInvalidValue_225()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNonNull() = -128;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_225, OnFailureCallback_225);
    }

    void OnFailureResponse_225(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_225() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt8sUnchangedValue_226()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_226, OnFailureCallback_226);
    }

    void OnFailureResponse_226(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_226(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8s", nullableInt8s));
        VerifyOrReturn(CheckValue("nullableInt8s.Value()", nullableInt8s.Value(), -127));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sNullValue_227()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_227, OnFailureCallback_227);
    }

    void OnFailureResponse_227(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_227() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8sNullValue_228()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_228, OnFailureCallback_228);
    }

    void OnFailureResponse_228(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_228(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt8s", nullableInt8s));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sMinValue_229()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNonNull() = -32767;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_229, OnFailureCallback_229);
    }

    void OnFailureResponse_229(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_229() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16sMinValue_230()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_230, OnFailureCallback_230);
    }

    void OnFailureResponse_230(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_230(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16s", nullableInt16s));
        VerifyOrReturn(CheckValue("nullableInt16s.Value()", nullableInt16s.Value(), -32767));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sInvalidValue_231()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNonNull() = -32768;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_231, OnFailureCallback_231);
    }

    void OnFailureResponse_231(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_231() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt16sUnchangedValue_232()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_232, OnFailureCallback_232);
    }

    void OnFailureResponse_232(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_232(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16s", nullableInt16s));
        VerifyOrReturn(CheckValue("nullableInt16s.Value()", nullableInt16s.Value(), -32767));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sNullValue_233()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_233, OnFailureCallback_233);
    }

    void OnFailureResponse_233(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_233() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16sNullValue_234()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_234, OnFailureCallback_234);
    }

    void OnFailureResponse_234(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_234(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt16s", nullableInt16s));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sMinValue_235()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNonNull() = -2147483647L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_235, OnFailureCallback_235);
    }

    void OnFailureResponse_235(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_235() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32sMinValue_236()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_236, OnFailureCallback_236);
    }

    void OnFailureResponse_236(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_236(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32s", nullableInt32s));
        VerifyOrReturn(CheckValue("nullableInt32s.Value()", nullableInt32s.Value(), -2147483647L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sInvalidValue_237()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNonNull() = -2147483648L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_237, OnFailureCallback_237);
    }

    void OnFailureResponse_237(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_237() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt32sUnchangedValue_238()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_238, OnFailureCallback_238);
    }

    void OnFailureResponse_238(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_238(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32s", nullableInt32s));
        VerifyOrReturn(CheckValue("nullableInt32s.Value()", nullableInt32s.Value(), -2147483647L));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sNullValue_239()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_239, OnFailureCallback_239);
    }

    void OnFailureResponse_239(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_239() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32sNullValue_240()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_240, OnFailureCallback_240);
    }

    void OnFailureResponse_240(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_240(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt32s", nullableInt32s));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sMinValue_241()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNonNull() = -9223372036854775807LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_241, OnFailureCallback_241);
    }

    void OnFailureResponse_241(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_241() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64sMinValue_242()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_242, OnFailureCallback_242);
    }

    void OnFailureResponse_242(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_242(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64s", nullableInt64s));
        VerifyOrReturn(CheckValue("nullableInt64s.Value()", nullableInt64s.Value(), -9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sInvalidValue_243()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNonNull() = -9223372036854775807LL - 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_243, OnFailureCallback_243);
    }

    void OnFailureResponse_243(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_243() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt64sUnchangedValue_244()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_244, OnFailureCallback_244);
    }

    void OnFailureResponse_244(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_244(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64s", nullableInt64s));
        VerifyOrReturn(CheckValue("nullableInt64s.Value()", nullableInt64s.Value(), -9223372036854775807LL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sNullValue_245()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_245, OnFailureCallback_245);
    }

    void OnFailureResponse_245(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_245() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64sNullValue_246()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_246, OnFailureCallback_246);
    }

    void OnFailureResponse_246(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_246(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt64s", nullableInt64s));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingleMediumValue_247()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNonNull() = 0.1f;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_247, OnFailureCallback_247);
    }

    void OnFailureResponse_247(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_247() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingleMediumValue_248()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_248, OnFailureCallback_248);
    }

    void OnFailureResponse_248(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_248(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", nullableFloatSingle));
        VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", nullableFloatSingle.Value(), 0.1f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingleLargestValue_249()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNonNull() = INFINITY;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_249, OnFailureCallback_249);
    }

    void OnFailureResponse_249(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_249() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingleLargestValue_250()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_250, OnFailureCallback_250);
    }

    void OnFailureResponse_250(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_250(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", nullableFloatSingle));
        VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", nullableFloatSingle.Value(), INFINITY));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingleSmallestValue_251()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNonNull() = -INFINITY;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_251, OnFailureCallback_251);
    }

    void OnFailureResponse_251(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_251() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingleSmallestValue_252()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_252, OnFailureCallback_252);
    }

    void OnFailureResponse_252(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_252(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", nullableFloatSingle));
        VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", nullableFloatSingle.Value(), -INFINITY));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingleNullValue_253()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_253, OnFailureCallback_253);
    }

    void OnFailureResponse_253(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_253() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingleNullValue_254()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_254, OnFailureCallback_254);
    }

    void OnFailureResponse_254(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_254(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNull("nullableFloatSingle", nullableFloatSingle));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableSingle0Value_255()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<float> nullableFloatSingleArgument;
        nullableFloatSingleArgument.SetNonNull() = 0.0f;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            nullableFloatSingleArgument, this, OnSuccessCallback_255, OnFailureCallback_255);
    }

    void OnFailureResponse_255(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_255() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableSingle0Value_256()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatSingle::TypeInfo>(
            this, OnSuccessCallback_256, OnFailureCallback_256);
    }

    void OnFailureResponse_256(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_256(const chip::app::DataModel::Nullable<float> & nullableFloatSingle)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", nullableFloatSingle));
        VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", nullableFloatSingle.Value(), 0.0f));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleMediumValue_257()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNonNull() = 0.1234567890123;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_257, OnFailureCallback_257);
    }

    void OnFailureResponse_257(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_257() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDoubleMediumValue_258()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_258, OnFailureCallback_258);
    }

    void OnFailureResponse_258(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_258(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", nullableFloatDouble));
        VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", nullableFloatDouble.Value(), 0.1234567890123));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleLargestValue_259()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNonNull() = INFINITY;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_259, OnFailureCallback_259);
    }

    void OnFailureResponse_259(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_259() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDoubleLargestValue_260()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_260, OnFailureCallback_260);
    }

    void OnFailureResponse_260(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_260(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", nullableFloatDouble));
        VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", nullableFloatDouble.Value(), INFINITY));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleSmallestValue_261()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNonNull() = -INFINITY;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_261, OnFailureCallback_261);
    }

    void OnFailureResponse_261(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_261() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDoubleSmallestValue_262()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_262, OnFailureCallback_262);
    }

    void OnFailureResponse_262(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_262(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", nullableFloatDouble));
        VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", nullableFloatDouble.Value(), -INFINITY));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDoubleNullValue_263()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_263, OnFailureCallback_263);
    }

    void OnFailureResponse_263(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_263() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDoubleNullValue_264()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_264, OnFailureCallback_264);
    }

    void OnFailureResponse_264(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_264(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNull("nullableFloatDouble", nullableFloatDouble));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableDouble0Value_265()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<double> nullableFloatDoubleArgument;
        nullableFloatDoubleArgument.SetNonNull() = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            nullableFloatDoubleArgument, this, OnSuccessCallback_265, OnFailureCallback_265);
    }

    void OnFailureResponse_265(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_265() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableDouble0Value_266()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableFloatDouble::TypeInfo>(
            this, OnSuccessCallback_266, OnFailureCallback_266);
    }

    void OnFailureResponse_266(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_266(const chip::app::DataModel::Nullable<double> & nullableFloatDouble)
    {
        VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", nullableFloatDouble));
        VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", nullableFloatDouble.Value(), 0));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8MaxValue_267()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNonNull() = static_cast<uint8_t>(254);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_267, OnFailureCallback_267);
    }

    void OnFailureResponse_267(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_267() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum8MaxValue_268()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_268, OnFailureCallback_268);
    }

    void OnFailureResponse_268(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_268(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum8", nullableEnum8));
        VerifyOrReturn(CheckValue("nullableEnum8.Value()", nullableEnum8.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8InvalidValue_269()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNonNull() = static_cast<uint8_t>(255);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_269, OnFailureCallback_269);
    }

    void OnFailureResponse_269(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_269() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableEnum8UnchangedValue_270()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_270, OnFailureCallback_270);
    }

    void OnFailureResponse_270(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_270(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum8", nullableEnum8));
        VerifyOrReturn(CheckValue("nullableEnum8.Value()", nullableEnum8.Value(), 254));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8NullValue_271()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_271, OnFailureCallback_271);
    }

    void OnFailureResponse_271(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_271() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum8NullValue_272()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_272, OnFailureCallback_272);
    }

    void OnFailureResponse_272(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_272(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNull("nullableEnum8", nullableEnum8));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16MaxValue_273()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNonNull() = static_cast<uint16_t>(65534);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_273, OnFailureCallback_273);
    }

    void OnFailureResponse_273(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_273() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum16MaxValue_274()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_274, OnFailureCallback_274);
    }

    void OnFailureResponse_274(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_274(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum16", nullableEnum16));
        VerifyOrReturn(CheckValue("nullableEnum16.Value()", nullableEnum16.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16InvalidValue_275()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNonNull() = static_cast<uint16_t>(65535);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_275, OnFailureCallback_275);
    }

    void OnFailureResponse_275(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_275() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableEnum16UnchangedValue_276()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_276, OnFailureCallback_276);
    }

    void OnFailureResponse_276(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_276(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum16", nullableEnum16));
        VerifyOrReturn(CheckValue("nullableEnum16.Value()", nullableEnum16.Value(), 65534U));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16NullValue_277()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_277, OnFailureCallback_277);
    }

    void OnFailureResponse_277(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_277() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum16NullValue_278()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_278, OnFailureCallback_278);
    }

    void OnFailureResponse_278(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_278(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNull("nullableEnum16", nullableEnum16));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableOctetStringDefaultValue_279()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_279, OnFailureCallback_279);
    }

    void OnFailureResponse_279(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_279(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_280()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNonNull() =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_280, OnFailureCallback_280);
    }

    void OnFailureResponse_280(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_280() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_281()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_281, OnFailureCallback_281);
    }

    void OnFailureResponse_281(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_281(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_282()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_282, OnFailureCallback_282);
    }

    void OnFailureResponse_282(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_282() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_283()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_283, OnFailureCallback_283);
    }

    void OnFailureResponse_283(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_283(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNull("nullableOctetString", nullableOctetString));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_284()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNonNull() =
            chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_284, OnFailureCallback_284);
    }

    void OnFailureResponse_284(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_284() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_285()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_285, OnFailureCallback_285);
    }

    void OnFailureResponse_285(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_285(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableCharStringDefaultValue_286()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_286, OnFailureCallback_286);
    }

    void OnFailureResponse_286(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_286(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableCharString", nullableCharString));
        VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", nullableCharString.Value(), chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableCharString_287()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNonNull() = chip::Span<const char>("Tgarbage: not in length on purpose", 7);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_287, OnFailureCallback_287);
    }

    void OnFailureResponse_287(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_287() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableCharString_288()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_288, OnFailureCallback_288);
    }

    void OnFailureResponse_288(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_288(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableCharString", nullableCharString));
        VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", nullableCharString.Value(), chip::CharSpan("T", 7)));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableCharStringValueTooLong_289()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_289, OnFailureCallback_289);
    }

    void OnFailureResponse_289(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_289() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableCharString_290()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_290, OnFailureCallback_290);
    }

    void OnFailureResponse_290(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_290(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNull("nullableCharString", nullableCharString));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableCharStringEmpty_291()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNonNull() = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_291, OnFailureCallback_291);
    }

    void OnFailureResponse_291(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_291() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableCharString_292()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_292, OnFailureCallback_292);
    }

    void OnFailureResponse_292(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_292(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableCharString", nullableCharString));
        VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", nullableCharString.Value(), chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeFromNonexistentEndpoint_293()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 200;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(this, OnSuccessCallback_293,
                                                                                                        OnFailureCallback_293);
    }

    void OnFailureResponse_293(uint8_t status)
    {
        VerifyOrReturn(CheckConstraintNotValue("status", status, 0));
        NextTest();
    }

    void OnSuccessResponse_293(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeFromNonexistentCluster_294()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(this, OnSuccessCallback_294,
                                                                                                        OnFailureCallback_294);
    }

    void OnFailureResponse_294(uint8_t status)
    {
        VerifyOrReturn(CheckConstraintNotValue("status", status, 0));
        NextTest();
    }

    void OnSuccessResponse_294(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u) { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_295()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_295();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_295(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_295(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_INVALID_VALUE));
        NextTest();
    }

    void OnSuccessResponse_295() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendACommandThatTakesAnOptionalParameterButDoNotSetIt_296()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type;

        RequestType request;
        request.arg1.Emplace() = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_296();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_296(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_296(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_296() { NextTest(); }
};

class TestClusterComplexTypes : public TestCommand
{
public:
    TestClusterComplexTypes() : TestCommand("TestClusterComplexTypes"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestClusterComplexTypes\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestClusterComplexTypes\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command with optional arg set to null.\n");
            err = TestSendTestCommandWithOptionalArgSetToNull_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send command that needs timed invoke without a timeout value\n");
            err = TestSendCommandThatNeedsTimedInvokeWithoutATimeoutValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send command that needs timed invoke with a long timeout value\n");
            err = TestSendCommandThatNeedsTimedInvokeWithALongTimeoutValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send command that needs timed invoke with a too-short timeout value\n");
            err = TestSendCommandThatNeedsTimedInvokeWithATooShortTimeoutValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Send command that does not need timed invoke with a long timeout value\n");
            err = TestSendCommandThatDoesNotNeedTimedInvokeWithALongTimeoutValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Send command that does not need timed invoke with a too-short timeout value\n");
            err = TestSendCommandThatDoesNotNeedTimedInvokeWithATooShortTimeoutValue_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendTestCommandWithOptionalArgSetToNull_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;
        request.arg1.Emplace().SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))
                ->OnSuccessResponse_1(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                             const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue("wasPresent", wasPresent, true));

        VerifyOrReturn(CheckValuePresent("wasNull", wasNull));
        VerifyOrReturn(CheckValue("wasNull.Value()", wasNull.Value(), true));

        VerifyOrReturn(CheckValuePresent("originalValue", originalValue));
        VerifyOrReturn(CheckValueNull("originalValue.Value()", originalValue.Value()));

        NextTest();
    }

    CHIP_ERROR TestSendCommandThatNeedsTimedInvokeWithoutATimeoutValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request,
                                                             chip::NullOptional));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_NEEDS_TIMED_INTERACTION));
        NextTest();
    }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendCommandThatNeedsTimedInvokeWithALongTimeoutValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestSendCommandThatNeedsTimedInvokeWithATooShortTimeoutValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 1));
        {
            using namespace chip::System::Clock::Literals;
            // Busy-wait for 100 milliseconds.
            auto & clock = chip::System::SystemClock();
            auto start   = clock.GetMonotonicTimestamp();
            while (clock.GetMonotonicTimestamp() - start < 100_ms)
                ;
        }
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
        NextTest();
    }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendCommandThatDoesNotNeedTimedInvokeWithALongTimeoutValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 10000));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestSendCommandThatDoesNotNeedTimedInvokeWithATooShortTimeoutValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(
            chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request, 1));
        {
            using namespace chip::System::Clock::Literals;
            // Busy-wait for 100 milliseconds.
            auto & clock = chip::System::SystemClock();
            auto start   = clock.GetMonotonicTimestamp();
            while (clock.GetMonotonicTimestamp() - start < 100_ms)
                ;
        }
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
        NextTest();
    }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }
};

class TestConstraints : public TestCommand
{
public:
    TestConstraints() : TestCommand("TestConstraints"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestConstraints\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestConstraints\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write attribute INT32U Value\n");
            err = TestWriteAttributeInt32uValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute INT32U Value MinValue Constraints\n");
            err = TestReadAttributeInt32uValueMinValueConstraints_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute INT32U Value MaxValue Constraints\n");
            err = TestReadAttributeInt32uValueMaxValueConstraints_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute INT32U Value NotValue Constraints\n");
            err = TestReadAttributeInt32uValueNotValueConstraints_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute INT32U Value Back to Default Value\n");
            err = TestWriteAttributeInt32uValueBackToDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write attribute CHAR_STRING Value\n");
            err = TestWriteAttributeCharStringValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute CHAR_STRING Value MinLength Constraints\n");
            err = TestReadAttributeCharStringValueMinLengthConstraints_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute CHAR_STRING Value MaxLength Constraints\n");
            err = TestReadAttributeCharStringValueMaxLengthConstraints_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute CHAR_STRING Value StartsWith Constraints\n");
            err = TestReadAttributeCharStringValueStartsWithConstraints_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute CHAR_STRING Value EndsWith Constraints\n");
            err = TestReadAttributeCharStringValueEndsWithConstraints_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write attribute CHAR_STRING Value Back to Default Value\n");
            err = TestWriteAttributeCharStringValueBackToDefaultValue_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<TestConstraints *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_2(int32u);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_3(int32u);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_4(int32u);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<TestConstraints *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<TestConstraints *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_7(charString);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_8(charString);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_9(charString);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, chip::CharSpan charString)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_10(charString);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<TestConstraints *>(context))->OnSuccessResponse_11(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestWriteAttributeInt32uValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 5UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uValueMinValueConstraints_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                     OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint32_t>("int32u", int32u, 5));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueMaxValueConstraints_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                     OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("int32u", int32u, 5));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueNotValueConstraints_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                     OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int32u", int32u, 6UL));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uValueBackToDefaultValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWriteAttributeCharStringValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("** Test **garbage: not in length on purpose", 10);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringValueMinLengthConstraints_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(this, OnSuccessCallback_7,
                                                                                                         OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintMinLength("charString", charString.size(), 5));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringValueMaxLengthConstraints_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(this, OnSuccessCallback_8,
                                                                                                         OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintMaxLength("charString", charString.size(), 20));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringValueStartsWithConstraints_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(this, OnSuccessCallback_9,
                                                                                                         OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintStartsWith("charString", charString, "**"));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCharStringValueEndsWithConstraints_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(this, OnSuccessCallback_10,
                                                                                                         OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckConstraintEndsWith("charString", charString, "**"));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharStringValueBackToDefaultValue_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }
};

class TestDelayCommands : public TestCommand
{
public:
    TestDelayCommands() : TestCommand("TestDelayCommands"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDelayCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDelayCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait 100ms\n");
            err = TestWait100ms_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestWait100ms_1()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForMs(100);
    }
};

class TestLogCommands : public TestCommand
{
public:
    TestLogCommands() : TestCommand("TestLogCommands"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestLogCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestLogCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Log a simple message\n");
            err = TestLogASimpleMessage_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Do a simple user prompt message\n");
            err = TestDoASimpleUserPromptMessage_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestLogASimpleMessage_1()
    {
        SetIdentity(kIdentityAlpha);
        return Log("This is a simple message");
    }

    CHIP_ERROR TestDoASimpleUserPromptMessage_2()
    {
        SetIdentity(kIdentityAlpha);
        return UserPrompt("This is a simple message");
    }
};

class TestSaveAs : public TestCommand
{
public:
    TestSaveAs() : TestCommand("TestSaveAs"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSaveAs\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSaveAs\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute BOOLEAN Not Default Value\n");
            err = TestWriteAttributeBooleanNotDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute BOOLEAN Not Default Value\n");
            err = TestReadAttributeBooleanNotDefaultValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute BOOLEAN DefaultValue\n");
            err = TestWriteAttributeBooleanDefaultValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write attribute BITMAP8 Not Default Value\n");
            err = TestWriteAttributeBitmap8NotDefaultValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read attribute BITMAP8 Not Default Value\n");
            err = TestReadAttributeBitmap8NotDefaultValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Write attribute BITMAP8 Default Value\n");
            err = TestWriteAttributeBitmap8DefaultValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write attribute BITMAP16 Not Default Value\n");
            err = TestWriteAttributeBitmap16NotDefaultValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute BITMAP16 Not Default Value\n");
            err = TestReadAttributeBitmap16NotDefaultValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute BITMAP16 Default Value\n");
            err = TestWriteAttributeBitmap16DefaultValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Write attribute BITMAP32 Not Default Value\n");
            err = TestWriteAttributeBitmap32NotDefaultValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Read attribute BITMAP32 Not Default Value\n");
            err = TestReadAttributeBitmap32NotDefaultValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Write attribute BITMAP32 Default Value\n");
            err = TestWriteAttributeBitmap32DefaultValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Write attribute BITMAP64 Not Default Value\n");
            err = TestWriteAttributeBitmap64NotDefaultValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute BITMAP64 Default Value\n");
            err = TestWriteAttributeBitmap64DefaultValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Write attribute INT8U Not Default Value\n");
            err = TestWriteAttributeInt8uNotDefaultValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read attribute INT8U Not Default Value\n");
            err = TestReadAttributeInt8uNotDefaultValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Write attribute INT8U Default Value\n");
            err = TestWriteAttributeInt8uDefaultValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Write attribute INT16U Not Default Value\n");
            err = TestWriteAttributeInt16uNotDefaultValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute INT16U Not Default Value\n");
            err = TestReadAttributeInt16uNotDefaultValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute INT16U Default Value\n");
            err = TestWriteAttributeInt16uDefaultValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Write attribute INT32U Not Default Value\n");
            err = TestWriteAttributeInt32uNotDefaultValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Read attribute INT32U Not Default Value\n");
            err = TestReadAttributeInt32uNotDefaultValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Write attribute INT32U Default Value\n");
            err = TestWriteAttributeInt32uDefaultValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Write attribute INT64U Not Default Value\n");
            err = TestWriteAttributeInt64uNotDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute INT64U Not Default Value\n");
            err = TestReadAttributeInt64uNotDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute INT64U Default Value\n");
            err = TestWriteAttributeInt64uDefaultValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Write attribute INT8S Not Default Value\n");
            err = TestWriteAttributeInt8sNotDefaultValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read attribute INT8S Not Default Value\n");
            err = TestReadAttributeInt8sNotDefaultValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Write attribute INT16S Not Default Value\n");
            err = TestWriteAttributeInt16sNotDefaultValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read attribute INT16S Not Default Value\n");
            err = TestReadAttributeInt16sNotDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Write attribute INT32S Not Default Value\n");
            err = TestWriteAttributeInt32sNotDefaultValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Read attribute INT32S Not Default Value\n");
            err = TestReadAttributeInt32sNotDefaultValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write attribute INTS Not Default Value\n");
            err = TestWriteAttributeIntsNotDefaultValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read attribute INT64S Not Default Value\n");
            err = TestReadAttributeInt64sNotDefaultValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write attribute ENUM8 Not Default Value\n");
            err = TestWriteAttributeEnum8NotDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute ENUM8 Not Default Value\n");
            err = TestReadAttributeEnum8NotDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Write attribute ENUM8 Default Value\n");
            err = TestWriteAttributeEnum8DefaultValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute ENUM16 Not Default Value\n");
            err = TestWriteAttributeEnum16NotDefaultValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute ENUM16 Not Default Value\n");
            err = TestReadAttributeEnum16NotDefaultValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute ENUM16 Default Value\n");
            err = TestWriteAttributeEnum16DefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write attribute EPOCH_US Not Default Value\n");
            err = TestWriteAttributeEpochUsNotDefaultValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read attribute EPOCH_US Not Default Value\n");
            err = TestReadAttributeEpochUsNotDefaultValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Write attribute EPOCH_US Default Value\n");
            err = TestWriteAttributeEpochUsDefaultValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Write attribute EPOCH_S Not Default Value\n");
            err = TestWriteAttributeEpochSNotDefaultValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read attribute EPOCH_S Not Default Value\n");
            err = TestReadAttributeEpochSNotDefaultValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write attribute EPOCH_S Default Value\n");
            err = TestWriteAttributeEpochSDefaultValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Write attribute vendor_id Not Default Value\n");
            err = TestWriteAttributeVendorIdNotDefaultValue_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Read attribute vendor_id Not Default Value\n");
            err = TestReadAttributeVendorIdNotDefaultValue_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Write attribute vendor_id Default Value\n");
            err = TestWriteAttributeVendorIdDefaultValue_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_93();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 94;

    uint8_t TestAddArgumentDefaultValue;
    bool readAttributeBooleanDefaultValue;
    uint8_t readAttributeBitmap8DefaultValue;
    uint16_t readAttributeBitmap16DefaultValue;
    uint32_t readAttributeBitmap32DefaultValue;
    uint64_t readAttributeBitmap64DefaultValue;
    uint8_t readAttributeInt8uDefaultValue;
    uint16_t readAttributeInt16uDefaultValue;
    uint32_t readAttributeInt32uDefaultValue;
    uint64_t readAttributeInt64uDefaultValue;
    int8_t readAttributeInt8sDefaultValue;
    int16_t readAttributeInt16sDefaultValue;
    int32_t readAttributeInt32sDefaultValue;
    int64_t readAttributeInt64sDefaultValue;
    uint8_t readAttributeEnum8DefaultValue;
    uint16_t readAttributeEnum16DefaultValue;
    uint64_t readAttributeEpochUSDefaultValue;
    uint32_t readAttributeEpochSDefaultValue;
    chip::VendorId readAttributeVendorIdDefaultValue;

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool boolean)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_4(boolean);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool boolean)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_6(boolean);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, bool boolean)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_8(boolean);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t bitmap8)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_9(bitmap8);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t bitmap8)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_11(bitmap8);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t bitmap8)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_13(bitmap8);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint16_t bitmap16)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_14(bitmap16);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, uint16_t bitmap16)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_16(bitmap16);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, uint16_t bitmap16)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_18(bitmap16);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, uint32_t bitmap32)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_19(bitmap32);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, uint32_t bitmap32)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_21(bitmap32);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_22(); }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, uint32_t bitmap32)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_23(bitmap32);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context, uint64_t bitmap64)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_24(bitmap64);
    }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_25(); }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, uint64_t bitmap64)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_26(bitmap64);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_27(); }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, uint64_t bitmap64)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_28(bitmap64);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context, uint8_t int8u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_29(int8u);
    }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_30(); }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, uint8_t int8u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_31(int8u);
    }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context, uint8_t int8u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_33(int8u);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, uint16_t int16u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_34(int16u);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context, uint16_t int16u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_36(int16u);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, uint16_t int16u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_38(int16u);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, uint32_t int32u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_39(int32u);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_40(); }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context, uint32_t int32u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_41(int32u);
    }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context, uint32_t int32u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_43(int32u);
    }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context, uint64_t int64u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_44(int64u);
    }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_45(); }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context, uint64_t int64u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_46(int64u);
    }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context, uint64_t int64u)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_48(int64u);
    }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context, int8_t int8s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_49(int8s);
    }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_50(); }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context, int8_t int8s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_51(int8s);
    }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_52(); }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context, int8_t int8s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_53(int8s);
    }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context, int16_t int16s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_54(int16s);
    }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_55(); }

    static void OnFailureCallback_56(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_56(chip::to_underlying(status));
    }

    static void OnSuccessCallback_56(void * context, int16_t int16s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_56(int16s);
    }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_57(); }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context, int16_t int16s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_58(int16s);
    }

    static void OnFailureCallback_59(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_59(chip::to_underlying(status));
    }

    static void OnSuccessCallback_59(void * context, int32_t int32s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_59(int32s);
    }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_60(); }

    static void OnFailureCallback_61(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_61(chip::to_underlying(status));
    }

    static void OnSuccessCallback_61(void * context, int32_t int32s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_61(int32s);
    }

    static void OnFailureCallback_62(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_62(chip::to_underlying(status));
    }

    static void OnSuccessCallback_62(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_62(); }

    static void OnFailureCallback_63(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_63(chip::to_underlying(status));
    }

    static void OnSuccessCallback_63(void * context, int32_t int32s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_63(int32s);
    }

    static void OnFailureCallback_64(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_64(chip::to_underlying(status));
    }

    static void OnSuccessCallback_64(void * context, int64_t int64s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_64(int64s);
    }

    static void OnFailureCallback_65(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_65(chip::to_underlying(status));
    }

    static void OnSuccessCallback_65(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_65(); }

    static void OnFailureCallback_66(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_66(chip::to_underlying(status));
    }

    static void OnSuccessCallback_66(void * context, int64_t int64s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_66(int64s);
    }

    static void OnFailureCallback_67(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_67(chip::to_underlying(status));
    }

    static void OnSuccessCallback_67(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_67(); }

    static void OnFailureCallback_68(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_68(chip::to_underlying(status));
    }

    static void OnSuccessCallback_68(void * context, int64_t int64s)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_68(int64s);
    }

    static void OnFailureCallback_69(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_69(chip::to_underlying(status));
    }

    static void OnSuccessCallback_69(void * context, uint8_t enum8)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_69(enum8);
    }

    static void OnFailureCallback_70(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_70(chip::to_underlying(status));
    }

    static void OnSuccessCallback_70(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_70(); }

    static void OnFailureCallback_71(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_71(chip::to_underlying(status));
    }

    static void OnSuccessCallback_71(void * context, uint8_t enum8)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_71(enum8);
    }

    static void OnFailureCallback_72(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_72(chip::to_underlying(status));
    }

    static void OnSuccessCallback_72(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_72(); }

    static void OnFailureCallback_73(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_73(chip::to_underlying(status));
    }

    static void OnSuccessCallback_73(void * context, uint8_t enum8)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_73(enum8);
    }

    static void OnFailureCallback_74(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_74(chip::to_underlying(status));
    }

    static void OnSuccessCallback_74(void * context, uint16_t enum16)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_74(enum16);
    }

    static void OnFailureCallback_75(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_75(chip::to_underlying(status));
    }

    static void OnSuccessCallback_75(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_75(); }

    static void OnFailureCallback_76(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_76(chip::to_underlying(status));
    }

    static void OnSuccessCallback_76(void * context, uint16_t enum16)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_76(enum16);
    }

    static void OnFailureCallback_77(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_77(chip::to_underlying(status));
    }

    static void OnSuccessCallback_77(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_77(); }

    static void OnFailureCallback_78(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_78(chip::to_underlying(status));
    }

    static void OnSuccessCallback_78(void * context, uint16_t enum16)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_78(enum16);
    }

    static void OnFailureCallback_79(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_79(chip::to_underlying(status));
    }

    static void OnSuccessCallback_79(void * context, uint64_t epochUs)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_79(epochUs);
    }

    static void OnFailureCallback_80(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_80(chip::to_underlying(status));
    }

    static void OnSuccessCallback_80(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_80(); }

    static void OnFailureCallback_81(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_81(chip::to_underlying(status));
    }

    static void OnSuccessCallback_81(void * context, uint64_t epochUs)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_81(epochUs);
    }

    static void OnFailureCallback_82(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_82(chip::to_underlying(status));
    }

    static void OnSuccessCallback_82(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_82(); }

    static void OnFailureCallback_83(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_83(chip::to_underlying(status));
    }

    static void OnSuccessCallback_83(void * context, uint64_t epochUs)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_83(epochUs);
    }

    static void OnFailureCallback_84(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_84(chip::to_underlying(status));
    }

    static void OnSuccessCallback_84(void * context, uint32_t epochS)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_84(epochS);
    }

    static void OnFailureCallback_85(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_85(chip::to_underlying(status));
    }

    static void OnSuccessCallback_85(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_85(); }

    static void OnFailureCallback_86(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_86(chip::to_underlying(status));
    }

    static void OnSuccessCallback_86(void * context, uint32_t epochS)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_86(epochS);
    }

    static void OnFailureCallback_87(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_87(chip::to_underlying(status));
    }

    static void OnSuccessCallback_87(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_87(); }

    static void OnFailureCallback_88(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_88(chip::to_underlying(status));
    }

    static void OnSuccessCallback_88(void * context, uint32_t epochS)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_88(epochS);
    }

    static void OnFailureCallback_89(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_89(chip::to_underlying(status));
    }

    static void OnSuccessCallback_89(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_89(vendorId);
    }

    static void OnFailureCallback_90(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_90(chip::to_underlying(status));
    }

    static void OnSuccessCallback_90(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_90(); }

    static void OnFailureCallback_91(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_91(chip::to_underlying(status));
    }

    static void OnSuccessCallback_91(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_91(vendorId);
    }

    static void OnFailureCallback_92(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_92(chip::to_underlying(status));
    }

    static void OnSuccessCallback_92(void * context) { (static_cast<TestSaveAs *>(context))->OnSuccessResponse_92(); }

    static void OnFailureCallback_93(void * context, EmberAfStatus status)
    {
        (static_cast<TestSaveAs *>(context))->OnFailureResponse_93(chip::to_underlying(status));
    }

    static void OnSuccessCallback_93(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestSaveAs *>(context))->OnSuccessResponse_93(vendorId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSaveAs *>(context))->OnSuccessResponse_1(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSaveAs *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, 20));

        TestAddArgumentDefaultValue = returnValue;
        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSaveAs *>(context))->OnSuccessResponse_2(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSaveAs *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue("returnValue", returnValue, TestAddArgumentDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = TestAddArgumentDefaultValue;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSaveAs *>(context))->OnSuccessResponse_3(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSaveAs *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t returnValue)
    {
        VerifyOrReturn(CheckConstraintNotValue("returnValue", returnValue, TestAddArgumentDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                      OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, 0));

        readAttributeBooleanDefaultValue = boolean;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanNotDefaultValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanNotDefaultValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_6,
                                                                                                      OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool boolean)
    {
        VerifyOrReturn(CheckConstraintNotValue("boolean", boolean, readAttributeBooleanDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanDefaultValue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        bool booleanArgument;
        booleanArgument = readAttributeBooleanDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanFalse_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_8,
                                                                                                      OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool boolean)
    {
        VerifyOrReturn(CheckValue("boolean", boolean, readAttributeBooleanDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_9,
                                                                                                      OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, 0));

        readAttributeBitmap8DefaultValue = bitmap8;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8NotDefaultValue_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8NotDefaultValue_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_11,
                                                                                                      OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckConstraintNotValue("bitmap8", bitmap8, readAttributeBitmap8DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8DefaultValue_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = readAttributeBitmap8DefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_13,
                                                                                                      OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue("bitmap8", bitmap8, readAttributeBitmap8DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_14,
                                                                                                       OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, 0U));

        readAttributeBitmap16DefaultValue = bitmap16;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16NotDefaultValue_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16NotDefaultValue_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_16,
                                                                                                       OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckConstraintNotValue("bitmap16", bitmap16, readAttributeBitmap16DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16DefaultValue_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = readAttributeBitmap16DefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_18,
                                                                                                       OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue("bitmap16", bitmap16, readAttributeBitmap16DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_19,
                                                                                                       OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, 0UL));

        readAttributeBitmap32DefaultValue = bitmap32;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32NotDefaultValue_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = 1UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32NotDefaultValue_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_21,
                                                                                                       OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckConstraintNotValue("bitmap32", bitmap32, readAttributeBitmap32DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32DefaultValue_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = readAttributeBitmap32DefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_23,
                                                                                                       OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue("bitmap32", bitmap32, readAttributeBitmap32DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_24,
                                                                                                       OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, 0ULL));

        readAttributeBitmap64DefaultValue = bitmap64;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64NotDefaultValue_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = 1ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_26,
                                                                                                       OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckConstraintNotValue("bitmap64", bitmap64, readAttributeBitmap64DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64DefaultValue_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = readAttributeBitmap64DefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_28,
                                                                                                       OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue("bitmap64", bitmap64, readAttributeBitmap64DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_29,
                                                                                                    OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, 0));

        readAttributeInt8uDefaultValue = int8u;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uNotDefaultValue_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t int8uArgument;
        int8uArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uNotDefaultValue_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_31,
                                                                                                    OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint8_t int8u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int8u", int8u, readAttributeInt8uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uDefaultValue_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t int8uArgument;
        int8uArgument = readAttributeInt8uDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_33,
                                                                                                    OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue("int8u", int8u, readAttributeInt8uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_34,
                                                                                                     OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, 0U));

        readAttributeInt16uDefaultValue = int16u;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uNotDefaultValue_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t int16uArgument;
        int16uArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uNotDefaultValue_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_36,
                                                                                                     OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(uint16_t int16u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int16u", int16u, readAttributeInt16uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uDefaultValue_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t int16uArgument;
        int16uArgument = readAttributeInt16uDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_38,
                                                                                                     OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue("int16u", int16u, readAttributeInt16uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_39,
                                                                                                     OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, 0UL));

        readAttributeInt32uDefaultValue = int32u;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uNotDefaultValue_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = 1UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uNotDefaultValue_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_41,
                                                                                                     OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int32u", int32u, readAttributeInt32uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uDefaultValue_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t int32uArgument;
        int32uArgument = readAttributeInt32uDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_43,
                                                                                                     OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue("int32u", int32u, readAttributeInt32uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_44,
                                                                                                     OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, 0ULL));

        readAttributeInt64uDefaultValue = int64u;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uNotDefaultValue_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t int64uArgument;
        int64uArgument = 1ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uNotDefaultValue_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_46,
                                                                                                     OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(uint64_t int64u)
    {
        VerifyOrReturn(CheckConstraintNotValue("int64u", int64u, readAttributeInt64uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uDefaultValue_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t int64uArgument;
        int64uArgument = readAttributeInt64uDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_48,
                                                                                                     OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue("int64u", int64u, readAttributeInt64uDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_49,
                                                                                                    OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, 0));

        readAttributeInt8sDefaultValue = int8s;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sNotDefaultValue_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_50, OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sNotDefaultValue_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_51,
                                                                                                    OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51(int8_t int8s)
    {
        VerifyOrReturn(CheckConstraintNotValue("int8s", int8s, readAttributeInt8sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int8_t int8sArgument;
        int8sArgument = readAttributeInt8sDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_52, OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_53,
                                                                                                    OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53(int8_t int8s)
    {
        VerifyOrReturn(CheckValue("int8s", int8s, readAttributeInt8sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_54,
                                                                                                     OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, 0));

        readAttributeInt16sDefaultValue = int16s;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sNotDefaultValue_55()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_55, OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sNotDefaultValue_56()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_56,
                                                                                                     OnFailureCallback_56);
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(int16_t int16s)
    {
        VerifyOrReturn(CheckConstraintNotValue("int16s", int16s, readAttributeInt16sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_57()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int16_t int16sArgument;
        int16sArgument = readAttributeInt16sDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_57, OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_57() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_58()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_58,
                                                                                                     OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58(int16_t int16s)
    {
        VerifyOrReturn(CheckValue("int16s", int16s, readAttributeInt16sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_59()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_59,
                                                                                                     OnFailureCallback_59);
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, 0L));

        readAttributeInt32sDefaultValue = int32s;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sNotDefaultValue_60()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = 1L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_60, OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_60() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sNotDefaultValue_61()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_61,
                                                                                                     OnFailureCallback_61);
    }

    void OnFailureResponse_61(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_61(int32_t int32s)
    {
        VerifyOrReturn(CheckConstraintNotValue("int32s", int32s, readAttributeInt32sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_62()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int32_t int32sArgument;
        int32sArgument = readAttributeInt32sDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_62, OnFailureCallback_62);
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_63()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_63,
                                                                                                     OnFailureCallback_63);
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63(int32_t int32s)
    {
        VerifyOrReturn(CheckValue("int32s", int32s, readAttributeInt32sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_64()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_64,
                                                                                                     OnFailureCallback_64);
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, 0LL));

        readAttributeInt64sDefaultValue = int64s;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeIntsNotDefaultValue_65()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = 1LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_65, OnFailureCallback_65);
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sNotDefaultValue_66()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_66,
                                                                                                     OnFailureCallback_66);
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66(int64_t int64s)
    {
        VerifyOrReturn(CheckConstraintNotValue("int64s", int64s, readAttributeInt64sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_67()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        int64_t int64sArgument;
        int64sArgument = readAttributeInt64sDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_67, OnFailureCallback_67);
    }

    void OnFailureResponse_67(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_67() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_68()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_68,
                                                                                                     OnFailureCallback_68);
    }

    void OnFailureResponse_68(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_68(int64_t int64s)
    {
        VerifyOrReturn(CheckValue("int64s", int64s, readAttributeInt64sDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_69()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_69,
                                                                                                    OnFailureCallback_69);
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, 0));

        readAttributeEnum8DefaultValue = enum8;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8NotDefaultValue_70()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t enum8Argument;
        enum8Argument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_70, OnFailureCallback_70);
    }

    void OnFailureResponse_70(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_70() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8NotDefaultValue_71()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_71,
                                                                                                    OnFailureCallback_71);
    }

    void OnFailureResponse_71(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_71(uint8_t enum8)
    {
        VerifyOrReturn(CheckConstraintNotValue("enum8", enum8, readAttributeEnum8DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8DefaultValue_72()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint8_t enum8Argument;
        enum8Argument = static_cast<uint8_t>(readAttributeEnum8DefaultValue);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_72, OnFailureCallback_72);
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_73()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_73,
                                                                                                    OnFailureCallback_73);
    }

    void OnFailureResponse_73(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_73(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue("enum8", enum8, readAttributeEnum8DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_74()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_74,
                                                                                                     OnFailureCallback_74);
    }

    void OnFailureResponse_74(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_74(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, 0U));

        readAttributeEnum16DefaultValue = enum16;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16NotDefaultValue_75()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enum16Argument;
        enum16Argument = static_cast<uint16_t>(1);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_75, OnFailureCallback_75);
    }

    void OnFailureResponse_75(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_75() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16NotDefaultValue_76()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_76,
                                                                                                     OnFailureCallback_76);
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76(uint16_t enum16)
    {
        VerifyOrReturn(CheckConstraintNotValue("enum16", enum16, readAttributeEnum16DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16DefaultValue_77()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t enum16Argument;
        enum16Argument = static_cast<uint16_t>(readAttributeEnum16DefaultValue);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_77, OnFailureCallback_77);
    }

    void OnFailureResponse_77(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_77() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_78()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_78,
                                                                                                     OnFailureCallback_78);
    }

    void OnFailureResponse_78(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_78(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue("enum16", enum16, readAttributeEnum16DefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_79()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_79,
                                                                                                      OnFailureCallback_79);
    }

    void OnFailureResponse_79(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_79(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, 0ULL));

        readAttributeEpochUSDefaultValue = epochUs;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsNotDefaultValue_80()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = 1ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_80, OnFailureCallback_80);
    }

    void OnFailureResponse_80(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_80() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsNotDefaultValue_81()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_81,
                                                                                                      OnFailureCallback_81);
    }

    void OnFailureResponse_81(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_81(uint64_t epochUs)
    {
        VerifyOrReturn(CheckConstraintNotValue("epochUs", epochUs, readAttributeEpochUSDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsDefaultValue_82()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = readAttributeEpochUSDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_82, OnFailureCallback_82);
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_83()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_83,
                                                                                                      OnFailureCallback_83);
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue("epochUs", epochUs, readAttributeEpochUSDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_84()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_84,
                                                                                                     OnFailureCallback_84);
    }

    void OnFailureResponse_84(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_84(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, 0UL));

        readAttributeEpochSDefaultValue = epochS;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSNotDefaultValue_85()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t epochSArgument;
        epochSArgument = 1UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_85, OnFailureCallback_85);
    }

    void OnFailureResponse_85(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_85() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSNotDefaultValue_86()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_86,
                                                                                                     OnFailureCallback_86);
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86(uint32_t epochS)
    {
        VerifyOrReturn(CheckConstraintNotValue("epochS", epochS, readAttributeEpochSDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSDefaultValue_87()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint32_t epochSArgument;
        epochSArgument = readAttributeEpochSDefaultValue;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_87, OnFailureCallback_87);
    }

    void OnFailureResponse_87(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_87() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_88()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_88,
                                                                                                     OnFailureCallback_88);
    }

    void OnFailureResponse_88(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_88(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue("epochS", epochS, readAttributeEpochSDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_89()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(this, OnSuccessCallback_89,
                                                                                                       OnFailureCallback_89);
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, 0U));

        readAttributeVendorIdDefaultValue = vendorId;
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeVendorIdNotDefaultValue_90()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(1);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_90, OnFailureCallback_90);
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorIdNotDefaultValue_91()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(this, OnSuccessCallback_91,
                                                                                                       OnFailureCallback_91);
    }

    void OnFailureResponse_91(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_91(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckConstraintNotValue("vendorId", vendorId, readAttributeVendorIdDefaultValue));

        NextTest();
    }

    CHIP_ERROR TestWriteAttributeVendorIdDefaultValue_92()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(readAttributeVendorIdDefaultValue);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_92, OnFailureCallback_92);
    }

    void OnFailureResponse_92(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_92() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_93()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(this, OnSuccessCallback_93,
                                                                                                       OnFailureCallback_93);
    }

    void OnFailureResponse_93(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_93(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue("vendorId", vendorId, readAttributeVendorIdDefaultValue));

        NextTest();
    }
};

class TestDescriptorCluster : public TestCommand
{
public:
    TestDescriptorCluster() : TestCommand("TestDescriptorCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDescriptorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDescriptorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Device list\n");
            err = TestReadAttributeDeviceList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute Server list\n");
            err = TestReadAttributeServerList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute Client list\n");
            err = TestReadAttributeClientList_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute Parts list\n");
            err = TestReadAttributePartsList_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_1(deviceList);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_2(serverList);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_3(clientList);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_4(partsList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadAttributeDeviceList_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::DeviceList::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                        OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        auto iter = deviceList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(deviceList)>("deviceList", iter, 0));
        VerifyOrReturn(CheckValue("deviceList[0].type", iter.GetValue().type, 0UL));
        VerifyOrReturn(CheckValue("deviceList[0].revision", iter.GetValue().revision, 1U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(deviceList)>("deviceList", iter, 1));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeServerList_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::ServerList::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                        OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        auto iter = serverList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 0));
        VerifyOrReturn(CheckValue("serverList[0]", iter.GetValue(), 3UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 1));
        VerifyOrReturn(CheckValue("serverList[1]", iter.GetValue(), 29UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 2));
        VerifyOrReturn(CheckValue("serverList[2]", iter.GetValue(), 30UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 3));
        VerifyOrReturn(CheckValue("serverList[3]", iter.GetValue(), 31UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 4));
        VerifyOrReturn(CheckValue("serverList[4]", iter.GetValue(), 40UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 5));
        VerifyOrReturn(CheckValue("serverList[5]", iter.GetValue(), 41UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 6));
        VerifyOrReturn(CheckValue("serverList[6]", iter.GetValue(), 42UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 7));
        VerifyOrReturn(CheckValue("serverList[7]", iter.GetValue(), 46UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 8));
        VerifyOrReturn(CheckValue("serverList[8]", iter.GetValue(), 48UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 9));
        VerifyOrReturn(CheckValue("serverList[9]", iter.GetValue(), 49UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 10));
        VerifyOrReturn(CheckValue("serverList[10]", iter.GetValue(), 50UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 11));
        VerifyOrReturn(CheckValue("serverList[11]", iter.GetValue(), 51UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 12));
        VerifyOrReturn(CheckValue("serverList[12]", iter.GetValue(), 52UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 13));
        VerifyOrReturn(CheckValue("serverList[13]", iter.GetValue(), 53UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 14));
        VerifyOrReturn(CheckValue("serverList[14]", iter.GetValue(), 54UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 15));
        VerifyOrReturn(CheckValue("serverList[15]", iter.GetValue(), 55UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 16));
        VerifyOrReturn(CheckValue("serverList[16]", iter.GetValue(), 60UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 17));
        VerifyOrReturn(CheckValue("serverList[17]", iter.GetValue(), 62UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 18));
        VerifyOrReturn(CheckValue("serverList[18]", iter.GetValue(), 63UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 19));
        VerifyOrReturn(CheckValue("serverList[19]", iter.GetValue(), 1029UL));
        VerifyOrReturn(CheckNoMoreListItems<decltype(serverList)>("serverList", iter, 20));

        NextTest();
    }

    CHIP_ERROR TestReadAttributeClientList_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::ClientList::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                        OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        auto iter = clientList.begin();
        VerifyOrReturn(CheckNoMoreListItems<decltype(clientList)>("clientList", iter, 0));

        NextTest();
    }

    CHIP_ERROR TestReadAttributePartsList_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::PartsList::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                       OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        auto iter = partsList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(partsList)>("partsList", iter, 0));
        VerifyOrReturn(CheckValue("partsList[0]", iter.GetValue(), 1U));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(partsList)>("partsList", iter, 1));
        VerifyOrReturn(CheckValue("partsList[1]", iter.GetValue(), 2U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(partsList)>("partsList", iter, 2));

        NextTest();
    }
};

class TestBasicInformation : public TestCommand
{
public:
    TestBasicInformation() : TestCommand("TestBasicInformation"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestBasicInformation\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestBasicInformation\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read location\n");
            err = TestReadLocation_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write location\n");
            err = TestWriteLocation_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read back location\n");
            err = TestReadBackLocation_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Restore initial location value\n");
            err = TestRestoreInitialLocationValue_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan location)
    {
        (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_1(location);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan location)
    {
        (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_3(location);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_4(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadLocation_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                 OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("", 0)));

        NextTest();
    }

    CHIP_ERROR TestWriteLocation_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("usgarbage: not in length on purpose", 2);

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadBackLocation_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                 OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("us", 2)));

        NextTest();
    }

    CHIP_ERROR TestRestoreInitialLocationValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }
};

class TestIdentifyCluster : public TestCommand
{
public:
    TestIdentifyCluster() : TestCommand("TestIdentifyCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestIdentifyCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestIdentifyCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Identify command and expect success response\n");
            err = TestSendIdentifyCommandAndExpectSuccessResponse_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSendIdentifyCommandAndExpectSuccessResponse_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        using RequestType               = chip::app::Clusters::Identify::Commands::Identify::Type;

        RequestType request;
        request.identifyTime = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestIdentifyCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestIdentifyCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }
};

class TestGroupsCluster : public TestCommand
{
public:
    TestGroupsCluster() : TestCommand("TestGroupsCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : View Group 0 (invalid)\n");
            err = TestViewGroup0Invalid_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : View Group 1 (not found)\n");
            err = TestViewGroup1NotFound_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Add Group 1 (new)\n");
            err = TestAddGroup1New_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : View Group 1 (new)\n");
            err = TestViewGroup1New_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : View Group 2 (not found)\n");
            err = TestViewGroup2NotFound_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Get Group Membership 1 (all)\n");
            err = TestGetGroupMembership1All_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Add Group 2 (new)\n");
            err = TestAddGroup2New_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : View Group 2 (new)\n");
            err = TestViewGroup2New_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : View Group 3 (not found)\n");
            err = TestViewGroup3NotFound_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Add Group 3 (new)\n");
            err = TestAddGroup3New_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : View Group 1 (existing)\n");
            err = TestViewGroup1Existing_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : View Group 2 (existing)\n");
            err = TestViewGroup2Existing_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Get Group Membership 2\n");
            err = TestGetGroupMembership2_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : View Group 3 (new)\n");
            err = TestViewGroup3New_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Remove Group 0 (invalid)\n");
            err = TestRemoveGroup0Invalid_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Remove Group 4 (not found)\n");
            err = TestRemoveGroup4NotFound_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Remove Group 2 (existing)\n");
            err = TestRemoveGroup2Existing_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : View Group 1 (not removed)\n");
            err = TestViewGroup1NotRemoved_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : View Group 2 (removed)\n");
            err = TestViewGroup2Removed_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : View Group 3 (not removed)\n");
            err = TestViewGroup3NotRemoved_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Get Group Membership 3\n");
            err = TestGetGroupMembership3_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Remove All\n");
            err = TestRemoveAll_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : View Group 1 (removed)\n");
            err = TestViewGroup1Removed_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : View Group 2 (still removed)\n");
            err = TestViewGroup2StillRemoved_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : View Group 3 (removed)\n");
            err = TestViewGroup3Removed_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Get Group Membership 4\n");
            err = TestGetGroupMembership4_26();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 27;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestViewGroup0Invalid_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_1(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 135));

        VerifyOrReturn(CheckValue("groupId", groupId, 0U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1NotFound_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_2(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        NextTest();
    }

    CHIP_ERROR TestAddGroup1New_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 1U;
        request.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_3(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1New_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_4(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2NotFound_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_5(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestGetGroupMembership1All_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::GetGroupMembership::Type;

        RequestType request;

        request.groupList = chip::app::DataModel::List<uint16_t>();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_6(data.capacity, data.groupList);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t capacity, const chip::app::DataModel::DecodableList<uint16_t> & groupList)
    {
        VerifyOrReturn(CheckValue("capacity", capacity, 255));

        auto iter = groupList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(groupList)>("groupList", iter, 0));
        VerifyOrReturn(CheckValue("groupList[0]", iter.GetValue(), 1U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(groupList)>("groupList", iter, 1));

        NextTest();
    }

    CHIP_ERROR TestAddGroup2New_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 4369U;
        request.groupName = chip::Span<const char>("Group #2garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_7(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2New_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_8(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #2", 8)));

        NextTest();
    }

    CHIP_ERROR TestViewGroup3NotFound_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 32767U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_9(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 32767U));

        NextTest();
    }

    CHIP_ERROR TestAddGroup3New_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 32767U;
        request.groupName = chip::Span<const char>("Group #3garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_10(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 32767U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1Existing_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_11(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2Existing_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_12(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #2", 8)));

        NextTest();
    }

    CHIP_ERROR TestGetGroupMembership2_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::GetGroupMembership::Type;

        RequestType request;

        uint16_t groupListList[3];
        groupListList[0]  = 2U;
        groupListList[1]  = 3U;
        groupListList[2]  = 32767U;
        request.groupList = groupListList;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_13(data.capacity, data.groupList);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_13(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t capacity, const chip::app::DataModel::DecodableList<uint16_t> & groupList)
    {
        VerifyOrReturn(CheckValue("capacity", capacity, 255));

        auto iter = groupList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(groupList)>("groupList", iter, 0));
        VerifyOrReturn(CheckValue("groupList[0]", iter.GetValue(), 32767U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(groupList)>("groupList", iter, 1));

        NextTest();
    }

    CHIP_ERROR TestViewGroup3New_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 32767U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_14(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_14(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 32767U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #3", 8)));

        NextTest();
    }

    CHIP_ERROR TestRemoveGroup0Invalid_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveGroup::Type;

        RequestType request;
        request.groupId = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_15(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_15(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 135));

        VerifyOrReturn(CheckValue("groupId", groupId, 0U));

        NextTest();
    }

    CHIP_ERROR TestRemoveGroup4NotFound_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveGroup::Type;

        RequestType request;
        request.groupId = 4U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_16(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_16(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 4U));

        NextTest();
    }

    CHIP_ERROR TestRemoveGroup2Existing_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_17(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_17(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1NotRemoved_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_18(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_18(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2Removed_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_19(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_19(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup3NotRemoved_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 32767U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_20(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_20(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 0));

        VerifyOrReturn(CheckValue("groupId", groupId, 32767U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #3", 8)));

        NextTest();
    }

    CHIP_ERROR TestGetGroupMembership3_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::GetGroupMembership::Type;

        RequestType request;

        uint16_t groupListList[4];
        groupListList[0]  = 1U;
        groupListList[1]  = 2U;
        groupListList[2]  = 4369U;
        groupListList[3]  = 3U;
        request.groupList = groupListList;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_21(data.capacity, data.groupList);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_21(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(uint8_t capacity, const chip::app::DataModel::DecodableList<uint16_t> & groupList)
    {
        VerifyOrReturn(CheckValue("capacity", capacity, 255));

        auto iter = groupList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(groupList)>("groupList", iter, 0));
        VerifyOrReturn(CheckValue("groupList[0]", iter.GetValue(), 1U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(groupList)>("groupList", iter, 1));

        NextTest();
    }

    CHIP_ERROR TestRemoveAll_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_22();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_22(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22() { NextTest(); }

    CHIP_ERROR TestViewGroup1Removed_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_23(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_23(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 1U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2StillRemoved_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_24(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_24(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup3Removed_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 32767U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_25(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_25(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue("status", status, 139));

        VerifyOrReturn(CheckValue("groupId", groupId, 32767U));

        NextTest();
    }

    CHIP_ERROR TestGetGroupMembership4_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::GetGroupMembership::Type;

        RequestType request;

        uint16_t groupListList[5];
        groupListList[0]  = 1U;
        groupListList[1]  = 2U;
        groupListList[2]  = 4369U;
        groupListList[3]  = 3U;
        groupListList[4]  = 32767U;
        request.groupList = groupListList;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_26(data.capacity, data.groupList);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_26(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint8_t capacity, const chip::app::DataModel::DecodableList<uint16_t> & groupList)
    {
        VerifyOrReturn(CheckValue("capacity", capacity, 255));

        auto iter = groupList.begin();
        VerifyOrReturn(CheckNoMoreListItems<decltype(groupList)>("groupList", iter, 0));

        NextTest();
    }
};

class TestOperationalCredentialsCluster : public TestCommand
{
public:
    TestOperationalCredentialsCluster() : TestCommand("TestOperationalCredentialsCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestOperationalCredentialsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestOperationalCredentialsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read number of supported fabrics\n");
            err = TestReadNumberOfSupportedFabrics_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read number of commissioned fabrics\n");
            err = TestReadNumberOfCommissionedFabrics_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read current fabric index\n");
            err = TestReadCurrentFabricIndex_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t supportedFabrics)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_1(supportedFabrics);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_2(commissionedFabrics);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, chip::FabricIndex currentFabricIndex)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_3(currentFabricIndex);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadNumberOfSupportedFabrics_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::SupportedFabrics::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("supportedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("supportedFabrics", supportedFabrics, 4));

        NextTest();
    }

    CHIP_ERROR TestReadNumberOfCommissionedFabrics_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("commissionedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("commissionedFabrics", commissionedFabrics, 1));

        NextTest();
    }

    CHIP_ERROR TestReadCurrentFabricIndex_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CurrentFabricIndex::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::FabricIndex currentFabricIndex)
    {
        VerifyOrReturn(CheckConstraintType("currentFabricIndex", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::FabricIndex>("currentFabricIndex", currentFabricIndex, 1));

        NextTest();
    }
};

class TestModeSelectCluster : public TestCommand
{
public:
    TestModeSelectCluster() : TestCommand("TestModeSelectCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestModeSelectCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestModeSelectCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read CurrentMode\n");
            err = TestReadCurrentMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read OnMode\n");
            err = TestReadOnMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read StartUpMode\n");
            err = TestReadStartUpMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read Description\n");
            err = TestReadDescription_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read SupportedModes\n");
            err = TestReadSupportedModes_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Change to Supported Mode\n");
            err = TestChangeToSupportedMode_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Verify Current Mode Change\n");
            err = TestVerifyCurrentModeChange_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Change to Unsupported Mode\n");
            err = TestChangeToUnsupportedMode_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_1(currentMode);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t onMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_2(onMode);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t startUpMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_3(startUpMode);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, chip::CharSpan description)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_4(description);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_5(supportedModes);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t currentMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_7(currentMode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadCurrentMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::CurrentMode::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                         OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t currentMode)
    {
        VerifyOrReturn(CheckValue("currentMode", currentMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadOnMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::OnMode::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                    OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t onMode)
    {
        VerifyOrReturn(CheckValue("onMode", onMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadStartUpMode_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::StartUpMode::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                         OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t startUpMode)
    {
        VerifyOrReturn(CheckValue("startUpMode", startUpMode, 0));

        NextTest();
    }

    CHIP_ERROR TestReadDescription_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::Description::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                         OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(chip::CharSpan description)
    {
        VerifyOrReturn(CheckValueAsString("description", description, chip::CharSpan("Coffee", 6)));

        NextTest();
    }

    CHIP_ERROR TestReadSupportedModes_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::SupportedModes::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)
    {
        auto iter = supportedModes.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 0));
        VerifyOrReturn(CheckValueAsString("supportedModes[0].label", iter.GetValue().label, chip::CharSpan("Black", 5)));
        VerifyOrReturn(CheckValue("supportedModes[0].mode", iter.GetValue().mode, 0));
        VerifyOrReturn(CheckValue("supportedModes[0].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 1));
        VerifyOrReturn(CheckValueAsString("supportedModes[1].label", iter.GetValue().label, chip::CharSpan("Cappuccino", 10)));
        VerifyOrReturn(CheckValue("supportedModes[1].mode", iter.GetValue().mode, 4));
        VerifyOrReturn(CheckValue("supportedModes[1].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 2));
        VerifyOrReturn(CheckValueAsString("supportedModes[2].label", iter.GetValue().label, chip::CharSpan("Espresso", 8)));
        VerifyOrReturn(CheckValue("supportedModes[2].mode", iter.GetValue().mode, 7));
        VerifyOrReturn(CheckValue("supportedModes[2].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNoMoreListItems<decltype(supportedModes)>("supportedModes", iter, 3));

        NextTest();
    }

    CHIP_ERROR TestChangeToSupportedMode_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type;

        RequestType request;
        request.newMode = 4;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestVerifyCurrentModeChange_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::CurrentMode::TypeInfo>(this, OnSuccessCallback_7,
                                                                                                         OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t currentMode)
    {
        VerifyOrReturn(CheckValue("currentMode", currentMode, 4));

        NextTest();
    }

    CHIP_ERROR TestChangeToUnsupportedMode_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type;

        RequestType request;
        request.newMode = 2;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status)
    {
        VerifyOrReturn(CheckValue("status", status, EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
        NextTest();
    }

    void OnSuccessResponse_8() { ThrowSuccessResponse(); }
};

class TestGroupMessaging : public TestCommand
{
public:
    TestGroupMessaging() : TestCommand("TestGroupMessaging"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupMessaging\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupMessaging\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Group Write Attribute\n");
            err = TestGroupWriteAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read back Attribute\n");
            err = TestReadBackAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Restore initial location value\n");
            err = TestRestoreInitialLocationValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read back Attribute\n");
            err = TestReadBackAttribute_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestGroupMessaging *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnDoneCallback_1(void * context) { (static_cast<TestGroupMessaging *>(context))->OnDoneResponse_1(); }

    static void OnSuccessCallback_1(void * context) { (static_cast<TestGroupMessaging *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestGroupMessaging *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, chip::CharSpan location)
    {
        (static_cast<TestGroupMessaging *>(context))->OnSuccessResponse_2(location);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestGroupMessaging *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnDoneCallback_3(void * context) { (static_cast<TestGroupMessaging *>(context))->OnDoneResponse_3(); }

    static void OnSuccessCallback_3(void * context) { (static_cast<TestGroupMessaging *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TestGroupMessaging *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, chip::CharSpan location)
    {
        (static_cast<TestGroupMessaging *>(context))->OnSuccessResponse_4(location);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestGroupWriteAttribute_1()
    {
        const chip::GroupId groupId = 1234;
        chip::Controller::BasicClusterTest cluster;
        cluster.AssociateWithGroup(mDevices[kIdentityAlpha], groupId);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("usgarbage: not in length on purpose", 2);

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_1, OnFailureCallback_1, OnDoneCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    void OnDoneResponse_1() { NextTest(); }

    CHIP_ERROR TestReadBackAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                 OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("us", 2)));

        NextTest();
    }

    CHIP_ERROR TestRestoreInitialLocationValue_3()
    {
        const chip::GroupId groupId = 1234;
        chip::Controller::BasicClusterTest cluster;
        cluster.AssociateWithGroup(mDevices[kIdentityAlpha], groupId);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_3, OnFailureCallback_3, OnDoneCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    void OnDoneResponse_3() { NextTest(); }

    CHIP_ERROR TestReadBackAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                 OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("", 0)));

        NextTest();
    }
};

class Test_TC_DIAGSW_1_1 : public TestCommand
{
public:
    Test_TC_DIAGSW_1_1() : TestCommand("Test_TC_DIAGSW_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGSW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGSW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads CurrentHeapFree non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapUsed non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads CurrentHeapHighWaterMark non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint64_t currentHeapFree)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_1(currentHeapFree);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint64_t currentHeapUsed)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_2(currentHeapUsed);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint64_t currentHeapHighWatermark)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_3(currentHeapHighWatermark);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapFree::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint64_t currentHeapFree)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapFree", "", "uint64"));

        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapUsed::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint64_t currentHeapUsed)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapUsed", "", "uint64"));

        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_3(uint64_t currentHeapHighWatermark)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapHighWatermark", "", "uint64"));

        NextTest();
    }
};

class Test_TC_DIAGSW_2_1 : public TestCommand
{
public:
    Test_TC_DIAGSW_2_1() : TestCommand("Test_TC_DIAGSW_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGSW_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGSW_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_DIAGSW_3_2 : public TestCommand
{
public:
    Test_TC_DIAGSW_3_2() : TestCommand("Test_TC_DIAGSW_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGSW_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGSW_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }
};

class TestSubscribe_OnOff : public TestCommand
{
public:
    TestSubscribe_OnOff() : TestCommand("TestSubscribe_OnOff"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSubscribe_OnOff\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSubscribe_OnOff\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait for the commissioned device to be retrieved\n");
            err = TestWaitForTheCommissionedDeviceToBeRetrieved_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Set OnOff Attribute to false\n");
            err = TestSetOnOffAttributeToFalse_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Report: Subscribe OnOff Attribute\n");
            err = TestReportSubscribeOnOffAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Subscribe OnOff Attribute\n");
            err = TestSubscribeOnOffAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check for attribute report\n");
            err = TestCheckForAttributeReport_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check for attribute report\n");
            err = TestCheckForAttributeReport_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_2(onOff);
    }

    bool mReceivedReport_2 = false;

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_3(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_5(onOff);
    }

    bool mReceivedReport_5 = false;

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_7(onOff);
    }

    bool mReceivedReport_7 = false;

    //
    // Tests methods
    //

    CHIP_ERROR TestWaitForTheCommissionedDeviceToBeRetrieved_0()
    {
        SetIdentity(kIdentityAlpha);
        return WaitForCommissionee();
    }

    CHIP_ERROR TestSetOnOffAttributeToFalse_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReportSubscribeOnOffAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        ReturnErrorOnFailure(cluster.ReportAttributeOnOff(mOnSuccessCallback_2.Cancel()));

        return WaitForMs(0);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_2 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_2 = true;

        VerifyOrReturn(CheckValue("onOff", onOff, false));
    }

    CHIP_ERROR TestSubscribeOnOffAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        uint16_t minIntervalArgument;
        minIntervalArgument = 2U;
        uint16_t maxIntervalArgument;
        maxIntervalArgument = 10U;

        return cluster.SubscribeAttributeOnOff(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel(), minIntervalArgument,
                                               maxIntervalArgument);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_2, Exit("Initial report not received!"));

        NextTest();
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReportAttributeOnOff(mOnSuccessCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_5 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_5 = true;

        VerifyOrReturn(CheckValue("onOff", onOff, true));

        NextTest();
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevices[kIdentityAlpha], this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevices[kIdentityAlpha], endpoint);

        return cluster.ReportAttributeOnOff(mOnSuccessCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_7 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_7 = true;

        VerifyOrReturn(CheckValue("onOff", onOff, false));

        NextTest();
    }
};

void registerCommandsTests(Commands & commands)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
        make_unique<TestList>(),
        make_unique<Test_TC_BI_1_1>(),
        make_unique<Test_TC_BI_2_1>(),
        make_unique<Test_TC_BI_2_2>(),
        make_unique<Test_TC_BOOL_1_1>(),
        make_unique<Test_TC_BOOL_2_1>(),
        make_unique<Test_TC_CC_1_1>(),
        make_unique<Test_TC_CC_2_1>(),
        make_unique<Test_TC_CC_3_1>(),
        make_unique<Test_TC_CC_3_2>(),
        make_unique<Test_TC_CC_3_3>(),
        make_unique<Test_TC_CC_4_1>(),
        make_unique<Test_TC_CC_4_2>(),
        make_unique<Test_TC_CC_4_3>(),
        make_unique<Test_TC_CC_4_4>(),
        make_unique<Test_TC_CC_5_1>(),
        make_unique<Test_TC_CC_5_2>(),
        make_unique<Test_TC_CC_5_3>(),
        make_unique<Test_TC_CC_6_1>(),
        make_unique<Test_TC_CC_6_2>(),
        make_unique<Test_TC_CC_6_3>(),
        make_unique<Test_TC_CC_7_1>(),
        make_unique<Test_TC_CC_7_2>(),
        make_unique<Test_TC_CC_7_3>(),
        make_unique<Test_TC_CC_7_4>(),
        make_unique<Test_TC_CC_8_1>(),
        make_unique<Test_TC_CC_9_1>(),
        make_unique<Test_TC_CC_9_2>(),
        make_unique<Test_TC_CC_9_3>(),
        make_unique<Test_TC_DM_1_1>(),
        make_unique<Test_TC_DM_3_1>(),
        make_unique<Test_TC_DM_2_2>(),
        make_unique<Test_TC_EMR_1_1>(),
        make_unique<Test_TC_FLW_1_1>(),
        make_unique<Test_TC_FLW_2_1>(),
        make_unique<Test_TC_FLW_2_2>(),
        make_unique<Test_TC_ILL_1_1>(),
        make_unique<Test_TC_LVL_1_1>(),
        make_unique<Test_TC_LVL_2_1>(),
        make_unique<Test_TC_LVL_3_1>(),
        make_unique<Test_TC_LVL_4_1>(),
        make_unique<Test_TC_LVL_5_1>(),
        make_unique<Test_TC_MC_1_1>(),
        make_unique<Test_TC_MC_2_1>(),
        make_unique<Test_TC_MC_3_1>(),
        make_unique<Test_TC_MC_3_2>(),
        make_unique<Test_TC_MC_3_3>(),
        make_unique<Test_TC_MC_3_4>(),
        make_unique<Test_TC_MC_3_5>(),
        make_unique<Test_TC_MC_3_6>(),
        make_unique<Test_TC_MC_3_7>(),
        make_unique<Test_TC_MC_3_8>(),
        make_unique<Test_TC_MC_3_9>(),
        make_unique<Test_TC_MC_3_10>(),
        make_unique<Test_TC_MC_3_11>(),
        make_unique<Test_TC_OCC_1_1>(),
        make_unique<Test_TC_OCC_2_1>(),
        make_unique<Test_TC_OCC_2_2>(),
        make_unique<Test_TC_OO_1_1>(),
        make_unique<Test_TC_OO_2_1>(),
        make_unique<Test_TC_OO_2_2>(),
        make_unique<Test_TC_OO_2_3>(),
        make_unique<Test_TC_PRS_1_1>(),
        make_unique<Test_TC_PRS_2_1>(),
        make_unique<Test_TC_PCC_1_1>(),
        make_unique<Test_TC_PCC_2_1>(),
        make_unique<Test_TC_PCC_2_2>(),
        make_unique<Test_TC_PCC_2_3>(),
        make_unique<Test_TC_RH_1_1>(),
        make_unique<Test_TC_RH_2_1>(),
        make_unique<Test_TC_RH_2_2>(),
        make_unique<Test_TC_TM_1_1>(),
        make_unique<Test_TC_TM_2_1>(),
        make_unique<Test_TC_TM_2_2>(),
        make_unique<Test_TC_TSTAT_1_1>(),
        make_unique<Test_TC_TSTAT_2_1>(),
        make_unique<Test_TC_TSTAT_2_2>(),
        make_unique<Test_TC_TSUIC_1_1>(),
        make_unique<Test_TC_TSUIC_2_1>(),
        make_unique<Test_TC_TSUIC_2_2>(),
        make_unique<Test_TC_DIAGTH_1_1>(),
        make_unique<Test_TC_WNCV_1_1>(),
        make_unique<Test_TC_WNCV_2_1>(),
        make_unique<Test_TC_WNCV_2_2>(),
        make_unique<Test_TC_WNCV_2_4>(),
        make_unique<Test_TC_WNCV_2_5>(),
        make_unique<Test_TC_WNCV_3_1>(),
        make_unique<Test_TC_WNCV_3_2>(),
        make_unique<Test_TC_WNCV_3_3>(),
        make_unique<TV_TargetNavigatorCluster>(),
        make_unique<TV_AudioOutputCluster>(),
        make_unique<TV_ApplicationLauncherCluster>(),
        make_unique<TV_KeypadInputCluster>(),
        make_unique<TV_AccountLoginCluster>(),
        make_unique<TV_WakeOnLanCluster>(),
        make_unique<TV_ApplicationBasicCluster>(),
        make_unique<TV_MediaPlaybackCluster>(),
        make_unique<TV_TvChannelCluster>(),
        make_unique<TV_LowPowerCluster>(),
        make_unique<TV_MediaInputCluster>(),
        make_unique<TestCluster>(),
        make_unique<TestClusterComplexTypes>(),
        make_unique<TestConstraints>(),
        make_unique<TestDelayCommands>(),
        make_unique<TestLogCommands>(),
        make_unique<TestSaveAs>(),
        make_unique<TestDescriptorCluster>(),
        make_unique<TestBasicInformation>(),
        make_unique<TestIdentifyCluster>(),
        make_unique<TestGroupsCluster>(),
        make_unique<TestOperationalCredentialsCluster>(),
        make_unique<TestModeSelectCluster>(),
        make_unique<TestGroupMessaging>(),
        make_unique<Test_TC_DIAGSW_1_1>(),
        make_unique<Test_TC_DIAGSW_2_1>(),
        make_unique<Test_TC_DIAGSW_3_2>(),
        make_unique<TestSubscribe_OnOff>(),
    };

    commands.Register(clusterName, clusterCommands);
}
