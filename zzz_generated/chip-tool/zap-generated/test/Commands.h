/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <commands/tests/TestCommand.h>

class Test_TC_BI_1_1 : public TestCommand
{
public:
    Test_TC_BI_1_1() : TestCommand("Test_TC_BI_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 1U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1(uint16_t clusterRevision) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }
};

class Test_TC_CC_1_1 : public TestCommand
{
public:
    Test_TC_CC_1_1() : TestCommand("Test_TC_CC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_CC_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 4U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_CC_3_1 : public TestCommand
{
public:
    Test_TC_CC_3_1() : TestCommand("Test_TC_CC_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to hue shortest distance command\n");
            err = TestMoveToHueShortestDistanceCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to hue longest distance command\n");
            err = TestMoveToHueLongestDistanceCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move to hue up command\n");
            err = TestMoveToHueUpCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move to hue down command\n");
            err = TestMoveToHueDownCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToHueShortestDistanceCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;
        request.hue             = 150;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveToHueLongestDistanceCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;
        request.hue             = 200;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveToHueUpCommand_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;
        request.hue             = 250;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveToHueDownCommand_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;
        request.hue             = 225;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_3_2 : public TestCommand
{
public:
    Test_TC_CC_3_2() : TestCommand("Test_TC_CC_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move hue up command\n");
            err = TestMoveHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move hue stop command\n");
            err = TestMoveHueStopCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move hue down command\n");
            err = TestMoveHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move hue stop command\n");
            err = TestMoveHueStopCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveHueUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveHueDownCommand_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_3_3 : public TestCommand
{
public:
    Test_TC_CC_3_3() : TestCommand("Test_TC_CC_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step hue up command\n");
            err = TestStepHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step hue down command\n");
            err = TestStepHueDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepHueUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepHue::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepHueDownCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepHue::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_1 : public TestCommand
{
public:
    Test_TC_CC_4_1() : TestCommand("Test_TC_CC_4_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to saturation command\n");
            err = TestMoveToSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToSaturationCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type request;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_2 : public TestCommand
{
public:
    Test_TC_CC_4_2() : TestCommand("Test_TC_CC_4_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveSaturationUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveSaturationDownCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_3 : public TestCommand
{
public:
    Test_TC_CC_4_3() : TestCommand("Test_TC_CC_4_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step saturation up command\n");
            err = TestStepSaturationUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step saturation down command\n");
            err = TestStepSaturationDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepSaturationUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepSaturation::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(1);
        request.stepSize        = 15;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepSaturationDownCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepSaturation::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(3);
        request.stepSize        = 20;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_4 : public TestCommand
{
public:
    Test_TC_CC_4_4() : TestCommand("Test_TC_CC_4_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move To current hue and saturation command\n");
            err = TestMoveToCurrentHueAndSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToCurrentHueAndSaturationCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type request;
        request.hue             = 40;
        request.saturation      = 160;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_1 : public TestCommand
{
public:
    Test_TC_CC_5_1() : TestCommand("Test_TC_CC_5_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to Color command\n");
            err = TestMoveToColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToColorCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToColor::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToColor::Type request;
        request.colorX          = 200U;
        request.colorY          = 300U;
        request.transitionTime  = 20U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_2 : public TestCommand
{
public:
    Test_TC_CC_5_2() : TestCommand("Test_TC_CC_5_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move Color command\n");
            err = TestMoveColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Stop Move Step command\n");
            err = TestStopMoveStepCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveColorCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveColor::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveColor::Type request;
        request.rateX           = 15;
        request.rateY           = 20;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStopMoveStepCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type request;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_3 : public TestCommand
{
public:
    Test_TC_CC_5_3() : TestCommand("Test_TC_CC_5_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step Color command\n");
            err = TestStepColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepColorCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepColor::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepColor::Type request;
        request.stepX           = 15;
        request.stepY           = 20;
        request.transitionTime  = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_1 : public TestCommand
{
public:
    Test_TC_CC_6_1() : TestCommand("Test_TC_CC_6_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move To Color Temperature command\n");
            err = TestMoveToColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToColorTemperatureCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type request;
        request.colorTemperature = 100U;
        request.transitionTime   = 10U;
        request.optionsMask      = 0;
        request.optionsOverride  = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_2 : public TestCommand
{
public:
    Test_TC_CC_6_2() : TestCommand("Test_TC_CC_6_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move up color temperature command\n");
            err = TestMoveUpColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Stop Color Temperature command\n");
            err = TestStopColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move down color temperature command\n");
            err = TestMoveDownColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveUpColorTemperatureCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStopColorTemperatureCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveDownColorTemperatureCommand_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate                    = 20U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_3 : public TestCommand
{
public:
    Test_TC_CC_6_3() : TestCommand("Test_TC_CC_6_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step up color temperature command\n");
            err = TestStepUpColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step down color temperature command\n");
            err = TestStepDownColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepUpColorTemperatureCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepDownColorTemperatureCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_1 : public TestCommand
{
public:
    Test_TC_CC_7_1() : TestCommand("Test_TC_CC_7_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : Check Remaining time attribute value matched the value sent by the last command\n");
            err = TestCheckRemainingTimeAttributeValueMatchedTheValueSentByTheLastCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t remainingTime)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_3(remainingTime);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type request;
        request.enhancedHue     = 1025U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckRemainingTimeAttributeValueMatchedTheValueSentByTheLastCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeRemainingTime(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("remainingTime", remainingTime, 1U));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_2 : public TestCommand
{
public:
    Test_TC_CC_7_2() : TestCommand("Test_TC_CC_7_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Move Hue Down command \n");
            err = TestEnhancedMoveHueDownCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move Hue Up command\n");
            err = TestEnhancedMoveHueUpCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveHueDownCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 5U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueUpCommand_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_3 : public TestCommand
{
public:
    Test_TC_CC_7_3() : TestCommand("Test_TC_CC_7_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Step Hue Up command\n");
            err = TestEnhancedStepHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Step Hue Down command\n");
            err = TestEnhancedStepHueDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedStepHueUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(0);
        request.stepSize        = 50U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestEnhancedStepHueDownCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 75U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_4 : public TestCommand
{
public:
    Test_TC_CC_7_4() : TestCommand("Test_TC_CC_7_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced move to hue and saturation command\n");
            err = TestEnhancedMoveToHueAndSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueAndSaturationCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type request;
        request.enhancedHue     = 1200U;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_8_1 : public TestCommand
{
public:
    Test_TC_CC_8_1() : TestCommand("Test_TC_CC_8_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_8_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_8_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Color Loop Set Command - Set all Attributs\n");
            err = TestColorLoopSetCommandSetAllAttributs_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check ColorLoopStartEnhancedHue Value\n");
            err = TestCheckColorLoopStartEnhancedHueValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Color Loop Set Command - Set direction and time while running\n");
            err = TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Set direction while running\n");
            err = TestColorLoopSetCommandSetDirectionWhileRunning_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_3{ OnSuccessCallback_3,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStartEnhancedHue)> mOnSuccessCallback_5{
        OnSuccessCallback_5, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_10{ OnSuccessCallback_10,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_13{ OnSuccessCallback_13,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_15{ OnSuccessCallback_15, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_3(colorLoopDirection);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_4(colorLoopTime);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_5(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_6(colorLoopActive);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_8(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_10(colorLoopDirection);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_11(colorLoopTime);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_13(colorLoopDirection);
    }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_15(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributs_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(14);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 100U;
        request.startHue        = 500U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 100U));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopStartEnhancedHueValue_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStartEnhancedHue(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 500U));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopActiveValue_6()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_7()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopActiveValue_8()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_9()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(6);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 3500U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_9(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_10()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_11()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 3500U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionWhileRunning_12()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_12(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_13()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_14()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_14(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_15()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_DM_1_1 : public TestCommand
{
public:
    Test_TC_DM_1_1() : TestCommand("Test_TC_DM_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Query Interaction Model Version\n");
            err = TestQueryInteractionModelVersion_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Vendor Name\n");
            err = TestQueryVendorName_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query VendorID\n");
            err = TestQueryVendorID_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query Product Name\n");
            err = TestQueryProductName_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query ProductID\n");
            err = TestQueryProductID_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Query User Label\n");
            err = TestQueryUserLabel_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Query User Location\n");
            err = TestQueryUserLocation_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Query HardwareVersion\n");
            err = TestQueryHardwareVersion_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Query HardwareVersionString\n");
            err = TestQueryHardwareVersionString_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Query SoftwareVersion\n");
            err = TestQuerySoftwareVersion_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Query SoftwareVersionString\n");
            err = TestQuerySoftwareVersionString_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Query ManufacturingDate\n");
            err = TestQueryManufacturingDate_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Query PartNumber\n");
            err = TestQueryPartNumber_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Query ProductURL\n");
            err = TestQueryProductURL_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Query ProductLabel\n");
            err = TestQueryProductLabel_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Query SerialNumber\n");
            err = TestQuerySerialNumber_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Query LocalConfigDisabled\n");
            err = TestQueryLocalConfigDisabled_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Query Reachable\n");
            err = TestQueryReachable_17();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 18;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t interactionModelVersion)> mOnSuccessCallback_0{ OnSuccessCallback_0,
                                                                                                               this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan vendorName)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t vendorID)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan productName)> mOnSuccessCallback_3{ OnSuccessCallback_3,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t productID)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan userLabel)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan location)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t hardwareVersion)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan hardwareVersionString)> mOnSuccessCallback_8{
        OnSuccessCallback_8, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t softwareVersion)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan softwareVersionString)> mOnSuccessCallback_10{
        OnSuccessCallback_10, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan manufacturingDate)> mOnSuccessCallback_11{
        OnSuccessCallback_11, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan partNumber)> mOnSuccessCallback_12{ OnSuccessCallback_12,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan productURL)> mOnSuccessCallback_13{ OnSuccessCallback_13,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_14{ OnFailureCallback_14, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan productLabel)> mOnSuccessCallback_14{ OnSuccessCallback_14,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan serialNumber)> mOnSuccessCallback_15{ OnSuccessCallback_15,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_16{ OnFailureCallback_16, this };
    chip::Callback::Callback<void (*)(void * context, bool localConfigDisabled)> mOnSuccessCallback_16{ OnSuccessCallback_16,
                                                                                                        this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_17{ OnFailureCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, bool reachable)> mOnSuccessCallback_17{ OnSuccessCallback_17, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t interactionModelVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_0(interactionModelVersion);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan vendorName)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_1(vendorName);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t vendorID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_2(vendorID);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan productName)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_3(productName);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint16_t productID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_4(productID);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, chip::CharSpan userLabel)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_5(userLabel);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, chip::CharSpan location)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_6(location);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint16_t hardwareVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_7(hardwareVersion);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, chip::CharSpan hardwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_8(hardwareVersionString);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint32_t softwareVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_9(softwareVersion);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, chip::CharSpan softwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_10(softwareVersionString);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, chip::CharSpan manufacturingDate)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_11(manufacturingDate);
    }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, chip::CharSpan partNumber)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_12(partNumber);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, chip::CharSpan productURL)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_13(productURL);
    }

    static void OnFailureCallback_14(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_14(status);
    }

    static void OnSuccessCallback_14(void * context, chip::CharSpan productLabel)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_14(productLabel);
    }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, chip::CharSpan serialNumber)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_15(serialNumber);
    }

    static void OnFailureCallback_16(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_16(status);
    }

    static void OnSuccessCallback_16(void * context, bool localConfigDisabled)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_16(localConfigDisabled);
    }

    static void OnFailureCallback_17(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_17(status);
    }

    static void OnSuccessCallback_17(void * context, bool reachable)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_17(reachable);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestQueryInteractionModelVersion_0()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeInteractionModelVersion(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t interactionModelVersion)
    {
        VerifyOrReturn(CheckConstraintType("interactionModelVersion", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryVendorName_1()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeVendorName(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::CharSpan vendorName)
    {
        VerifyOrReturn(CheckConstraintType("vendorName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("vendorName", vendorName.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryVendorID_2()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeVendorID(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t vendorID)
    {
        VerifyOrReturn(CheckConstraintType("vendorID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryProductName_3()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeProductName(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::CharSpan productName)
    {
        VerifyOrReturn(CheckConstraintType("productName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productName", productName.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryProductID_4()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeProductID(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t productID)
    {
        VerifyOrReturn(CheckConstraintType("productID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryUserLabel_5()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeUserLabel(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(chip::CharSpan userLabel)
    {
        VerifyOrReturn(CheckConstraintType("userLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("userLabel", userLabel.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryUserLocation_6()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeLocation(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(chip::CharSpan location)
    {
        VerifyOrReturn(CheckConstraintType("location", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("location", "", "ISO 3166-1 alpha-2"));
        VerifyOrReturn(CheckConstraintMaxLength("location", location.size(), 2));
        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersion_7()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeHardwareVersion(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t hardwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersion", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersionString_8()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeHardwareVersionString(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(chip::CharSpan hardwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintMinLength("hardwareVersionString", hardwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("hardwareVersionString", hardwareVersionString.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersion_9()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSoftwareVersion(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint32_t softwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersion", "", "uint32"));
        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersionString_10()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSoftwareVersionString(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(chip::CharSpan softwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("softwareVersionString", "", "ASCII"));
        VerifyOrReturn(CheckConstraintMinLength("softwareVersionString", softwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("softwareVersionString", softwareVersionString.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQueryManufacturingDate_11()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeManufacturingDate(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_11(chip::CharSpan manufacturingDate)
    {
        VerifyOrReturn(CheckConstraintType("manufacturingDate", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("manufacturingDate", "", "ISO 8601"));
        VerifyOrReturn(CheckConstraintMinLength("manufacturingDate", manufacturingDate.size(), 8));
        VerifyOrReturn(CheckConstraintMaxLength("manufacturingDate", manufacturingDate.size(), 16));
        NextTest();
    }

    CHIP_ERROR TestQueryPartNumber_12()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributePartNumber(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel());
    }

    void OnFailureResponse_12(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_12(chip::CharSpan partNumber)
    {
        VerifyOrReturn(CheckConstraintType("partNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("partNumber", partNumber.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryProductURL_13()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeProductURL(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_13(chip::CharSpan productURL)
    {
        VerifyOrReturn(CheckConstraintType("productURL", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("productURL", "", "RFC3986"));
        VerifyOrReturn(CheckConstraintMaxLength("productURL", productURL.size(), 256));
        NextTest();
    }

    CHIP_ERROR TestQueryProductLabel_14()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeProductLabel(mOnSuccessCallback_14.Cancel(), mOnFailureCallback_14.Cancel());
    }

    void OnFailureResponse_14(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_14(chip::CharSpan productLabel)
    {
        VerifyOrReturn(CheckConstraintType("productLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productLabel", productLabel.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQuerySerialNumber_15()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSerialNumber(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_15(chip::CharSpan serialNumber)
    {
        VerifyOrReturn(CheckConstraintType("serialNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("serialNumber", serialNumber.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryLocalConfigDisabled_16()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeLocalConfigDisabled(mOnSuccessCallback_16.Cancel(), mOnFailureCallback_16.Cancel());
    }

    void OnFailureResponse_16(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_16(bool localConfigDisabled)
    {
        VerifyOrReturn(CheckConstraintType("localConfigDisabled", "", "boolean"));
        NextTest();
    }

    CHIP_ERROR TestQueryReachable_17()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeReachable(mOnSuccessCallback_17.Cancel(), mOnFailureCallback_17.Cancel());
    }

    void OnFailureResponse_17(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_17(bool reachable)
    {
        VerifyOrReturn(CheckConstraintType("reachable", "", "boolean"));
        NextTest();
    }
};

class Test_TC_DM_3_1 : public TestCommand
{
public:
    Test_TC_DM_3_1() : TestCommand("Test_TC_DM_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_FLW_1_1 : public TestCommand
{
public:
    Test_TC_FLW_1_1() : TestCommand("Test_TC_FLW_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_FLW_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 2U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_LVL_1_1 : public TestCommand
{
public:
    Test_TC_LVL_1_1() : TestCommand("Test_TC_LVL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_LVL_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 4U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_LVL_2_1 : public TestCommand
{
public:
    Test_TC_LVL_2_1() : TestCommand("Test_TC_LVL_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 10ms\n");
            err = TestWait10ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 100ms\n");
            err = TestWait100ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : reads On Off Transition Time attribute from DUT\n");
            err = TestReadsOnOffTransitionTimeAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 1ms\n");
            err = TestWait1ms_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reset level to 0\n");
            err = TestResetLevelTo0_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 10ms\n");
            err = TestWait10ms_12();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 13;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onOffTransitionTime)> mOnSuccessCallback_7{ OnSuccessCallback_7,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_0(currentLevel);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_3(currentLevel);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_6(currentLevel);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint16_t onOffTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_7(onOffTransitionTime);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_10(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_0()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_1()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;
        request.level          = 64;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait10ms_2() { return WaitForMs(10); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_3()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 64));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_4()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;
        request.level          = 128;
        request.transitionTime = 1U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait100ms_5() { return WaitForMs(100); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_6()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 128));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffTransitionTimeAttributeFromDut_7()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOffTransitionTime(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t onOffTransitionTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onOffTransitionTime", onOffTransitionTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_8()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;
        request.level          = 254;
        request.transitionTime = 65535U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWait1ms_9() { return WaitForMs(1); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_10()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 254));
        NextTest();
    }

    CHIP_ERROR TestResetLevelTo0_11()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;
        request.level          = 0;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_11(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestWait10ms_12() { return WaitForMs(10); }
};

class Test_TC_LVL_3_1 : public TestCommand
{
public:
    Test_TC_LVL_3_1() : TestCommand("Test_TC_LVL_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads max level attribute from DUT\n");
            err = TestReadsMaxLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : sends a Move up command\n");
            err = TestSendsAMoveUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 2500ms\n");
            err = TestWait2500ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads min level attribute from DUT\n");
            err = TestReadsMinLevelAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : sends a Move down command\n");
            err = TestSendsAMoveDownCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Wait 2500ms\n");
            err = TestWait2500ms_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write default move rate attribute from DUT\n");
            err = TestWriteDefaultMoveRateAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads default move rate attribute from DUT\n");
            err = TestReadsDefaultMoveRateAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : sends a Move up command at default move rate\n");
            err = TestSendsAMoveUpCommandAtDefaultMoveRate_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 10ms\n");
            err = TestWait10ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t maxLevel)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t minLevel)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t defaultMoveRate)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t defaultMoveRate)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_13{ OnSuccessCallback_13, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_0(currentLevel);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t maxLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_1(maxLevel);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_4(currentLevel);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t minLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_5(minLevel);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_8(currentLevel);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint8_t defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_9(defaultMoveRate);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_10(defaultMoveRate);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_13(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_0()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMaxLevelAttributeFromDut_1()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxLevel(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t maxLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("maxLevel", maxLevel, 255));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommand_2()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Move::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Move::Type request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 200;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWait2500ms_3() { return WaitForMs(2500); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 255));
        NextTest();
    }

    CHIP_ERROR TestReadsMinLevelAttributeFromDut_5()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMinLevel(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t minLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("minLevel", minLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveDownCommand_6()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Move::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Move::Type request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 250;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWait2500ms_7() { return WaitForMs(2500); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_8()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteDefaultMoveRateAttributeFromDut_9()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t defaultMoveRateArgument = 20;

        return cluster.WriteAttributeDefaultMoveRate(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel(),
                                                     defaultMoveRateArgument);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t defaultMoveRate) { NextTest(); }

    CHIP_ERROR TestReadsDefaultMoveRateAttributeFromDut_10()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeDefaultMoveRate(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t defaultMoveRate)
    {
        VerifyOrReturn(CheckValue<uint8_t>("defaultMoveRate", defaultMoveRate, 20));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommandAtDefaultMoveRate_11()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Move::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Move::Type request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 255;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_11(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestWait10ms_12() { return WaitForMs(10); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_13()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckConstraintNotValue<uint8_t>("currentLevel", currentLevel, 255));
        NextTest();
    }
};

class Test_TC_MC_1_1 : public TestCommand
{
public:
    Test_TC_MC_1_1() : TestCommand("Test_TC_MC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_MC_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_MC_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 1U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_OCC_1_1 : public TestCommand
{
public:
    Test_TC_OCC_1_1() : TestCommand("Test_TC_OCC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 2U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_OO_1_1 : public TestCommand
{
public:
    Test_TC_OO_1_1() : TestCommand("Test_TC_OO_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default values to optional global attribute: FeatureMap\n");
            err = TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads back optional global attribute: FeatureMap\n");
            err = TestReadsBackOptionalGlobalAttributeFeatureMap_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t featureMap)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t featureMap)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t featureMap)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_3(featureMap);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_4(featureMap);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_5(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 3U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1(uint16_t clusterRevision) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeFeatureMap(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t featureMapArgument = 0UL;

        return cluster.WriteAttributeFeatureMap(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel(), featureMapArgument);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4(uint32_t featureMap) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalGlobalAttributeFeatureMap_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeFeatureMap(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }
};

class Test_TC_OO_2_1 : public TestCommand
{
public:
    Test_TC_OO_2_1() : TestCommand("Test_TC_OO_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: OnOff\n");
            err = TestReadTheMandatoryAttributeOnOff_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads back mandatory attribute: OnOff\n");
            err = TestReadsBackMandatoryAttributeOnOff_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read LT attribute: GlobalSceneControl\n");
            err = TestReadLtAttributeGlobalSceneControl_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read LT attribute: OnTime\n");
            err = TestReadLtAttributeOnTime_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read LT attribute: OffWaitTime\n");
            err = TestReadLtAttributeOffWaitTime_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read LT attribute: StartUpOnOff\n");
            err = TestReadLtAttributeStartUpOnOff_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : write the default value to LT attribute: OnTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOnTime_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write the default value to LT attribute: OffWaitTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOffWaitTime_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default value to LT attribute: StartUpOnOff\n");
            err = TestWriteTheDefaultValueToLtAttributeStartUpOnOff_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads back LT attribute: OnTime\n");
            err = TestReadsBackLtAttributeOnTime_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads back LT attribute: OffWaitTime\n");
            err = TestReadsBackLtAttributeOffWaitTime_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads back LT attribute: StartUpOnOff\n");
            err = TestReadsBackLtAttributeStartUpOnOff_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, bool globalSceneControl)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t startUpOnOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t startUpOnOff)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t startUpOnOff)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_0(onOff);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_2(globalSceneControl);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_3(onTime);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_4(offWaitTime);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_5(startUpOnOff);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_6(onTime);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_7(offWaitTime);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_8(startUpOnOff);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_9(onTime);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_10(offWaitTime);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_11(startUpOnOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeOnOff_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeOnOff_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeGlobalSceneControl_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeGlobalSceneControl(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOnTime_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOffWaitTime_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeStartUpOnOff_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStartUpOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startUpOnOff", startUpOnOff, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOnTime_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t onTimeArgument = 0U;

        return cluster.WriteAttributeOnTime(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel(), onTimeArgument);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint16_t onTime) { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOffWaitTime_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t offWaitTimeArgument = 0U;

        return cluster.WriteAttributeOffWaitTime(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel(), offWaitTimeArgument);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t offWaitTime) { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeStartUpOnOff_8()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t startUpOnOffArgument = 0;

        return cluster.WriteAttributeStartUpOnOff(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel(),
                                                  startUpOnOffArgument);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t startUpOnOff) { NextTest(); }

    CHIP_ERROR TestReadsBackLtAttributeOnTime_9()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeOffWaitTime_10()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeStartUpOnOff_11()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStartUpOnOff(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startUpOnOff", startUpOnOff, 0));
        NextTest();
    }
};

class Test_TC_OO_2_2 : public TestCommand
{
public:
    Test_TC_OO_2_2() : TestCommand("Test_TC_OO_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Off Command\n");
            err = TestSendOffCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send On Command\n");
            err = TestSendOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Off Command\n");
            err = TestSendOffCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Send Toggle Command\n");
            err = TestSendToggleCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is true after toggle command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Send Toggle Command\n");
            err = TestSendToggleCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after toggle command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Send On Command\n");
            err = TestSendOnCommand_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Send Off Command\n");
            err = TestSendOffCommand_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_13{ OnSuccessCallback_13, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_3(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_9(onOff);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_11(onOff);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_13(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendOffCommand_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Toggle::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Toggle::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_8()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Toggle::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Toggle::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_9()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_10()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_10(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_11()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_12()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_12(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_13()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_PCC_1_1 : public TestCommand
{
public:
    Test_TC_PCC_1_1() : TestCommand("Test_TC_PCC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 3U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_PCC_2_1 : public TestCommand
{
public:
    Test_TC_PCC_2_1() : TestCommand("Test_TC_PCC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, int16_t maxPressure)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveOperationMode)> mOnSuccessCallback_1{ OnSuccessCallback_1,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveControlMode)> mOnSuccessCallback_2{ OnSuccessCallback_2,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, int16_t capacity)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, int16_t maxPressure)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveOperationMode)> mOnSuccessCallback_5{ OnSuccessCallback_5,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveControlMode)> mOnSuccessCallback_6{ OnSuccessCallback_6,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, int16_t capacity)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_0(maxPressure);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_1(effectiveOperationMode);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_2(effectiveControlMode);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_3(capacity);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_4(maxPressure);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_5(effectiveOperationMode);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_6(effectiveControlMode);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_7(capacity);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_0()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxPressure(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_1()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveOperationMode(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_2()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveControlMode(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_3()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCapacity(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_4()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxPressure(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_5()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveOperationMode(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_6()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveControlMode(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_7()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCapacity(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
        NextTest();
    }
};

class Test_TC_RH_1_1 : public TestCommand
{
public:
    Test_TC_RH_1_1() : TestCommand("Test_TC_RH_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_RH_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_RH_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 1U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_TM_1_1 : public TestCommand
{
public:
    Test_TC_TM_1_1() : TestCommand("Test_TC_TM_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 3U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1(uint16_t clusterRevision) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }
};

class Test_TC_TM_2_1 : public TestCommand
{
public:
    Test_TC_TM_2_1() : TestCommand("Test_TC_TM_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_0()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
        NextTest();
    }
};

class Test_TC_TSTAT_1_1 : public TestCommand
{
public:
    Test_TC_TSTAT_1_1() : TestCommand("Test_TC_TSTAT_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 5U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_TSUIC_1_1 : public TestCommand
{
public:
    Test_TC_TSUIC_1_1() : TestCommand("Test_TC_TSUIC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 2U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0(uint16_t clusterRevision) { ThrowSuccessResponse(); }
};

class Test_TC_TSUIC_2_1 : public TestCommand
{
public:
    Test_TC_TSUIC_2_1() : TestCommand("Test_TC_TSUIC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : write to the mandatory attribute: TemperatureDisplayMode\n");
            err = TestWriteToTheMandatoryAttributeTemperatureDisplayMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write to the mandatory attribute: KeypadLockout\n");
            err = TestWriteToTheMandatoryAttributeKeypadLockout_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : write to the mandatory attribute: ScheduleProgrammingVisibility\n");
            err = TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_0{ OnSuccessCallback_0,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_1{ OnSuccessCallback_1,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_2{ OnSuccessCallback_2,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_3{ OnSuccessCallback_3,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_4{ OnSuccessCallback_4,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_10{
        OnSuccessCallback_10, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_11{
        OnSuccessCallback_11, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_12{
        OnSuccessCallback_12, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_13{
        OnSuccessCallback_13, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_14{ OnFailureCallback_14, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_14{
        OnSuccessCallback_14, this
    };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_0(temperatureDisplayMode);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_1(temperatureDisplayMode);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_2(temperatureDisplayMode);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_3(temperatureDisplayMode);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_4(temperatureDisplayMode);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_5(keypadLockout);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_6(keypadLockout);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_7(keypadLockout);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_8(keypadLockout);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_9(keypadLockout);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_10(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_11(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_12(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_13(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_14(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_14(status);
    }

    static void OnSuccessCallback_14(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_14(scheduleProgrammingVisibility);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_0()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTemperatureDisplayMode(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("temperatureDisplayMode", temperatureDisplayMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_1()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTemperatureDisplayMode(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeTemperatureDisplayMode_2()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t temperatureDisplayModeArgument = 0;

        return cluster.WriteAttributeTemperatureDisplayMode(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel(),
                                                            temperatureDisplayModeArgument);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t temperatureDisplayMode) { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_3()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTemperatureDisplayMode(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("temperatureDisplayMode", temperatureDisplayMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_4()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTemperatureDisplayMode(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_5()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeKeypadLockout(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue<uint8_t>("keypadLockout", keypadLockout, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_6()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeKeypadLockout(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeKeypadLockout_7()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t keypadLockoutArgument = 0;

        return cluster.WriteAttributeKeypadLockout(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel(),
                                                   keypadLockoutArgument);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t keypadLockout) { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_8()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeKeypadLockout(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue<uint8_t>("keypadLockout", keypadLockout, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_9()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeKeypadLockout(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_10()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeScheduleProgrammingVisibility(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue<uint8_t>("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_11()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeScheduleProgrammingVisibility(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_12()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t scheduleProgrammingVisibilityArgument = 0;

        return cluster.WriteAttributeScheduleProgrammingVisibility(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel(),
                                                                   scheduleProgrammingVisibilityArgument);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t scheduleProgrammingVisibility) { NextTest(); }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_13()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeScheduleProgrammingVisibility(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue<uint8_t>("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_14()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeScheduleProgrammingVisibility(mOnSuccessCallback_14.Cancel(), mOnFailureCallback_14.Cancel());
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
        NextTest();
    }
};

class Test_TC_DIAGTH_1_1 : public TestCommand
{
public:
    Test_TC_DIAGTH_1_1() : TestCommand("Test_TC_DIAGTH_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGTH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGTH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        uint16_t clusterRevisionArgument = 1U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1(uint16_t clusterRevision) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }
};

class Test_TC_WNCV_1_1 : public TestCommand
{
public:
    Test_TC_WNCV_1_1() : TestCommand("Test_TC_WNCV_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default value to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValueToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 5U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument = 5U;

        return cluster.WriteAttributeClusterRevision(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel(),
                                                     clusterRevisionArgument);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1(uint16_t clusterRevision) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 5U));
        NextTest();
    }
};

class Test_TC_WNCV_2_1 : public TestCommand
{
public:
    Test_TC_WNCV_2_1() : TestCommand("Test_TC_WNCV_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the RO mandatory attribute default: Type\n");
            err = TestReadTheRoMandatoryAttributeDefaultType_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads back the RO mandatory attribute: Type\n");
            err = TestReadsBackTheRoMandatoryAttributeType_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the RO mandatory attribute default: ConfigStatus\n");
            err = TestReadTheRoMandatoryAttributeDefaultConfigStatus_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : reads back the RO mandatory attribute: ConfigStatus\n");
            err = TestReadsBackTheRoMandatoryAttributeConfigStatus_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the RO mandatory attribute default: OperationalStatus\n");
            err = TestReadTheRoMandatoryAttributeDefaultOperationalStatus_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads back the RO mandatory attribute: OperationalStatus\n");
            err = TestReadsBackTheRoMandatoryAttributeOperationalStatus_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the RO mandatory attribute default: EndProductType\n");
            err = TestReadTheRoMandatoryAttributeDefaultEndProductType_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : reads back the RO mandatory attribute: EndProductType\n");
            err = TestReadsBackTheRoMandatoryAttributeEndProductType_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the RW mandatory attribute default: Mode\n");
            err = TestReadTheRwMandatoryAttributeDefaultMode_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : write a value into the RW mandatory attribute:: Mode\n");
            err = TestWriteAValueIntoTheRwMandatoryAttributeMode_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads back the RW mandatory attribute: Mode\n");
            err = TestReadsBackTheRwMandatoryAttributeMode_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t type)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t type)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t configStatus)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t configStatus)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t endProductType)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t endProductType)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t mode)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t mode)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t mode)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_0(type);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_1(type);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_2(configStatus);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_3(configStatus);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_4(operationalStatus);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_5(operationalStatus);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_6(endProductType);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_7(endProductType);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_8(mode);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_9(mode);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_10(mode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultType_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeType(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t type)
    {
        VerifyOrReturn(CheckValue<uint8_t>("type", type, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeType_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeType(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t type)
    {
        VerifyOrReturn(CheckValue<uint8_t>("type", type, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultConfigStatus_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeConfigStatus(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t configStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("configStatus", configStatus, 3));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeConfigStatus_3()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeConfigStatus(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t configStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("configStatus", configStatus, 3));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultOperationalStatus_4()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeOperationalStatus_5()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultEndProductType_6()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEndProductType(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("endProductType", endProductType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeEndProductType_7()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEndProductType(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("endProductType", endProductType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRwMandatoryAttributeDefaultMode_8()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMode(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t mode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mode", mode, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAValueIntoTheRwMandatoryAttributeMode_9()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t modeArgument = 7;

        return cluster.WriteAttributeMode(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel(), modeArgument);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t mode) { NextTest(); }

    CHIP_ERROR TestReadsBackTheRwMandatoryAttributeMode_10()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMode(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t mode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mode", mode, 7));
        NextTest();
    }
};

class Test_TC_WNCV_3_1 : public TestCommand
{
public:
    Test_TC_WNCV_3_1() : TestCommand("Test_TC_WNCV_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-open position\n");
            err = Test1aThAdjustsTheTheDutToANonOpenPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends UpOrOpen command to DUT\n");
            err = Test2aThSendsUpOrOpenCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: TH reads OperationalStatus attribute from DUT\n");
            err = Test3aThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonOpenPosition_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsUpOrOpenCommandToDut_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test3aThReadsOperationalStatusAttributeFromDut_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class Test_TC_WNCV_3_2 : public TestCommand
{
public:
    Test_TC_WNCV_3_2() : TestCommand("Test_TC_WNCV_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-closed position\n");
            err = Test1aThAdjustsTheTheDutToANonClosedPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends DownOrClose command to DUT\n");
            err = Test2aThSendsDownOrCloseCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: TH reads OperationalStatus attribute from DUT\n");
            err = Test3aThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonClosedPosition_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsDownOrCloseCommandToDut_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test3aThReadsOperationalStatusAttributeFromDut_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class Test_TC_WNCV_3_3 : public TestCommand
{
public:
    Test_TC_WNCV_3_3() : TestCommand("Test_TC_WNCV_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-open position\n");
            err = Test1aThAdjustsTheTheDutToANonOpenPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends StopMotion command to DUT\n");
            err = Test2aThSendsStopMotionCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 2b: TH reads OperationalStatus attribute from DUT\n");
            err = Test2bThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonOpenPosition_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsStopMotionCommandToDut_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::StopMotion::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::StopMotion::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test2bThReadsOperationalStatusAttributeFromDut_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class TV_TargetNavigatorCluster : public TestCommand
{
public:
    TV_TargetNavigatorCluster() : TestCommand("TV_TargetNavigatorCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TargetNavigatorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TargetNavigatorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Target Navigator list\n");
            err = TestReadAttributeTargetNavigatorList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Navigate Target Command\n");
            err = TestNavigateTargetCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_TargetNavigatorCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)
    {
        (static_cast<TV_TargetNavigatorCluster *>(context))->OnSuccessResponse_0(targetNavigatorList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeTargetNavigatorList_0()
    {
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTargetNavigatorList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)
    {
        VerifyOrReturn(CheckValueAsListLength("targetNavigatorList", targetNavigatorList, 2));
        NextTest();
    }

    CHIP_ERROR TestNavigateTargetCommand_1()
    {
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type;
        using responseType = chip::app::Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType;

        chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type request;
        request.target = 1;
        request.data   = chip::Span<const char>("1", strlen("1"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_TargetNavigatorCluster *>(context))->OnSuccessResponse_1(data.status, data.data);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TargetNavigatorCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::TargetNavigator::NavigateTargetStatus status, chip::CharSpan data) { NextTest(); }
};

class TV_AudioOutputCluster : public TestCommand
{
public:
    TV_AudioOutputCluster() : TestCommand("TV_AudioOutputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AudioOutputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AudioOutputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Audio Output list\n");
            err = TestReadAttributeAudioOutputList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Select Output Command\n");
            err = TestSelectOutputCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Rename Output Command\n");
            err = TestRenameOutputCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)
    {
        (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_0(audioOutputList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeAudioOutputList_0()
    {
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevice, 2);

        return cluster.ReadAttributeAudioOutputList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)
    {
        VerifyOrReturn(CheckValueAsListLength("audioOutputList", audioOutputList, 3));
        NextTest();
    }

    CHIP_ERROR TestSelectOutputCommand_1()
    {
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevice, 2);

        using requestType  = chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type request;
        request.index = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestRenameOutputCommand_2()
    {
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevice, 2);

        using requestType  = chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type request;
        request.index = 1;
        request.name  = chip::Span<const char>("exampleName", strlen("exampleName"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class TV_ApplicationLauncherCluster : public TestCommand
{
public:
    TV_ApplicationLauncherCluster() : TestCommand("TV_ApplicationLauncherCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationLauncherCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationLauncherCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Application Launcher list\n");
            err = TestReadAttributeApplicationLauncherList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Launch App Command\n");
            err = TestLaunchAppCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute catalog vendor id\n");
            err = TestReadAttributeCatalogVendorId_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute application id\n");
            err = TestReadAttributeApplicationId_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context,
                                      const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t catalogVendorId)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t applicationId)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_0(applicationLauncherList);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t catalogVendorId)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_2(catalogVendorId);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t applicationId)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_3(applicationId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeApplicationLauncherList_0()
    {
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeApplicationLauncherList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)
    {
        VerifyOrReturn(CheckValueAsListLength("applicationLauncherList", applicationLauncherList, 2));
        NextTest();
    }

    CHIP_ERROR TestLaunchAppCommand_1()
    {
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type;
        using responseType = chip::app::Clusters::ApplicationLauncher::Commands::LaunchAppResponse::DecodableType;

        chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type request;
        request.data            = chip::Span<const char>("exampleData", strlen("exampleData"));
        request.catalogVendorId = 1U;
        request.applicationId   = chip::Span<const char>("appId", strlen("appId"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_1(data.status, data.data);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::ApplicationLauncher::ApplicationLauncherStatus status, chip::CharSpan data)
    {

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCatalogVendorId_2()
    {
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCatalogVendorId(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t catalogVendorId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("catalogVendorId", catalogVendorId, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationId_3()
    {
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeApplicationId(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t applicationId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("applicationId", applicationId, 0));
        NextTest();
    }
};

class TV_KeypadInputCluster : public TestCommand
{
public:
    TV_KeypadInputCluster() : TestCommand("TV_KeypadInputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_KeypadInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_KeypadInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Key Command\n");
            err = TestSendKeyCommand_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendKeyCommand_0()
    {
        chip::Controller::KeypadInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::KeypadInput::Commands::SendKey::Type;
        using responseType = chip::app::Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType;

        chip::app::Clusters::KeypadInput::Commands::SendKey::Type request;
        request.keyCode = static_cast<chip::app::Clusters::KeypadInput::KeypadInputCecKeyCode>(3);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_KeypadInputCluster *>(context))->OnSuccessResponse_0(data.status);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_KeypadInputCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::app::Clusters::KeypadInput::KeypadInputStatus status) { NextTest(); }
};

class TV_AccountLoginCluster : public TestCommand
{
public:
    TV_AccountLoginCluster() : TestCommand("TV_AccountLoginCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AccountLoginCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AccountLoginCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Get Setup PIN Command\n");
            err = TestGetSetupPinCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Login Command\n");
            err = TestLoginCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    //
    // Tests methods
    //

    CHIP_ERROR TestGetSetupPinCommand_0()
    {
        chip::Controller::AccountLoginClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type;
        using responseType = chip::app::Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType;

        chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type request;
        request.tempAccountIdentifier = chip::Span<const char>("asdf", strlen("asdf"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnSuccessResponse_0(data.setupPIN);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::CharSpan setupPIN) { NextTest(); }

    CHIP_ERROR TestLoginCommand_1()
    {
        chip::Controller::AccountLoginClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::AccountLogin::Commands::Login::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::AccountLogin::Commands::Login::Type request;
        request.tempAccountIdentifier = chip::Span<const char>("asdf", strlen("asdf"));
        request.setupPIN              = chip::Span<const char>("tempPin123", strlen("tempPin123"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }
};

class TV_WakeOnLanCluster : public TestCommand
{
public:
    TV_WakeOnLanCluster() : TestCommand("TV_WakeOnLanCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_WakeOnLanCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_WakeOnLanCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read mac address\n");
            err = TestReadMacAddress_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan wakeOnLanMacAddress)> mOnSuccessCallback_0{
        OnSuccessCallback_0, this
    };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_WakeOnLanCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, chip::CharSpan wakeOnLanMacAddress)
    {
        (static_cast<TV_WakeOnLanCluster *>(context))->OnSuccessResponse_0(wakeOnLanMacAddress);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadMacAddress_0()
    {
        chip::Controller::WakeOnLanClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeWakeOnLanMacAddress(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::CharSpan wakeOnLanMacAddress)
    {
        VerifyOrReturn(CheckValueAsString("wakeOnLanMacAddress", wakeOnLanMacAddress, "00:00:00:00:00"));
        NextTest();
    }
};

class TV_ApplicationBasicCluster : public TestCommand
{
public:
    TV_ApplicationBasicCluster() : TestCommand("TV_ApplicationBasicCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationBasicCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationBasicCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Change Status Command\n");
            err = TestChangeStatusCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute vendor id\n");
            err = TestReadAttributeVendorId_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute product id\n");
            err = TestReadAttributeProductId_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute catalog vendor id\n");
            err = TestReadAttributeCatalogVendorId_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t vendorId)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t productId)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t catalogVendorId)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t vendorId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_1(vendorId);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t productId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_2(productId);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint16_t catalogVendorId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_3(catalogVendorId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestChangeStatusCommand_0()
    {
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type request;
        request.status = static_cast<chip::app::Clusters::ApplicationBasic::ApplicationBasicStatus>(1);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorId_1()
    {
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, 3);

        return cluster.ReadAttributeVendorId(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t vendorId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("vendorId", vendorId, 1U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeProductId_2()
    {
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, 3);

        return cluster.ReadAttributeProductId(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t productId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("productId", productId, 1U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeCatalogVendorId_3()
    {
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, 3);

        return cluster.ReadAttributeCatalogVendorId(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t catalogVendorId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("catalogVendorId", catalogVendorId, 1U));
        NextTest();
    }
};

class TV_MediaPlaybackCluster : public TestCommand
{
public:
    TV_MediaPlaybackCluster() : TestCommand("TV_MediaPlaybackCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaPlaybackCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaPlaybackCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Media Playback Play Command\n");
            err = TestMediaPlaybackPlayCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Media Playback Pause Command\n");
            err = TestMediaPlaybackPauseCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Media Playback Stop Command\n");
            err = TestMediaPlaybackStopCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Media Playback Start Over Command\n");
            err = TestMediaPlaybackStartOverCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Media Playback Previous Command\n");
            err = TestMediaPlaybackPreviousCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Media Playback Next Command\n");
            err = TestMediaPlaybackNextCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Media Playback Rewind Command\n");
            err = TestMediaPlaybackRewindCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Media Playback Fast Forward Command\n");
            err = TestMediaPlaybackFastForwardCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Media Playback Skip Forward Command\n");
            err = TestMediaPlaybackSkipForwardCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Media Playback Skip Backward Command\n");
            err = TestMediaPlaybackSkipBackwardCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Media Playback Seek Command\n");
            err = TestMediaPlaybackSeekCommand_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    //
    // Tests methods
    //

    CHIP_ERROR TestMediaPlaybackPlayCommand_0()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaPlayResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_0(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPauseCommand_1()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaPauseResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_1(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStopCommand_2()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaStopResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_2(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStartOverCommand_3()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaStartOverResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_3(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPreviousCommand_4()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaPreviousResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_4(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackNextCommand_5()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaNextResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_5(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackRewindCommand_6()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaRewindResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_6(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackFastForwardCommand_7()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaFastForwardResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_7(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipForwardCommand_8()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaSkipForwardResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_8(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipBackwardCommand_9()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackwardResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_9(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_9(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSeekCommand_10()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaSeekResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type request;
        request.position = 100ULL;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_10(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_10(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }
};

class TV_TvChannelCluster : public TestCommand
{
public:
    TV_TvChannelCluster() : TestCommand("TV_TvChannelCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TvChannelCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TvChannelCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute TV Channel list\n");
            err = TestReadAttributeTvChannelList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Change Channel By Number Command\n");
            err = TestChangeChannelByNumberCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Skip Channel Command\n");
            err = TestSkipChannelCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context,
                                      const chip::app::DataModel::DecodableList<
                                          chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> & tvChannelList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> &
            tvChannelList)
    {
        (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_0(tvChannelList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeTvChannelList_0()
    {
        chip::Controller::TvChannelClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTvChannelList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> &
            tvChannelList)
    {
        VerifyOrReturn(CheckValueAsListLength("tvChannelList", tvChannelList, 2));
        NextTest();
    }

    CHIP_ERROR TestChangeChannelByNumberCommand_1()
    {
        chip::Controller::TvChannelClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type request;
        request.majorNumber = 1U;
        request.minorNumber = 2U;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestSkipChannelCommand_2()
    {
        chip::Controller::TvChannelClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TvChannel::Commands::SkipChannel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TvChannel::Commands::SkipChannel::Type request;
        request.count = 1U;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class TV_LowPowerCluster : public TestCommand
{
public:
    TV_LowPowerCluster() : TestCommand("TV_LowPowerCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_LowPowerCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_LowPowerCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Sleep Input Status Command\n");
            err = TestSleepInputStatusCommand_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestSleepInputStatusCommand_0()
    {
        chip::Controller::LowPowerClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LowPower::Commands::Sleep::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LowPower::Commands::Sleep::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_LowPowerCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_LowPowerCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }
};

class TV_MediaInputCluster : public TestCommand
{
public:
    TV_MediaInputCluster() : TestCommand("TV_MediaInputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute media input list\n");
            err = TestReadAttributeMediaInputList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Select Input Command\n");
            err = TestSelectInputCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read current input list\n");
            err = TestReadCurrentInputList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Hide Input Status Command\n");
            err = TestHideInputStatusCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Show Input Status Command\n");
            err = TestShowInputStatusCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Rename Input Command\n");
            err = TestRenameInputCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentMediaInput)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_0(mediaInputList);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t currentMediaInput)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_2(currentMediaInput);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeMediaInputList_0()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMediaInputList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)
    {
        VerifyOrReturn(CheckValueAsListLength("mediaInputList", mediaInputList, 2));
        NextTest();
    }

    CHIP_ERROR TestSelectInputCommand_1()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::MediaInput::Commands::SelectInput::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::MediaInput::Commands::SelectInput::Type request;
        request.index = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadCurrentInputList_2()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentMediaInput(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t currentMediaInput)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentMediaInput", currentMediaInput, 1));
        NextTest();
    }

    CHIP_ERROR TestHideInputStatusCommand_3()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestShowInputStatusCommand_4()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestRenameInputCommand_5()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::MediaInput::Commands::RenameInput::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::MediaInput::Commands::RenameInput::Type request;
        request.index = 1;
        request.name  = chip::Span<const char>("newName", strlen("newName"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }
};

class TestCluster : public TestCommand
{
public:
    TestCluster() : TestCommand("TestCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Test Command\n");
            err = TestSendTestCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Not Handled Command\n");
            err = TestSendTestNotHandledCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Specific Command\n");
            err = TestSendTestSpecificCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send failing Test Add Arguments Command\n");
            err = TestSendFailingTestAddArgumentsCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write attribute BOOLEAN True\n");
            err = TestWriteAttributeBooleanTrue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute BOOLEAN True\n");
            err = TestReadAttributeBooleanTrue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write attribute BOOLEAN False\n");
            err = TestWriteAttributeBooleanFalse_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write attribute BITMAP8 Max Value\n");
            err = TestWriteAttributeBitmap8MaxValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read attribute BITMAP8 Max Value\n");
            err = TestReadAttributeBitmap8MaxValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Write attribute BITMAP8 Min Value\n");
            err = TestWriteAttributeBitmap8MinValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read attribute BITMAP8 Min Value\n");
            err = TestReadAttributeBitmap8MinValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Write attribute BITMAP16 Max Value\n");
            err = TestWriteAttributeBitmap16MaxValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read attribute BITMAP16 Max Value\n");
            err = TestReadAttributeBitmap16MaxValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Write attribute BITMAP16 Min Value\n");
            err = TestWriteAttributeBitmap16MinValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute BITMAP16 Min Value\n");
            err = TestReadAttributeBitmap16MinValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write attribute BITMAP32 Max Value\n");
            err = TestWriteAttributeBitmap32MaxValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read attribute BITMAP32 Max Value\n");
            err = TestReadAttributeBitmap32MaxValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Write attribute BITMAP32 Min Value\n");
            err = TestWriteAttributeBitmap32MinValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read attribute BITMAP32 Min Value\n");
            err = TestReadAttributeBitmap32MinValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Write attribute BITMAP64 Max Value\n");
            err = TestWriteAttributeBitmap64MaxValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read attribute BITMAP64 Max Value\n");
            err = TestReadAttributeBitmap64MaxValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Write attribute BITMAP64 Min Value\n");
            err = TestWriteAttributeBitmap64MinValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read attribute BITMAP64 Min Value\n");
            err = TestReadAttributeBitmap64MinValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Write attribute INT8U Max Value\n");
            err = TestWriteAttributeInt8uMaxValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read attribute INT8U Max Value\n");
            err = TestReadAttributeInt8uMaxValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Write attribute INT8U Min Value\n");
            err = TestWriteAttributeInt8uMinValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read attribute INT8U Min Value\n");
            err = TestReadAttributeInt8uMinValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Write attribute INT16U Max Value\n");
            err = TestWriteAttributeInt16uMaxValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read attribute INT16U Max Value\n");
            err = TestReadAttributeInt16uMaxValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Write attribute INT16U Min Value\n");
            err = TestWriteAttributeInt16uMinValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read attribute INT16U Min Value\n");
            err = TestReadAttributeInt16uMinValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Write attribute INT32U Max Value\n");
            err = TestWriteAttributeInt32uMaxValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Read attribute INT32U Max Value\n");
            err = TestReadAttributeInt32uMaxValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Write attribute INT32U Min Value\n");
            err = TestWriteAttributeInt32uMinValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read attribute INT32U Min Value\n");
            err = TestReadAttributeInt32uMinValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Write attribute INT64U Max Value\n");
            err = TestWriteAttributeInt64uMaxValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Read attribute INT64U Max Value\n");
            err = TestReadAttributeInt64uMaxValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Write attribute INT64U Min Value\n");
            err = TestWriteAttributeInt64uMinValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read attribute INT64U Min Value\n");
            err = TestReadAttributeInt64uMinValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Write attribute INT8S Max Value\n");
            err = TestWriteAttributeInt8sMaxValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Read attribute INT8S Max Value\n");
            err = TestReadAttributeInt8sMaxValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Write attribute INT8S Min Value\n");
            err = TestWriteAttributeInt8sMinValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Read attribute INT8S Min Value\n");
            err = TestReadAttributeInt8sMinValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Write attribute INT16S Max Value\n");
            err = TestWriteAttributeInt16sMaxValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read attribute INT16S Max Value\n");
            err = TestReadAttributeInt16sMaxValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Write attribute INT16S Min Value\n");
            err = TestWriteAttributeInt16sMinValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Read attribute INT16S Min Value\n");
            err = TestReadAttributeInt16sMinValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write attribute INT32S Max Value\n");
            err = TestWriteAttributeInt32sMaxValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read attribute INT32S Max Value\n");
            err = TestReadAttributeInt32sMaxValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write attribute INT32S Min Value\n");
            err = TestWriteAttributeInt32sMinValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read attribute INT32S Min Value\n");
            err = TestReadAttributeInt32sMinValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Write attribute INT64S Max Value\n");
            err = TestWriteAttributeInt64sMaxValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read attribute INT64S Max Value\n");
            err = TestReadAttributeInt64sMaxValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Write attribute INT64S Min Value\n");
            err = TestWriteAttributeInt64sMinValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Read attribute INT64S Min Value\n");
            err = TestReadAttributeInt64sMinValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Write attribute ENUM8 Max Value\n");
            err = TestWriteAttributeEnum8MaxValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Read attribute ENUM8 Max Value\n");
            err = TestReadAttributeEnum8MaxValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Write attribute ENUM8 Min Value\n");
            err = TestWriteAttributeEnum8MinValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read attribute ENUM8 Min Value\n");
            err = TestReadAttributeEnum8MinValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write attribute ENUM16 Max Value\n");
            err = TestWriteAttributeEnum16MaxValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read attribute ENUM16 Max Value\n");
            err = TestReadAttributeEnum16MaxValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Write attribute ENUM16 Min Value\n");
            err = TestWriteAttributeEnum16MinValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read attribute ENUM16 Min Value\n");
            err = TestReadAttributeEnum16MinValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute OCTET_STRING Default Value\n");
            err = TestReadAttributeOctetStringDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute LONG_OCTET_STRING Default Value\n");
            err = TestReadAttributeLongOctetStringDefaultValue_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read attribute LONG_OCTET_STRING\n");
            err = TestReadAttributeLongOctetString_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Read attribute CHAR_STRING Default Value\n");
            err = TestReadAttributeCharStringDefaultValue_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Write attribute CHAR_STRING\n");
            err = TestWriteAttributeCharString_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Write attribute CHAR_STRING - Value too long\n");
            err = TestWriteAttributeCharStringValueTooLong_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write attribute CHAR_STRING - Empty\n");
            err = TestWriteAttributeCharStringEmpty_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute LONG_CHAR_STRING Default Value\n");
            err = TestReadAttributeLongCharStringDefaultValue_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read attribute LONG_CHAR_STRING\n");
            err = TestReadAttributeLongCharString_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read attribute LIST\n");
            err = TestReadAttributeList_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read attribute LIST_OCTET_STRING\n");
            err = TestReadAttributeListOctetString_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Read attribute LIST_STRUCT_OCTET_STRING\n");
            err = TestReadAttributeListStructOctetString_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Write attribute EPOCH_US Max Value\n");
            err = TestWriteAttributeEpochUsMaxValue_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read attribute EPOCH_US Max Value\n");
            err = TestReadAttributeEpochUsMaxValue_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Write attribute EPOCH_US Min Value\n");
            err = TestWriteAttributeEpochUsMinValue_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read attribute EPOCH_US Min Value\n");
            err = TestReadAttributeEpochUsMinValue_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Write attribute EPOCH_S Max Value\n");
            err = TestWriteAttributeEpochSMaxValue_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Read attribute EPOCH_S Max Value\n");
            err = TestReadAttributeEpochSMaxValue_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Write attribute EPOCH_S Min Value\n");
            err = TestWriteAttributeEpochSMinValue_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Read attribute EPOCH_S Min Value\n");
            err = TestReadAttributeEpochSMinValue_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read attribute UNSUPPORTED\n");
            err = TestReadAttributeUnsupported_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Writeattribute UNSUPPORTED\n");
            err = TestWriteattributeUnsupported_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Send Test Command to unsupported endpoint\n");
            err = TestSendTestCommandToUnsupportedEndpoint_121();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 122;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool boolean)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, bool boolean)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool boolean)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, bool boolean)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, bool boolean)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t bitmap8)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t bitmap8)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t bitmap8)> mOnSuccessCallback_12{ OnSuccessCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t bitmap8)> mOnSuccessCallback_13{ OnSuccessCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_14{ OnFailureCallback_14, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t bitmap8)> mOnSuccessCallback_14{ OnSuccessCallback_14, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t bitmap16)> mOnSuccessCallback_15{ OnSuccessCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_16{ OnFailureCallback_16, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t bitmap16)> mOnSuccessCallback_16{ OnSuccessCallback_16, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_17{ OnFailureCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t bitmap16)> mOnSuccessCallback_17{ OnSuccessCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_18{ OnFailureCallback_18, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t bitmap16)> mOnSuccessCallback_18{ OnSuccessCallback_18, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_19{ OnFailureCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t bitmap16)> mOnSuccessCallback_19{ OnSuccessCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_20{ OnFailureCallback_20, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t bitmap32)> mOnSuccessCallback_20{ OnSuccessCallback_20, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_21{ OnFailureCallback_21, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t bitmap32)> mOnSuccessCallback_21{ OnSuccessCallback_21, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_22{ OnFailureCallback_22, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t bitmap32)> mOnSuccessCallback_22{ OnSuccessCallback_22, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_23{ OnFailureCallback_23, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t bitmap32)> mOnSuccessCallback_23{ OnSuccessCallback_23, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_24{ OnFailureCallback_24, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t bitmap32)> mOnSuccessCallback_24{ OnSuccessCallback_24, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_25{ OnFailureCallback_25, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t bitmap64)> mOnSuccessCallback_25{ OnSuccessCallback_25, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_26{ OnFailureCallback_26, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t bitmap64)> mOnSuccessCallback_26{ OnSuccessCallback_26, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_27{ OnFailureCallback_27, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t bitmap64)> mOnSuccessCallback_27{ OnSuccessCallback_27, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_28{ OnFailureCallback_28, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t bitmap64)> mOnSuccessCallback_28{ OnSuccessCallback_28, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_29{ OnFailureCallback_29, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t bitmap64)> mOnSuccessCallback_29{ OnSuccessCallback_29, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_30{ OnFailureCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t int8u)> mOnSuccessCallback_30{ OnSuccessCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_31{ OnFailureCallback_31, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t int8u)> mOnSuccessCallback_31{ OnSuccessCallback_31, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_32{ OnFailureCallback_32, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t int8u)> mOnSuccessCallback_32{ OnSuccessCallback_32, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_33{ OnFailureCallback_33, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t int8u)> mOnSuccessCallback_33{ OnSuccessCallback_33, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_34{ OnFailureCallback_34, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t int8u)> mOnSuccessCallback_34{ OnSuccessCallback_34, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_35{ OnFailureCallback_35, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t int16u)> mOnSuccessCallback_35{ OnSuccessCallback_35, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_36{ OnFailureCallback_36, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t int16u)> mOnSuccessCallback_36{ OnSuccessCallback_36, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_37{ OnFailureCallback_37, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t int16u)> mOnSuccessCallback_37{ OnSuccessCallback_37, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_38{ OnFailureCallback_38, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t int16u)> mOnSuccessCallback_38{ OnSuccessCallback_38, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_39{ OnFailureCallback_39, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t int16u)> mOnSuccessCallback_39{ OnSuccessCallback_39, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_40{ OnFailureCallback_40, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_40{ OnSuccessCallback_40, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_41{ OnFailureCallback_41, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_41{ OnSuccessCallback_41, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_42{ OnFailureCallback_42, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_42{ OnSuccessCallback_42, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_43{ OnFailureCallback_43, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_43{ OnSuccessCallback_43, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_44{ OnFailureCallback_44, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_44{ OnSuccessCallback_44, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_45{ OnFailureCallback_45, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t int64u)> mOnSuccessCallback_45{ OnSuccessCallback_45, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_46{ OnFailureCallback_46, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t int64u)> mOnSuccessCallback_46{ OnSuccessCallback_46, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_47{ OnFailureCallback_47, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t int64u)> mOnSuccessCallback_47{ OnSuccessCallback_47, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_48{ OnFailureCallback_48, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t int64u)> mOnSuccessCallback_48{ OnSuccessCallback_48, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_49{ OnFailureCallback_49, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t int64u)> mOnSuccessCallback_49{ OnSuccessCallback_49, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_50{ OnFailureCallback_50, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_50{ OnSuccessCallback_50, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_51{ OnFailureCallback_51, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_51{ OnSuccessCallback_51, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_52{ OnFailureCallback_52, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_52{ OnSuccessCallback_52, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_53{ OnFailureCallback_53, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_53{ OnSuccessCallback_53, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_54{ OnFailureCallback_54, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_54{ OnSuccessCallback_54, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_55{ OnFailureCallback_55, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_55{ OnSuccessCallback_55, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_56{ OnFailureCallback_56, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_56{ OnSuccessCallback_56, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_57{ OnFailureCallback_57, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_57{ OnSuccessCallback_57, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_58{ OnFailureCallback_58, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_58{ OnSuccessCallback_58, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_59{ OnFailureCallback_59, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_59{ OnSuccessCallback_59, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_60{ OnFailureCallback_60, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_60{ OnSuccessCallback_60, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_61{ OnFailureCallback_61, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_61{ OnSuccessCallback_61, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_62{ OnFailureCallback_62, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_62{ OnSuccessCallback_62, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_63{ OnFailureCallback_63, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_63{ OnSuccessCallback_63, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_64{ OnFailureCallback_64, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_64{ OnSuccessCallback_64, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_65{ OnFailureCallback_65, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_65{ OnSuccessCallback_65, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_66{ OnFailureCallback_66, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_66{ OnSuccessCallback_66, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_67{ OnFailureCallback_67, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_67{ OnSuccessCallback_67, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_68{ OnFailureCallback_68, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_68{ OnSuccessCallback_68, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_69{ OnFailureCallback_69, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_69{ OnSuccessCallback_69, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_70{ OnFailureCallback_70, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_70{ OnSuccessCallback_70, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_71{ OnFailureCallback_71, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_71{ OnSuccessCallback_71, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_72{ OnFailureCallback_72, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_72{ OnSuccessCallback_72, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_73{ OnFailureCallback_73, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_73{ OnSuccessCallback_73, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_74{ OnFailureCallback_74, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_74{ OnSuccessCallback_74, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_75{ OnFailureCallback_75, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_75{ OnSuccessCallback_75, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_76{ OnFailureCallback_76, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_76{ OnSuccessCallback_76, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_77{ OnFailureCallback_77, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_77{ OnSuccessCallback_77, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_78{ OnFailureCallback_78, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enum8)> mOnSuccessCallback_78{ OnSuccessCallback_78, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_79{ OnFailureCallback_79, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enum8)> mOnSuccessCallback_79{ OnSuccessCallback_79, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_80{ OnFailureCallback_80, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enum8)> mOnSuccessCallback_80{ OnSuccessCallback_80, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_81{ OnFailureCallback_81, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enum8)> mOnSuccessCallback_81{ OnSuccessCallback_81, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_82{ OnFailureCallback_82, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enum8)> mOnSuccessCallback_82{ OnSuccessCallback_82, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_83{ OnFailureCallback_83, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enum16)> mOnSuccessCallback_83{ OnSuccessCallback_83, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_84{ OnFailureCallback_84, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enum16)> mOnSuccessCallback_84{ OnSuccessCallback_84, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_85{ OnFailureCallback_85, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enum16)> mOnSuccessCallback_85{ OnSuccessCallback_85, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_86{ OnFailureCallback_86, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enum16)> mOnSuccessCallback_86{ OnSuccessCallback_86, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_87{ OnFailureCallback_87, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enum16)> mOnSuccessCallback_87{ OnSuccessCallback_87, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_88{ OnFailureCallback_88, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_88{ OnSuccessCallback_88,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_89{ OnFailureCallback_89, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_89{ OnSuccessCallback_89,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_90{ OnFailureCallback_90, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_90{ OnSuccessCallback_90,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_91{ OnFailureCallback_91, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_91{ OnSuccessCallback_91,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_92{ OnFailureCallback_92, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_92{ OnSuccessCallback_92,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_93{ OnFailureCallback_93, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_93{ OnSuccessCallback_93,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_94{ OnFailureCallback_94, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan longOctetString)> mOnSuccessCallback_94{ OnSuccessCallback_94,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_95{ OnFailureCallback_95, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan longOctetString)> mOnSuccessCallback_95{ OnSuccessCallback_95,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_96{ OnFailureCallback_96, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan longOctetString)> mOnSuccessCallback_96{ OnSuccessCallback_96,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_97{ OnFailureCallback_97, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan longOctetString)> mOnSuccessCallback_97{ OnSuccessCallback_97,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_98{ OnFailureCallback_98, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan charString)> mOnSuccessCallback_98{ OnSuccessCallback_98,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_99{ OnFailureCallback_99, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan charString)> mOnSuccessCallback_99{ OnSuccessCallback_99,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_100{ OnFailureCallback_100, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan charString)> mOnSuccessCallback_100{ OnSuccessCallback_100,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_101{ OnFailureCallback_101, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan charString)> mOnSuccessCallback_101{ OnSuccessCallback_101,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_102{ OnFailureCallback_102, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan longCharString)> mOnSuccessCallback_102{ OnSuccessCallback_102,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_103{ OnFailureCallback_103, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan longCharString)> mOnSuccessCallback_103{ OnSuccessCallback_103,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_104{ OnFailureCallback_104, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan longCharString)> mOnSuccessCallback_104{ OnSuccessCallback_104,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_105{ OnFailureCallback_105, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan longCharString)> mOnSuccessCallback_105{ OnSuccessCallback_105,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_106{ OnFailureCallback_106, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)>
        mOnSuccessCallback_106{ OnSuccessCallback_106, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_107{ OnFailureCallback_107, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)>
        mOnSuccessCallback_107{ OnSuccessCallback_107, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_108{ OnFailureCallback_108, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)>
        mOnSuccessCallback_108{ OnSuccessCallback_108, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_109{ OnFailureCallback_109, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t epochUs)> mOnSuccessCallback_109{ OnSuccessCallback_109, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_110{ OnFailureCallback_110, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t epochUs)> mOnSuccessCallback_110{ OnSuccessCallback_110, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_111{ OnFailureCallback_111, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t epochUs)> mOnSuccessCallback_111{ OnSuccessCallback_111, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_112{ OnFailureCallback_112, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t epochUs)> mOnSuccessCallback_112{ OnSuccessCallback_112, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_113{ OnFailureCallback_113, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t epochUs)> mOnSuccessCallback_113{ OnSuccessCallback_113, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_114{ OnFailureCallback_114, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t epochS)> mOnSuccessCallback_114{ OnSuccessCallback_114, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_115{ OnFailureCallback_115, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t epochS)> mOnSuccessCallback_115{ OnSuccessCallback_115, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_116{ OnFailureCallback_116, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t epochS)> mOnSuccessCallback_116{ OnSuccessCallback_116, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_117{ OnFailureCallback_117, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t epochS)> mOnSuccessCallback_117{ OnSuccessCallback_117, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_118{ OnFailureCallback_118, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t epochS)> mOnSuccessCallback_118{ OnSuccessCallback_118, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_119{ OnFailureCallback_119, this };
    chip::Callback::Callback<void (*)(void * context, bool unsupported)> mOnSuccessCallback_119{ OnSuccessCallback_119, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_120{ OnFailureCallback_120, this };
    chip::Callback::Callback<void (*)(void * context, bool unsupported)> mOnSuccessCallback_120{ OnSuccessCallback_120, this };

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_5(boolean);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_6(boolean);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_7(boolean);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_8(boolean);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_9(boolean);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_10(bitmap8);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_11(bitmap8);
    }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_12(bitmap8);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_13(bitmap8);
    }

    static void OnFailureCallback_14(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_14(status);
    }

    static void OnSuccessCallback_14(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_14(bitmap8);
    }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_15(bitmap16);
    }

    static void OnFailureCallback_16(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_16(status);
    }

    static void OnSuccessCallback_16(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_16(bitmap16);
    }

    static void OnFailureCallback_17(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_17(status);
    }

    static void OnSuccessCallback_17(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_17(bitmap16);
    }

    static void OnFailureCallback_18(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_18(status);
    }

    static void OnSuccessCallback_18(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_18(bitmap16);
    }

    static void OnFailureCallback_19(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_19(status);
    }

    static void OnSuccessCallback_19(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_19(bitmap16);
    }

    static void OnFailureCallback_20(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_20(status);
    }

    static void OnSuccessCallback_20(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_20(bitmap32);
    }

    static void OnFailureCallback_21(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_21(status);
    }

    static void OnSuccessCallback_21(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_21(bitmap32);
    }

    static void OnFailureCallback_22(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_22(status);
    }

    static void OnSuccessCallback_22(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_22(bitmap32);
    }

    static void OnFailureCallback_23(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_23(status);
    }

    static void OnSuccessCallback_23(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_23(bitmap32);
    }

    static void OnFailureCallback_24(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_24(status);
    }

    static void OnSuccessCallback_24(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_24(bitmap32);
    }

    static void OnFailureCallback_25(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_25(status);
    }

    static void OnSuccessCallback_25(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_25(bitmap64);
    }

    static void OnFailureCallback_26(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_26(status);
    }

    static void OnSuccessCallback_26(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_26(bitmap64);
    }

    static void OnFailureCallback_27(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_27(status);
    }

    static void OnSuccessCallback_27(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_27(bitmap64);
    }

    static void OnFailureCallback_28(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_28(status);
    }

    static void OnSuccessCallback_28(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_28(bitmap64);
    }

    static void OnFailureCallback_29(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_29(status);
    }

    static void OnSuccessCallback_29(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_29(bitmap64);
    }

    static void OnFailureCallback_30(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_30(status);
    }

    static void OnSuccessCallback_30(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_30(int8u);
    }

    static void OnFailureCallback_31(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_31(status);
    }

    static void OnSuccessCallback_31(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_31(int8u);
    }

    static void OnFailureCallback_32(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_32(status);
    }

    static void OnSuccessCallback_32(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_32(int8u);
    }

    static void OnFailureCallback_33(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_33(status);
    }

    static void OnSuccessCallback_33(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_33(int8u);
    }

    static void OnFailureCallback_34(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_34(status);
    }

    static void OnSuccessCallback_34(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_34(int8u);
    }

    static void OnFailureCallback_35(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_35(status);
    }

    static void OnSuccessCallback_35(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_35(int16u);
    }

    static void OnFailureCallback_36(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_36(status);
    }

    static void OnSuccessCallback_36(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_36(int16u);
    }

    static void OnFailureCallback_37(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_37(status);
    }

    static void OnSuccessCallback_37(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_37(int16u);
    }

    static void OnFailureCallback_38(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_38(status);
    }

    static void OnSuccessCallback_38(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_38(int16u);
    }

    static void OnFailureCallback_39(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_39(status);
    }

    static void OnSuccessCallback_39(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_39(int16u);
    }

    static void OnFailureCallback_40(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_40(status);
    }

    static void OnSuccessCallback_40(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_40(int32u);
    }

    static void OnFailureCallback_41(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_41(status);
    }

    static void OnSuccessCallback_41(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_41(int32u);
    }

    static void OnFailureCallback_42(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_42(status);
    }

    static void OnSuccessCallback_42(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_42(int32u);
    }

    static void OnFailureCallback_43(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_43(status);
    }

    static void OnSuccessCallback_43(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_43(int32u);
    }

    static void OnFailureCallback_44(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_44(status);
    }

    static void OnSuccessCallback_44(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_44(int32u);
    }

    static void OnFailureCallback_45(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_45(status);
    }

    static void OnSuccessCallback_45(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_45(int64u);
    }

    static void OnFailureCallback_46(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_46(status);
    }

    static void OnSuccessCallback_46(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_46(int64u);
    }

    static void OnFailureCallback_47(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_47(status);
    }

    static void OnSuccessCallback_47(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_47(int64u);
    }

    static void OnFailureCallback_48(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_48(status);
    }

    static void OnSuccessCallback_48(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_48(int64u);
    }

    static void OnFailureCallback_49(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_49(status);
    }

    static void OnSuccessCallback_49(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_49(int64u);
    }

    static void OnFailureCallback_50(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_50(status);
    }

    static void OnSuccessCallback_50(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_50(int8s);
    }

    static void OnFailureCallback_51(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_51(status);
    }

    static void OnSuccessCallback_51(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_51(int8s);
    }

    static void OnFailureCallback_52(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_52(status);
    }

    static void OnSuccessCallback_52(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_52(int8s);
    }

    static void OnFailureCallback_53(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_53(status);
    }

    static void OnSuccessCallback_53(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_53(int8s);
    }

    static void OnFailureCallback_54(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_54(status);
    }

    static void OnSuccessCallback_54(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_54(int8s);
    }

    static void OnFailureCallback_55(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_55(status);
    }

    static void OnSuccessCallback_55(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_55(int8s);
    }

    static void OnFailureCallback_56(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_56(status);
    }

    static void OnSuccessCallback_56(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_56(int8s);
    }

    static void OnFailureCallback_57(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_57(status);
    }

    static void OnSuccessCallback_57(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_57(int16s);
    }

    static void OnFailureCallback_58(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_58(status);
    }

    static void OnSuccessCallback_58(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_58(int16s);
    }

    static void OnFailureCallback_59(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_59(status);
    }

    static void OnSuccessCallback_59(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_59(int16s);
    }

    static void OnFailureCallback_60(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_60(status);
    }

    static void OnSuccessCallback_60(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_60(int16s);
    }

    static void OnFailureCallback_61(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_61(status);
    }

    static void OnSuccessCallback_61(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_61(int16s);
    }

    static void OnFailureCallback_62(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_62(status);
    }

    static void OnSuccessCallback_62(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_62(int16s);
    }

    static void OnFailureCallback_63(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_63(status);
    }

    static void OnSuccessCallback_63(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_63(int16s);
    }

    static void OnFailureCallback_64(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_64(status);
    }

    static void OnSuccessCallback_64(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_64(int32s);
    }

    static void OnFailureCallback_65(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_65(status);
    }

    static void OnSuccessCallback_65(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_65(int32s);
    }

    static void OnFailureCallback_66(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_66(status);
    }

    static void OnSuccessCallback_66(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_66(int32s);
    }

    static void OnFailureCallback_67(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_67(status);
    }

    static void OnSuccessCallback_67(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_67(int32s);
    }

    static void OnFailureCallback_68(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_68(status);
    }

    static void OnSuccessCallback_68(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_68(int32s);
    }

    static void OnFailureCallback_69(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_69(status);
    }

    static void OnSuccessCallback_69(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_69(int32s);
    }

    static void OnFailureCallback_70(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_70(status);
    }

    static void OnSuccessCallback_70(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_70(int32s);
    }

    static void OnFailureCallback_71(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_71(status);
    }

    static void OnSuccessCallback_71(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_71(int64s);
    }

    static void OnFailureCallback_72(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_72(status);
    }

    static void OnSuccessCallback_72(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_72(int64s);
    }

    static void OnFailureCallback_73(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_73(status);
    }

    static void OnSuccessCallback_73(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_73(int64s);
    }

    static void OnFailureCallback_74(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_74(status);
    }

    static void OnSuccessCallback_74(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_74(int64s);
    }

    static void OnFailureCallback_75(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_75(status);
    }

    static void OnSuccessCallback_75(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_75(int64s);
    }

    static void OnFailureCallback_76(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_76(status);
    }

    static void OnSuccessCallback_76(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_76(int64s);
    }

    static void OnFailureCallback_77(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_77(status);
    }

    static void OnSuccessCallback_77(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_77(int64s);
    }

    static void OnFailureCallback_78(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_78(status);
    }

    static void OnSuccessCallback_78(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_78(enum8);
    }

    static void OnFailureCallback_79(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_79(status);
    }

    static void OnSuccessCallback_79(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_79(enum8);
    }

    static void OnFailureCallback_80(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_80(status);
    }

    static void OnSuccessCallback_80(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_80(enum8);
    }

    static void OnFailureCallback_81(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_81(status);
    }

    static void OnSuccessCallback_81(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_81(enum8);
    }

    static void OnFailureCallback_82(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_82(status);
    }

    static void OnSuccessCallback_82(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_82(enum8);
    }

    static void OnFailureCallback_83(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_83(status);
    }

    static void OnSuccessCallback_83(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_83(enum16);
    }

    static void OnFailureCallback_84(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_84(status);
    }

    static void OnSuccessCallback_84(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_84(enum16);
    }

    static void OnFailureCallback_85(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_85(status);
    }

    static void OnSuccessCallback_85(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_85(enum16);
    }

    static void OnFailureCallback_86(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_86(status);
    }

    static void OnSuccessCallback_86(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_86(enum16);
    }

    static void OnFailureCallback_87(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_87(status);
    }

    static void OnSuccessCallback_87(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_87(enum16);
    }

    static void OnFailureCallback_88(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_88(status);
    }

    static void OnSuccessCallback_88(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_88(octetString);
    }

    static void OnFailureCallback_89(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_89(status);
    }

    static void OnSuccessCallback_89(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_89(octetString);
    }

    static void OnFailureCallback_90(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_90(status);
    }

    static void OnSuccessCallback_90(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_90(octetString);
    }

    static void OnFailureCallback_91(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_91(status);
    }

    static void OnSuccessCallback_91(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_91(octetString);
    }

    static void OnFailureCallback_92(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_92(status);
    }

    static void OnSuccessCallback_92(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_92(octetString);
    }

    static void OnFailureCallback_93(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_93(status);
    }

    static void OnSuccessCallback_93(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_93(octetString);
    }

    static void OnFailureCallback_94(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_94(status);
    }

    static void OnSuccessCallback_94(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_94(longOctetString);
    }

    static void OnFailureCallback_95(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_95(status);
    }

    static void OnSuccessCallback_95(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_95(longOctetString);
    }

    static void OnFailureCallback_96(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_96(status);
    }

    static void OnSuccessCallback_96(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_96(longOctetString);
    }

    static void OnFailureCallback_97(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_97(status);
    }

    static void OnSuccessCallback_97(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_97(longOctetString);
    }

    static void OnFailureCallback_98(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_98(status);
    }

    static void OnSuccessCallback_98(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_98(charString);
    }

    static void OnFailureCallback_99(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_99(status);
    }

    static void OnSuccessCallback_99(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_99(charString);
    }

    static void OnFailureCallback_100(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_100(status);
    }

    static void OnSuccessCallback_100(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_100(charString);
    }

    static void OnFailureCallback_101(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_101(status);
    }

    static void OnSuccessCallback_101(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_101(charString);
    }

    static void OnFailureCallback_102(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_102(status);
    }

    static void OnSuccessCallback_102(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_102(longCharString);
    }

    static void OnFailureCallback_103(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_103(status);
    }

    static void OnSuccessCallback_103(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_103(longCharString);
    }

    static void OnFailureCallback_104(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_104(status);
    }

    static void OnSuccessCallback_104(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_104(longCharString);
    }

    static void OnFailureCallback_105(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_105(status);
    }

    static void OnSuccessCallback_105(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_105(longCharString);
    }

    static void OnFailureCallback_106(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_106(status);
    }

    static void OnSuccessCallback_106(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_106(listInt8u);
    }

    static void OnFailureCallback_107(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_107(status);
    }

    static void OnSuccessCallback_107(void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_107(listOctetString);
    }

    static void OnFailureCallback_108(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_108(status);
    }

    static void OnSuccessCallback_108(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_108(listStructOctetString);
    }

    static void OnFailureCallback_109(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_109(status);
    }

    static void OnSuccessCallback_109(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_109(epochUs);
    }

    static void OnFailureCallback_110(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_110(status);
    }

    static void OnSuccessCallback_110(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_110(epochUs);
    }

    static void OnFailureCallback_111(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_111(status);
    }

    static void OnSuccessCallback_111(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_111(epochUs);
    }

    static void OnFailureCallback_112(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_112(status);
    }

    static void OnSuccessCallback_112(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_112(epochUs);
    }

    static void OnFailureCallback_113(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_113(status);
    }

    static void OnSuccessCallback_113(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_113(epochUs);
    }

    static void OnFailureCallback_114(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_114(status);
    }

    static void OnSuccessCallback_114(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_114(epochS);
    }

    static void OnFailureCallback_115(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_115(status);
    }

    static void OnSuccessCallback_115(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_115(epochS);
    }

    static void OnFailureCallback_116(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_116(status);
    }

    static void OnSuccessCallback_116(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_116(epochS);
    }

    static void OnFailureCallback_117(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_117(status);
    }

    static void OnSuccessCallback_117(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_117(epochS);
    }

    static void OnFailureCallback_118(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_118(status);
    }

    static void OnSuccessCallback_118(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_118(epochS);
    }

    static void OnFailureCallback_119(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_119(status);
    }

    static void OnSuccessCallback_119(void * context, bool unsupported)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_119(unsupported);
    }

    static void OnFailureCallback_120(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_120(status);
    }

    static void OnSuccessCallback_120(void * context, bool unsupported)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_120(unsupported);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendTestCommand_0()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::Test::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::Test::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestSendTestNotHandledCommand_1()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestSpecificCommand_2()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestSpecific::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestSpecificResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestSpecific::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_2(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("returnValue", returnValue, 7));
        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_3()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_3(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("returnValue", returnValue, 20));
        NextTest();
    }

    CHIP_ERROR TestSendFailingTestAddArgumentsCommand_4()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type request;
        request.arg1 = 250;
        request.arg2 = 6;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_4(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4(uint8_t returnValue) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_5()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBoolean(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanTrue_6()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool booleanArgument = 1;

        return cluster.WriteAttributeBoolean(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel(), booleanArgument);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool boolean) { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanTrue_7()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBoolean(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 1));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanFalse_8()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool booleanArgument = 0;

        return cluster.WriteAttributeBoolean(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel(), booleanArgument);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool boolean) { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanFalse_9()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBoolean(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_10()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap8(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MaxValue_11()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t bitmap8Argument = 255;

        return cluster.WriteAttributeBitmap8(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel(), bitmap8Argument);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t bitmap8) { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MaxValue_12()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap8(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel());
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MinValue_13()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t bitmap8Argument = 0;

        return cluster.WriteAttributeBitmap8(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel(), bitmap8Argument);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t bitmap8) { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MinValue_14()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap8(mOnSuccessCallback_14.Cancel(), mOnFailureCallback_14.Cancel());
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_15()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap16(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MaxValue_16()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t bitmap16Argument = 65535U;

        return cluster.WriteAttributeBitmap16(mOnSuccessCallback_16.Cancel(), mOnFailureCallback_16.Cancel(), bitmap16Argument);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t bitmap16) { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MaxValue_17()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap16(mOnSuccessCallback_17.Cancel(), mOnFailureCallback_17.Cancel());
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MinValue_18()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t bitmap16Argument = 0U;

        return cluster.WriteAttributeBitmap16(mOnSuccessCallback_18.Cancel(), mOnFailureCallback_18.Cancel(), bitmap16Argument);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint16_t bitmap16) { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MinValue_19()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap16(mOnSuccessCallback_19.Cancel(), mOnFailureCallback_19.Cancel());
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_20()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap32(mOnSuccessCallback_20.Cancel(), mOnFailureCallback_20.Cancel());
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MaxValue_21()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t bitmap32Argument = 4294967295UL;

        return cluster.WriteAttributeBitmap32(mOnSuccessCallback_21.Cancel(), mOnFailureCallback_21.Cancel(), bitmap32Argument);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(uint32_t bitmap32) { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MaxValue_22()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap32(mOnSuccessCallback_22.Cancel(), mOnFailureCallback_22.Cancel());
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MinValue_23()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t bitmap32Argument = 0UL;

        return cluster.WriteAttributeBitmap32(mOnSuccessCallback_23.Cancel(), mOnFailureCallback_23.Cancel(), bitmap32Argument);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint32_t bitmap32) { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MinValue_24()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap32(mOnSuccessCallback_24.Cancel(), mOnFailureCallback_24.Cancel());
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_25()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap64(mOnSuccessCallback_25.Cancel(), mOnFailureCallback_25.Cancel());
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MaxValue_26()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t bitmap64Argument = 18446744073709551615ULL;

        return cluster.WriteAttributeBitmap64(mOnSuccessCallback_26.Cancel(), mOnFailureCallback_26.Cancel(), bitmap64Argument);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint64_t bitmap64) { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MaxValue_27()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap64(mOnSuccessCallback_27.Cancel(), mOnFailureCallback_27.Cancel());
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MinValue_28()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t bitmap64Argument = 0ULL;

        return cluster.WriteAttributeBitmap64(mOnSuccessCallback_28.Cancel(), mOnFailureCallback_28.Cancel(), bitmap64Argument);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint64_t bitmap64) { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MinValue_29()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap64(mOnSuccessCallback_29.Cancel(), mOnFailureCallback_29.Cancel());
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_30()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8u(mOnSuccessCallback_30.Cancel(), mOnFailureCallback_30.Cancel());
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMaxValue_31()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t int8uArgument = 255;

        return cluster.WriteAttributeInt8u(mOnSuccessCallback_31.Cancel(), mOnFailureCallback_31.Cancel(), int8uArgument);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint8_t int8u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMaxValue_32()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8u(mOnSuccessCallback_32.Cancel(), mOnFailureCallback_32.Cancel());
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMinValue_33()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t int8uArgument = 0;

        return cluster.WriteAttributeInt8u(mOnSuccessCallback_33.Cancel(), mOnFailureCallback_33.Cancel(), int8uArgument);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(uint8_t int8u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMinValue_34()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8u(mOnSuccessCallback_34.Cancel(), mOnFailureCallback_34.Cancel());
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_35()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16u(mOnSuccessCallback_35.Cancel(), mOnFailureCallback_35.Cancel());
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMaxValue_36()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t int16uArgument = 65535U;

        return cluster.WriteAttributeInt16u(mOnSuccessCallback_36.Cancel(), mOnFailureCallback_36.Cancel(), int16uArgument);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(uint16_t int16u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMaxValue_37()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16u(mOnSuccessCallback_37.Cancel(), mOnFailureCallback_37.Cancel());
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMinValue_38()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t int16uArgument = 0U;

        return cluster.WriteAttributeInt16u(mOnSuccessCallback_38.Cancel(), mOnFailureCallback_38.Cancel(), int16uArgument);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(uint16_t int16u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMinValue_39()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16u(mOnSuccessCallback_39.Cancel(), mOnFailureCallback_39.Cancel());
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_40()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_40.Cancel(), mOnFailureCallback_40.Cancel());
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMaxValue_41()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t int32uArgument = 4294967295UL;

        return cluster.WriteAttributeInt32u(mOnSuccessCallback_41.Cancel(), mOnFailureCallback_41.Cancel(), int32uArgument);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint32_t int32u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMaxValue_42()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_42.Cancel(), mOnFailureCallback_42.Cancel());
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMinValue_43()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t int32uArgument = 0UL;

        return cluster.WriteAttributeInt32u(mOnSuccessCallback_43.Cancel(), mOnFailureCallback_43.Cancel(), int32uArgument);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint32_t int32u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMinValue_44()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_44.Cancel(), mOnFailureCallback_44.Cancel());
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_45()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64u(mOnSuccessCallback_45.Cancel(), mOnFailureCallback_45.Cancel());
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMaxValue_46()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t int64uArgument = 18446744073709551615ULL;

        return cluster.WriteAttributeInt64u(mOnSuccessCallback_46.Cancel(), mOnFailureCallback_46.Cancel(), int64uArgument);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(uint64_t int64u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMaxValue_47()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64u(mOnSuccessCallback_47.Cancel(), mOnFailureCallback_47.Cancel());
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMinValue_48()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t int64uArgument = 0ULL;

        return cluster.WriteAttributeInt64u(mOnSuccessCallback_48.Cancel(), mOnFailureCallback_48.Cancel(), int64uArgument);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(uint64_t int64u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMinValue_49()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64u(mOnSuccessCallback_49.Cancel(), mOnFailureCallback_49.Cancel());
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_50()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8s(mOnSuccessCallback_50.Cancel(), mOnFailureCallback_50.Cancel());
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMaxValue_51()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int8_t int8sArgument = 127;

        return cluster.WriteAttributeInt8s(mOnSuccessCallback_51.Cancel(), mOnFailureCallback_51.Cancel(), int8sArgument);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51(int8_t int8s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMaxValue_52()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8s(mOnSuccessCallback_52.Cancel(), mOnFailureCallback_52.Cancel());
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 127));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMinValue_53()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int8_t int8sArgument = -128;

        return cluster.WriteAttributeInt8s(mOnSuccessCallback_53.Cancel(), mOnFailureCallback_53.Cancel(), int8sArgument);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53(int8_t int8s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMinValue_54()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8s(mOnSuccessCallback_54.Cancel(), mOnFailureCallback_54.Cancel());
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, -128));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_55()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int8_t int8sArgument = 0;

        return cluster.WriteAttributeInt8s(mOnSuccessCallback_55.Cancel(), mOnFailureCallback_55.Cancel(), int8sArgument);
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55(int8_t int8s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_56()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8s(mOnSuccessCallback_56.Cancel(), mOnFailureCallback_56.Cancel());
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_57()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16s(mOnSuccessCallback_57.Cancel(), mOnFailureCallback_57.Cancel());
    }

    void OnFailureResponse_57(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_57(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMaxValue_58()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t int16sArgument = 32767;

        return cluster.WriteAttributeInt16s(mOnSuccessCallback_58.Cancel(), mOnFailureCallback_58.Cancel(), int16sArgument);
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58(int16_t int16s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMaxValue_59()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16s(mOnSuccessCallback_59.Cancel(), mOnFailureCallback_59.Cancel());
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 32767));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMinValue_60()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t int16sArgument = -32768;

        return cluster.WriteAttributeInt16s(mOnSuccessCallback_60.Cancel(), mOnFailureCallback_60.Cancel(), int16sArgument);
    }

    void OnFailureResponse_60(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_60(int16_t int16s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMinValue_61()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16s(mOnSuccessCallback_61.Cancel(), mOnFailureCallback_61.Cancel());
    }

    void OnFailureResponse_61(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_61(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, -32768));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_62()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t int16sArgument = 0;

        return cluster.WriteAttributeInt16s(mOnSuccessCallback_62.Cancel(), mOnFailureCallback_62.Cancel(), int16sArgument);
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62(int16_t int16s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_63()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16s(mOnSuccessCallback_63.Cancel(), mOnFailureCallback_63.Cancel());
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_64()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32s(mOnSuccessCallback_64.Cancel(), mOnFailureCallback_64.Cancel());
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 0L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMaxValue_65()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int32_t int32sArgument = 2147483647L;

        return cluster.WriteAttributeInt32s(mOnSuccessCallback_65.Cancel(), mOnFailureCallback_65.Cancel(), int32sArgument);
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65(int32_t int32s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMaxValue_66()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32s(mOnSuccessCallback_66.Cancel(), mOnFailureCallback_66.Cancel());
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 2147483647L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMinValue_67()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int32_t int32sArgument = -2147483648L;

        return cluster.WriteAttributeInt32s(mOnSuccessCallback_67.Cancel(), mOnFailureCallback_67.Cancel(), int32sArgument);
    }

    void OnFailureResponse_67(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_67(int32_t int32s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMinValue_68()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32s(mOnSuccessCallback_68.Cancel(), mOnFailureCallback_68.Cancel());
    }

    void OnFailureResponse_68(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_68(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, -2147483648L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_69()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int32_t int32sArgument = 0L;

        return cluster.WriteAttributeInt32s(mOnSuccessCallback_69.Cancel(), mOnFailureCallback_69.Cancel(), int32sArgument);
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69(int32_t int32s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_70()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32s(mOnSuccessCallback_70.Cancel(), mOnFailureCallback_70.Cancel());
    }

    void OnFailureResponse_70(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_70(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 0L));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_71()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64s(mOnSuccessCallback_71.Cancel(), mOnFailureCallback_71.Cancel());
    }

    void OnFailureResponse_71(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_71(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 0LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMaxValue_72()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int64_t int64sArgument = 9223372036854775807LL;

        return cluster.WriteAttributeInt64s(mOnSuccessCallback_72.Cancel(), mOnFailureCallback_72.Cancel(), int64sArgument);
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72(int64_t int64s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMaxValue_73()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64s(mOnSuccessCallback_73.Cancel(), mOnFailureCallback_73.Cancel());
    }

    void OnFailureResponse_73(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_73(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMinValue_74()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int64_t int64sArgument = -9223372036854775807LL;

        return cluster.WriteAttributeInt64s(mOnSuccessCallback_74.Cancel(), mOnFailureCallback_74.Cancel(), int64sArgument);
    }

    void OnFailureResponse_74(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_74(int64_t int64s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMinValue_75()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64s(mOnSuccessCallback_75.Cancel(), mOnFailureCallback_75.Cancel());
    }

    void OnFailureResponse_75(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_75(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, -9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_76()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int64_t int64sArgument = 0LL;

        return cluster.WriteAttributeInt64s(mOnSuccessCallback_76.Cancel(), mOnFailureCallback_76.Cancel(), int64sArgument);
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76(int64_t int64s) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_77()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64s(mOnSuccessCallback_77.Cancel(), mOnFailureCallback_77.Cancel());
    }

    void OnFailureResponse_77(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_77(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 0LL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_78()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum8(mOnSuccessCallback_78.Cancel(), mOnFailureCallback_78.Cancel());
    }

    void OnFailureResponse_78(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_78(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MaxValue_79()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t enum8Argument = 255;

        return cluster.WriteAttributeEnum8(mOnSuccessCallback_79.Cancel(), mOnFailureCallback_79.Cancel(), enum8Argument);
    }

    void OnFailureResponse_79(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_79(uint8_t enum8) { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MaxValue_80()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum8(mOnSuccessCallback_80.Cancel(), mOnFailureCallback_80.Cancel());
    }

    void OnFailureResponse_80(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_80(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MinValue_81()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t enum8Argument = 0;

        return cluster.WriteAttributeEnum8(mOnSuccessCallback_81.Cancel(), mOnFailureCallback_81.Cancel(), enum8Argument);
    }

    void OnFailureResponse_81(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_81(uint8_t enum8) { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MinValue_82()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum8(mOnSuccessCallback_82.Cancel(), mOnFailureCallback_82.Cancel());
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_83()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum16(mOnSuccessCallback_83.Cancel(), mOnFailureCallback_83.Cancel());
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MaxValue_84()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t enum16Argument = 65535U;

        return cluster.WriteAttributeEnum16(mOnSuccessCallback_84.Cancel(), mOnFailureCallback_84.Cancel(), enum16Argument);
    }

    void OnFailureResponse_84(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_84(uint16_t enum16) { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MaxValue_85()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum16(mOnSuccessCallback_85.Cancel(), mOnFailureCallback_85.Cancel());
    }

    void OnFailureResponse_85(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_85(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MinValue_86()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t enum16Argument = 0U;

        return cluster.WriteAttributeEnum16(mOnSuccessCallback_86.Cancel(), mOnFailureCallback_86.Cancel(), enum16Argument);
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86(uint16_t enum16) { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MinValue_87()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum16(mOnSuccessCallback_87.Cancel(), mOnFailureCallback_87.Cancel());
    }

    void OnFailureResponse_87(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_87(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValue_88()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOctetString(mOnSuccessCallback_88.Cancel(), mOnFailureCallback_88.Cancel());
    }

    void OnFailureResponse_88(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_88(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_89()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), strlen("TestValue"));

        return cluster.WriteAttributeOctetString(mOnSuccessCallback_89.Cancel(), mOnFailureCallback_89.Cancel(),
                                                 octetStringArgument);
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89(chip::ByteSpan octetString) { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetString_90()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOctetString(mOnSuccessCallback_90.Cancel(), mOnFailureCallback_90.Cancel());
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, "TestValue"));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_91()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan octetStringArgument =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValueLongerThan10"), strlen("TestValueLongerThan10"));

        return cluster.WriteAttributeOctetString(mOnSuccessCallback_91.Cancel(), mOnFailureCallback_91.Cancel(),
                                                 octetStringArgument);
    }

    void OnFailureResponse_91(uint8_t status) { NextTest(); }

    void OnSuccessResponse_91(chip::ByteSpan octetString) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeOctetString_92()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOctetString(mOnSuccessCallback_92.Cancel(), mOnFailureCallback_92.Cancel());
    }

    void OnFailureResponse_92(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_92(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, "TestValue"));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_93()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char(""), strlen(""));

        return cluster.WriteAttributeOctetString(mOnSuccessCallback_93.Cancel(), mOnFailureCallback_93.Cancel(),
                                                 octetStringArgument);
    }

    void OnFailureResponse_93(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_93(chip::ByteSpan octetString) { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetStringDefaultValue_94()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeLongOctetString(mOnSuccessCallback_94.Cancel(), mOnFailureCallback_94.Cancel());
    }

    void OnFailureResponse_94(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_94(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString("longOctetString", longOctetString, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_95()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan longOctetStringArgument = chip::ByteSpan(
            chip::Uint8::from_const_char(
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111"),
            strlen("111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                   "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                   "111111111111111111111111111111111111111111111111111111111111111111111111111111"));

        return cluster.WriteAttributeLongOctetString(mOnSuccessCallback_95.Cancel(), mOnFailureCallback_95.Cancel(),
                                                     longOctetStringArgument);
    }

    void OnFailureResponse_95(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_95(chip::ByteSpan longOctetString) { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetString_96()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeLongOctetString(mOnSuccessCallback_96.Cancel(), mOnFailureCallback_96.Cancel());
    }

    void OnFailureResponse_96(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_96(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longOctetString", longOctetString,
            "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
            "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
            "1111111111111111111111111111111111111111111111111111111111111111"));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_97()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan longOctetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char(""), strlen(""));

        return cluster.WriteAttributeLongOctetString(mOnSuccessCallback_97.Cancel(), mOnFailureCallback_97.Cancel(),
                                                     longOctetStringArgument);
    }

    void OnFailureResponse_97(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_97(chip::ByteSpan longOctetString) { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringDefaultValue_98()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCharString(mOnSuccessCallback_98.Cancel(), mOnFailureCallback_98.Cancel());
    }

    void OnFailureResponse_98(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_98(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharString_99()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan charStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("T"), strlen("T"));

        return cluster.WriteAttributeCharString(mOnSuccessCallback_99.Cancel(), mOnFailureCallback_99.Cancel(), charStringArgument);
    }

    void OnFailureResponse_99(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_99(chip::CharSpan charString) { NextTest(); }

    CHIP_ERROR TestWriteAttributeCharStringValueTooLong_100()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan charStringArgument =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValueLongerThan10"), strlen("TestValueLongerThan10"));

        return cluster.WriteAttributeCharString(mOnSuccessCallback_100.Cancel(), mOnFailureCallback_100.Cancel(),
                                                charStringArgument);
    }

    void OnFailureResponse_100(uint8_t status) { NextTest(); }

    void OnSuccessResponse_100(chip::CharSpan charString) { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteAttributeCharStringEmpty_101()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan charStringArgument = chip::ByteSpan(chip::Uint8::from_const_char(""), strlen(""));

        return cluster.WriteAttributeCharString(mOnSuccessCallback_101.Cancel(), mOnFailureCallback_101.Cancel(),
                                                charStringArgument);
    }

    void OnFailureResponse_101(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_101(chip::CharSpan charString) { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharStringDefaultValue_102()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeLongCharString(mOnSuccessCallback_102.Cancel(), mOnFailureCallback_102.Cancel());
    }

    void OnFailureResponse_102(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_102(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString("longCharString", longCharString, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_103()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan longCharStringArgument = chip::ByteSpan(
            chip::Uint8::from_const_char(
                ""
                ""
                ""),
            strlen(""
                   ""
                   ""));

        return cluster.WriteAttributeLongCharString(mOnSuccessCallback_103.Cancel(), mOnFailureCallback_103.Cancel(),
                                                    longCharStringArgument);
    }

    void OnFailureResponse_103(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_103(chip::CharSpan longCharString) { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharString_104()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeLongCharString(mOnSuccessCallback_104.Cancel(), mOnFailureCallback_104.Cancel());
    }

    void OnFailureResponse_104(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_104(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longCharString", longCharString,
            ""
            ""
            ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_105()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan longCharStringArgument = chip::ByteSpan(chip::Uint8::from_const_char(""), strlen(""));

        return cluster.WriteAttributeLongCharString(mOnSuccessCallback_105.Cancel(), mOnFailureCallback_105.Cancel(),
                                                    longCharStringArgument);
    }

    void OnFailureResponse_105(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_105(chip::CharSpan longCharString) { NextTest(); }

    CHIP_ERROR TestReadAttributeList_106()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeListInt8u(mOnSuccessCallback_106.Cancel(), mOnFailureCallback_106.Cancel());
    }

    void OnFailureResponse_106(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_106(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        VerifyOrReturn(CheckValueAsListLength("listInt8u", listInt8u, 4));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeListOctetString_107()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeListOctetString(mOnSuccessCallback_107.Cancel(), mOnFailureCallback_107.Cancel());
    }

    void OnFailureResponse_107(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_107(const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        VerifyOrReturn(CheckValueAsListLength("listOctetString", listOctetString, 4));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeListStructOctetString_108()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeListStructOctetString(mOnSuccessCallback_108.Cancel(), mOnFailureCallback_108.Cancel());
    }

    void OnFailureResponse_108(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_108(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        VerifyOrReturn(CheckValueAsListLength("listStructOctetString", listStructOctetString, 4));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_109()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochUs(mOnSuccessCallback_109.Cancel(), mOnFailureCallback_109.Cancel());
    }

    void OnFailureResponse_109(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_109(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMaxValue_110()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t epochUsArgument = 18446744073709551615ULL;

        return cluster.WriteAttributeEpochUs(mOnSuccessCallback_110.Cancel(), mOnFailureCallback_110.Cancel(), epochUsArgument);
    }

    void OnFailureResponse_110(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_110(uint64_t epochUs) { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMaxValue_111()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochUs(mOnSuccessCallback_111.Cancel(), mOnFailureCallback_111.Cancel());
    }

    void OnFailureResponse_111(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_111(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMinValue_112()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t epochUsArgument = 0ULL;

        return cluster.WriteAttributeEpochUs(mOnSuccessCallback_112.Cancel(), mOnFailureCallback_112.Cancel(), epochUsArgument);
    }

    void OnFailureResponse_112(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_112(uint64_t epochUs) { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMinValue_113()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochUs(mOnSuccessCallback_113.Cancel(), mOnFailureCallback_113.Cancel());
    }

    void OnFailureResponse_113(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_113(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_114()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochS(mOnSuccessCallback_114.Cancel(), mOnFailureCallback_114.Cancel());
    }

    void OnFailureResponse_114(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_114(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMaxValue_115()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t epochSArgument = 4294967295UL;

        return cluster.WriteAttributeEpochS(mOnSuccessCallback_115.Cancel(), mOnFailureCallback_115.Cancel(), epochSArgument);
    }

    void OnFailureResponse_115(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_115(uint32_t epochS) { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMaxValue_116()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochS(mOnSuccessCallback_116.Cancel(), mOnFailureCallback_116.Cancel());
    }

    void OnFailureResponse_116(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_116(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMinValue_117()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t epochSArgument = 0UL;

        return cluster.WriteAttributeEpochS(mOnSuccessCallback_117.Cancel(), mOnFailureCallback_117.Cancel(), epochSArgument);
    }

    void OnFailureResponse_117(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_117(uint32_t epochS) { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMinValue_118()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochS(mOnSuccessCallback_118.Cancel(), mOnFailureCallback_118.Cancel());
    }

    void OnFailureResponse_118(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_118(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeUnsupported_119()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeUnsupported(mOnSuccessCallback_119.Cancel(), mOnFailureCallback_119.Cancel());
    }

    void OnFailureResponse_119(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_119(bool unsupported)
    {
        VerifyOrReturn(CheckValue<bool>("unsupported", unsupported, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteattributeUnsupported_120()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool unsupportedArgument = 0;

        return cluster.WriteAttributeUnsupported(mOnSuccessCallback_120.Cancel(), mOnFailureCallback_120.Cancel(),
                                                 unsupportedArgument);
    }

    void OnFailureResponse_120(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_120(bool unsupported) { NextTest(); }

    CHIP_ERROR TestSendTestCommandToUnsupportedEndpoint_121()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 200);

        using requestType  = chip::app::Clusters::TestCluster::Commands::Test::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::Test::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_121();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_121(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_121(uint8_t status) { NextTest(); }

    void OnSuccessResponse_121() { ThrowSuccessResponse(); }
};

class TestClusterComplexTypes : public TestCommand
{
public:
    TestClusterComplexTypes() : TestCommand("TestClusterComplexTypes"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestClusterComplexTypes\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestClusterComplexTypes\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Test Command With Struct Argument and arg1.b is true\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsTrue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command With Struct Argument and arg1.b is false\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsFalse_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Command With List of INT8U and none of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Command With List of INT8U and one of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Test Command With List of INT8U and get it reversed\n");
            err = TestSendTestCommandWithListOfInt8uAndGetItReversed_4();
            break;
        case 5:
            ChipLogProgress(
                chipTool, " ***** Test Step 5 : Send Test Command With List of Struct Argument and arg1.b of first item is true\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : Send Test Command With List of Struct Argument and arg1.b of first item is false\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsTrue_0()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type request;

        request.arg1.a = 0;
        request.arg1.b = true;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_string"), strlen("octet_string"));
        request.arg1.e = chip::Span<const char>("char_string", strlen("char_string"));
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsFalse_1()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type request;

        request.arg1.a = 0;
        request.arg1.b = false;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_string"), strlen("octet_string"));
        request.arg1.e = chip::Span<const char>("char_string", strlen("char_string"));
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_2()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type request;

        uint8_t arg1List[9];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_3()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type request;

        uint8_t arg1List[10];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        arg1List[9]  = 0;
        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { NextTest(); }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndGetItReversed_4()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type request;

        uint8_t arg1List[9];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_4(data.arg1);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        VerifyOrReturn(CheckValueAsList("arg1", arg1, 9, 8, 7, 6, 5, 4, 3, 2, 1));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_5()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type request;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type arg1List[2];

        arg1List[0].a = 0;
        arg1List[0].b = true;
        arg1List[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[0].d = chip::ByteSpan(chip::Uint8::from_const_char("first_octet_string"), strlen("first_octet_string"));
        arg1List[0].e = chip::Span<const char>("first_char_string", strlen("first_char_string"));
        arg1List[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        arg1List[1].a = 1;
        arg1List[1].b = true;
        arg1List[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        arg1List[1].d = chip::ByteSpan(chip::Uint8::from_const_char("second_octet_string"), strlen("second_octet_string"));
        arg1List[1].e = chip::Span<const char>("second_char_string", strlen("second_char_string"));
        arg1List[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_6()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type request;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type arg1List[2];

        arg1List[0].a = 1;
        arg1List[0].b = true;
        arg1List[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        arg1List[0].d = chip::ByteSpan(chip::Uint8::from_const_char("second_octet_string"), strlen("second_octet_string"));
        arg1List[0].e = chip::Span<const char>("second_char_string", strlen("second_char_string"));
        arg1List[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        arg1List[1].a = 0;
        arg1List[1].b = false;
        arg1List[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[1].d = chip::ByteSpan(chip::Uint8::from_const_char("first_octet_string"), strlen("first_octet_string"));
        arg1List[1].e = chip::Span<const char>("first_char_string", strlen("first_char_string"));
        arg1List[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { NextTest(); }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }
};

class TestConstraints : public TestCommand
{
public:
    TestConstraints() : TestCommand("TestConstraints"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestConstraints\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestConstraints\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Write attribute INT32U Value\n");
            err = TestWriteAttributeInt32uValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute INT32U Value MinValue Constraints\n");
            err = TestReadAttributeInt32uValueMinValueConstraints_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute INT32U Value MaxValue Constraints\n");
            err = TestReadAttributeInt32uValueMaxValueConstraints_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute INT32U Value NotValue Constraints\n");
            err = TestReadAttributeInt32uValueNotValueConstraints_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_0(int32u);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_1(int32u);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_2(int32u);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_3(int32u);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteAttributeInt32uValue_0()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t int32uArgument = 5UL;

        return cluster.WriteAttributeInt32u(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel(), int32uArgument);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint32_t int32u) { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uValueMinValueConstraints_1()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint32_t>("int32u", int32u, 5));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueMaxValueConstraints_2()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("int32u", int32u, 5));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueNotValueConstraints_3()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintNotValue<uint32_t>("int32u", int32u, 6));
        NextTest();
    }
};

class TestDelayCommands : public TestCommand
{
public:
    TestDelayCommands() : TestCommand("TestDelayCommands"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDelayCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDelayCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait 100ms\n");
            err = TestWait100ms_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWait100ms_0() { return WaitForMs(100); }
};

class TestLogCommands : public TestCommand
{
public:
    TestLogCommands() : TestCommand("TestLogCommands"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestLogCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestLogCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Log a simple message\n");
            err = TestLogASimpleMessage_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestLogASimpleMessage_0() { return Log("This is a simple message"); }
};

class TestDescriptorCluster : public TestCommand
{
public:
    TestDescriptorCluster() : TestCommand("TestDescriptorCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDescriptorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDescriptorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Device list\n");
            err = TestReadAttributeDeviceList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Server list\n");
            err = TestReadAttributeServerList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute Client list\n");
            err = TestReadAttributeClientList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute Parts list\n");
            err = TestReadAttributePartsList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context,
                                      const chip::app::DataModel::DecodableList<
                                          chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)>
        mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)>
        mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)>
        mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_0(deviceList);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_1(serverList);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_2(clientList);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_3(partsList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeDeviceList_0()
    {
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeDeviceList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        VerifyOrReturn(CheckValueAsListLength("deviceList", deviceList, 1));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeServerList_1()
    {
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeServerList(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        VerifyOrReturn(CheckValueAsListLength("serverList", serverList, 18));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeClientList_2()
    {
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeClientList(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        VerifyOrReturn(CheckValueAsListLength("clientList", clientList, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributePartsList_3()
    {
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributePartsList(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        VerifyOrReturn(CheckValueAsListLength("partsList", partsList, 2));
        NextTest();
    }
};

class TestOperationalCredentialsCluster : public TestCommand
{
public:
    TestOperationalCredentialsCluster() : TestCommand("TestOperationalCredentialsCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestOperationalCredentialsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestOperationalCredentialsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read number of supported fabrics\n");
            err = TestReadNumberOfSupportedFabrics_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read number of commissioned fabrics\n");
            err = TestReadNumberOfCommissionedFabrics_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t supportedFabrics)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t commissionedFabrics)> mOnSuccessCallback_1{ OnSuccessCallback_1,
                                                                                                          this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t supportedFabrics)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_0(supportedFabrics);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_1(commissionedFabrics);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadNumberOfSupportedFabrics_0()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSupportedFabrics(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("supportedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("supportedFabrics", supportedFabrics, 4));
        NextTest();
    }

    CHIP_ERROR TestReadNumberOfCommissionedFabrics_1()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeCommissionedFabrics(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("commissionedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("commissionedFabrics", commissionedFabrics, 1));
        NextTest();
    }
};

class TestSubscribe_OnOff : public TestCommand
{
public:
    TestSubscribe_OnOff() : TestCommand("TestSubscribe_OnOff"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSubscribe_OnOff\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSubscribe_OnOff\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Set OnOff Attribute to false\n");
            err = TestSetOnOffAttributeToFalse_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Report: Subscribe OnOff Attribute\n");
            err = TestReportSubscribeOnOffAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Subscribe OnOff Attribute\n");
            err = TestSubscribeOnOffAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check for attribute report\n");
            err = TestCheckForAttributeReport_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check for attribute report\n");
            err = TestCheckForAttributeReport_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_1(onOff);
    }

    bool mReceivedReport_1 = false;

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_4(onOff);
    }

    bool mReceivedReport_4 = false;

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_6(onOff);
    }

    bool mReceivedReport_6 = false;

    //
    // Tests methods
    //

    CHIP_ERROR TestSetOnOffAttributeToFalse_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReportSubscribeOnOffAttribute_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        ReturnErrorOnFailure(cluster.ReportAttributeOnOff(mOnSuccessCallback_1.Cancel()));
        return WaitForMs(0);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_1 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_1 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, false));
    }

    CHIP_ERROR TestSubscribeOnOffAttribute_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t minIntervalArgument = 2;
        uint16_t maxIntervalArgument = 10;

        return cluster.SubscribeAttributeOnOff(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel(), minIntervalArgument,
                                               maxIntervalArgument);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_1, Exit("Initial report not received!"));

        NextTest();
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReportAttributeOnOff(mOnSuccessCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_4 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_4 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, true));
        NextTest();
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReportAttributeOnOff(mOnSuccessCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_6 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_6 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, false));
        NextTest();
    }
};

void registerCommandsTests(Commands & commands)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
        make_unique<Test_TC_BI_1_1>(),
        make_unique<Test_TC_CC_1_1>(),
        make_unique<Test_TC_CC_3_1>(),
        make_unique<Test_TC_CC_3_2>(),
        make_unique<Test_TC_CC_3_3>(),
        make_unique<Test_TC_CC_4_1>(),
        make_unique<Test_TC_CC_4_2>(),
        make_unique<Test_TC_CC_4_3>(),
        make_unique<Test_TC_CC_4_4>(),
        make_unique<Test_TC_CC_5_1>(),
        make_unique<Test_TC_CC_5_2>(),
        make_unique<Test_TC_CC_5_3>(),
        make_unique<Test_TC_CC_6_1>(),
        make_unique<Test_TC_CC_6_2>(),
        make_unique<Test_TC_CC_6_3>(),
        make_unique<Test_TC_CC_7_1>(),
        make_unique<Test_TC_CC_7_2>(),
        make_unique<Test_TC_CC_7_3>(),
        make_unique<Test_TC_CC_7_4>(),
        make_unique<Test_TC_CC_8_1>(),
        make_unique<Test_TC_DM_1_1>(),
        make_unique<Test_TC_DM_3_1>(),
        make_unique<Test_TC_FLW_1_1>(),
        make_unique<Test_TC_LVL_1_1>(),
        make_unique<Test_TC_LVL_2_1>(),
        make_unique<Test_TC_LVL_3_1>(),
        make_unique<Test_TC_MC_1_1>(),
        make_unique<Test_TC_OCC_1_1>(),
        make_unique<Test_TC_OO_1_1>(),
        make_unique<Test_TC_OO_2_1>(),
        make_unique<Test_TC_OO_2_2>(),
        make_unique<Test_TC_PCC_1_1>(),
        make_unique<Test_TC_PCC_2_1>(),
        make_unique<Test_TC_RH_1_1>(),
        make_unique<Test_TC_TM_1_1>(),
        make_unique<Test_TC_TM_2_1>(),
        make_unique<Test_TC_TSTAT_1_1>(),
        make_unique<Test_TC_TSUIC_1_1>(),
        make_unique<Test_TC_TSUIC_2_1>(),
        make_unique<Test_TC_DIAGTH_1_1>(),
        make_unique<Test_TC_WNCV_1_1>(),
        make_unique<Test_TC_WNCV_2_1>(),
        make_unique<Test_TC_WNCV_3_1>(),
        make_unique<Test_TC_WNCV_3_2>(),
        make_unique<Test_TC_WNCV_3_3>(),
        make_unique<TV_TargetNavigatorCluster>(),
        make_unique<TV_AudioOutputCluster>(),
        make_unique<TV_ApplicationLauncherCluster>(),
        make_unique<TV_KeypadInputCluster>(),
        make_unique<TV_AccountLoginCluster>(),
        make_unique<TV_WakeOnLanCluster>(),
        make_unique<TV_ApplicationBasicCluster>(),
        make_unique<TV_MediaPlaybackCluster>(),
        make_unique<TV_TvChannelCluster>(),
        make_unique<TV_LowPowerCluster>(),
        make_unique<TV_MediaInputCluster>(),
        make_unique<TestCluster>(),
        make_unique<TestClusterComplexTypes>(),
        make_unique<TestConstraints>(),
        make_unique<TestDelayCommands>(),
        make_unique<TestLogCommands>(),
        make_unique<TestDescriptorCluster>(),
        make_unique<TestOperationalCredentialsCluster>(),
        make_unique<TestSubscribe_OnOff>(),
    };

    commands.Register(clusterName, clusterCommands);
}
