/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <commands/tests/TestCommand.h>

class Test_TC_BI_1_1 : public TestCommand
{
public:
    Test_TC_BI_1_1() : TestCommand("Test_TC_BI_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }
};

class Test_TC_BI_2_1 : public TestCommand
{
public:
    Test_TC_BI_2_1() : TestCommand("Test_TC_BI_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read mandatory non-global attribute: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeOutOfService_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute constraints: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default values to mandatory non-global attribute: OutOfService\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back the mandatory non-global attribute: OutOfService\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read mandatory non-global attribute constraints: PresentValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Write the default values to mandatory non-global attribute: PresentValue\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back the mandatory non-global attribute: PresentValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributePresentValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read mandatory non-global attribute: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeStatusFlags_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read mandatory non-global attribute constraints: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Write the default values to mandatory non-global attribute: StatusFlags\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads back the mandatory non-global attribute: StatusFlags\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, bool outOfService)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool outOfService)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, bool outOfService)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool presentValue)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, bool presentValue)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t statusFlags)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t statusFlags)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t statusFlags)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_0(outOfService);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_1(outOfService);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_3(outOfService);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_4(presentValue);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_6(presentValue);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_7(statusFlags);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_8(statusFlags);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_10(statusFlags);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeOutOfService_0()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOutOfService(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool outOfService)
    {
        VerifyOrReturn(CheckValue<bool>("outOfService", outOfService, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_1()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOutOfService(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool outOfService)
    {
        VerifyOrReturn(CheckConstraintType("outOfService", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_2()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool outOfServiceArgument;
        outOfServiceArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            outOfServiceArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_3()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOutOfService(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool outOfService)
    {
        VerifyOrReturn(CheckValue<bool>("outOfService", outOfService, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_4()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePresentValue(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool presentValue)
    {
        VerifyOrReturn(CheckConstraintType("presentValue", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_5()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool presentValueArgument;
        presentValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            presentValueArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributePresentValue_6()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePresentValue(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool presentValue)
    {
        VerifyOrReturn(CheckValue<bool>("presentValue", presentValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStatusFlags_7()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStatusFlags(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue<uint8_t>("statusFlags", statusFlags, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_8()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStatusFlags(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckConstraintType("statusFlags", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("statusFlags", statusFlags, 15));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_9()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t statusFlagsArgument;
        statusFlagsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            statusFlagsArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { NextTest(); }

    void OnSuccessResponse_9() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_10()
    {
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStatusFlags(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue<uint8_t>("statusFlags", statusFlags, 0));
        NextTest();
    }
};

class Test_TC_BOOL_1_1 : public TestCommand
{
public:
    Test_TC_BOOL_1_1() : TestCommand("Test_TC_BOOL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }
};

class Test_TC_BOOL_2_1 : public TestCommand
{
public:
    Test_TC_BOOL_2_1() : TestCommand("Test_TC_BOOL_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read mandatory non-global attribute: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeStateValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute constraints: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStateValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default value to mandatory non-global attribute: StateValue\n");
            err = TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back the mandatory non-global attribute: StateValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStateValue_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, bool stateValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool stateValue)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, bool stateValue)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_0(stateValue);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_1(stateValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_3(stateValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStateValue_0()
    {
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStateValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool stateValue)
    {
        VerifyOrReturn(CheckValue<bool>("stateValue", stateValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStateValue_1()
    {
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStateValue(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool stateValue)
    {
        VerifyOrReturn(CheckConstraintType("stateValue", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_2()
    {
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool stateValueArgument;
        stateValueArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(
            stateValueArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { NextTest(); }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStateValue_3()
    {
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStateValue(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool stateValue)
    {
        VerifyOrReturn(CheckValue<bool>("stateValue", stateValue, 0));
        NextTest();
    }
};

class Test_TC_CC_1_1 : public TestCommand
{
public:
    Test_TC_CC_1_1() : TestCommand("Test_TC_CC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_CC_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_CC_2_1 : public TestCommand
{
public:
    Test_TC_CC_2_1() : TestCommand("Test_TC_CC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads mandatory attribute: CurrentHue\n");
            err = TestReadsMandatoryAttributeCurrentHue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Validate constraints of attribute: current hue\n");
            err = TestValidateConstraintsOfAttributeCurrentHue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write the default value to mandatory attribute: CurrentHue\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: CurrentHue\n");
            err = TestReadsBackMandatoryAttributeCurrentHue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads mandatory attribute: CurrentSaturation\n");
            err = TestReadsMandatoryAttributeCurrentSaturation_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Validate constraints of attribute: CurrentSaturation\n");
            err = TestValidateConstraintsOfAttributeCurrentSaturation_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write the default value to mandatory attribute: CurrentSaturation\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads back mandatory attribute: CurrentSaturation\n");
            err = TestReadsBackMandatoryAttributeCurrentSaturation_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read the mandatory attribute: CurrentX\n");
            err = TestReadTheMandatoryAttributeCurrentX_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Validate constraints of attribute: CurrentX\n");
            err = TestValidateConstraintsOfAttributeCurrentX_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write the default value to mandatory attribute: CurrentX\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentX_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads back mandatory attribute: CurrentX\n");
            err = TestReadsBackMandatoryAttributeCurrentX_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read the mandatory attribute: CurrentY\n");
            err = TestReadTheMandatoryAttributeCurrentY_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Validate constraints of attribute: CurrentY\n");
            err = TestValidateConstraintsOfAttributeCurrentY_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Write the default values to mandatory attribute: CurrentY\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reads back mandatory attribute: CurrentY\n");
            err = TestReadsBackMandatoryAttributeCurrentY_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Validate constraints of attribute: ColorTemperatureMireds\n");
            err = TestValidateConstraintsOfAttributeColorTemperatureMireds_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Validate constraints of attribute: ColorMode\n");
            err = TestValidateConstraintsOfAttributeColorMode_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read the mandatory attribute: Options\n");
            err = TestReadTheMandatoryAttributeOptions_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Validate constraints of attribute: Options\n");
            err = TestValidateConstraintsOfAttributeOptions_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Write the default values to mandatory attribute: Options\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeOptions_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads back mandatory attribute: Options\n");
            err = TestReadsBackMandatoryAttributeOptions_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read the mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadTheMandatoryAttributeEnhancedCurrentHue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Validate constraints of attribute: EnhancedCurrentHue\n");
            err = TestValidateConstraintsOfAttributeEnhancedCurrentHue_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : Write the default values to mandatory attribute: EnhancedCurrentHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Reads back mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadsBackMandatoryAttributeEnhancedCurrentHue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Validate constraints of attribute: EnhancedColorMode\n");
            err = TestValidateConstraintsOfAttributeEnhancedColorMode_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read the mandatory attribute: ColorLoopActive\n");
            err = TestReadTheMandatoryAttributeColorLoopActive_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Validate constraints of attribute: ColorLoopActive\n");
            err = TestValidateConstraintsOfAttributeColorLoopActive_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Write the default values to mandatory attribute: ColorLoopActive\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads back mandatory attribute: ColorLoopActive\n");
            err = TestReadsBackMandatoryAttributeColorLoopActive_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read the mandatory attribute: ColorLoopDirection\n");
            err = TestReadTheMandatoryAttributeColorLoopDirection_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Validate constraints of attribute: ColorLoopDirection\n");
            err = TestValidateConstraintsOfAttributeColorLoopDirection_32();
            break;
        case 33:
            ChipLogProgress(chipTool,
                            " ***** Test Step 33 : Write the default values to mandatory attribute: ColorLoopDirection\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads back mandatory attribute: ColorLoopDirection\n");
            err = TestReadsBackMandatoryAttributeColorLoopDirection_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read the mandatory attribute: ColorLoopTime\n");
            err = TestReadTheMandatoryAttributeColorLoopTime_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Validate constraints of attribute: ColorLoopTime\n");
            err = TestValidateConstraintsOfAttributeColorLoopTime_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write the default values to mandatory attribute: ColorLoopTime\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads back mandatory attribute: ColorLoopTime\n");
            err = TestReadsBackMandatoryAttributeColorLoopTime_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read the mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadTheMandatoryAttributeColorLoopStartEnhancedHue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Validate constraints of attribute: ColorLoopStartEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_40();
            break;
        case 41:
            ChipLogProgress(chipTool,
                            " ***** Test Step 41 : Write the default values to mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads back mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read the mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadTheMandatoryAttributeColorLoopStoredEnhancedHue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Validate constraints of attribute: ColorLoopStoredEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_44();
            break;
        case 45:
            ChipLogProgress(chipTool,
                            " ***** Test Step 45 : Write the default values to mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reads back mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Read the mandatory attribute: ColorCapabilities\n");
            err = TestReadTheMandatoryAttributeColorCapabilities_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Validate constraints of attribute: ColorCapabilities\n");
            err = TestValidateConstraintsOfAttributeColorCapabilities_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Write the default values to mandatory attribute: ColorCapabilities\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Reads back mandatory attribute: ColorCapabilities\n");
            err = TestReadsBackMandatoryAttributeColorCapabilities_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read the mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadTheMandatoryAttributeColorTempPhysicalMinMireds_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Validate constraints of attribute: ColorTempPhysicalMinMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_52();
            break;
        case 53:
            ChipLogProgress(chipTool,
                            " ***** Test Step 53 : Write the default values to mandatory  attribute: ColorTempPhysicalMinMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Reads back mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Read the mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadTheMandatoryAttributeColorTempPhysicalMaxMireds_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Validate constraints of attribute: ColorTempPhysicalMaxMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_56();
            break;
        case 57:
            ChipLogProgress(chipTool,
                            " ***** Test Step 57 : Write the default values to mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Reads back mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read the optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_59();
            break;
        case 60:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 60 : Write the default values to optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Reads back optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Read the optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadTheOptionalAttributeStartUpColorTemperatureMireds_62();
            break;
        case 63:
            ChipLogProgress(
                chipTool, " ***** Test Step 63 : Write the default values to optional attribute: StartUpColorTemperatureMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Reads back optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Read the Optional attribute: RemainingTime\n");
            err = TestReadTheOptionalAttributeRemainingTime_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Validate constraints of attribute: RemainingTime\n");
            err = TestValidateConstraintsOfAttributeRemainingTime_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write the default values to optional attribute: RemainingTime\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Reads back optional attribute: RemainingTime\n");
            err = TestReadsBackOptionalAttributeRemainingTime_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read the optional attribute: DriftCompensation\n");
            err = TestReadTheOptionalAttributeDriftCompensation_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write the default values to optional attribute: DriftCompensation\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Reads back optional attribute: DriftCompensation\n");
            err = TestReadsBackOptionalAttributeDriftCompensation_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Read the optional attribute: CompensationText\n");
            err = TestReadTheOptionalAttributeCompensationText_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadTheMandatoryAttributeNumberOfPrimaries_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Write the default mandatory attribute: NumberOfPrimaries\n");
            err = TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Read back the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadBackTheMandatoryAttributeNumberOfPrimaries_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read the mandatory attribute: Primary1X\n");
            err = TestReadTheMandatoryAttributePrimary1X_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write the default mandatory attribute: Primary1X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1X_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read back the mandatory attribute: Primary1X\n");
            err = TestReadBackTheMandatoryAttributePrimary1X_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read the mandatory attribute: Primary1Y\n");
            err = TestReadTheMandatoryAttributePrimary1Y_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write the default mandatory attribute: Primary1Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1Y_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read back the mandatory attribute: Primary1Y\n");
            err = TestReadBackTheMandatoryAttributePrimary1Y_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read the mandatory attribute: Primary1Intensity\n");
            err = TestReadTheMandatoryAttributePrimary1Intensity_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read the mandatory attribute: Primary2X\n");
            err = TestReadTheMandatoryAttributePrimary2X_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write the default mandatory attribute: Primary2X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2X_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read back the mandatory attribute: Primary2X\n");
            err = TestReadBackTheMandatoryAttributePrimary2X_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read the mandatory attribute: Primary2Y\n");
            err = TestReadTheMandatoryAttributePrimary2Y_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write the default mandatory attribute: Primary2Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2Y_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read back the mandatory attribute: Primary2Y\n");
            err = TestReadBackTheMandatoryAttributePrimary2Y_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Validate constraints of attribute: Primary2Intensity\n");
            err = TestValidateConstraintsOfAttributePrimary2Intensity_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read the mandatory attribute: Primary3X\n");
            err = TestReadTheMandatoryAttributePrimary3X_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write the default mandatory attribute: Primary3X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3X_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read back the mandatory attribute: Primary3X\n");
            err = TestReadBackTheMandatoryAttributePrimary3X_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read the mandatory attribute: Primary3Y\n");
            err = TestReadTheMandatoryAttributePrimary3Y_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Write the default mandatory attribute: Primary3Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3Y_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Read back the mandatory attribute: Primary3Y\n");
            err = TestReadBackTheMandatoryAttributePrimary3Y_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read the mandatory attribute: Primary3Intensity\n");
            err = TestReadTheMandatoryAttributePrimary3Intensity_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read the mandatory attribute: Primary4X\n");
            err = TestReadTheMandatoryAttributePrimary4X_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Write the default mandatory attribute: Primary4X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4X_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read back the mandatory attribute: Primary4X\n");
            err = TestReadBackTheMandatoryAttributePrimary4X_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Read the mandatory attribute: Primary4Y\n");
            err = TestReadTheMandatoryAttributePrimary4Y_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write the default mandatory attribute: Primary4Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4Y_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read back the mandatory attribute: Primary4Y\n");
            err = TestReadBackTheMandatoryAttributePrimary4Y_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Read the mandatory attribute: Primary4Intensity\n");
            err = TestReadTheMandatoryAttributePrimary4Intensity_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read the mandatory attribute: Primary5X\n");
            err = TestReadTheMandatoryAttributePrimary5X_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write the default mandatory attribute: Primary5X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5X_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read back the mandatory attribute: Primary5X\n");
            err = TestReadBackTheMandatoryAttributePrimary5X_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read the mandatory attribute: Primary5Y\n");
            err = TestReadTheMandatoryAttributePrimary5Y_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Write the default mandatory attribute: Primary5Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5Y_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read back the mandatory attribute: Primary5Y\n");
            err = TestReadBackTheMandatoryAttributePrimary5Y_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Read the mandatory attribute: Primary5Intensity\n");
            err = TestReadTheMandatoryAttributePrimary5Intensity_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read the mandatory attribute: Primary6X\n");
            err = TestReadTheMandatoryAttributePrimary6X_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Write the default mandatory attribute: Primary6X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6X_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read back the mandatory attribute: Primary6X\n");
            err = TestReadBackTheMandatoryAttributePrimary6X_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Read the mandatory attribute: Primary6Y\n");
            err = TestReadTheMandatoryAttributePrimary6Y_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Write the default mandatory attribute: Primary6Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6Y_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Read back the mandatory attribute: Primary6Y\n");
            err = TestReadBackTheMandatoryAttributePrimary6Y_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read the mandatory attribute: Primary6Intensity\n");
            err = TestReadTheMandatoryAttributePrimary6Intensity_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Read the optional attribute: WhitePointX\n");
            err = TestReadTheOptionalAttributeWhitePointX_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Write the default optional attribute: WhitePointX\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointX_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Read back the optional attribute: WhitePointX\n");
            err = TestReadBackTheOptionalAttributeWhitePointX_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read the optional attribute: WhitePointY\n");
            err = TestReadTheOptionalAttributeWhitePointY_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write the default optional attribute: WhitePointY\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointY_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read back the optional attribute: WhitePointY\n");
            err = TestReadBackTheOptionalAttributeWhitePointY_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Read the optional attribute: ColorPointRX\n");
            err = TestReadTheOptionalAttributeColorPointRX_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Write the default optional attribute: ColorPointRX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRX_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Read back the optional attribute: ColorPointRX\n");
            err = TestReadBackTheOptionalAttributeColorPointRX_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read the optional attribute: ColorPointRY\n");
            err = TestReadTheOptionalAttributeColorPointRY_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write the default optional attribute: ColorPointRY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRY_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read back the optional attribute: ColorPointRY\n");
            err = TestReadBackTheOptionalAttributeColorPointRY_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Read the optional attribute: ColorPointRIntensity\n");
            err = TestReadTheOptionalAttributeColorPointRIntensity_130();
            break;
        case 131:
            ChipLogProgress(chipTool, " ***** Test Step 131 : Read the optional attribute: ColorPointGX\n");
            err = TestReadTheOptionalAttributeColorPointGX_131();
            break;
        case 132:
            ChipLogProgress(chipTool, " ***** Test Step 132 : Write the default optional attribute: ColorPointGX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGX_132();
            break;
        case 133:
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read back the optional attribute: ColorPointGX\n");
            err = TestReadBackTheOptionalAttributeColorPointGX_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Read the optional attribute: ColorPointGY\n");
            err = TestReadTheOptionalAttributeColorPointGY_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Write the default optional attribute: ColorPointGY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGY_135();
            break;
        case 136:
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read back the optional attribute: ColorPointGY\n");
            err = TestReadBackTheOptionalAttributeColorPointGY_136();
            break;
        case 137:
            ChipLogProgress(chipTool, " ***** Test Step 137 : Read the optional attribute: ColorPointGIntensity\n");
            err = TestReadTheOptionalAttributeColorPointGIntensity_137();
            break;
        case 138:
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read the optional attribute: ColorPointBX\n");
            err = TestReadTheOptionalAttributeColorPointBX_138();
            break;
        case 139:
            ChipLogProgress(chipTool, " ***** Test Step 139 : Write the default optional attribute: ColorPointBX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBX_139();
            break;
        case 140:
            ChipLogProgress(chipTool, " ***** Test Step 140 : Read back the optional attribute: ColorPointBX\n");
            err = TestReadBackTheOptionalAttributeColorPointBX_140();
            break;
        case 141:
            ChipLogProgress(chipTool, " ***** Test Step 141 : Read the optional attribute: ColorPointBY\n");
            err = TestReadTheOptionalAttributeColorPointBY_141();
            break;
        case 142:
            ChipLogProgress(chipTool, " ***** Test Step 142 : Write the default optional attribute: ColorPointBY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBY_142();
            break;
        case 143:
            ChipLogProgress(chipTool, " ***** Test Step 143 : Read back the optional attribute: ColorPointBY\n");
            err = TestReadBackTheOptionalAttributeColorPointBY_143();
            break;
        case 144:
            ChipLogProgress(chipTool, " ***** Test Step 144 : Read the optional attribute: ColorPointBIntensity\n");
            err = TestReadTheOptionalAttributeColorPointBIntensity_144();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 145;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentHue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentHue)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentHue)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentSaturation)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentSaturation)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentSaturation)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t currentX)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t currentX)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t currentX)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t currentY)> mOnSuccessCallback_12{ OnSuccessCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t currentY)> mOnSuccessCallback_13{ OnSuccessCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t currentY)> mOnSuccessCallback_15{ OnSuccessCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_16{ OnFailureCallback_16, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorTemperature)> mOnSuccessCallback_16{ OnSuccessCallback_16,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_17{ OnFailureCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorMode)> mOnSuccessCallback_17{ OnSuccessCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_18{ OnFailureCallback_18, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorControlOptions)> mOnSuccessCallback_18{ OnSuccessCallback_18,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_19{ OnFailureCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorControlOptions)> mOnSuccessCallback_19{ OnSuccessCallback_19,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_21{ OnFailureCallback_21, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorControlOptions)> mOnSuccessCallback_21{ OnSuccessCallback_21,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_22{ OnFailureCallback_22, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enhancedCurrentHue)> mOnSuccessCallback_22{ OnSuccessCallback_22,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_23{ OnFailureCallback_23, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enhancedCurrentHue)> mOnSuccessCallback_23{ OnSuccessCallback_23,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_25{ OnFailureCallback_25, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enhancedCurrentHue)> mOnSuccessCallback_25{ OnSuccessCallback_25,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_26{ OnFailureCallback_26, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enhancedColorMode)> mOnSuccessCallback_26{ OnSuccessCallback_26,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_27{ OnFailureCallback_27, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_27{ OnSuccessCallback_27, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_28{ OnFailureCallback_28, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_28{ OnSuccessCallback_28, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_30{ OnFailureCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_30{ OnSuccessCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_31{ OnFailureCallback_31, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_31{ OnSuccessCallback_31,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_32{ OnFailureCallback_32, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_32{ OnSuccessCallback_32,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_34{ OnFailureCallback_34, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_34{ OnSuccessCallback_34,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_35{ OnFailureCallback_35, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_35{ OnSuccessCallback_35, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_36{ OnFailureCallback_36, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_36{ OnSuccessCallback_36, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_38{ OnFailureCallback_38, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_38{ OnSuccessCallback_38, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_39{ OnFailureCallback_39, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStartEnhancedHue)> mOnSuccessCallback_39{
        OnSuccessCallback_39, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_40{ OnFailureCallback_40, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStartEnhancedHue)> mOnSuccessCallback_40{
        OnSuccessCallback_40, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_42{ OnFailureCallback_42, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStartEnhancedHue)> mOnSuccessCallback_42{
        OnSuccessCallback_42, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_43{ OnFailureCallback_43, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStoredEnhancedHue)> mOnSuccessCallback_43{
        OnSuccessCallback_43, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_44{ OnFailureCallback_44, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStoredEnhancedHue)> mOnSuccessCallback_44{
        OnSuccessCallback_44, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_46{ OnFailureCallback_46, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStoredEnhancedHue)> mOnSuccessCallback_46{
        OnSuccessCallback_46, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_47{ OnFailureCallback_47, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorCapabilities)> mOnSuccessCallback_47{ OnSuccessCallback_47,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_48{ OnFailureCallback_48, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorCapabilities)> mOnSuccessCallback_48{ OnSuccessCallback_48,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_50{ OnFailureCallback_50, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorCapabilities)> mOnSuccessCallback_50{ OnSuccessCallback_50,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_51{ OnFailureCallback_51, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorTempPhysicalMin)> mOnSuccessCallback_51{ OnSuccessCallback_51,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_52{ OnFailureCallback_52, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorTempPhysicalMin)> mOnSuccessCallback_52{ OnSuccessCallback_52,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_54{ OnFailureCallback_54, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorTempPhysicalMin)> mOnSuccessCallback_54{ OnSuccessCallback_54,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_55{ OnFailureCallback_55, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorTempPhysicalMax)> mOnSuccessCallback_55{ OnSuccessCallback_55,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_56{ OnFailureCallback_56, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorTempPhysicalMax)> mOnSuccessCallback_56{ OnSuccessCallback_56,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_58{ OnFailureCallback_58, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorTempPhysicalMax)> mOnSuccessCallback_58{ OnSuccessCallback_58,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_59{ OnFailureCallback_59, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t coupleColorTempToLevelMinMireds)> mOnSuccessCallback_59{
        OnSuccessCallback_59, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_61{ OnFailureCallback_61, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t coupleColorTempToLevelMinMireds)> mOnSuccessCallback_61{
        OnSuccessCallback_61, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_62{ OnFailureCallback_62, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t startUpColorTemperatureMireds)> mOnSuccessCallback_62{
        OnSuccessCallback_62, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_64{ OnFailureCallback_64, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t startUpColorTemperatureMireds)> mOnSuccessCallback_64{
        OnSuccessCallback_64, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_65{ OnFailureCallback_65, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t remainingTime)> mOnSuccessCallback_65{ OnSuccessCallback_65, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_66{ OnFailureCallback_66, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t remainingTime)> mOnSuccessCallback_66{ OnSuccessCallback_66, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_68{ OnFailureCallback_68, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t remainingTime)> mOnSuccessCallback_68{ OnSuccessCallback_68, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_69{ OnFailureCallback_69, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t driftCompensation)> mOnSuccessCallback_69{ OnSuccessCallback_69,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_71{ OnFailureCallback_71, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t driftCompensation)> mOnSuccessCallback_71{ OnSuccessCallback_71,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_72{ OnFailureCallback_72, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan compensationText)> mOnSuccessCallback_72{ OnSuccessCallback_72,
                                                                                                               this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_73{ OnFailureCallback_73, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t numberOfPrimaries)> mOnSuccessCallback_73{ OnSuccessCallback_73,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_75{ OnFailureCallback_75, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t numberOfPrimaries)> mOnSuccessCallback_75{ OnSuccessCallback_75,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_76{ OnFailureCallback_76, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary1X)> mOnSuccessCallback_76{ OnSuccessCallback_76, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_78{ OnFailureCallback_78, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary1X)> mOnSuccessCallback_78{ OnSuccessCallback_78, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_79{ OnFailureCallback_79, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary1Y)> mOnSuccessCallback_79{ OnSuccessCallback_79, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_81{ OnFailureCallback_81, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary1Y)> mOnSuccessCallback_81{ OnSuccessCallback_81, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_82{ OnFailureCallback_82, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t primary1Intensity)> mOnSuccessCallback_82{ OnSuccessCallback_82,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_83{ OnFailureCallback_83, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary2X)> mOnSuccessCallback_83{ OnSuccessCallback_83, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_85{ OnFailureCallback_85, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary2X)> mOnSuccessCallback_85{ OnSuccessCallback_85, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_86{ OnFailureCallback_86, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary2Y)> mOnSuccessCallback_86{ OnSuccessCallback_86, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_88{ OnFailureCallback_88, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary2Y)> mOnSuccessCallback_88{ OnSuccessCallback_88, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_89{ OnFailureCallback_89, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t primary2Intensity)> mOnSuccessCallback_89{ OnSuccessCallback_89,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_90{ OnFailureCallback_90, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary3X)> mOnSuccessCallback_90{ OnSuccessCallback_90, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_92{ OnFailureCallback_92, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary3X)> mOnSuccessCallback_92{ OnSuccessCallback_92, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_93{ OnFailureCallback_93, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary3Y)> mOnSuccessCallback_93{ OnSuccessCallback_93, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_95{ OnFailureCallback_95, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary3Y)> mOnSuccessCallback_95{ OnSuccessCallback_95, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_96{ OnFailureCallback_96, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t primary3Intensity)> mOnSuccessCallback_96{ OnSuccessCallback_96,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_97{ OnFailureCallback_97, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary4X)> mOnSuccessCallback_97{ OnSuccessCallback_97, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_99{ OnFailureCallback_99, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary4X)> mOnSuccessCallback_99{ OnSuccessCallback_99, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_100{ OnFailureCallback_100, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary4Y)> mOnSuccessCallback_100{ OnSuccessCallback_100, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_102{ OnFailureCallback_102, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary4Y)> mOnSuccessCallback_102{ OnSuccessCallback_102, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_103{ OnFailureCallback_103, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t primary4Intensity)> mOnSuccessCallback_103{ OnSuccessCallback_103,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_104{ OnFailureCallback_104, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary5X)> mOnSuccessCallback_104{ OnSuccessCallback_104, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_106{ OnFailureCallback_106, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary5X)> mOnSuccessCallback_106{ OnSuccessCallback_106, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_107{ OnFailureCallback_107, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary5Y)> mOnSuccessCallback_107{ OnSuccessCallback_107, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_109{ OnFailureCallback_109, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary5Y)> mOnSuccessCallback_109{ OnSuccessCallback_109, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_110{ OnFailureCallback_110, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t primary5Intensity)> mOnSuccessCallback_110{ OnSuccessCallback_110,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_111{ OnFailureCallback_111, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary6X)> mOnSuccessCallback_111{ OnSuccessCallback_111, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_113{ OnFailureCallback_113, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary6X)> mOnSuccessCallback_113{ OnSuccessCallback_113, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_114{ OnFailureCallback_114, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary6Y)> mOnSuccessCallback_114{ OnSuccessCallback_114, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_116{ OnFailureCallback_116, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t primary6Y)> mOnSuccessCallback_116{ OnSuccessCallback_116, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_117{ OnFailureCallback_117, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t primary6Intensity)> mOnSuccessCallback_117{ OnSuccessCallback_117,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_118{ OnFailureCallback_118, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t whitePointX)> mOnSuccessCallback_118{ OnSuccessCallback_118, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_120{ OnFailureCallback_120, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t whitePointX)> mOnSuccessCallback_120{ OnSuccessCallback_120, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_121{ OnFailureCallback_121, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t whitePointY)> mOnSuccessCallback_121{ OnSuccessCallback_121, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_123{ OnFailureCallback_123, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t whitePointY)> mOnSuccessCallback_123{ OnSuccessCallback_123, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_124{ OnFailureCallback_124, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointRX)> mOnSuccessCallback_124{ OnSuccessCallback_124, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_126{ OnFailureCallback_126, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointRX)> mOnSuccessCallback_126{ OnSuccessCallback_126, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_127{ OnFailureCallback_127, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointRY)> mOnSuccessCallback_127{ OnSuccessCallback_127, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_129{ OnFailureCallback_129, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointRY)> mOnSuccessCallback_129{ OnSuccessCallback_129, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_130{ OnFailureCallback_130, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorPointRIntensity)> mOnSuccessCallback_130{ OnSuccessCallback_130,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_131{ OnFailureCallback_131, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointGX)> mOnSuccessCallback_131{ OnSuccessCallback_131, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_133{ OnFailureCallback_133, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointGX)> mOnSuccessCallback_133{ OnSuccessCallback_133, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_134{ OnFailureCallback_134, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointGY)> mOnSuccessCallback_134{ OnSuccessCallback_134, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_136{ OnFailureCallback_136, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointGY)> mOnSuccessCallback_136{ OnSuccessCallback_136, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_137{ OnFailureCallback_137, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorPointGIntensity)> mOnSuccessCallback_137{ OnSuccessCallback_137,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_138{ OnFailureCallback_138, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointBX)> mOnSuccessCallback_138{ OnSuccessCallback_138, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_140{ OnFailureCallback_140, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointBX)> mOnSuccessCallback_140{ OnSuccessCallback_140, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_141{ OnFailureCallback_141, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointBY)> mOnSuccessCallback_141{ OnSuccessCallback_141, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_143{ OnFailureCallback_143, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorPointBY)> mOnSuccessCallback_143{ OnSuccessCallback_143, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_144{ OnFailureCallback_144, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorPointBIntensity)> mOnSuccessCallback_144{ OnSuccessCallback_144,
                                                                                                             this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_0(currentHue);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_1(currentHue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_3(currentHue);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_4(currentSaturation);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_5(currentSaturation);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_7(currentSaturation);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_8(currentX);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_9(currentX);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_11(currentX);
    }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_12(currentY);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_13(currentY);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_15(currentY);
    }

    static void OnFailureCallback_16(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_16(status);
    }

    static void OnSuccessCallback_16(void * context, uint16_t colorTemperature)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_16(colorTemperature);
    }

    static void OnFailureCallback_17(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_17(status);
    }

    static void OnSuccessCallback_17(void * context, uint8_t colorMode)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_17(colorMode);
    }

    static void OnFailureCallback_18(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_18(status);
    }

    static void OnSuccessCallback_18(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_18(colorControlOptions);
    }

    static void OnFailureCallback_19(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_19(status);
    }

    static void OnSuccessCallback_19(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_19(colorControlOptions);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_21(status);
    }

    static void OnSuccessCallback_21(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_21(colorControlOptions);
    }

    static void OnFailureCallback_22(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_22(status);
    }

    static void OnSuccessCallback_22(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_22(enhancedCurrentHue);
    }

    static void OnFailureCallback_23(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_23(status);
    }

    static void OnSuccessCallback_23(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_23(enhancedCurrentHue);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_25(status);
    }

    static void OnSuccessCallback_25(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_25(enhancedCurrentHue);
    }

    static void OnFailureCallback_26(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_26(status);
    }

    static void OnSuccessCallback_26(void * context, uint8_t enhancedColorMode)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_26(enhancedColorMode);
    }

    static void OnFailureCallback_27(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_27(status);
    }

    static void OnSuccessCallback_27(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_27(colorLoopActive);
    }

    static void OnFailureCallback_28(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_28(status);
    }

    static void OnSuccessCallback_28(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_28(colorLoopActive);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_30(status);
    }

    static void OnSuccessCallback_30(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_30(colorLoopActive);
    }

    static void OnFailureCallback_31(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_31(status);
    }

    static void OnSuccessCallback_31(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_31(colorLoopDirection);
    }

    static void OnFailureCallback_32(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_32(status);
    }

    static void OnSuccessCallback_32(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_32(colorLoopDirection);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_33(); }

    static void OnFailureCallback_34(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_34(status);
    }

    static void OnSuccessCallback_34(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_34(colorLoopDirection);
    }

    static void OnFailureCallback_35(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_35(status);
    }

    static void OnSuccessCallback_35(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_35(colorLoopTime);
    }

    static void OnFailureCallback_36(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_36(status);
    }

    static void OnSuccessCallback_36(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_36(colorLoopTime);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_38(status);
    }

    static void OnSuccessCallback_38(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_38(colorLoopTime);
    }

    static void OnFailureCallback_39(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_39(status);
    }

    static void OnSuccessCallback_39(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_39(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_40(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_40(status);
    }

    static void OnSuccessCallback_40(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_40(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_41(); }

    static void OnFailureCallback_42(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_42(status);
    }

    static void OnSuccessCallback_42(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_42(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_43(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_43(status);
    }

    static void OnSuccessCallback_43(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_43(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_44(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_44(status);
    }

    static void OnSuccessCallback_44(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_44(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_45(); }

    static void OnFailureCallback_46(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_46(status);
    }

    static void OnSuccessCallback_46(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_46(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_47(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_47(status);
    }

    static void OnSuccessCallback_47(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_47(colorCapabilities);
    }

    static void OnFailureCallback_48(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_48(status);
    }

    static void OnSuccessCallback_48(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_48(colorCapabilities);
    }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_49(); }

    static void OnFailureCallback_50(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_50(status);
    }

    static void OnSuccessCallback_50(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_50(colorCapabilities);
    }

    static void OnFailureCallback_51(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_51(status);
    }

    static void OnSuccessCallback_51(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_51(colorTempPhysicalMin);
    }

    static void OnFailureCallback_52(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_52(status);
    }

    static void OnSuccessCallback_52(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_52(colorTempPhysicalMin);
    }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_53(); }

    static void OnFailureCallback_54(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_54(status);
    }

    static void OnSuccessCallback_54(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_54(colorTempPhysicalMin);
    }

    static void OnFailureCallback_55(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_55(status);
    }

    static void OnSuccessCallback_55(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_55(colorTempPhysicalMax);
    }

    static void OnFailureCallback_56(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_56(status);
    }

    static void OnSuccessCallback_56(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_56(colorTempPhysicalMax);
    }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_57(); }

    static void OnFailureCallback_58(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_58(status);
    }

    static void OnSuccessCallback_58(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_58(colorTempPhysicalMax);
    }

    static void OnFailureCallback_59(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_59(status);
    }

    static void OnSuccessCallback_59(void * context, uint16_t coupleColorTempToLevelMinMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_59(coupleColorTempToLevelMinMireds);
    }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_60(); }

    static void OnFailureCallback_61(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_61(status);
    }

    static void OnSuccessCallback_61(void * context, uint16_t coupleColorTempToLevelMinMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_61(coupleColorTempToLevelMinMireds);
    }

    static void OnFailureCallback_62(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_62(status);
    }

    static void OnSuccessCallback_62(void * context, uint16_t startUpColorTemperatureMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_62(startUpColorTemperatureMireds);
    }

    static void OnFailureCallback_63(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_63(chip::to_underlying(status));
    }

    static void OnSuccessCallback_63(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_63(); }

    static void OnFailureCallback_64(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_64(status);
    }

    static void OnSuccessCallback_64(void * context, uint16_t startUpColorTemperatureMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_64(startUpColorTemperatureMireds);
    }

    static void OnFailureCallback_65(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_65(status);
    }

    static void OnSuccessCallback_65(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_65(remainingTime);
    }

    static void OnFailureCallback_66(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_66(status);
    }

    static void OnSuccessCallback_66(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_66(remainingTime);
    }

    static void OnFailureCallback_67(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_67(chip::to_underlying(status));
    }

    static void OnSuccessCallback_67(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_67(); }

    static void OnFailureCallback_68(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_68(status);
    }

    static void OnSuccessCallback_68(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_68(remainingTime);
    }

    static void OnFailureCallback_69(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_69(status);
    }

    static void OnSuccessCallback_69(void * context, uint8_t driftCompensation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_69(driftCompensation);
    }

    static void OnFailureCallback_70(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_70(chip::to_underlying(status));
    }

    static void OnSuccessCallback_70(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_70(); }

    static void OnFailureCallback_71(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_71(status);
    }

    static void OnSuccessCallback_71(void * context, uint8_t driftCompensation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_71(driftCompensation);
    }

    static void OnFailureCallback_72(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_72(status);
    }

    static void OnSuccessCallback_72(void * context, chip::CharSpan compensationText)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_72(compensationText);
    }

    static void OnFailureCallback_73(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_73(status);
    }

    static void OnSuccessCallback_73(void * context, uint8_t numberOfPrimaries)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_73(numberOfPrimaries);
    }

    static void OnFailureCallback_74(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_74(chip::to_underlying(status));
    }

    static void OnSuccessCallback_74(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_74(); }

    static void OnFailureCallback_75(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_75(status);
    }

    static void OnSuccessCallback_75(void * context, uint8_t numberOfPrimaries)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_75(numberOfPrimaries);
    }

    static void OnFailureCallback_76(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_76(status);
    }

    static void OnSuccessCallback_76(void * context, uint16_t primary1X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_76(primary1X);
    }

    static void OnFailureCallback_77(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_77(chip::to_underlying(status));
    }

    static void OnSuccessCallback_77(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_77(); }

    static void OnFailureCallback_78(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_78(status);
    }

    static void OnSuccessCallback_78(void * context, uint16_t primary1X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_78(primary1X);
    }

    static void OnFailureCallback_79(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_79(status);
    }

    static void OnSuccessCallback_79(void * context, uint16_t primary1Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_79(primary1Y);
    }

    static void OnFailureCallback_80(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_80(chip::to_underlying(status));
    }

    static void OnSuccessCallback_80(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_80(); }

    static void OnFailureCallback_81(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_81(status);
    }

    static void OnSuccessCallback_81(void * context, uint16_t primary1Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_81(primary1Y);
    }

    static void OnFailureCallback_82(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_82(status);
    }

    static void OnSuccessCallback_82(void * context, uint8_t primary1Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_82(primary1Intensity);
    }

    static void OnFailureCallback_83(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_83(status);
    }

    static void OnSuccessCallback_83(void * context, uint16_t primary2X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_83(primary2X);
    }

    static void OnFailureCallback_84(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_84(chip::to_underlying(status));
    }

    static void OnSuccessCallback_84(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_84(); }

    static void OnFailureCallback_85(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_85(status);
    }

    static void OnSuccessCallback_85(void * context, uint16_t primary2X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_85(primary2X);
    }

    static void OnFailureCallback_86(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_86(status);
    }

    static void OnSuccessCallback_86(void * context, uint16_t primary2Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_86(primary2Y);
    }

    static void OnFailureCallback_87(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_87(chip::to_underlying(status));
    }

    static void OnSuccessCallback_87(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_87(); }

    static void OnFailureCallback_88(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_88(status);
    }

    static void OnSuccessCallback_88(void * context, uint16_t primary2Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_88(primary2Y);
    }

    static void OnFailureCallback_89(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_89(status);
    }

    static void OnSuccessCallback_89(void * context, uint8_t primary2Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_89(primary2Intensity);
    }

    static void OnFailureCallback_90(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_90(status);
    }

    static void OnSuccessCallback_90(void * context, uint16_t primary3X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_90(primary3X);
    }

    static void OnFailureCallback_91(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_91(chip::to_underlying(status));
    }

    static void OnSuccessCallback_91(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_91(); }

    static void OnFailureCallback_92(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_92(status);
    }

    static void OnSuccessCallback_92(void * context, uint16_t primary3X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_92(primary3X);
    }

    static void OnFailureCallback_93(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_93(status);
    }

    static void OnSuccessCallback_93(void * context, uint16_t primary3Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_93(primary3Y);
    }

    static void OnFailureCallback_94(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_94(chip::to_underlying(status));
    }

    static void OnSuccessCallback_94(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_94(); }

    static void OnFailureCallback_95(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_95(status);
    }

    static void OnSuccessCallback_95(void * context, uint16_t primary3Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_95(primary3Y);
    }

    static void OnFailureCallback_96(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_96(status);
    }

    static void OnSuccessCallback_96(void * context, uint8_t primary3Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_96(primary3Intensity);
    }

    static void OnFailureCallback_97(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_97(status);
    }

    static void OnSuccessCallback_97(void * context, uint16_t primary4X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_97(primary4X);
    }

    static void OnFailureCallback_98(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_98(chip::to_underlying(status));
    }

    static void OnSuccessCallback_98(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_98(); }

    static void OnFailureCallback_99(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_99(status);
    }

    static void OnSuccessCallback_99(void * context, uint16_t primary4X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_99(primary4X);
    }

    static void OnFailureCallback_100(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_100(status);
    }

    static void OnSuccessCallback_100(void * context, uint16_t primary4Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_100(primary4Y);
    }

    static void OnFailureCallback_101(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_101(chip::to_underlying(status));
    }

    static void OnSuccessCallback_101(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_101(); }

    static void OnFailureCallback_102(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_102(status);
    }

    static void OnSuccessCallback_102(void * context, uint16_t primary4Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_102(primary4Y);
    }

    static void OnFailureCallback_103(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_103(status);
    }

    static void OnSuccessCallback_103(void * context, uint8_t primary4Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_103(primary4Intensity);
    }

    static void OnFailureCallback_104(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_104(status);
    }

    static void OnSuccessCallback_104(void * context, uint16_t primary5X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_104(primary5X);
    }

    static void OnFailureCallback_105(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_105(chip::to_underlying(status));
    }

    static void OnSuccessCallback_105(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_105(); }

    static void OnFailureCallback_106(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_106(status);
    }

    static void OnSuccessCallback_106(void * context, uint16_t primary5X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_106(primary5X);
    }

    static void OnFailureCallback_107(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_107(status);
    }

    static void OnSuccessCallback_107(void * context, uint16_t primary5Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_107(primary5Y);
    }

    static void OnFailureCallback_108(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_108(chip::to_underlying(status));
    }

    static void OnSuccessCallback_108(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_108(); }

    static void OnFailureCallback_109(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_109(status);
    }

    static void OnSuccessCallback_109(void * context, uint16_t primary5Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_109(primary5Y);
    }

    static void OnFailureCallback_110(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_110(status);
    }

    static void OnSuccessCallback_110(void * context, uint8_t primary5Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_110(primary5Intensity);
    }

    static void OnFailureCallback_111(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_111(status);
    }

    static void OnSuccessCallback_111(void * context, uint16_t primary6X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_111(primary6X);
    }

    static void OnFailureCallback_112(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_112(chip::to_underlying(status));
    }

    static void OnSuccessCallback_112(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_112(); }

    static void OnFailureCallback_113(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_113(status);
    }

    static void OnSuccessCallback_113(void * context, uint16_t primary6X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_113(primary6X);
    }

    static void OnFailureCallback_114(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_114(status);
    }

    static void OnSuccessCallback_114(void * context, uint16_t primary6Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_114(primary6Y);
    }

    static void OnFailureCallback_115(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_115(chip::to_underlying(status));
    }

    static void OnSuccessCallback_115(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_115(); }

    static void OnFailureCallback_116(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_116(status);
    }

    static void OnSuccessCallback_116(void * context, uint16_t primary6Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_116(primary6Y);
    }

    static void OnFailureCallback_117(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_117(status);
    }

    static void OnSuccessCallback_117(void * context, uint8_t primary6Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_117(primary6Intensity);
    }

    static void OnFailureCallback_118(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_118(status);
    }

    static void OnSuccessCallback_118(void * context, uint16_t whitePointX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_118(whitePointX);
    }

    static void OnFailureCallback_119(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_119(chip::to_underlying(status));
    }

    static void OnSuccessCallback_119(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_119(); }

    static void OnFailureCallback_120(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_120(status);
    }

    static void OnSuccessCallback_120(void * context, uint16_t whitePointX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_120(whitePointX);
    }

    static void OnFailureCallback_121(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_121(status);
    }

    static void OnSuccessCallback_121(void * context, uint16_t whitePointY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_121(whitePointY);
    }

    static void OnFailureCallback_122(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_122(chip::to_underlying(status));
    }

    static void OnSuccessCallback_122(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_122(); }

    static void OnFailureCallback_123(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_123(status);
    }

    static void OnSuccessCallback_123(void * context, uint16_t whitePointY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_123(whitePointY);
    }

    static void OnFailureCallback_124(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_124(status);
    }

    static void OnSuccessCallback_124(void * context, uint16_t colorPointRX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_124(colorPointRX);
    }

    static void OnFailureCallback_125(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_125(chip::to_underlying(status));
    }

    static void OnSuccessCallback_125(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_125(); }

    static void OnFailureCallback_126(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_126(status);
    }

    static void OnSuccessCallback_126(void * context, uint16_t colorPointRX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_126(colorPointRX);
    }

    static void OnFailureCallback_127(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_127(status);
    }

    static void OnSuccessCallback_127(void * context, uint16_t colorPointRY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_127(colorPointRY);
    }

    static void OnFailureCallback_128(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_128(chip::to_underlying(status));
    }

    static void OnSuccessCallback_128(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_128(); }

    static void OnFailureCallback_129(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_129(status);
    }

    static void OnSuccessCallback_129(void * context, uint16_t colorPointRY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_129(colorPointRY);
    }

    static void OnFailureCallback_130(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_130(status);
    }

    static void OnSuccessCallback_130(void * context, uint8_t colorPointRIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_130(colorPointRIntensity);
    }

    static void OnFailureCallback_131(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_131(status);
    }

    static void OnSuccessCallback_131(void * context, uint16_t colorPointGX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_131(colorPointGX);
    }

    static void OnFailureCallback_132(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_132(chip::to_underlying(status));
    }

    static void OnSuccessCallback_132(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_132(); }

    static void OnFailureCallback_133(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_133(status);
    }

    static void OnSuccessCallback_133(void * context, uint16_t colorPointGX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_133(colorPointGX);
    }

    static void OnFailureCallback_134(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_134(status);
    }

    static void OnSuccessCallback_134(void * context, uint16_t colorPointGY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_134(colorPointGY);
    }

    static void OnFailureCallback_135(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_135(chip::to_underlying(status));
    }

    static void OnSuccessCallback_135(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_135(); }

    static void OnFailureCallback_136(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_136(status);
    }

    static void OnSuccessCallback_136(void * context, uint16_t colorPointGY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_136(colorPointGY);
    }

    static void OnFailureCallback_137(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_137(status);
    }

    static void OnSuccessCallback_137(void * context, uint8_t colorPointGIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_137(colorPointGIntensity);
    }

    static void OnFailureCallback_138(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_138(status);
    }

    static void OnSuccessCallback_138(void * context, uint16_t colorPointBX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_138(colorPointBX);
    }

    static void OnFailureCallback_139(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_139(chip::to_underlying(status));
    }

    static void OnSuccessCallback_139(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_139(); }

    static void OnFailureCallback_140(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_140(status);
    }

    static void OnSuccessCallback_140(void * context, uint16_t colorPointBX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_140(colorPointBX);
    }

    static void OnFailureCallback_141(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_141(status);
    }

    static void OnSuccessCallback_141(void * context, uint16_t colorPointBY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_141(colorPointBY);
    }

    static void OnFailureCallback_142(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_142(chip::to_underlying(status));
    }

    static void OnSuccessCallback_142(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_142(); }

    static void OnFailureCallback_143(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_143(status);
    }

    static void OnSuccessCallback_143(void * context, uint16_t colorPointBY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_143(colorPointBY);
    }

    static void OnFailureCallback_144(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_144(status);
    }

    static void OnSuccessCallback_144(void * context, uint8_t colorPointBIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_144(colorPointBIntensity);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsMandatoryAttributeCurrentHue_0()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentHue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentHue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentHue", currentHue, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentHue_1()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentHue(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t currentHue)
    {
        VerifyOrReturn(CheckConstraintType("currentHue", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentHue", currentHue, 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t currentHueArgument;
        currentHueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(
            currentHueArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { NextTest(); }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentHue_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentHue(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t currentHue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentHue", currentHue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeCurrentSaturation_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentSaturation(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentSaturation", currentSaturation, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentSaturation_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentSaturation(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckConstraintType("currentSaturation", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentSaturation", currentSaturation, 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_6()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t currentSaturationArgument;
        currentSaturationArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            currentSaturationArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { NextTest(); }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentSaturation_7()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentSaturation(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentSaturation", currentSaturation, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCurrentX_8()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentX(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint16_t currentX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("currentX", currentX, 24939U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentX_9()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentX(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint16_t currentX)
    {
        VerifyOrReturn(CheckConstraintType("currentX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentX", currentX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentX_10()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t currentXArgument;
        currentXArgument = 24939U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(
            currentXArgument, this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { NextTest(); }

    void OnSuccessResponse_10() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentX_11()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentX(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint16_t currentX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("currentX", currentX, 24939U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCurrentY_12()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentY(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel());
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint16_t currentY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("currentY", currentY, 24701U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentY_13()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentY(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint16_t currentY)
    {
        VerifyOrReturn(CheckConstraintType("currentY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentY", currentY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_14()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t currentYArgument;
        currentYArgument = 24701U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(
            currentYArgument, this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { NextTest(); }

    void OnSuccessResponse_14() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentY_15()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentY(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint16_t currentY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("currentY", currentY, 24701U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTemperatureMireds_16()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorTemperature(mOnSuccessCallback_16.Cancel(), mOnFailureCallback_16.Cancel());
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t colorTemperature)
    {
        VerifyOrReturn(CheckConstraintType("colorTemperature", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTemperature", colorTemperature, 65279));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorMode_17()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorMode(mOnSuccessCallback_17.Cancel(), mOnFailureCallback_17.Cancel());
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint8_t colorMode)
    {
        VerifyOrReturn(CheckConstraintType("colorMode", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("colorMode", colorMode, 2));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeOptions_18()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorControlOptions(mOnSuccessCallback_18.Cancel(), mOnFailureCallback_18.Cancel());
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorControlOptions", colorControlOptions, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeOptions_19()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorControlOptions(mOnSuccessCallback_19.Cancel(), mOnFailureCallback_19.Cancel());
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckConstraintType("colorControlOptions", "", "map8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeOptions_20()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t colorControlOptionsArgument;
        colorControlOptionsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            colorControlOptionsArgument, this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOptions_21()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorControlOptions(mOnSuccessCallback_21.Cancel(), mOnFailureCallback_21.Cancel());
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorControlOptions", colorControlOptions, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEnhancedCurrentHue_22()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnhancedCurrentHue(mOnSuccessCallback_22.Cancel(), mOnFailureCallback_22.Cancel());
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enhancedCurrentHue", enhancedCurrentHue, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedCurrentHue_23()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnhancedCurrentHue(mOnSuccessCallback_23.Cancel(), mOnFailureCallback_23.Cancel());
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_24()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t enhancedCurrentHueArgument;
        enhancedCurrentHueArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            enhancedCurrentHueArgument, this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { NextTest(); }

    void OnSuccessResponse_24() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeEnhancedCurrentHue_25()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnhancedCurrentHue(mOnSuccessCallback_25.Cancel(), mOnFailureCallback_25.Cancel());
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enhancedCurrentHue", enhancedCurrentHue, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedColorMode_26()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnhancedColorMode(mOnSuccessCallback_26.Cancel(), mOnFailureCallback_26.Cancel());
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint8_t enhancedColorMode)
    {
        VerifyOrReturn(CheckConstraintType("enhancedColorMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopActive_27()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_27.Cancel(), mOnFailureCallback_27.Cancel());
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopActive_28()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_28.Cancel(), mOnFailureCallback_28.Cancel());
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopActive", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_29()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t colorLoopActiveArgument;
        colorLoopActiveArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            colorLoopActiveArgument, this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { NextTest(); }

    void OnSuccessResponse_29() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopActive_30()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_30.Cancel(), mOnFailureCallback_30.Cancel());
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopDirection_31()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_31.Cancel(), mOnFailureCallback_31.Cancel());
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopDirection_32()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_32.Cancel(), mOnFailureCallback_32.Cancel());
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopDirection", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_33()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t colorLoopDirectionArgument;
        colorLoopDirectionArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            colorLoopDirectionArgument, this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { NextTest(); }

    void OnSuccessResponse_33() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopDirection_34()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_34.Cancel(), mOnFailureCallback_34.Cancel());
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopTime_35()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_35.Cancel(), mOnFailureCallback_35.Cancel());
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 25U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopTime_36()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_36.Cancel(), mOnFailureCallback_36.Cancel());
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_37()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorLoopTimeArgument;
        colorLoopTimeArgument = 25U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            colorLoopTimeArgument, this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { NextTest(); }

    void OnSuccessResponse_37() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopTime_38()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_38.Cancel(), mOnFailureCallback_38.Cancel());
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 25U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopStartEnhancedHue_39()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStartEnhancedHue(mOnSuccessCallback_39.Cancel(), mOnFailureCallback_39.Cancel());
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 8960U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_40()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStartEnhancedHue(mOnSuccessCallback_40.Cancel(), mOnFailureCallback_40.Cancel());
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStartEnhancedHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_41()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorLoopStartEnhancedHueArgument;
        colorLoopStartEnhancedHueArgument = 8960U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            colorLoopStartEnhancedHueArgument, this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { NextTest(); }

    void OnSuccessResponse_41() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_42()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStartEnhancedHue(mOnSuccessCallback_42.Cancel(), mOnFailureCallback_42.Cancel());
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 8960U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopStoredEnhancedHue_43()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStoredEnhancedHue(mOnSuccessCallback_43.Cancel(), mOnFailureCallback_43.Cancel());
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_44()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStoredEnhancedHue(mOnSuccessCallback_44.Cancel(), mOnFailureCallback_44.Cancel());
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_45()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorLoopStoredEnhancedHueArgument;
        colorLoopStoredEnhancedHueArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            colorLoopStoredEnhancedHueArgument, this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { NextTest(); }

    void OnSuccessResponse_45() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_46()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStoredEnhancedHue(mOnSuccessCallback_46.Cancel(), mOnFailureCallback_46.Cancel());
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorCapabilities_47()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorCapabilities(mOnSuccessCallback_47.Cancel(), mOnFailureCallback_47.Cancel());
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorCapabilities", colorCapabilities, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorCapabilities_48()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorCapabilities(mOnSuccessCallback_48.Cancel(), mOnFailureCallback_48.Cancel());
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckConstraintType("colorCapabilities", "", "map16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorCapabilities", colorCapabilities, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_49()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorCapabilitiesArgument;
        colorCapabilitiesArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            colorCapabilitiesArgument, this, OnSuccessCallback_49, OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { NextTest(); }

    void OnSuccessResponse_49() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorCapabilities_50()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorCapabilities(mOnSuccessCallback_50.Cancel(), mOnFailureCallback_50.Cancel());
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorCapabilities", colorCapabilities, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorTempPhysicalMinMireds_51()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorTempPhysicalMin(mOnSuccessCallback_51.Cancel(), mOnFailureCallback_51.Cancel());
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_52()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorTempPhysicalMin(mOnSuccessCallback_52.Cancel(), mOnFailureCallback_52.Cancel());
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckConstraintType("colorTempPhysicalMin", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_53()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorTempPhysicalMinArgument;
        colorTempPhysicalMinArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            colorTempPhysicalMinArgument, this, OnSuccessCallback_53, OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { NextTest(); }

    void OnSuccessResponse_53() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_54()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorTempPhysicalMin(mOnSuccessCallback_54.Cancel(), mOnFailureCallback_54.Cancel());
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorTempPhysicalMaxMireds_55()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorTempPhysicalMax(mOnSuccessCallback_55.Cancel(), mOnFailureCallback_55.Cancel());
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_56()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorTempPhysicalMax(mOnSuccessCallback_56.Cancel(), mOnFailureCallback_56.Cancel());
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckConstraintType("colorTempPhysicalMax", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_57()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorTempPhysicalMaxArgument;
        colorTempPhysicalMaxArgument = 65279U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            colorTempPhysicalMaxArgument, this, OnSuccessCallback_57, OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { NextTest(); }

    void OnSuccessResponse_57() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_58()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorTempPhysicalMax(mOnSuccessCallback_58.Cancel(), mOnFailureCallback_58.Cancel());
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_59()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCoupleColorTempToLevelMinMireds(mOnSuccessCallback_59.Cancel(), mOnFailureCallback_59.Cancel());
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59(uint16_t coupleColorTempToLevelMinMireds)
    {
        VerifyOrReturn(CheckConstraintType("coupleColorTempToLevelMinMireds", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_60()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t coupleColorTempToLevelMinMiredsArgument;
        coupleColorTempToLevelMinMiredsArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
            coupleColorTempToLevelMinMiredsArgument, this, OnSuccessCallback_60, OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status) { NextTest(); }

    void OnSuccessResponse_60() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_61()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCoupleColorTempToLevelMinMireds(mOnSuccessCallback_61.Cancel(), mOnFailureCallback_61.Cancel());
    }

    void OnFailureResponse_61(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_61(uint16_t coupleColorTempToLevelMinMireds)
    {
        VerifyOrReturn(CheckValue<uint16_t>("coupleColorTempToLevelMinMireds", coupleColorTempToLevelMinMireds, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeStartUpColorTemperatureMireds_62()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStartUpColorTemperatureMireds(mOnSuccessCallback_62.Cancel(), mOnFailureCallback_62.Cancel());
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62(uint16_t startUpColorTemperatureMireds)
    {
        VerifyOrReturn(CheckConstraintType("startUpColorTemperatureMireds", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_63()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t startUpColorTemperatureMiredsArgument;
        startUpColorTemperatureMiredsArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
            startUpColorTemperatureMiredsArgument, this, OnSuccessCallback_63, OnFailureCallback_63);
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63() { NextTest(); }

    CHIP_ERROR TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_64()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStartUpColorTemperatureMireds(mOnSuccessCallback_64.Cancel(), mOnFailureCallback_64.Cancel());
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64(uint16_t startUpColorTemperatureMireds)
    {
        VerifyOrReturn(CheckValue<uint16_t>("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeRemainingTime_65()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeRemainingTime(mOnSuccessCallback_65.Cancel(), mOnFailureCallback_65.Cancel());
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("remainingTime", remainingTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeRemainingTime_66()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeRemainingTime(mOnSuccessCallback_66.Cancel(), mOnFailureCallback_66.Cancel());
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckConstraintType("remainingTime", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("remainingTime", remainingTime, 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_67()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t remainingTimeArgument;
        remainingTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            remainingTimeArgument, this, OnSuccessCallback_67, OnFailureCallback_67);
    }

    void OnFailureResponse_67(uint8_t status) { NextTest(); }

    void OnSuccessResponse_67() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeRemainingTime_68()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeRemainingTime(mOnSuccessCallback_68.Cancel(), mOnFailureCallback_68.Cancel());
    }

    void OnFailureResponse_68(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_68(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("remainingTime", remainingTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeDriftCompensation_69()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeDriftCompensation(mOnSuccessCallback_69.Cancel(), mOnFailureCallback_69.Cancel());
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69(uint8_t driftCompensation)
    {
        VerifyOrReturn(CheckConstraintType("driftCompensation", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("driftCompensation", driftCompensation, 4));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_70()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t driftCompensationArgument;
        driftCompensationArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            driftCompensationArgument, this, OnSuccessCallback_70, OnFailureCallback_70);
    }

    void OnFailureResponse_70(uint8_t status) { NextTest(); }

    void OnSuccessResponse_70() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeDriftCompensation_71()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeDriftCompensation(mOnSuccessCallback_71.Cancel(), mOnFailureCallback_71.Cancel());
    }

    void OnFailureResponse_71(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_71(uint8_t driftCompensation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("driftCompensation", driftCompensation, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeCompensationText_72()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCompensationText(mOnSuccessCallback_72.Cancel(), mOnFailureCallback_72.Cancel());
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72(chip::CharSpan compensationText)
    {
        VerifyOrReturn(CheckConstraintType("compensationText", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("compensationText", compensationText.size(), 254));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeNumberOfPrimaries_73()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeNumberOfPrimaries(mOnSuccessCallback_73.Cancel(), mOnFailureCallback_73.Cancel());
    }

    void OnFailureResponse_73(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_73(uint8_t numberOfPrimaries)
    {
        VerifyOrReturn(CheckConstraintType("numberOfPrimaries", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("numberOfPrimaries", numberOfPrimaries, 6));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_74()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t numberOfPrimariesArgument;
        numberOfPrimariesArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            numberOfPrimariesArgument, this, OnSuccessCallback_74, OnFailureCallback_74);
    }

    void OnFailureResponse_74(uint8_t status) { NextTest(); }

    void OnSuccessResponse_74() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributeNumberOfPrimaries_75()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeNumberOfPrimaries(mOnSuccessCallback_75.Cancel(), mOnFailureCallback_75.Cancel());
    }

    void OnFailureResponse_75(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_75(uint8_t numberOfPrimaries)
    {
        VerifyOrReturn(CheckValue<uint8_t>("numberOfPrimaries", numberOfPrimaries, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1X_76()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary1X(mOnSuccessCallback_76.Cancel(), mOnFailureCallback_76.Cancel());
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76(uint16_t primary1X)
    {
        VerifyOrReturn(CheckConstraintType("primary1X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1X", primary1X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1X_77()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary1XArgument;
        primary1XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(
            primary1XArgument, this, OnSuccessCallback_77, OnFailureCallback_77);
    }

    void OnFailureResponse_77(uint8_t status) { NextTest(); }

    void OnSuccessResponse_77() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1X_78()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary1X(mOnSuccessCallback_78.Cancel(), mOnFailureCallback_78.Cancel());
    }

    void OnFailureResponse_78(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_78(uint16_t primary1X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary1X", primary1X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Y_79()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary1Y(mOnSuccessCallback_79.Cancel(), mOnFailureCallback_79.Cancel());
    }

    void OnFailureResponse_79(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_79(uint16_t primary1Y)
    {
        VerifyOrReturn(CheckConstraintType("primary1Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1Y", primary1Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1Y_80()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary1YArgument;
        primary1YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(
            primary1YArgument, this, OnSuccessCallback_80, OnFailureCallback_80);
    }

    void OnFailureResponse_80(uint8_t status) { NextTest(); }

    void OnSuccessResponse_80() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1Y_81()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary1Y(mOnSuccessCallback_81.Cancel(), mOnFailureCallback_81.Cancel());
    }

    void OnFailureResponse_81(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_81(uint16_t primary1Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary1Y", primary1Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Intensity_82()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary1Intensity(mOnSuccessCallback_82.Cancel(), mOnFailureCallback_82.Cancel());
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82(uint8_t primary1Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary1Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2X_83()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary2X(mOnSuccessCallback_83.Cancel(), mOnFailureCallback_83.Cancel());
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83(uint16_t primary2X)
    {
        VerifyOrReturn(CheckConstraintType("primary2X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2X", primary2X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2X_84()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary2XArgument;
        primary2XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(
            primary2XArgument, this, OnSuccessCallback_84, OnFailureCallback_84);
    }

    void OnFailureResponse_84(uint8_t status) { NextTest(); }

    void OnSuccessResponse_84() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2X_85()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary2X(mOnSuccessCallback_85.Cancel(), mOnFailureCallback_85.Cancel());
    }

    void OnFailureResponse_85(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_85(uint16_t primary2X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary2X", primary2X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2Y_86()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary2Y(mOnSuccessCallback_86.Cancel(), mOnFailureCallback_86.Cancel());
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86(uint16_t primary2Y)
    {
        VerifyOrReturn(CheckConstraintType("primary2Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2Y", primary2Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2Y_87()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary2YArgument;
        primary2YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(
            primary2YArgument, this, OnSuccessCallback_87, OnFailureCallback_87);
    }

    void OnFailureResponse_87(uint8_t status) { NextTest(); }

    void OnSuccessResponse_87() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2Y_88()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary2Y(mOnSuccessCallback_88.Cancel(), mOnFailureCallback_88.Cancel());
    }

    void OnFailureResponse_88(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_88(uint16_t primary2Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary2Y", primary2Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributePrimary2Intensity_89()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary2Intensity(mOnSuccessCallback_89.Cancel(), mOnFailureCallback_89.Cancel());
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89(uint8_t primary2Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary2Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3X_90()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary3X(mOnSuccessCallback_90.Cancel(), mOnFailureCallback_90.Cancel());
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90(uint16_t primary3X)
    {
        VerifyOrReturn(CheckConstraintType("primary3X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3X", primary3X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3X_91()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary3XArgument;
        primary3XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(
            primary3XArgument, this, OnSuccessCallback_91, OnFailureCallback_91);
    }

    void OnFailureResponse_91(uint8_t status) { NextTest(); }

    void OnSuccessResponse_91() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3X_92()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary3X(mOnSuccessCallback_92.Cancel(), mOnFailureCallback_92.Cancel());
    }

    void OnFailureResponse_92(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_92(uint16_t primary3X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary3X", primary3X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Y_93()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary3Y(mOnSuccessCallback_93.Cancel(), mOnFailureCallback_93.Cancel());
    }

    void OnFailureResponse_93(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_93(uint16_t primary3Y)
    {
        VerifyOrReturn(CheckConstraintType("primary3Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3Y", primary3Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3Y_94()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary3YArgument;
        primary3YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(
            primary3YArgument, this, OnSuccessCallback_94, OnFailureCallback_94);
    }

    void OnFailureResponse_94(uint8_t status) { NextTest(); }

    void OnSuccessResponse_94() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3Y_95()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary3Y(mOnSuccessCallback_95.Cancel(), mOnFailureCallback_95.Cancel());
    }

    void OnFailureResponse_95(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_95(uint16_t primary3Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary3Y", primary3Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Intensity_96()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary3Intensity(mOnSuccessCallback_96.Cancel(), mOnFailureCallback_96.Cancel());
    }

    void OnFailureResponse_96(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_96(uint8_t primary3Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary3Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4X_97()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary4X(mOnSuccessCallback_97.Cancel(), mOnFailureCallback_97.Cancel());
    }

    void OnFailureResponse_97(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_97(uint16_t primary4X)
    {
        VerifyOrReturn(CheckConstraintType("primary4X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4X", primary4X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4X_98()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary4XArgument;
        primary4XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(
            primary4XArgument, this, OnSuccessCallback_98, OnFailureCallback_98);
    }

    void OnFailureResponse_98(uint8_t status) { NextTest(); }

    void OnSuccessResponse_98() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4X_99()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary4X(mOnSuccessCallback_99.Cancel(), mOnFailureCallback_99.Cancel());
    }

    void OnFailureResponse_99(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_99(uint16_t primary4X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary4X", primary4X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Y_100()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary4Y(mOnSuccessCallback_100.Cancel(), mOnFailureCallback_100.Cancel());
    }

    void OnFailureResponse_100(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_100(uint16_t primary4Y)
    {
        VerifyOrReturn(CheckConstraintType("primary4Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4Y", primary4Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4Y_101()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary4YArgument;
        primary4YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            primary4YArgument, this, OnSuccessCallback_101, OnFailureCallback_101);
    }

    void OnFailureResponse_101(uint8_t status) { NextTest(); }

    void OnSuccessResponse_101() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4Y_102()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary4Y(mOnSuccessCallback_102.Cancel(), mOnFailureCallback_102.Cancel());
    }

    void OnFailureResponse_102(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_102(uint16_t primary4Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary4Y", primary4Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Intensity_103()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary4Intensity(mOnSuccessCallback_103.Cancel(), mOnFailureCallback_103.Cancel());
    }

    void OnFailureResponse_103(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_103(uint8_t primary4Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary4Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5X_104()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary5X(mOnSuccessCallback_104.Cancel(), mOnFailureCallback_104.Cancel());
    }

    void OnFailureResponse_104(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_104(uint16_t primary5X)
    {
        VerifyOrReturn(CheckConstraintType("primary5X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5X", primary5X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5X_105()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary5XArgument;
        primary5XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            primary5XArgument, this, OnSuccessCallback_105, OnFailureCallback_105);
    }

    void OnFailureResponse_105(uint8_t status) { NextTest(); }

    void OnSuccessResponse_105() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5X_106()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary5X(mOnSuccessCallback_106.Cancel(), mOnFailureCallback_106.Cancel());
    }

    void OnFailureResponse_106(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_106(uint16_t primary5X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary5X", primary5X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Y_107()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary5Y(mOnSuccessCallback_107.Cancel(), mOnFailureCallback_107.Cancel());
    }

    void OnFailureResponse_107(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_107(uint16_t primary5Y)
    {
        VerifyOrReturn(CheckConstraintType("primary5Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5Y", primary5Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5Y_108()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary5YArgument;
        primary5YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            primary5YArgument, this, OnSuccessCallback_108, OnFailureCallback_108);
    }

    void OnFailureResponse_108(uint8_t status) { NextTest(); }

    void OnSuccessResponse_108() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5Y_109()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary5Y(mOnSuccessCallback_109.Cancel(), mOnFailureCallback_109.Cancel());
    }

    void OnFailureResponse_109(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_109(uint16_t primary5Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary5Y", primary5Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Intensity_110()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary5Intensity(mOnSuccessCallback_110.Cancel(), mOnFailureCallback_110.Cancel());
    }

    void OnFailureResponse_110(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_110(uint8_t primary5Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary5Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6X_111()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary6X(mOnSuccessCallback_111.Cancel(), mOnFailureCallback_111.Cancel());
    }

    void OnFailureResponse_111(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_111(uint16_t primary6X)
    {
        VerifyOrReturn(CheckConstraintType("primary6X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6X", primary6X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6X_112()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary6XArgument;
        primary6XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            primary6XArgument, this, OnSuccessCallback_112, OnFailureCallback_112);
    }

    void OnFailureResponse_112(uint8_t status) { NextTest(); }

    void OnSuccessResponse_112() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6X_113()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary6X(mOnSuccessCallback_113.Cancel(), mOnFailureCallback_113.Cancel());
    }

    void OnFailureResponse_113(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_113(uint16_t primary6X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary6X", primary6X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Y_114()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary6Y(mOnSuccessCallback_114.Cancel(), mOnFailureCallback_114.Cancel());
    }

    void OnFailureResponse_114(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_114(uint16_t primary6Y)
    {
        VerifyOrReturn(CheckConstraintType("primary6Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6Y", primary6Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6Y_115()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t primary6YArgument;
        primary6YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            primary6YArgument, this, OnSuccessCallback_115, OnFailureCallback_115);
    }

    void OnFailureResponse_115(uint8_t status) { NextTest(); }

    void OnSuccessResponse_115() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6Y_116()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary6Y(mOnSuccessCallback_116.Cancel(), mOnFailureCallback_116.Cancel());
    }

    void OnFailureResponse_116(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_116(uint16_t primary6Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary6Y", primary6Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Intensity_117()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributePrimary6Intensity(mOnSuccessCallback_117.Cancel(), mOnFailureCallback_117.Cancel());
    }

    void OnFailureResponse_117(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_117(uint8_t primary6Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary6Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointX_118()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeWhitePointX(mOnSuccessCallback_118.Cancel(), mOnFailureCallback_118.Cancel());
    }

    void OnFailureResponse_118(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_118(uint16_t whitePointX)
    {
        VerifyOrReturn(CheckConstraintType("whitePointX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointX", whitePointX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointX_119()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t whitePointXArgument;
        whitePointXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            whitePointXArgument, this, OnSuccessCallback_119, OnFailureCallback_119);
    }

    void OnFailureResponse_119(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_119() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointX_120()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeWhitePointX(mOnSuccessCallback_120.Cancel(), mOnFailureCallback_120.Cancel());
    }

    void OnFailureResponse_120(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_120(uint16_t whitePointX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("whitePointX", whitePointX, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointY_121()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeWhitePointY(mOnSuccessCallback_121.Cancel(), mOnFailureCallback_121.Cancel());
    }

    void OnFailureResponse_121(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_121(uint16_t whitePointY)
    {
        VerifyOrReturn(CheckConstraintType("whitePointY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointY", whitePointY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointY_122()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t whitePointYArgument;
        whitePointYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            whitePointYArgument, this, OnSuccessCallback_122, OnFailureCallback_122);
    }

    void OnFailureResponse_122(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_122() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointY_123()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeWhitePointY(mOnSuccessCallback_123.Cancel(), mOnFailureCallback_123.Cancel());
    }

    void OnFailureResponse_123(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_123(uint16_t whitePointY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("whitePointY", whitePointY, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRX_124()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointRX(mOnSuccessCallback_124.Cancel(), mOnFailureCallback_124.Cancel());
    }

    void OnFailureResponse_124(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_124(uint16_t colorPointRX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRX", colorPointRX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRX_125()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorPointRXArgument;
        colorPointRXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            colorPointRXArgument, this, OnSuccessCallback_125, OnFailureCallback_125);
    }

    void OnFailureResponse_125(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_125() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRX_126()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointRX(mOnSuccessCallback_126.Cancel(), mOnFailureCallback_126.Cancel());
    }

    void OnFailureResponse_126(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_126(uint16_t colorPointRX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointRX", colorPointRX, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRY_127()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointRY(mOnSuccessCallback_127.Cancel(), mOnFailureCallback_127.Cancel());
    }

    void OnFailureResponse_127(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_127(uint16_t colorPointRY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRY", colorPointRY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRY_128()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorPointRYArgument;
        colorPointRYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            colorPointRYArgument, this, OnSuccessCallback_128, OnFailureCallback_128);
    }

    void OnFailureResponse_128(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_128() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRY_129()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointRY(mOnSuccessCallback_129.Cancel(), mOnFailureCallback_129.Cancel());
    }

    void OnFailureResponse_129(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_129(uint16_t colorPointRY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointRY", colorPointRY, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRIntensity_130()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointRIntensity(mOnSuccessCallback_130.Cancel(), mOnFailureCallback_130.Cancel());
    }

    void OnFailureResponse_130(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_130(uint8_t colorPointRIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRIntensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGX_131()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointGX(mOnSuccessCallback_131.Cancel(), mOnFailureCallback_131.Cancel());
    }

    void OnFailureResponse_131(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_131(uint16_t colorPointGX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGX", colorPointGX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGX_132()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorPointGXArgument;
        colorPointGXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            colorPointGXArgument, this, OnSuccessCallback_132, OnFailureCallback_132);
    }

    void OnFailureResponse_132(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_132() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGX_133()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointGX(mOnSuccessCallback_133.Cancel(), mOnFailureCallback_133.Cancel());
    }

    void OnFailureResponse_133(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_133(uint16_t colorPointGX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointGX", colorPointGX, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGY_134()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointGY(mOnSuccessCallback_134.Cancel(), mOnFailureCallback_134.Cancel());
    }

    void OnFailureResponse_134(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_134(uint16_t colorPointGY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGY", colorPointGY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGY_135()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorPointGYArgument;
        colorPointGYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            colorPointGYArgument, this, OnSuccessCallback_135, OnFailureCallback_135);
    }

    void OnFailureResponse_135(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_135() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGY_136()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointGY(mOnSuccessCallback_136.Cancel(), mOnFailureCallback_136.Cancel());
    }

    void OnFailureResponse_136(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_136(uint16_t colorPointGY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointGY", colorPointGY, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGIntensity_137()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointGIntensity(mOnSuccessCallback_137.Cancel(), mOnFailureCallback_137.Cancel());
    }

    void OnFailureResponse_137(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_137(uint8_t colorPointGIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGIntensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBX_138()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointBX(mOnSuccessCallback_138.Cancel(), mOnFailureCallback_138.Cancel());
    }

    void OnFailureResponse_138(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_138(uint16_t colorPointBX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBX", colorPointBX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBX_139()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorPointBXArgument;
        colorPointBXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            colorPointBXArgument, this, OnSuccessCallback_139, OnFailureCallback_139);
    }

    void OnFailureResponse_139(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_139() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBX_140()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointBX(mOnSuccessCallback_140.Cancel(), mOnFailureCallback_140.Cancel());
    }

    void OnFailureResponse_140(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_140(uint16_t colorPointBX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointBX", colorPointBX, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBY_141()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointBY(mOnSuccessCallback_141.Cancel(), mOnFailureCallback_141.Cancel());
    }

    void OnFailureResponse_141(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_141(uint16_t colorPointBY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBY", colorPointBY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBY_142()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t colorPointBYArgument;
        colorPointBYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            colorPointBYArgument, this, OnSuccessCallback_142, OnFailureCallback_142);
    }

    void OnFailureResponse_142(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_142() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBY_143()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointBY(mOnSuccessCallback_143.Cancel(), mOnFailureCallback_143.Cancel());
    }

    void OnFailureResponse_143(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_143(uint16_t colorPointBY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointBY", colorPointBY, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBIntensity_144()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorPointBIntensity(mOnSuccessCallback_144.Cancel(), mOnFailureCallback_144.Cancel());
    }

    void OnFailureResponse_144(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_144(uint8_t colorPointBIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBIntensity", "", "uint8"));
        NextTest();
    }
};

class Test_TC_CC_3_1 : public TestCommand
{
public:
    Test_TC_CC_3_1() : TestCommand("Test_TC_CC_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to hue shortest distance command\n");
            err = TestMoveToHueShortestDistanceCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to hue longest distance command\n");
            err = TestMoveToHueLongestDistanceCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move to hue up command\n");
            err = TestMoveToHueUpCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move to hue down command\n");
            err = TestMoveToHueDownCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToHueShortestDistanceCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;
        request.hue             = 150;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveToHueLongestDistanceCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;
        request.hue             = 200;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveToHueUpCommand_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;
        request.hue             = 250;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveToHueDownCommand_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHue::Type request;
        request.hue             = 225;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_3_2 : public TestCommand
{
public:
    Test_TC_CC_3_2() : TestCommand("Test_TC_CC_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move hue up command\n");
            err = TestMoveHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move hue stop command\n");
            err = TestMoveHueStopCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move hue down command\n");
            err = TestMoveHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move hue stop command\n");
            err = TestMoveHueStopCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveHueUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveHueDownCommand_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_3_3 : public TestCommand
{
public:
    Test_TC_CC_3_3() : TestCommand("Test_TC_CC_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step hue up command\n");
            err = TestStepHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step hue down command\n");
            err = TestStepHueDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepHueUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepHue::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepHueDownCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepHue::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_1 : public TestCommand
{
public:
    Test_TC_CC_4_1() : TestCommand("Test_TC_CC_4_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to saturation command\n");
            err = TestMoveToSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToSaturationCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type request;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_2 : public TestCommand
{
public:
    Test_TC_CC_4_2() : TestCommand("Test_TC_CC_4_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveSaturationUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveSaturationDownCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_3 : public TestCommand
{
public:
    Test_TC_CC_4_3() : TestCommand("Test_TC_CC_4_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step saturation up command\n");
            err = TestStepSaturationUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step saturation down command\n");
            err = TestStepSaturationDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepSaturationUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepSaturation::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(1);
        request.stepSize        = 15;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepSaturationDownCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepSaturation::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(3);
        request.stepSize        = 20;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_4 : public TestCommand
{
public:
    Test_TC_CC_4_4() : TestCommand("Test_TC_CC_4_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move To current hue and saturation command\n");
            err = TestMoveToCurrentHueAndSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToCurrentHueAndSaturationCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type request;
        request.hue             = 40;
        request.saturation      = 160;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_1 : public TestCommand
{
public:
    Test_TC_CC_5_1() : TestCommand("Test_TC_CC_5_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to Color command\n");
            err = TestMoveToColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToColorCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToColor::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToColor::Type request;
        request.colorX          = 200U;
        request.colorY          = 300U;
        request.transitionTime  = 20U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_2 : public TestCommand
{
public:
    Test_TC_CC_5_2() : TestCommand("Test_TC_CC_5_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move Color command\n");
            err = TestMoveColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Stop Move Step command\n");
            err = TestStopMoveStepCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveColorCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveColor::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveColor::Type request;
        request.rateX           = 15;
        request.rateY           = 20;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStopMoveStepCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type request;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_3 : public TestCommand
{
public:
    Test_TC_CC_5_3() : TestCommand("Test_TC_CC_5_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step Color command\n");
            err = TestStepColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepColorCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepColor::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepColor::Type request;
        request.stepX           = 15;
        request.stepY           = 20;
        request.transitionTime  = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_1 : public TestCommand
{
public:
    Test_TC_CC_6_1() : TestCommand("Test_TC_CC_6_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move To Color Temperature command\n");
            err = TestMoveToColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToColorTemperatureCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type request;
        request.colorTemperature = 100U;
        request.transitionTime   = 10U;
        request.optionsMask      = 0;
        request.optionsOverride  = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_2 : public TestCommand
{
public:
    Test_TC_CC_6_2() : TestCommand("Test_TC_CC_6_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move up color temperature command\n");
            err = TestMoveUpColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Stop Color Temperature command\n");
            err = TestStopColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move down color temperature command\n");
            err = TestMoveDownColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveUpColorTemperatureCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStopColorTemperatureCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveDownColorTemperatureCommand_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate                    = 20U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_3 : public TestCommand
{
public:
    Test_TC_CC_6_3() : TestCommand("Test_TC_CC_6_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step up color temperature command\n");
            err = TestStepUpColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step down color temperature command\n");
            err = TestStepDownColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepUpColorTemperatureCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepDownColorTemperatureCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_1 : public TestCommand
{
public:
    Test_TC_CC_7_1() : TestCommand("Test_TC_CC_7_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : Check Remaining time attribute value matched the value sent by the last command\n");
            err = TestCheckRemainingTimeAttributeValueMatchedTheValueSentByTheLastCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t remainingTime)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_3(remainingTime);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type request;
        request.enhancedHue     = 1025U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckRemainingTimeAttributeValueMatchedTheValueSentByTheLastCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeRemainingTime(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("remainingTime", remainingTime, 1U));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_2 : public TestCommand
{
public:
    Test_TC_CC_7_2() : TestCommand("Test_TC_CC_7_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Move Hue Down command \n");
            err = TestEnhancedMoveHueDownCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move Hue Up command\n");
            err = TestEnhancedMoveHueUpCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveHueDownCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 5U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueUpCommand_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_3 : public TestCommand
{
public:
    Test_TC_CC_7_3() : TestCommand("Test_TC_CC_7_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Step Hue Up command\n");
            err = TestEnhancedStepHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Step Hue Down command\n");
            err = TestEnhancedStepHueDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedStepHueUpCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(0);
        request.stepSize        = 50U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestEnhancedStepHueDownCommand_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 75U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_4 : public TestCommand
{
public:
    Test_TC_CC_7_4() : TestCommand("Test_TC_CC_7_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced move to hue and saturation command\n");
            err = TestEnhancedMoveToHueAndSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueAndSaturationCommand_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type request;
        request.enhancedHue     = 1200U;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_8_1 : public TestCommand
{
public:
    Test_TC_CC_8_1() : TestCommand("Test_TC_CC_8_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_8_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_8_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Color Loop Set Command - Set all Attributs\n");
            err = TestColorLoopSetCommandSetAllAttributs_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check ColorLoopStartEnhancedHue Value\n");
            err = TestCheckColorLoopStartEnhancedHueValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Color Loop Set Command - Set direction and time while running\n");
            err = TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Set direction while running\n");
            err = TestColorLoopSetCommandSetDirectionWhileRunning_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_3{ OnSuccessCallback_3,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStartEnhancedHue)> mOnSuccessCallback_5{
        OnSuccessCallback_5, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_10{ OnSuccessCallback_10,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_13{ OnSuccessCallback_13,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_15{ OnSuccessCallback_15, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_3(colorLoopDirection);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_4(colorLoopTime);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_5(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_6(colorLoopActive);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_8(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_10(colorLoopDirection);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_11(colorLoopTime);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_13(colorLoopDirection);
    }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_15(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributs_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(14);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 100U;
        request.startHue        = 500U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 100U));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopStartEnhancedHueValue_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStartEnhancedHue(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 500U));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopActiveValue_6()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_7()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopActiveValue_8()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_9()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(6);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 3500U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_9(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_10()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_11()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 3500U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionWhileRunning_12()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_12(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_13()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_14()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_14(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_15()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_9_1 : public TestCommand
{
public:
    Test_TC_CC_9_1() : TestCommand("Test_TC_CC_9_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition : Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopTime attribute from DUT\n");
            err = TestReadColorLoopTimeAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopStartEnhancedHue attribute from DUT\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Enhanced Move To Hue command 10\n");
            err = TestEnhancedMoveToHueCommand10_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Wait 2000ms\n");
            err = TestWait2000ms_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read EnhancedCurrentHue attribute from DUT\n");
            err = TestReadEnhancedCurrentHueAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Turn Off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_35();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 36;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_5{ OnSuccessCallback_5,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStartEnhancedHue)> mOnSuccessCallback_9{
        OnSuccessCallback_9, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_13{ OnSuccessCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_15{ OnSuccessCallback_15,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_17{ OnFailureCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_17{ OnSuccessCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_19{ OnFailureCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_19{ OnSuccessCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_22{ OnFailureCallback_22, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enhancedCurrentHue)> mOnSuccessCallback_22{ OnSuccessCallback_22,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_24{ OnFailureCallback_24, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_24{ OnSuccessCallback_24,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_26{ OnFailureCallback_26, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_26{ OnSuccessCallback_26, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_28{ OnFailureCallback_28, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_28{ OnSuccessCallback_28, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_30{ OnFailureCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_30{ OnSuccessCallback_30,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_32{ OnFailureCallback_32, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_32{ OnSuccessCallback_32, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_34{ OnFailureCallback_34, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_34{ OnSuccessCallback_34, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_3(colorLoopActive);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_5(colorLoopDirection);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_7(colorLoopTime);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_9(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_11(colorLoopActive);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_13(colorLoopActive);
    }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_15(colorLoopDirection);
    }

    static void OnFailureCallback_17(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_17(status);
    }

    static void OnSuccessCallback_17(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_17(colorLoopActive);
    }

    static void OnFailureCallback_19(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_19(status);
    }

    static void OnSuccessCallback_19(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_19(colorLoopActive);
    }

    static void OnFailureCallback_22(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_22(status);
    }

    static void OnSuccessCallback_22(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_22(enhancedCurrentHue);
    }

    static void OnFailureCallback_24(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_24(status);
    }

    static void OnSuccessCallback_24(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_24(colorLoopDirection);
    }

    static void OnFailureCallback_26(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_26(status);
    }

    static void OnSuccessCallback_26(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_26(colorLoopActive);
    }

    static void OnFailureCallback_28(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_28(status);
    }

    static void OnSuccessCallback_28(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_28(colorLoopActive);
    }

    static void OnFailureCallback_30(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_30(status);
    }

    static void OnSuccessCallback_30(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_30(colorLoopDirection);
    }

    static void OnFailureCallback_32(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_32(status);
    }

    static void OnSuccessCallback_32(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_32(colorLoopActive);
    }

    static void OnFailureCallback_34(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_34(status);
    }

    static void OnSuccessCallback_34(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_34(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_6()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_7()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 30U));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_8()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(8);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_9()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStartEnhancedHue(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_10()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_10(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_11()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_12()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_12(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_13()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_14()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_14(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_15()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_16()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_16();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_16(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_17()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_17.Cancel(), mOnFailureCallback_17.Cancel());
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_18()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_18();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_18(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_19()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_19.Cancel(), mOnFailureCallback_19.Cancel());
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand10_20()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type request;
        request.enhancedHue     = 40960U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_20();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_20(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestWait2000ms_21() { return WaitForMs(2000); }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_22()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnhancedCurrentHue(mOnSuccessCallback_22.Cancel(), mOnFailureCallback_22.Cancel());
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enhancedCurrentHue", enhancedCurrentHue, 40960U));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_23()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_23();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_23(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_24()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_24.Cancel(), mOnFailureCallback_24.Cancel());
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_25()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_25();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_25(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_26()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_26.Cancel(), mOnFailureCallback_26.Cancel());
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_27()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_27();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_27(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_28()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_28.Cancel(), mOnFailureCallback_28.Cancel());
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_29()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_29();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_29(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_30()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_30.Cancel(), mOnFailureCallback_30.Cancel());
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_31()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_31();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_31(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_32()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_32.Cancel(), mOnFailureCallback_32.Cancel());
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_33()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_33();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_33(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_34()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_34.Cancel(), mOnFailureCallback_34.Cancel());
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_35()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_35();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_35(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35() { NextTest(); }
};

class Test_TC_CC_9_2 : public TestCommand
{
public:
    Test_TC_CC_9_2() : TestCommand("Test_TC_CC_9_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Color Loop Set Command - Set all Attributes\n");
            err = TestColorLoopSetCommandSetAllAttributes_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read ColorLoopActive attribute from DUT.\n");
            err = TestReadColorLoopActiveAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_4{ OnSuccessCallback_4,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStartEnhancedHue)> mOnSuccessCallback_6{
        OnSuccessCallback_6, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_10{ OnSuccessCallback_10,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_12{ OnSuccessCallback_12, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_3(colorLoopActive);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_4(colorLoopDirection);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_5(colorLoopTime);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_6(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_8(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_10(colorLoopDirection);
    }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_12(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 30U));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_6()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStartEnhancedHue(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_7()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_8()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_9()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_9(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_10()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_11()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_11(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_12()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel());
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_13()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_13(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }
};

class Test_TC_CC_9_3 : public TestCommand
{
public:
    Test_TC_CC_9_3() : TestCommand("Test_TC_CC_9_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Color Loop Set Command - Set all Attributes\n");
            err = TestColorLoopSetCommandSetAllAttributes_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read ColorLoopActive attribute from DUT.\n");
            err = TestReadColorLoopActiveAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopDirection)> mOnSuccessCallback_4{ OnSuccessCallback_4,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopStartEnhancedHue)> mOnSuccessCallback_6{
        OnSuccessCallback_6, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t colorLoopTime)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t colorLoopActive)> mOnSuccessCallback_12{ OnSuccessCallback_12, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_3(colorLoopActive);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_4(colorLoopDirection);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_5(colorLoopTime);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_6(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_8(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_10(colorLoopTime);
    }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_12(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_2()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_3()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_4()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopDirection(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_5()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 30U));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_6()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopStartEnhancedHue(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_7()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_8()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_9()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 60U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_9(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_10()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopTime(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 60U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_11()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_11(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_12()
    {
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeColorLoopActive(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel());
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_13()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_13(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }
};

class Test_TC_DM_1_1 : public TestCommand
{
public:
    Test_TC_DM_1_1() : TestCommand("Test_TC_DM_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Query Interaction Model Version\n");
            err = TestQueryInteractionModelVersion_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Vendor Name\n");
            err = TestQueryVendorName_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query VendorID\n");
            err = TestQueryVendorID_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query Product Name\n");
            err = TestQueryProductName_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query ProductID\n");
            err = TestQueryProductID_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Query User Label\n");
            err = TestQueryUserLabel_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Query User Location\n");
            err = TestQueryUserLocation_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Query HardwareVersion\n");
            err = TestQueryHardwareVersion_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Query HardwareVersionString\n");
            err = TestQueryHardwareVersionString_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Query SoftwareVersion\n");
            err = TestQuerySoftwareVersion_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Query SoftwareVersionString\n");
            err = TestQuerySoftwareVersionString_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Query ManufacturingDate\n");
            err = TestQueryManufacturingDate_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Query PartNumber\n");
            err = TestQueryPartNumber_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Query ProductURL\n");
            err = TestQueryProductURL_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Query ProductLabel\n");
            err = TestQueryProductLabel_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Query SerialNumber\n");
            err = TestQuerySerialNumber_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Query LocalConfigDisabled\n");
            err = TestQueryLocalConfigDisabled_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Query Reachable\n");
            err = TestQueryReachable_17();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 18;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t interactionModelVersion)> mOnSuccessCallback_0{ OnSuccessCallback_0,
                                                                                                               this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan vendorName)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t vendorID)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan productName)> mOnSuccessCallback_3{ OnSuccessCallback_3,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t productID)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan userLabel)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan location)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t hardwareVersion)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan hardwareVersionString)> mOnSuccessCallback_8{
        OnSuccessCallback_8, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t softwareVersion)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan softwareVersionString)> mOnSuccessCallback_10{
        OnSuccessCallback_10, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan manufacturingDate)> mOnSuccessCallback_11{
        OnSuccessCallback_11, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan partNumber)> mOnSuccessCallback_12{ OnSuccessCallback_12,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan productURL)> mOnSuccessCallback_13{ OnSuccessCallback_13,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_14{ OnFailureCallback_14, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan productLabel)> mOnSuccessCallback_14{ OnSuccessCallback_14,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan serialNumber)> mOnSuccessCallback_15{ OnSuccessCallback_15,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_16{ OnFailureCallback_16, this };
    chip::Callback::Callback<void (*)(void * context, bool localConfigDisabled)> mOnSuccessCallback_16{ OnSuccessCallback_16,
                                                                                                        this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_17{ OnFailureCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, bool reachable)> mOnSuccessCallback_17{ OnSuccessCallback_17, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t interactionModelVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_0(interactionModelVersion);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan vendorName)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_1(vendorName);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t vendorID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_2(vendorID);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan productName)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_3(productName);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint16_t productID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_4(productID);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, chip::CharSpan userLabel)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_5(userLabel);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, chip::CharSpan location)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_6(location);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint16_t hardwareVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_7(hardwareVersion);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, chip::CharSpan hardwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_8(hardwareVersionString);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint32_t softwareVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_9(softwareVersion);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, chip::CharSpan softwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_10(softwareVersionString);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, chip::CharSpan manufacturingDate)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_11(manufacturingDate);
    }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, chip::CharSpan partNumber)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_12(partNumber);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, chip::CharSpan productURL)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_13(productURL);
    }

    static void OnFailureCallback_14(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_14(status);
    }

    static void OnSuccessCallback_14(void * context, chip::CharSpan productLabel)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_14(productLabel);
    }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, chip::CharSpan serialNumber)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_15(serialNumber);
    }

    static void OnFailureCallback_16(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_16(status);
    }

    static void OnSuccessCallback_16(void * context, bool localConfigDisabled)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_16(localConfigDisabled);
    }

    static void OnFailureCallback_17(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_17(status);
    }

    static void OnSuccessCallback_17(void * context, bool reachable)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_17(reachable);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestQueryInteractionModelVersion_0()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeInteractionModelVersion(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t interactionModelVersion)
    {
        VerifyOrReturn(CheckConstraintType("interactionModelVersion", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryVendorName_1()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeVendorName(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::CharSpan vendorName)
    {
        VerifyOrReturn(CheckConstraintType("vendorName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("vendorName", vendorName.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryVendorID_2()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeVendorID(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t vendorID)
    {
        VerifyOrReturn(CheckConstraintType("vendorID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryProductName_3()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeProductName(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::CharSpan productName)
    {
        VerifyOrReturn(CheckConstraintType("productName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productName", productName.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryProductID_4()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeProductID(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t productID)
    {
        VerifyOrReturn(CheckConstraintType("productID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryUserLabel_5()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeUserLabel(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(chip::CharSpan userLabel)
    {
        VerifyOrReturn(CheckConstraintType("userLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("userLabel", userLabel.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryUserLocation_6()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeLocation(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(chip::CharSpan location)
    {
        VerifyOrReturn(CheckConstraintType("location", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("location", "", "ISO 3166-1 alpha-2"));
        VerifyOrReturn(CheckConstraintMaxLength("location", location.size(), 2));
        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersion_7()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeHardwareVersion(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t hardwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersion", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersionString_8()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeHardwareVersionString(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(chip::CharSpan hardwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintMinLength("hardwareVersionString", hardwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("hardwareVersionString", hardwareVersionString.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersion_9()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSoftwareVersion(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint32_t softwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersion", "", "uint32"));
        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersionString_10()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSoftwareVersionString(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(chip::CharSpan softwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("softwareVersionString", "", "ASCII"));
        VerifyOrReturn(CheckConstraintMinLength("softwareVersionString", softwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("softwareVersionString", softwareVersionString.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQueryManufacturingDate_11()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeManufacturingDate(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_11(chip::CharSpan manufacturingDate)
    {
        VerifyOrReturn(CheckConstraintType("manufacturingDate", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("manufacturingDate", "", "ISO 8601"));
        VerifyOrReturn(CheckConstraintMinLength("manufacturingDate", manufacturingDate.size(), 8));
        VerifyOrReturn(CheckConstraintMaxLength("manufacturingDate", manufacturingDate.size(), 16));
        NextTest();
    }

    CHIP_ERROR TestQueryPartNumber_12()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributePartNumber(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel());
    }

    void OnFailureResponse_12(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_12(chip::CharSpan partNumber)
    {
        VerifyOrReturn(CheckConstraintType("partNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("partNumber", partNumber.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryProductURL_13()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeProductURL(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_13(chip::CharSpan productURL)
    {
        VerifyOrReturn(CheckConstraintType("productURL", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("productURL", "", "RFC3986"));
        VerifyOrReturn(CheckConstraintMaxLength("productURL", productURL.size(), 256));
        NextTest();
    }

    CHIP_ERROR TestQueryProductLabel_14()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeProductLabel(mOnSuccessCallback_14.Cancel(), mOnFailureCallback_14.Cancel());
    }

    void OnFailureResponse_14(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_14(chip::CharSpan productLabel)
    {
        VerifyOrReturn(CheckConstraintType("productLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productLabel", productLabel.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQuerySerialNumber_15()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSerialNumber(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_15(chip::CharSpan serialNumber)
    {
        VerifyOrReturn(CheckConstraintType("serialNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("serialNumber", serialNumber.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryLocalConfigDisabled_16()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeLocalConfigDisabled(mOnSuccessCallback_16.Cancel(), mOnFailureCallback_16.Cancel());
    }

    void OnFailureResponse_16(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_16(bool localConfigDisabled)
    {
        VerifyOrReturn(CheckConstraintType("localConfigDisabled", "", "boolean"));
        NextTest();
    }

    CHIP_ERROR TestQueryReachable_17()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeReachable(mOnSuccessCallback_17.Cancel(), mOnFailureCallback_17.Cancel());
    }

    void OnFailureResponse_17(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_17(bool reachable)
    {
        VerifyOrReturn(CheckConstraintType("reachable", "", "boolean"));
        NextTest();
    }
};

class Test_TC_DM_3_1 : public TestCommand
{
public:
    Test_TC_DM_3_1() : TestCommand("Test_TC_DM_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_DM_2_2 : public TestCommand
{
public:
    Test_TC_DM_2_2() : TestCommand("Test_TC_DM_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Query fabrics list\n");
            err = TestQueryFabricsList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Supported Fabrics\n");
            err = TestQuerySupportedFabrics_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Commissioned Fabrics\n");
            err = TestQueryCommissionedFabrics_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query User Trusted Root Certificates\n");
            err = TestQueryUserTrustedRootCertificates_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabricsList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t supportedFabrics)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t commissionedFabrics)> mOnSuccessCallback_2{ OnSuccessCallback_2,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context,
                                      const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)>
        mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_0(status);
    }

    static void
    OnSuccessCallback_0(void * context,
                        const chip::app::DataModel::DecodableList<
                            chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabricsList)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_0(fabricsList);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t supportedFabrics)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_1(supportedFabrics);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_2(commissionedFabrics);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context,
                                    const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_3(trustedRootCertificates);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestQueryFabricsList_0()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeFabricsList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(const chip::app::DataModel::DecodableList<
                             chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabricsList)
    {
        auto iter = fabricsList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(fabricsList)>("fabricsList", iter, 0));
        VerifyOrReturn(CheckNoMoreListItems<decltype(fabricsList)>("fabricsList", iter, 1));
        NextTest();
    }

    CHIP_ERROR TestQuerySupportedFabrics_1()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSupportedFabrics(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckValue<uint8_t>("supportedFabrics", supportedFabrics, 16));
        NextTest();
    }

    CHIP_ERROR TestQueryCommissionedFabrics_2()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeCommissionedFabrics(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckValue<uint8_t>("commissionedFabrics", commissionedFabrics, 1));
        NextTest();
    }

    CHIP_ERROR TestQueryUserTrustedRootCertificates_3()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeTrustedRootCertificates(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)
    {
        VerifyOrReturn(CheckConstraintType("trustedRootCertificates", "", "list"));
        NextTest();
    }
};

class Test_TC_EMR_1_1 : public TestCommand
{
public:
    Test_TC_EMR_1_1() : TestCommand("Test_TC_EMR_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_EMR_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_EMR_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }
};

class Test_TC_FLW_1_1 : public TestCommand
{
public:
    Test_TC_FLW_1_1() : TestCommand("Test_TC_FLW_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_FLW_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_FLW_2_1 : public TestCommand
{
public:
    Test_TC_FLW_2_1() : TestCommand("Test_TC_FLW_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : write the default value to optional attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default value to optional attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, int16_t minMeasuredValue)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, int16_t maxMeasuredValue)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, int16_t minMeasuredValue)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, int16_t maxMeasuredValue)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_1(minMeasuredValue);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_2(maxMeasuredValue);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_5(measuredValue);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_6(minMeasuredValue);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_7(maxMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_0()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_1()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMinMeasuredValue(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_2()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxMeasuredValue(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_3()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t minMeasuredValueArgument;
        minMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            minMeasuredValueArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { NextTest(); }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_4()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t maxMeasuredValueArgument;
        maxMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            maxMeasuredValueArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_5()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_6()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMinMeasuredValue(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_7()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxMeasuredValue(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_FLW_2_2 : public TestCommand
{
public:
    Test_TC_FLW_2_2() : TestCommand("Test_TC_FLW_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_0()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_LVL_1_1 : public TestCommand
{
public:
    Test_TC_LVL_1_1() : TestCommand("Test_TC_LVL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_LVL_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        return cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_LVL_2_1 : public TestCommand
{
public:
    Test_TC_LVL_2_1() : TestCommand("Test_TC_LVL_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 100ms\n");
            err = TestWait100ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 200ms\n");
            err = TestWait200ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : reads On Off Transition Time attribute from DUT\n");
            err = TestReadsOnOffTransitionTimeAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 10ms\n");
            err = TestWait10ms_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reset level to 0\n");
            err = TestResetLevelTo0_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            err = TestWait100ms_12();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 13;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onOffTransitionTime)> mOnSuccessCallback_7{ OnSuccessCallback_7,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_0(currentLevel);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_3(currentLevel);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_6(currentLevel);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint16_t onOffTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_7(onOffTransitionTime);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_10(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_0()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_1()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;
        request.level          = 64;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait100ms_2() { return WaitForMs(100); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_3()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 64));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_4()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;
        request.level          = 128;
        request.transitionTime = 1U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait200ms_5() { return WaitForMs(200); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_6()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 128));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffTransitionTimeAttributeFromDut_7()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOffTransitionTime(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t onOffTransitionTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onOffTransitionTime", onOffTransitionTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_8()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;
        request.level          = 254;
        request.transitionTime = 65535U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWait10ms_9() { return WaitForMs(10); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_10()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 254));
        NextTest();
    }

    CHIP_ERROR TestResetLevelTo0_11()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type request;
        request.level          = 0;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_11(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestWait100ms_12() { return WaitForMs(100); }
};

class Test_TC_LVL_3_1 : public TestCommand
{
public:
    Test_TC_LVL_3_1() : TestCommand("Test_TC_LVL_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads max level attribute from DUT\n");
            err = TestReadsMaxLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : sends a Move up command\n");
            err = TestSendsAMoveUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 3000ms\n");
            err = TestWait3000ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads min level attribute from DUT\n");
            err = TestReadsMinLevelAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : sends a Move down command\n");
            err = TestSendsAMoveDownCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Wait 3000ms\n");
            err = TestWait3000ms_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write default move rate attribute from DUT\n");
            err = TestWriteDefaultMoveRateAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads default move rate attribute from DUT\n");
            err = TestReadsDefaultMoveRateAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : sends a Move up command at default move rate\n");
            err = TestSendsAMoveUpCommandAtDefaultMoveRate_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            err = TestWait100ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t maxLevel)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t minLevel)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t defaultMoveRate)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_13{ OnSuccessCallback_13, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_0(currentLevel);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t maxLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_1(maxLevel);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_4(currentLevel);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t minLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_5(minLevel);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_8(currentLevel);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_10(defaultMoveRate);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_13(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_0()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMaxLevelAttributeFromDut_1()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxLevel(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t maxLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("maxLevel", maxLevel, 255));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommand_2()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Move::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Move::Type request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 200;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWait3000ms_3() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 255));
        NextTest();
    }

    CHIP_ERROR TestReadsMinLevelAttributeFromDut_5()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMinLevel(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t minLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("minLevel", minLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveDownCommand_6()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Move::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Move::Type request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 250;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWait3000ms_7() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_8()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteDefaultMoveRateAttributeFromDut_9()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t defaultMoveRateArgument;
        defaultMoveRateArgument = 20;

        return cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            defaultMoveRateArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadsDefaultMoveRateAttributeFromDut_10()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeDefaultMoveRate(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t defaultMoveRate)
    {
        VerifyOrReturn(CheckValue<uint8_t>("defaultMoveRate", defaultMoveRate, 20));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommandAtDefaultMoveRate_11()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Move::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Move::Type request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 255;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_11(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestWait100ms_12() { return WaitForMs(100); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_13()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckConstraintNotValue<uint8_t>("currentLevel", currentLevel, 255));
        NextTest();
    }
};

class Test_TC_LVL_4_1 : public TestCommand
{
public:
    Test_TC_LVL_4_1() : TestCommand("Test_TC_LVL_4_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Sending on command\n");
            err = TestSendingOnCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: DUT level is set to 0x80\n");
            err = TestPreconditionDutLevelIsSetTo0x80_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 3000ms\n");
            err = TestWait3000ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Sends step down command to DUT\n");
            err = TestSendsStepDownCommandToDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 3000ms\n");
            err = TestWait3000ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends a Step up command\n");
            err = TestSendsAStepUpCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait 3000ms\n");
            err = TestWait3000ms_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Sending off command\n");
            err = TestSendingOffCommand_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentLevel)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_3(currentLevel);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_6(currentLevel);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_9(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendingOnCommand_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestPreconditionDutLevelIsSetTo0x80_1()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Step::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Step::Type request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 128;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait3000ms_2() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_3()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 128));
        NextTest();
    }

    CHIP_ERROR TestSendsStepDownCommandToDut_4()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Step::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Step::Type request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
        request.stepSize       = 64;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait3000ms_5() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_6()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 64));
        NextTest();
    }

    CHIP_ERROR TestSendsAStepUpCommand_7()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Step::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Step::Type request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 64;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWait3000ms_8() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_9()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentLevel(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 128));
        NextTest();
    }

    CHIP_ERROR TestSendingOffCommand_10()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_10(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }
};

class Test_TC_LVL_5_1 : public TestCommand
{
public:
    Test_TC_LVL_5_1() : TestCommand("Test_TC_LVL_5_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Sending on command\n");
            err = TestSendingOnCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: DUT level is set to 0x80\n");
            err = TestPreconditionDutLevelIsSetTo0x80_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 3000ms\n");
            err = TestWait3000ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends a move up command to DUT\n");
            err = TestSendsAMoveUpCommandToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Wait 3000ms\n");
            err = TestWait3000ms_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends stop command to DUT\n");
            err = TestSendsStopCommandToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Sending off command\n");
            err = TestSendingOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendingOnCommand_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestPreconditionDutLevelIsSetTo0x80_1()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Step::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Step::Type request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 128;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait3000ms_2() { return WaitForMs(3000); }

    CHIP_ERROR TestSendsAMoveUpCommandToDut_3()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Move::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Move::Type request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 1;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWait3000ms_4() { return WaitForMs(3000); }

    CHIP_ERROR TestSendsStopCommandToDut_5()
    {
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LevelControl::Commands::Stop::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LevelControl::Commands::Stop::Type request;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestSendingOffCommand_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }
};

class Test_TC_MC_1_1 : public TestCommand
{
public:
    Test_TC_MC_1_1() : TestCommand("Test_TC_MC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_MC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_MC_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_MC_2_1 : public TestCommand
{
public:
    Test_TC_MC_2_1() : TestCommand("Test_TC_MC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Put the device into low power mode\n");
            err = TestPutTheDeviceIntoLowPowerMode_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestPutTheDeviceIntoLowPowerMode_0()
    {
        chip::Controller::LowPowerClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LowPower::Commands::Sleep::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LowPower::Commands::Sleep::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_MC_2_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_MC_2_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }
};

class Test_TC_MC_3_1 : public TestCommand
{
public:
    Test_TC_MC_3_1() : TestCommand("Test_TC_MC_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_2 : public TestCommand
{
public:
    Test_TC_MC_3_2() : TestCommand("Test_TC_MC_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_3 : public TestCommand
{
public:
    Test_TC_MC_3_3() : TestCommand("Test_TC_MC_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_4 : public TestCommand
{
public:
    Test_TC_MC_3_4() : TestCommand("Test_TC_MC_3_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_5 : public TestCommand
{
public:
    Test_TC_MC_3_5() : TestCommand("Test_TC_MC_3_5"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_6 : public TestCommand
{
public:
    Test_TC_MC_3_6() : TestCommand("Test_TC_MC_3_6"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_7 : public TestCommand
{
public:
    Test_TC_MC_3_7() : TestCommand("Test_TC_MC_3_7"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_8 : public TestCommand
{
public:
    Test_TC_MC_3_8() : TestCommand("Test_TC_MC_3_8"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_9 : public TestCommand
{
public:
    Test_TC_MC_3_9() : TestCommand("Test_TC_MC_3_9"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_10 : public TestCommand
{
public:
    Test_TC_MC_3_10() : TestCommand("Test_TC_MC_3_10"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_10\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_11 : public TestCommand
{
public:
    Test_TC_MC_3_11() : TestCommand("Test_TC_MC_3_11"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_11\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_11\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_OCC_1_1 : public TestCommand
{
public:
    Test_TC_OCC_1_1() : TestCommand("Test_TC_OCC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_1(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }
};

class Test_TC_OCC_2_1 : public TestCommand
{
public:
    Test_TC_OCC_2_1() : TestCommand("Test_TC_OCC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads mandatory attribute constrains: Occupancy\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancy_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Writes the respective default value to mandatory attribute: Occupancy\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads back mandatory attribute: Occupancy\n");
            err = TestReadsBackMandatoryAttributeOccupancy_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads mandatory attribute constrains: OccupancySensorType\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorType_3();
            break;
        case 4:
            ChipLogProgress(
                chipTool, " ***** Test Step 4 : Writes the respective default value to mandatory attribute: OccupancySensorType\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads back mandatory attribute: OccupancySensorType\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorType_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads mandatory attribute constrains: OccupancySensorTypeBitmap\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 7 : Writes the respective default value to mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads back mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t occupancy)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t occupancy)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t occupancySensorType)> mOnSuccessCallback_3{ OnSuccessCallback_3,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t occupancySensorType)> mOnSuccessCallback_5{ OnSuccessCallback_5,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t occupancySensorTypeBitmap)> mOnSuccessCallback_6{ OnSuccessCallback_6,
                                                                                                                this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t occupancySensorTypeBitmap)> mOnSuccessCallback_8{ OnSuccessCallback_8,
                                                                                                                this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_0(occupancy);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_2(occupancy);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t occupancySensorType)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_3(occupancySensorType);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t occupancySensorType)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_5(occupancySensorType);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t occupancySensorTypeBitmap)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_6(occupancySensorTypeBitmap);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t occupancySensorTypeBitmap)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_8(occupancySensorTypeBitmap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancy_0()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOccupancy(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancy", occupancy, 1));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_1()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t occupancyArgument;
        occupancyArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            occupancyArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancy_2()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOccupancy(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t occupancy)
    {
        VerifyOrReturn(CheckValue<uint8_t>("occupancy", occupancy, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorType_3()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOccupancySensorType(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t occupancySensorType)
    {
        VerifyOrReturn(CheckConstraintType("occupancySensorType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorType", occupancySensorType, 3));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_4()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t occupancySensorTypeArgument;
        occupancySensorTypeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
            occupancySensorTypeArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorType_5()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOccupancySensorType(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t occupancySensorType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("occupancySensorType", occupancySensorType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_6()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOccupancySensorTypeBitmap(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t occupancySensorTypeBitmap)
    {
        VerifyOrReturn(CheckConstraintType("occupancySensorTypeBitmap", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 1));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 7));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_7()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t occupancySensorTypeBitmapArgument;
        occupancySensorTypeBitmapArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
            occupancySensorTypeBitmapArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { NextTest(); }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_8()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOccupancySensorTypeBitmap(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t occupancySensorTypeBitmap)
    {
        VerifyOrReturn(CheckValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 1));
        NextTest();
    }
};

class Test_TC_OCC_2_2 : public TestCommand
{
public:
    Test_TC_OCC_2_2() : TestCommand("Test_TC_OCC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads Occupancy attribute from DUT\n");
            err = TestReadsOccupancyAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Occupancy attribute from DUT\n");
            err = TestReadsOccupancyAttributeFromDut_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t occupancy)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t occupancy)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnSuccessResponse_0(occupancy);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnSuccessResponse_1(occupancy);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_0()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOccupancy(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        NextTest();
    }

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_1()
    {
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOccupancy(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        NextTest();
    }
};

class Test_TC_OO_1_1 : public TestCommand
{
public:
    Test_TC_OO_1_1() : TestCommand("Test_TC_OO_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default values to optional global attribute: FeatureMap\n");
            err = TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads back optional global attribute: FeatureMap\n");
            err = TestReadsBackOptionalGlobalAttributeFeatureMap_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t featureMap)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t featureMap)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_3(featureMap);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_5(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 4U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 4U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeFeatureMap(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t featureMapArgument;
        featureMapArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(
            featureMapArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalGlobalAttributeFeatureMap_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeFeatureMap(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }
};

class Test_TC_OO_2_1 : public TestCommand
{
public:
    Test_TC_OO_2_1() : TestCommand("Test_TC_OO_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: OnOff\n");
            err = TestReadTheMandatoryAttributeOnOff_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads back mandatory attribute: OnOff\n");
            err = TestReadsBackMandatoryAttributeOnOff_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read LT attribute: GlobalSceneControl\n");
            err = TestReadLtAttributeGlobalSceneControl_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read LT attribute: OnTime\n");
            err = TestReadLtAttributeOnTime_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read LT attribute: OffWaitTime\n");
            err = TestReadLtAttributeOffWaitTime_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read LT attribute: StartUpOnOff\n");
            err = TestReadLtAttributeStartUpOnOff_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : write the default value to LT attribute: OnTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOnTime_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write the default value to LT attribute: OffWaitTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOffWaitTime_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default value to LT attribute: StartUpOnOff\n");
            err = TestWriteTheDefaultValueToLtAttributeStartUpOnOff_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads back LT attribute: OnTime\n");
            err = TestReadsBackLtAttributeOnTime_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads back LT attribute: OffWaitTime\n");
            err = TestReadsBackLtAttributeOffWaitTime_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads back LT attribute: StartUpOnOff\n");
            err = TestReadsBackLtAttributeStartUpOnOff_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, bool globalSceneControl)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t startUpOnOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t startUpOnOff)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_0(onOff);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_2(globalSceneControl);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_3(onTime);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_4(offWaitTime);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_5(startUpOnOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_9(onTime);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_10(offWaitTime);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_11(startUpOnOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeOnOff_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeOnOff_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeGlobalSceneControl_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeGlobalSceneControl(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOnTime_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOffWaitTime_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeStartUpOnOff_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStartUpOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startUpOnOff", startUpOnOff, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOnTime_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t onTimeArgument;
        onTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            onTimeArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOffWaitTime_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t offWaitTimeArgument;
        offWaitTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            offWaitTimeArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeStartUpOnOff_8()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t startUpOnOffArgument;
        startUpOnOffArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(
            startUpOnOffArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadsBackLtAttributeOnTime_9()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeOffWaitTime_10()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeStartUpOnOff_11()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStartUpOnOff(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startUpOnOff", startUpOnOff, 0));
        NextTest();
    }
};

class Test_TC_OO_2_2 : public TestCommand
{
public:
    Test_TC_OO_2_2() : TestCommand("Test_TC_OO_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Off Command\n");
            err = TestSendOffCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send On Command\n");
            err = TestSendOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Off Command\n");
            err = TestSendOffCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Send Toggle Command\n");
            err = TestSendToggleCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is true after toggle command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Send Toggle Command\n");
            err = TestSendToggleCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after toggle command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Send On Command\n");
            err = TestSendOnCommand_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Send Off Command\n");
            err = TestSendOffCommand_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_13{ OnSuccessCallback_13, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_3(onOff);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_9(onOff);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_11(onOff);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_13(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendOffCommand_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Toggle::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Toggle::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_8()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Toggle::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Toggle::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_9()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_10()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_10(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_11()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_12()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_12(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_13()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_OO_2_3 : public TestCommand
{
public:
    Test_TC_OO_2_3() : TestCommand("Test_TC_OO_2_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send On Command\n");
            err = TestSendOnCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait 1000ms\n");
            err = TestWait1000ms_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send On Command\n");
            err = TestSendOnCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 1000ms\n");
            err = TestWait1000ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Send On Command\n");
            err = TestSendOnCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 1000ms\n");
            err = TestWait1000ms_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Send On Command\n");
            err = TestSendOnCommand_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Send Off Command\n");
            err = TestSendOffCommand_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Send On Command\n");
            err = TestSendOnCommand_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Send Off Command\n");
            err = TestSendOffCommand_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Send On Command\n");
            err = TestSendOnCommand_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Send Off Command\n");
            err = TestSendOffCommand_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Send Off Command\n");
            err = TestSendOffCommand_45();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 46;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, bool globalSceneControl)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool globalSceneControl)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, bool globalSceneControl)> mOnSuccessCallback_11{ OnSuccessCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_12{ OnSuccessCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_13{ OnSuccessCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_15{ OnSuccessCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_16{ OnFailureCallback_16, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_16{ OnSuccessCallback_16, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_17{ OnFailureCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_17{ OnSuccessCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_19{ OnFailureCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_19{ OnSuccessCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_20{ OnFailureCallback_20, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_20{ OnSuccessCallback_20, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_21{ OnFailureCallback_21, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_21{ OnSuccessCallback_21, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_22{ OnFailureCallback_22, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_22{ OnSuccessCallback_22, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_23{ OnFailureCallback_23, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_23{ OnSuccessCallback_23, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_25{ OnFailureCallback_25, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_25{ OnSuccessCallback_25, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_26{ OnFailureCallback_26, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_26{ OnSuccessCallback_26, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_28{ OnFailureCallback_28, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_28{ OnSuccessCallback_28, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_29{ OnFailureCallback_29, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_29{ OnSuccessCallback_29, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_30{ OnFailureCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_30{ OnSuccessCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_31{ OnFailureCallback_31, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_31{ OnSuccessCallback_31, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_33{ OnFailureCallback_33, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_33{ OnSuccessCallback_33, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_34{ OnFailureCallback_34, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_34{ OnSuccessCallback_34, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_35{ OnFailureCallback_35, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_35{ OnSuccessCallback_35, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_37{ OnFailureCallback_37, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_37{ OnSuccessCallback_37, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_38{ OnFailureCallback_38, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_38{ OnSuccessCallback_38, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_39{ OnFailureCallback_39, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_39{ OnSuccessCallback_39, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_40{ OnFailureCallback_40, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_40{ OnSuccessCallback_40, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_41{ OnFailureCallback_41, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_41{ OnSuccessCallback_41, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_42{ OnFailureCallback_42, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_42{ OnSuccessCallback_42, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_43{ OnFailureCallback_43, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t onTime)> mOnSuccessCallback_43{ OnSuccessCallback_43, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_44{ OnFailureCallback_44, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t offWaitTime)> mOnSuccessCallback_44{ OnSuccessCallback_44, this };

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_3(globalSceneControl);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_6(onOff);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_7(globalSceneControl);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_10(onOff);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_11(globalSceneControl);
    }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_12(onTime);
    }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_13(offWaitTime);
    }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_15(onOff);
    }

    static void OnFailureCallback_16(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_16(status);
    }

    static void OnSuccessCallback_16(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_16(onTime);
    }

    static void OnFailureCallback_17(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_17(status);
    }

    static void OnSuccessCallback_17(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_17(offWaitTime);
    }

    static void OnFailureCallback_19(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_19(status);
    }

    static void OnSuccessCallback_19(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_19(onOff);
    }

    static void OnFailureCallback_20(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_20(status);
    }

    static void OnSuccessCallback_20(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_20(onTime);
    }

    static void OnFailureCallback_21(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_21(status);
    }

    static void OnSuccessCallback_21(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_21(onOff);
    }

    static void OnFailureCallback_22(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_22(status);
    }

    static void OnSuccessCallback_22(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_22(onTime);
    }

    static void OnFailureCallback_23(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_23(status);
    }

    static void OnSuccessCallback_23(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_23(offWaitTime);
    }

    static void OnFailureCallback_25(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_25(status);
    }

    static void OnSuccessCallback_25(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_25(onTime);
    }

    static void OnFailureCallback_26(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_26(status);
    }

    static void OnSuccessCallback_26(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_26(offWaitTime);
    }

    static void OnFailureCallback_28(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_28(status);
    }

    static void OnSuccessCallback_28(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_28(onOff);
    }

    static void OnFailureCallback_29(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_29(status);
    }

    static void OnSuccessCallback_29(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_29(onTime);
    }

    static void OnFailureCallback_30(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_30(status);
    }

    static void OnSuccessCallback_30(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_30(onOff);
    }

    static void OnFailureCallback_31(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_31(status);
    }

    static void OnSuccessCallback_31(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_31(onTime);
    }

    static void OnFailureCallback_33(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_33(status);
    }

    static void OnSuccessCallback_33(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_33(onOff);
    }

    static void OnFailureCallback_34(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_34(status);
    }

    static void OnSuccessCallback_34(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_34(onTime);
    }

    static void OnFailureCallback_35(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_35(status);
    }

    static void OnSuccessCallback_35(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_35(offWaitTime);
    }

    static void OnFailureCallback_37(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_37(status);
    }

    static void OnSuccessCallback_37(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_37(onOff);
    }

    static void OnFailureCallback_38(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_38(status);
    }

    static void OnSuccessCallback_38(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_38(onTime);
    }

    static void OnFailureCallback_39(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_39(status);
    }

    static void OnSuccessCallback_39(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_39(onOff);
    }

    static void OnFailureCallback_40(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_40(status);
    }

    static void OnSuccessCallback_40(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_40(onTime);
    }

    static void OnFailureCallback_41(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_41(status);
    }

    static void OnSuccessCallback_41(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_41(offWaitTime);
    }

    static void OnFailureCallback_42(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_42(status);
    }

    static void OnSuccessCallback_42(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_42(onOff);
    }

    static void OnFailureCallback_43(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_43(status);
    }

    static void OnSuccessCallback_43(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_43(onTime);
    }

    static void OnFailureCallback_44(void * context, uint8_t status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_44(status);
    }

    static void OnSuccessCallback_44(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_44(offWaitTime);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendOnCommand_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestWait1000ms_1() { return WaitForMs(1000); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeGlobalSceneControl(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait1000ms_5() { return WaitForMs(1000); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_7()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeGlobalSceneControl(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_8()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWait1000ms_9() { return WaitForMs(1000); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_10()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_11()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeGlobalSceneControl(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_12()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel());
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_13()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_14()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_14(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_15()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_16()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_16.Cancel(), mOnFailureCallback_16.Cancel());
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_17()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_17.Cancel(), mOnFailureCallback_17.Cancel());
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_18()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_18();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_18(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_19()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_19.Cancel(), mOnFailureCallback_19.Cancel());
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_20()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_20.Cancel(), mOnFailureCallback_20.Cancel());
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_21()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_21.Cancel(), mOnFailureCallback_21.Cancel());
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_22()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_22.Cancel(), mOnFailureCallback_22.Cancel());
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_23()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_23.Cancel(), mOnFailureCallback_23.Cancel());
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_24()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_24();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_24(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_25()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_25.Cancel(), mOnFailureCallback_25.Cancel());
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_26()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_26.Cancel(), mOnFailureCallback_26.Cancel());
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_27()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_27();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_27(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_28()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_28.Cancel(), mOnFailureCallback_28.Cancel());
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_29()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_29.Cancel(), mOnFailureCallback_29.Cancel());
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_30()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_30.Cancel(), mOnFailureCallback_30.Cancel());
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_31()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_31.Cancel(), mOnFailureCallback_31.Cancel());
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_32()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_32();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_32(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_33()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_33.Cancel(), mOnFailureCallback_33.Cancel());
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_34()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_34.Cancel(), mOnFailureCallback_34.Cancel());
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_35()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_35.Cancel(), mOnFailureCallback_35.Cancel());
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_36()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_36();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_36(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_37()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_37.Cancel(), mOnFailureCallback_37.Cancel());
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_38()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_38.Cancel(), mOnFailureCallback_38.Cancel());
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_39()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_39.Cancel(), mOnFailureCallback_39.Cancel());
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_40()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_40.Cancel(), mOnFailureCallback_40.Cancel());
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_41()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_41.Cancel(), mOnFailureCallback_41.Cancel());
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_42()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnOff(mOnSuccessCallback_42.Cancel(), mOnFailureCallback_42.Cancel());
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_43()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnTime(mOnSuccessCallback_43.Cancel(), mOnFailureCallback_43.Cancel());
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_44()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOffWaitTime(mOnSuccessCallback_44.Cancel(), mOnFailureCallback_44.Cancel());
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_45()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_45();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_45(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45() { NextTest(); }
};

class Test_TC_PRS_1_1 : public TestCommand
{
public:
    Test_TC_PRS_1_1() : TestCommand("Test_TC_PRS_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_3(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { NextTest(); }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_3()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }
};

class Test_TC_PRS_2_1 : public TestCommand
{
public:
    Test_TC_PRS_2_1() : TestCommand("Test_TC_PRS_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read the mandatory attribute constraints: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMeasuredValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write the default values to mandatory attribute: MeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads back mandatory attribute: MeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the mandatory attribute constraints: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Write the default values to mandatory attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads back mandatory attribute: MinMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMinMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read the mandatory attribute constraints: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write the default values to mandatory attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads back mandatory attribute: MaxMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMaxMeasuredValue_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, int16_t minMeasuredValue)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, int16_t minMeasuredValue)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, int16_t maxMeasuredValue)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, int16_t maxMeasuredValue)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_2(measuredValue);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_3(minMeasuredValue);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_5(minMeasuredValue);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_6(maxMeasuredValue);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_8(maxMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMeasuredValue_0()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_1()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t measuredValueArgument;
        measuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            measuredValueArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMeasuredValue_2()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t measuredValue)
    {
        VerifyOrReturn(CheckValue<int16_t>("measuredValue", measuredValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_3()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMinMeasuredValue(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_4()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t minMeasuredValueArgument;
        minMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            minMeasuredValueArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMinMeasuredValue_5()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMinMeasuredValue(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckValue<int16_t>("minMeasuredValue", minMeasuredValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_6()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxMeasuredValue(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_7()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t maxMeasuredValueArgument;
        maxMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            maxMeasuredValueArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { NextTest(); }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMaxMeasuredValue_8()
    {
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxMeasuredValue(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxMeasuredValue", maxMeasuredValue, 0));
        NextTest();
    }
};

class Test_TC_PCC_1_1 : public TestCommand
{
public:
    Test_TC_PCC_1_1() : TestCommand("Test_TC_PCC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_PCC_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_PCC_2_1 : public TestCommand
{
public:
    Test_TC_PCC_2_1() : TestCommand("Test_TC_PCC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, int16_t maxPressure)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveOperationMode)> mOnSuccessCallback_1{ OnSuccessCallback_1,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveControlMode)> mOnSuccessCallback_2{ OnSuccessCallback_2,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, int16_t capacity)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, int16_t maxPressure)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveOperationMode)> mOnSuccessCallback_5{ OnSuccessCallback_5,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveControlMode)> mOnSuccessCallback_6{ OnSuccessCallback_6,
                                                                                                           this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, int16_t capacity)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_0(maxPressure);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_1(effectiveOperationMode);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_2(effectiveControlMode);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_3(capacity);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_4(maxPressure);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_5(effectiveOperationMode);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_6(effectiveControlMode);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_7(capacity);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_0()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxPressure(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_1()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveOperationMode(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_2()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveControlMode(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_3()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCapacity(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_4()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMaxPressure(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_5()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveOperationMode(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_6()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveControlMode(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_7()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCapacity(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
        NextTest();
    }
};

class Test_TC_PCC_2_2 : public TestCommand
{
public:
    Test_TC_PCC_2_2() : TestCommand("Test_TC_PCC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Write 1 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite1ToTheOperationModeAttributeToDutOperationMode_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 2 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite2ToTheOperationModeAttributeToDutOperationMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write 3 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite3ToTheOperationModeAttributeToDutOperationMode_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWrite1ToTheOperationModeAttributeToDutOperationMode_0()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestWrite2ToTheOperationModeAttributeToDutOperationMode_1()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(2);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWrite3ToTheOperationModeAttributeToDutOperationMode_2()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(3);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class Test_TC_PCC_2_3 : public TestCommand
{
public:
    Test_TC_PCC_2_3() : TestCommand("Test_TC_PCC_2_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Write 0 to the OperationMode attribute to DUT\n");
            err = TestWrite0ToTheOperationModeAttributeToDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the attribute: EffectiveOperationMode\n");
            err = TestReadsTheAttributeEffectiveOperationMode_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t effectiveOperationMode)> mOnSuccessCallback_1{ OnSuccessCallback_1,
                                                                                                             this };

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_PCC_2_3 *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnSuccessResponse_1(effectiveOperationMode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWrite0ToTheOperationModeAttributeToDut_0()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReadsTheAttributeEffectiveOperationMode_1()
    {
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEffectiveOperationMode(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("effectiveOperationMode", effectiveOperationMode, 0));
        NextTest();
    }
};

class Test_TC_RH_1_1 : public TestCommand
{
public:
    Test_TC_RH_1_1() : TestCommand("Test_TC_RH_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_RH_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_RH_2_1 : public TestCommand
{
public:
    Test_TC_RH_2_1() : TestCommand("Test_TC_RH_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads constraints of attribute: MeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMeasuredValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads constraints of attribute: MinMeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMinMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t measuredValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t minMeasuredValue)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t minMeasuredValue)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnSuccessResponse_1(minMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsConstraintsOfAttributeMeasuredValue_0()
    {
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeMinMeasuredValue_1()
    {
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMinMeasuredValue(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("minMeasuredValue", minMeasuredValue, 9999));
        NextTest();
    }
};

class Test_TC_RH_2_2 : public TestCommand
{
public:
    Test_TC_RH_2_2() : TestCommand("Test_TC_RH_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads MeasuredValue attribute from DUT\n");
            err = TestReadsMeasuredValueAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t measuredValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t measuredValue)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_0()
    {
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_TM_1_1 : public TestCommand
{
public:
    Test_TC_TM_1_1() : TestCommand("Test_TC_TM_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }
};

class Test_TC_TM_2_1 : public TestCommand
{
public:
    Test_TC_TM_2_1() : TestCommand("Test_TC_TM_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_0()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
        NextTest();
    }
};

class Test_TC_TM_2_2 : public TestCommand
{
public:
    Test_TC_TM_2_2() : TestCommand("Test_TC_TM_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads MeasuredValue attribute from DUT\n");
            err = TestReadsMeasuredValueAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, int16_t measuredValue)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_0()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMeasuredValue(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_TSTAT_1_1 : public TestCommand
{
public:
    Test_TC_TSTAT_1_1() : TestCommand("Test_TC_TSTAT_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 5U;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_TSUIC_1_1 : public TestCommand
{
public:
    Test_TC_TSUIC_1_1() : TestCommand("Test_TC_TSUIC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_TSUIC_2_1 : public TestCommand
{
public:
    Test_TC_TSUIC_2_1() : TestCommand("Test_TC_TSUIC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : write to the mandatory attribute: TemperatureDisplayMode\n");
            err = TestWriteToTheMandatoryAttributeTemperatureDisplayMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write to the mandatory attribute: KeypadLockout\n");
            err = TestWriteToTheMandatoryAttributeKeypadLockout_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : write to the mandatory attribute: ScheduleProgrammingVisibility\n");
            err = TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_0{ OnSuccessCallback_0,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_1{ OnSuccessCallback_1,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_3{ OnSuccessCallback_3,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t temperatureDisplayMode)> mOnSuccessCallback_4{ OnSuccessCallback_4,
                                                                                                             this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t keypadLockout)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_10{
        OnSuccessCallback_10, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_11{ OnFailureCallback_11, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_11{
        OnSuccessCallback_11, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_13{ OnFailureCallback_13, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_13{
        OnSuccessCallback_13, this
    };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_14{ OnFailureCallback_14, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t scheduleProgrammingVisibility)> mOnSuccessCallback_14{
        OnSuccessCallback_14, this
    };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_0(temperatureDisplayMode);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_1(temperatureDisplayMode);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_3(temperatureDisplayMode);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_4(temperatureDisplayMode);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_5(keypadLockout);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_6(keypadLockout);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_8(keypadLockout);
    }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_9(keypadLockout);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_10(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_11(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_11(status);
    }

    static void OnSuccessCallback_11(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_11(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_13(status);
    }

    static void OnSuccessCallback_13(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_13(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_14(void * context, uint8_t status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_14(status);
    }

    static void OnSuccessCallback_14(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_14(scheduleProgrammingVisibility);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_0()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTemperatureDisplayMode(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("temperatureDisplayMode", temperatureDisplayMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_1()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTemperatureDisplayMode(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeTemperatureDisplayMode_2()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_3()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTemperatureDisplayMode(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("temperatureDisplayMode", temperatureDisplayMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_4()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTemperatureDisplayMode(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_5()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeKeypadLockout(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue<uint8_t>("keypadLockout", keypadLockout, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_6()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeKeypadLockout(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeKeypadLockout_7()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(0);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_8()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeKeypadLockout(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue<uint8_t>("keypadLockout", keypadLockout, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_9()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeKeypadLockout(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_10()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeScheduleProgrammingVisibility(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue<uint8_t>("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_11()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeScheduleProgrammingVisibility(mOnSuccessCallback_11.Cancel(), mOnFailureCallback_11.Cancel());
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_12()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_13()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeScheduleProgrammingVisibility(mOnSuccessCallback_13.Cancel(), mOnFailureCallback_13.Cancel());
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue<uint8_t>("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_14()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeScheduleProgrammingVisibility(mOnSuccessCallback_14.Cancel(), mOnFailureCallback_14.Cancel());
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
        NextTest();
    }
};

class Test_TC_TSUIC_2_2 : public TestCommand
{
public:
    Test_TC_TSUIC_2_2() : TestCommand("Test_TC_TSUIC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Writes a value of 0 to TemperatureDisplayMode attribute of DUT\n");
            err = TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Writes a value of 1 to TemperatureDisplayMode attribute of DUT\n");
            err = TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Writes a value of 0 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Writes a value of 1 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Writes a value of 2 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Writes a value of 3 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Writes a value of 4 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes a value of 5 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : Writes a value of 0 to ScheduleProgrammingVisibility attribute of DUT\n");
            err = TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes a value of 1 to ScheduleProgrammingVisibility attribute of DUT\n");
            err = TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_9(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_0()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_1()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_2()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(0);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_3()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(1);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_4()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(2);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_5()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(3);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_6()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(4);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_7()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(5);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_8()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_9()
    {
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }
};

class Test_TC_DIAGTH_1_1 : public TestCommand
{
public:
    Test_TC_DIAGTH_1_1() : TestCommand("Test_TC_DIAGTH_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGTH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGTH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }
};

class Test_TC_WNCV_1_1 : public TestCommand
{
public:
    Test_TC_WNCV_1_1() : TestCommand("Test_TC_WNCV_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default value to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValueToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the global attribute: FeatureMap\n");
            err = TestReadTheGlobalAttributeFeatureMap_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: FeatureMap\n");
            err = TestReadsBackGlobalAttributeFeatureMap_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t clusterRevision)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t featureMap)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t featureMap)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_3(featureMap);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_4(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 5U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryGlobalAttributeClusterRevision_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 5U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeClusterRevision(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 5U));
        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeFeatureMap_3()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeFeatureMap(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadsBackGlobalAttributeFeatureMap_4()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeFeatureMap(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }
};

class Test_TC_WNCV_2_1 : public TestCommand
{
public:
    Test_TC_WNCV_2_1() : TestCommand("Test_TC_WNCV_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the RO mandatory attribute default: Type\n");
            err = TestReadTheRoMandatoryAttributeDefaultType_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads back the RO mandatory attribute: Type\n");
            err = TestReadsBackTheRoMandatoryAttributeType_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the RO mandatory attribute default: ConfigStatus\n");
            err = TestReadTheRoMandatoryAttributeDefaultConfigStatus_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : reads back the RO mandatory attribute: ConfigStatus\n");
            err = TestReadsBackTheRoMandatoryAttributeConfigStatus_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the RO mandatory attribute default: OperationalStatus\n");
            err = TestReadTheRoMandatoryAttributeDefaultOperationalStatus_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads back the RO mandatory attribute: OperationalStatus\n");
            err = TestReadsBackTheRoMandatoryAttributeOperationalStatus_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the RO mandatory attribute default: EndProductType\n");
            err = TestReadTheRoMandatoryAttributeDefaultEndProductType_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : reads back the RO mandatory attribute: EndProductType\n");
            err = TestReadsBackTheRoMandatoryAttributeEndProductType_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the RW mandatory attribute default: Mode\n");
            err = TestReadTheRwMandatoryAttributeDefaultMode_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : write a value into the RW mandatory attribute:: Mode\n");
            err = TestWriteAValueIntoTheRwMandatoryAttributeMode_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads back the RW mandatory attribute: Mode\n");
            err = TestReadsBackTheRwMandatoryAttributeMode_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t type)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t type)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t configStatus)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t configStatus)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t endProductType)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t endProductType)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_8{ OnFailureCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t mode)> mOnSuccessCallback_8{ OnSuccessCallback_8, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t mode)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_0(type);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_1(type);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_2(configStatus);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_3(configStatus);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_4(operationalStatus);
    }

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_5(operationalStatus);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_6(endProductType);
    }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_7(endProductType);
    }

    static void OnFailureCallback_8(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_8(status);
    }

    static void OnSuccessCallback_8(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_8(mode);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_10(mode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultType_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeType(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t type)
    {
        VerifyOrReturn(CheckValue<uint8_t>("type", type, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeType_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeType(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t type)
    {
        VerifyOrReturn(CheckValue<uint8_t>("type", type, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultConfigStatus_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeConfigStatus(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t configStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("configStatus", configStatus, 3));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeConfigStatus_3()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeConfigStatus(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t configStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("configStatus", configStatus, 3));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultOperationalStatus_4()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeOperationalStatus_5()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultEndProductType_6()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEndProductType(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("endProductType", endProductType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeEndProductType_7()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEndProductType(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("endProductType", endProductType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRwMandatoryAttributeDefaultMode_8()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMode(mOnSuccessCallback_8.Cancel(), mOnFailureCallback_8.Cancel());
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t mode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mode", mode, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAValueIntoTheRwMandatoryAttributeMode_9()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t modeArgument;
        modeArgument = 7;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(
            modeArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadsBackTheRwMandatoryAttributeMode_10()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMode(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t mode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mode", mode, 7));
        NextTest();
    }
};

class Test_TC_WNCV_2_2 : public TestCommand
{
public:
    Test_TC_WNCV_2_2() : TestCommand("Test_TC_WNCV_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_WNCV_2_5 : public TestCommand
{
public:
    Test_TC_WNCV_2_5() : TestCommand("Test_TC_WNCV_2_5"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads EndProductType attribute from DUT\n");
            err = TestReadsEndProductTypeAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads EndProductType attribute constraints from DUT\n");
            err = TestReadsEndProductTypeAttributeConstraintsFromDut_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t endProductType)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t endProductType)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnSuccessResponse_0(endProductType);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnSuccessResponse_1(endProductType);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsEndProductTypeAttributeFromDut_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEndProductType(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("endProductType", endProductType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsEndProductTypeAttributeConstraintsFromDut_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEndProductType(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t endProductType)
    {
        VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("endProductType", endProductType, 23));
        NextTest();
    }
};

class Test_TC_WNCV_3_1 : public TestCommand
{
public:
    Test_TC_WNCV_3_1() : TestCommand("Test_TC_WNCV_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-open position\n");
            err = Test1aThAdjustsTheTheDutToANonOpenPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends UpOrOpen command to DUT\n");
            err = Test2aThSendsUpOrOpenCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: TH reads OperationalStatus attribute from DUT\n");
            err = Test3aThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonOpenPosition_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsUpOrOpenCommandToDut_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test3aThReadsOperationalStatusAttributeFromDut_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class Test_TC_WNCV_3_2 : public TestCommand
{
public:
    Test_TC_WNCV_3_2() : TestCommand("Test_TC_WNCV_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-closed position\n");
            err = Test1aThAdjustsTheTheDutToANonClosedPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends DownOrClose command to DUT\n");
            err = Test2aThSendsDownOrCloseCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: TH reads OperationalStatus attribute from DUT\n");
            err = Test3aThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonClosedPosition_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsDownOrCloseCommandToDut_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test3aThReadsOperationalStatusAttributeFromDut_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class Test_TC_WNCV_3_3 : public TestCommand
{
public:
    Test_TC_WNCV_3_3() : TestCommand("Test_TC_WNCV_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-open position\n");
            err = Test1aThAdjustsTheTheDutToANonOpenPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends StopMotion command to DUT\n");
            err = Test2aThSendsStopMotionCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 2b: TH reads OperationalStatus attribute from DUT\n");
            err = Test2bThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t operationalStatus)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonOpenPosition_0()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsStopMotionCommandToDut_1()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::WindowCovering::Commands::StopMotion::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::WindowCovering::Commands::StopMotion::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test2bThReadsOperationalStatusAttributeFromDut_2()
    {
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOperationalStatus(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class TV_TargetNavigatorCluster : public TestCommand
{
public:
    TV_TargetNavigatorCluster() : TestCommand("TV_TargetNavigatorCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TargetNavigatorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TargetNavigatorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Target Navigator list\n");
            err = TestReadAttributeTargetNavigatorList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Navigate Target Command\n");
            err = TestNavigateTargetCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_TargetNavigatorCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)
    {
        (static_cast<TV_TargetNavigatorCluster *>(context))->OnSuccessResponse_0(targetNavigatorList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeTargetNavigatorList_0()
    {
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTargetNavigatorList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)
    {
        auto iter = targetNavigatorList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(targetNavigatorList)>("targetNavigatorList", iter, 0));
        VerifyOrReturn(CheckValue<>("targetNavigatorList[0].identifier", iter.GetValue().identifier, 1));
        VerifyOrReturn(CheckValueAsString("targetNavigatorList[0].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(targetNavigatorList)>("targetNavigatorList", iter, 1));
        VerifyOrReturn(CheckValue<>("targetNavigatorList[1].identifier", iter.GetValue().identifier, 2));
        VerifyOrReturn(CheckValueAsString("targetNavigatorList[1].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckNoMoreListItems<decltype(targetNavigatorList)>("targetNavigatorList", iter, 2));
        NextTest();
    }

    CHIP_ERROR TestNavigateTargetCommand_1()
    {
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type;
        using responseType = chip::app::Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType;

        chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type request;
        request.target = 1;
        request.data   = chip::Span<const char>("1", strlen("1"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_TargetNavigatorCluster *>(context))->OnSuccessResponse_1(data.status, data.data);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TargetNavigatorCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::TargetNavigator::NavigateTargetStatus status, chip::CharSpan data) { NextTest(); }
};

class TV_AudioOutputCluster : public TestCommand
{
public:
    TV_AudioOutputCluster() : TestCommand("TV_AudioOutputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AudioOutputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AudioOutputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Audio Output list\n");
            err = TestReadAttributeAudioOutputList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Select Output Command\n");
            err = TestSelectOutputCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Rename Output Command\n");
            err = TestRenameOutputCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)
    {
        (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_0(audioOutputList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeAudioOutputList_0()
    {
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevice, 2);

        return cluster.ReadAttributeAudioOutputList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)
    {
        auto iter = audioOutputList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 0));
        VerifyOrReturn(CheckValue<>("audioOutputList[0].index", iter.GetValue().index, 1));
        VerifyOrReturn(CheckValue<>("audioOutputList[0].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[0].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 1));
        VerifyOrReturn(CheckValue<>("audioOutputList[1].index", iter.GetValue().index, 2));
        VerifyOrReturn(CheckValue<>("audioOutputList[1].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[1].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 2));
        VerifyOrReturn(CheckValue<>("audioOutputList[2].index", iter.GetValue().index, 3));
        VerifyOrReturn(CheckValue<>("audioOutputList[2].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[2].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckNoMoreListItems<decltype(audioOutputList)>("audioOutputList", iter, 3));
        NextTest();
    }

    CHIP_ERROR TestSelectOutputCommand_1()
    {
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevice, 2);

        using requestType  = chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type request;
        request.index = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestRenameOutputCommand_2()
    {
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevice, 2);

        using requestType  = chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type request;
        request.index = 1;
        request.name  = chip::Span<const char>("exampleName", strlen("exampleName"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class TV_ApplicationLauncherCluster : public TestCommand
{
public:
    TV_ApplicationLauncherCluster() : TestCommand("TV_ApplicationLauncherCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationLauncherCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationLauncherCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Application Launcher list\n");
            err = TestReadAttributeApplicationLauncherList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Launch App Command\n");
            err = TestLaunchAppCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute catalog vendor id\n");
            err = TestReadAttributeCatalogVendorId_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute application id\n");
            err = TestReadAttributeApplicationId_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context,
                                      const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t catalogVendorId)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t applicationId)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_0(applicationLauncherList);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t catalogVendorId)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_2(catalogVendorId);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint8_t applicationId)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_3(applicationId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeApplicationLauncherList_0()
    {
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeApplicationLauncherList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)
    {
        auto iter = applicationLauncherList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(applicationLauncherList)>("applicationLauncherList", iter, 0));
        VerifyOrReturn(CheckValue<uint16_t>("applicationLauncherList[0]", iter.GetValue(), 123U));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(applicationLauncherList)>("applicationLauncherList", iter, 1));
        VerifyOrReturn(CheckValue<uint16_t>("applicationLauncherList[1]", iter.GetValue(), 456U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(applicationLauncherList)>("applicationLauncherList", iter, 2));
        NextTest();
    }

    CHIP_ERROR TestLaunchAppCommand_1()
    {
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type;
        using responseType = chip::app::Clusters::ApplicationLauncher::Commands::LaunchAppResponse::DecodableType;

        chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type request;
        request.data            = chip::Span<const char>("exampleData", strlen("exampleData"));
        request.catalogVendorId = 1U;
        request.applicationId   = chip::Span<const char>("appId", strlen("appId"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_1(data.status, data.data);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::ApplicationLauncher::ApplicationLauncherStatus status, chip::CharSpan data)
    {

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCatalogVendorId_2()
    {
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCatalogVendorId(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t catalogVendorId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("catalogVendorId", catalogVendorId, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationId_3()
    {
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeApplicationId(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t applicationId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("applicationId", applicationId, 0));
        NextTest();
    }
};

class TV_KeypadInputCluster : public TestCommand
{
public:
    TV_KeypadInputCluster() : TestCommand("TV_KeypadInputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_KeypadInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_KeypadInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Key Command\n");
            err = TestSendKeyCommand_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendKeyCommand_0()
    {
        chip::Controller::KeypadInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::KeypadInput::Commands::SendKey::Type;
        using responseType = chip::app::Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType;

        chip::app::Clusters::KeypadInput::Commands::SendKey::Type request;
        request.keyCode = static_cast<chip::app::Clusters::KeypadInput::KeypadInputCecKeyCode>(3);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_KeypadInputCluster *>(context))->OnSuccessResponse_0(data.status);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_KeypadInputCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::app::Clusters::KeypadInput::KeypadInputStatus status) { NextTest(); }
};

class TV_AccountLoginCluster : public TestCommand
{
public:
    TV_AccountLoginCluster() : TestCommand("TV_AccountLoginCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AccountLoginCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AccountLoginCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Get Setup PIN Command\n");
            err = TestGetSetupPinCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Login Command\n");
            err = TestLoginCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    //
    // Tests methods
    //

    CHIP_ERROR TestGetSetupPinCommand_0()
    {
        chip::Controller::AccountLoginClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type;
        using responseType = chip::app::Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType;

        chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type request;
        request.tempAccountIdentifier = chip::Span<const char>("asdf", strlen("asdf"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnSuccessResponse_0(data.setupPIN);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::CharSpan setupPIN) { NextTest(); }

    CHIP_ERROR TestLoginCommand_1()
    {
        chip::Controller::AccountLoginClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::AccountLogin::Commands::Login::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::AccountLogin::Commands::Login::Type request;
        request.tempAccountIdentifier = chip::Span<const char>("asdf", strlen("asdf"));
        request.setupPIN              = chip::Span<const char>("tempPin123", strlen("tempPin123"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }
};

class TV_WakeOnLanCluster : public TestCommand
{
public:
    TV_WakeOnLanCluster() : TestCommand("TV_WakeOnLanCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_WakeOnLanCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_WakeOnLanCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read mac address\n");
            err = TestReadMacAddress_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan wakeOnLanMacAddress)> mOnSuccessCallback_0{
        OnSuccessCallback_0, this
    };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_WakeOnLanCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, chip::CharSpan wakeOnLanMacAddress)
    {
        (static_cast<TV_WakeOnLanCluster *>(context))->OnSuccessResponse_0(wakeOnLanMacAddress);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadMacAddress_0()
    {
        chip::Controller::WakeOnLanClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeWakeOnLanMacAddress(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::CharSpan wakeOnLanMacAddress)
    {
        VerifyOrReturn(CheckValueAsString("wakeOnLanMacAddress", wakeOnLanMacAddress, "00:00:00:00:00"));
        NextTest();
    }
};

class TV_ApplicationBasicCluster : public TestCommand
{
public:
    TV_ApplicationBasicCluster() : TestCommand("TV_ApplicationBasicCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationBasicCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationBasicCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Change Status Command\n");
            err = TestChangeStatusCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute vendor id\n");
            err = TestReadAttributeVendorId_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute product id\n");
            err = TestReadAttributeProductId_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute catalog vendor id\n");
            err = TestReadAttributeCatalogVendorId_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t vendorId)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t productId)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t catalogVendorId)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint16_t vendorId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_1(vendorId);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint16_t productId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_2(productId);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint16_t catalogVendorId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_3(catalogVendorId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestChangeStatusCommand_0()
    {
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type request;
        request.status = static_cast<chip::app::Clusters::ApplicationBasic::ApplicationBasicStatus>(1);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorId_1()
    {
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, 3);

        return cluster.ReadAttributeVendorId(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t vendorId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("vendorId", vendorId, 1U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeProductId_2()
    {
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, 3);

        return cluster.ReadAttributeProductId(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t productId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("productId", productId, 1U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeCatalogVendorId_3()
    {
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, 3);

        return cluster.ReadAttributeCatalogVendorId(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t catalogVendorId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("catalogVendorId", catalogVendorId, 1U));
        NextTest();
    }
};

class TV_MediaPlaybackCluster : public TestCommand
{
public:
    TV_MediaPlaybackCluster() : TestCommand("TV_MediaPlaybackCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaPlaybackCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaPlaybackCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Media Playback Play Command\n");
            err = TestMediaPlaybackPlayCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Media Playback Pause Command\n");
            err = TestMediaPlaybackPauseCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Media Playback Stop Command\n");
            err = TestMediaPlaybackStopCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Media Playback Start Over Command\n");
            err = TestMediaPlaybackStartOverCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Media Playback Previous Command\n");
            err = TestMediaPlaybackPreviousCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Media Playback Next Command\n");
            err = TestMediaPlaybackNextCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Media Playback Rewind Command\n");
            err = TestMediaPlaybackRewindCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Media Playback Fast Forward Command\n");
            err = TestMediaPlaybackFastForwardCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Media Playback Skip Forward Command\n");
            err = TestMediaPlaybackSkipForwardCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Media Playback Skip Backward Command\n");
            err = TestMediaPlaybackSkipBackwardCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Media Playback Seek Command\n");
            err = TestMediaPlaybackSeekCommand_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    //
    // Tests methods
    //

    CHIP_ERROR TestMediaPlaybackPlayCommand_0()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaPlayResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_0(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPauseCommand_1()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaPauseResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_1(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStopCommand_2()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaStopResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_2(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStartOverCommand_3()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaStartOverResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_3(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPreviousCommand_4()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaPreviousResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_4(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackNextCommand_5()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaNextResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_5(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackRewindCommand_6()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaRewindResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_6(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackFastForwardCommand_7()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaFastForwardResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_7(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipForwardCommand_8()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaSkipForwardResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_8(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipBackwardCommand_9()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackwardResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_9(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_9(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSeekCommand_10()
    {
        chip::Controller::MediaPlaybackClusterTest cluster;
        cluster.Associate(mDevice, 3);

        using requestType  = chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type;
        using responseType = chip::app::Clusters::MediaPlayback::Commands::MediaSeekResponse::DecodableType;

        chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type request;
        request.position = 100ULL;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_10(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_10(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }
};

class TV_TvChannelCluster : public TestCommand
{
public:
    TV_TvChannelCluster() : TestCommand("TV_TvChannelCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TvChannelCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TvChannelCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute TV Channel list\n");
            err = TestReadAttributeTvChannelList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Change Channel By Number Command\n");
            err = TestChangeChannelByNumberCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Skip Channel Command\n");
            err = TestSkipChannelCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context,
                                      const chip::app::DataModel::DecodableList<
                                          chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> & tvChannelList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> &
            tvChannelList)
    {
        (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_0(tvChannelList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeTvChannelList_0()
    {
        chip::Controller::TvChannelClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeTvChannelList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> &
            tvChannelList)
    {
        auto iter = tvChannelList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(tvChannelList)>("tvChannelList", iter, 0));
        VerifyOrReturn(CheckValue<>("tvChannelList[0].majorNumber", iter.GetValue().majorNumber, 1U));
        VerifyOrReturn(CheckValue<>("tvChannelList[0].minorNumber", iter.GetValue().minorNumber, 2U));
        VerifyOrReturn(CheckValueAsString("tvChannelList[0].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckValueAsString("tvChannelList[0].callSign", iter.GetValue().callSign, "exampleCSign"));
        VerifyOrReturn(CheckValueAsString("tvChannelList[0].affiliateCallSign", iter.GetValue().affiliateCallSign, "exampleASign"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(tvChannelList)>("tvChannelList", iter, 1));
        VerifyOrReturn(CheckValue<>("tvChannelList[1].majorNumber", iter.GetValue().majorNumber, 2U));
        VerifyOrReturn(CheckValue<>("tvChannelList[1].minorNumber", iter.GetValue().minorNumber, 3U));
        VerifyOrReturn(CheckValueAsString("tvChannelList[1].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckValueAsString("tvChannelList[1].callSign", iter.GetValue().callSign, "exampleCSign"));
        VerifyOrReturn(CheckValueAsString("tvChannelList[1].affiliateCallSign", iter.GetValue().affiliateCallSign, "exampleASign"));
        VerifyOrReturn(CheckNoMoreListItems<decltype(tvChannelList)>("tvChannelList", iter, 2));
        NextTest();
    }

    CHIP_ERROR TestChangeChannelByNumberCommand_1()
    {
        chip::Controller::TvChannelClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type request;
        request.majorNumber = 1U;
        request.minorNumber = 2U;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestSkipChannelCommand_2()
    {
        chip::Controller::TvChannelClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TvChannel::Commands::SkipChannel::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TvChannel::Commands::SkipChannel::Type request;
        request.count = 1U;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class TV_LowPowerCluster : public TestCommand
{
public:
    TV_LowPowerCluster() : TestCommand("TV_LowPowerCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_LowPowerCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_LowPowerCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Sleep Input Status Command\n");
            err = TestSleepInputStatusCommand_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestSleepInputStatusCommand_0()
    {
        chip::Controller::LowPowerClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::LowPower::Commands::Sleep::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::LowPower::Commands::Sleep::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_LowPowerCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_LowPowerCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }
};

class TV_MediaInputCluster : public TestCommand
{
public:
    TV_MediaInputCluster() : TestCommand("TV_MediaInputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute media input list\n");
            err = TestReadAttributeMediaInputList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Select Input Command\n");
            err = TestSelectInputCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read current input list\n");
            err = TestReadCurrentInputList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Hide Input Status Command\n");
            err = TestHideInputStatusCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Show Input Status Command\n");
            err = TestShowInputStatusCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Rename Input Command\n");
            err = TestRenameInputCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentMediaInput)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_0(mediaInputList);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t currentMediaInput)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_2(currentMediaInput);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeMediaInputList_0()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeMediaInputList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)
    {
        auto iter = mediaInputList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(mediaInputList)>("mediaInputList", iter, 0));
        VerifyOrReturn(CheckValue<>("mediaInputList[0].index", iter.GetValue().index, 1));
        VerifyOrReturn(CheckValue<>("mediaInputList[0].inputType", iter.GetValue().inputType, 4));
        VerifyOrReturn(CheckValueAsString("mediaInputList[0].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckValueAsString("mediaInputList[0].description", iter.GetValue().description, "exampleDescription"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(mediaInputList)>("mediaInputList", iter, 1));
        VerifyOrReturn(CheckValue<>("mediaInputList[1].index", iter.GetValue().index, 2));
        VerifyOrReturn(CheckValue<>("mediaInputList[1].inputType", iter.GetValue().inputType, 4));
        VerifyOrReturn(CheckValueAsString("mediaInputList[1].name", iter.GetValue().name, "exampleName"));
        VerifyOrReturn(CheckValueAsString("mediaInputList[1].description", iter.GetValue().description, "exampleDescription"));
        VerifyOrReturn(CheckNoMoreListItems<decltype(mediaInputList)>("mediaInputList", iter, 2));
        NextTest();
    }

    CHIP_ERROR TestSelectInputCommand_1()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::MediaInput::Commands::SelectInput::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::MediaInput::Commands::SelectInput::Type request;
        request.index = 1;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadCurrentInputList_2()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentMediaInput(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t currentMediaInput)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentMediaInput", currentMediaInput, 1));
        NextTest();
    }

    CHIP_ERROR TestHideInputStatusCommand_3()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestShowInputStatusCommand_4()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestRenameInputCommand_5()
    {
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::MediaInput::Commands::RenameInput::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::MediaInput::Commands::RenameInput::Type request;
        request.index = 1;
        request.name  = chip::Span<const char>("newName", strlen("newName"));

        auto success = [](void * context, const responseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }
};

class TestCluster : public TestCommand
{
public:
    TestCluster() : TestCommand("TestCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Test Command\n");
            err = TestSendTestCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Not Handled Command\n");
            err = TestSendTestNotHandledCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Specific Command\n");
            err = TestSendTestSpecificCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send failing Test Add Arguments Command\n");
            err = TestSendFailingTestAddArgumentsCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write attribute BOOLEAN True\n");
            err = TestWriteAttributeBooleanTrue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute BOOLEAN True\n");
            err = TestReadAttributeBooleanTrue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write attribute BOOLEAN False\n");
            err = TestWriteAttributeBooleanFalse_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write attribute BITMAP8 Max Value\n");
            err = TestWriteAttributeBitmap8MaxValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read attribute BITMAP8 Max Value\n");
            err = TestReadAttributeBitmap8MaxValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Write attribute BITMAP8 Min Value\n");
            err = TestWriteAttributeBitmap8MinValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read attribute BITMAP8 Min Value\n");
            err = TestReadAttributeBitmap8MinValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Write attribute BITMAP16 Max Value\n");
            err = TestWriteAttributeBitmap16MaxValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read attribute BITMAP16 Max Value\n");
            err = TestReadAttributeBitmap16MaxValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Write attribute BITMAP16 Min Value\n");
            err = TestWriteAttributeBitmap16MinValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute BITMAP16 Min Value\n");
            err = TestReadAttributeBitmap16MinValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write attribute BITMAP32 Max Value\n");
            err = TestWriteAttributeBitmap32MaxValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read attribute BITMAP32 Max Value\n");
            err = TestReadAttributeBitmap32MaxValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Write attribute BITMAP32 Min Value\n");
            err = TestWriteAttributeBitmap32MinValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read attribute BITMAP32 Min Value\n");
            err = TestReadAttributeBitmap32MinValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Write attribute BITMAP64 Max Value\n");
            err = TestWriteAttributeBitmap64MaxValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read attribute BITMAP64 Max Value\n");
            err = TestReadAttributeBitmap64MaxValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Write attribute BITMAP64 Min Value\n");
            err = TestWriteAttributeBitmap64MinValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read attribute BITMAP64 Min Value\n");
            err = TestReadAttributeBitmap64MinValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Write attribute INT8U Max Value\n");
            err = TestWriteAttributeInt8uMaxValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read attribute INT8U Max Value\n");
            err = TestReadAttributeInt8uMaxValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Write attribute INT8U Min Value\n");
            err = TestWriteAttributeInt8uMinValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read attribute INT8U Min Value\n");
            err = TestReadAttributeInt8uMinValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Write attribute INT16U Max Value\n");
            err = TestWriteAttributeInt16uMaxValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read attribute INT16U Max Value\n");
            err = TestReadAttributeInt16uMaxValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Write attribute INT16U Min Value\n");
            err = TestWriteAttributeInt16uMinValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read attribute INT16U Min Value\n");
            err = TestReadAttributeInt16uMinValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Write attribute INT32U Max Value\n");
            err = TestWriteAttributeInt32uMaxValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Read attribute INT32U Max Value\n");
            err = TestReadAttributeInt32uMaxValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Write attribute INT32U Min Value\n");
            err = TestWriteAttributeInt32uMinValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read attribute INT32U Min Value\n");
            err = TestReadAttributeInt32uMinValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Write attribute INT64U Max Value\n");
            err = TestWriteAttributeInt64uMaxValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Read attribute INT64U Max Value\n");
            err = TestReadAttributeInt64uMaxValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Write attribute INT64U Min Value\n");
            err = TestWriteAttributeInt64uMinValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read attribute INT64U Min Value\n");
            err = TestReadAttributeInt64uMinValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Write attribute INT8S Max Value\n");
            err = TestWriteAttributeInt8sMaxValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Read attribute INT8S Max Value\n");
            err = TestReadAttributeInt8sMaxValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Write attribute INT8S Min Value\n");
            err = TestWriteAttributeInt8sMinValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Read attribute INT8S Min Value\n");
            err = TestReadAttributeInt8sMinValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Write attribute INT16S Max Value\n");
            err = TestWriteAttributeInt16sMaxValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read attribute INT16S Max Value\n");
            err = TestReadAttributeInt16sMaxValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Write attribute INT16S Min Value\n");
            err = TestWriteAttributeInt16sMinValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Read attribute INT16S Min Value\n");
            err = TestReadAttributeInt16sMinValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write attribute INT32S Max Value\n");
            err = TestWriteAttributeInt32sMaxValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read attribute INT32S Max Value\n");
            err = TestReadAttributeInt32sMaxValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write attribute INT32S Min Value\n");
            err = TestWriteAttributeInt32sMinValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read attribute INT32S Min Value\n");
            err = TestReadAttributeInt32sMinValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Write attribute INT64S Max Value\n");
            err = TestWriteAttributeInt64sMaxValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read attribute INT64S Max Value\n");
            err = TestReadAttributeInt64sMaxValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Write attribute INT64S Min Value\n");
            err = TestWriteAttributeInt64sMinValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Read attribute INT64S Min Value\n");
            err = TestReadAttributeInt64sMinValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Write attribute ENUM8 Max Value\n");
            err = TestWriteAttributeEnum8MaxValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Read attribute ENUM8 Max Value\n");
            err = TestReadAttributeEnum8MaxValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Write attribute ENUM8 Min Value\n");
            err = TestWriteAttributeEnum8MinValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read attribute ENUM8 Min Value\n");
            err = TestReadAttributeEnum8MinValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write attribute ENUM16 Max Value\n");
            err = TestWriteAttributeEnum16MaxValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read attribute ENUM16 Max Value\n");
            err = TestReadAttributeEnum16MaxValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Write attribute ENUM16 Min Value\n");
            err = TestWriteAttributeEnum16MinValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read attribute ENUM16 Min Value\n");
            err = TestReadAttributeEnum16MinValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute OCTET_STRING Default Value\n");
            err = TestReadAttributeOctetStringDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute LONG_OCTET_STRING Default Value\n");
            err = TestReadAttributeLongOctetStringDefaultValue_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read attribute LONG_OCTET_STRING\n");
            err = TestReadAttributeLongOctetString_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Read attribute CHAR_STRING Default Value\n");
            err = TestReadAttributeCharStringDefaultValue_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Write attribute CHAR_STRING\n");
            err = TestWriteAttributeCharString_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Write attribute CHAR_STRING - Value too long\n");
            err = TestWriteAttributeCharStringValueTooLong_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write attribute CHAR_STRING - Empty\n");
            err = TestWriteAttributeCharStringEmpty_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute LONG_CHAR_STRING Default Value\n");
            err = TestReadAttributeLongCharStringDefaultValue_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read attribute LONG_CHAR_STRING\n");
            err = TestReadAttributeLongCharString_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read attribute LIST\n");
            err = TestReadAttributeList_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read attribute LIST_OCTET_STRING\n");
            err = TestReadAttributeListOctetString_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Read attribute LIST_STRUCT_OCTET_STRING\n");
            err = TestReadAttributeListStructOctetString_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Write attribute EPOCH_US Max Value\n");
            err = TestWriteAttributeEpochUsMaxValue_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read attribute EPOCH_US Max Value\n");
            err = TestReadAttributeEpochUsMaxValue_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Write attribute EPOCH_US Min Value\n");
            err = TestWriteAttributeEpochUsMinValue_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read attribute EPOCH_US Min Value\n");
            err = TestReadAttributeEpochUsMinValue_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Write attribute EPOCH_S Max Value\n");
            err = TestWriteAttributeEpochSMaxValue_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Read attribute EPOCH_S Max Value\n");
            err = TestReadAttributeEpochSMaxValue_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Write attribute EPOCH_S Min Value\n");
            err = TestWriteAttributeEpochSMinValue_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Read attribute EPOCH_S Min Value\n");
            err = TestReadAttributeEpochSMinValue_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Read attribute UNSUPPORTED\n");
            err = TestReadAttributeUnsupported_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Writeattribute UNSUPPORTED\n");
            err = TestWriteattributeUnsupported_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Send Test Command to unsupported endpoint\n");
            err = TestSendTestCommandToUnsupportedEndpoint_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Write attribute vendor_id\n");
            err = TestWriteAttributeVendorId_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Read attribute vendor_id\n");
            err = TestReadAttributeVendorId_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Restore attribute vendor_id\n");
            err = TestRestoreAttributeVendorId_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Send a command with a vendor_id and enum\n");
            err = TestSendACommandWithAVendorIdAndEnum_126();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 127;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_5{ OnFailureCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, bool boolean)> mOnSuccessCallback_5{ OnSuccessCallback_5, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_7{ OnFailureCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, bool boolean)> mOnSuccessCallback_7{ OnSuccessCallback_7, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_9{ OnFailureCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, bool boolean)> mOnSuccessCallback_9{ OnSuccessCallback_9, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_10{ OnFailureCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t bitmap8)> mOnSuccessCallback_10{ OnSuccessCallback_10, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_12{ OnFailureCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t bitmap8)> mOnSuccessCallback_12{ OnSuccessCallback_12, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_14{ OnFailureCallback_14, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t bitmap8)> mOnSuccessCallback_14{ OnSuccessCallback_14, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_15{ OnFailureCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t bitmap16)> mOnSuccessCallback_15{ OnSuccessCallback_15, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_17{ OnFailureCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t bitmap16)> mOnSuccessCallback_17{ OnSuccessCallback_17, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_19{ OnFailureCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t bitmap16)> mOnSuccessCallback_19{ OnSuccessCallback_19, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_20{ OnFailureCallback_20, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t bitmap32)> mOnSuccessCallback_20{ OnSuccessCallback_20, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_22{ OnFailureCallback_22, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t bitmap32)> mOnSuccessCallback_22{ OnSuccessCallback_22, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_24{ OnFailureCallback_24, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t bitmap32)> mOnSuccessCallback_24{ OnSuccessCallback_24, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_25{ OnFailureCallback_25, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t bitmap64)> mOnSuccessCallback_25{ OnSuccessCallback_25, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_27{ OnFailureCallback_27, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t bitmap64)> mOnSuccessCallback_27{ OnSuccessCallback_27, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_29{ OnFailureCallback_29, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t bitmap64)> mOnSuccessCallback_29{ OnSuccessCallback_29, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_30{ OnFailureCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t int8u)> mOnSuccessCallback_30{ OnSuccessCallback_30, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_32{ OnFailureCallback_32, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t int8u)> mOnSuccessCallback_32{ OnSuccessCallback_32, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_34{ OnFailureCallback_34, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t int8u)> mOnSuccessCallback_34{ OnSuccessCallback_34, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_35{ OnFailureCallback_35, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t int16u)> mOnSuccessCallback_35{ OnSuccessCallback_35, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_37{ OnFailureCallback_37, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t int16u)> mOnSuccessCallback_37{ OnSuccessCallback_37, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_39{ OnFailureCallback_39, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t int16u)> mOnSuccessCallback_39{ OnSuccessCallback_39, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_40{ OnFailureCallback_40, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_40{ OnSuccessCallback_40, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_42{ OnFailureCallback_42, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_42{ OnSuccessCallback_42, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_44{ OnFailureCallback_44, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_44{ OnSuccessCallback_44, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_45{ OnFailureCallback_45, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t int64u)> mOnSuccessCallback_45{ OnSuccessCallback_45, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_47{ OnFailureCallback_47, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t int64u)> mOnSuccessCallback_47{ OnSuccessCallback_47, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_49{ OnFailureCallback_49, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t int64u)> mOnSuccessCallback_49{ OnSuccessCallback_49, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_50{ OnFailureCallback_50, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_50{ OnSuccessCallback_50, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_52{ OnFailureCallback_52, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_52{ OnSuccessCallback_52, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_54{ OnFailureCallback_54, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_54{ OnSuccessCallback_54, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_56{ OnFailureCallback_56, this };
    chip::Callback::Callback<void (*)(void * context, int8_t int8s)> mOnSuccessCallback_56{ OnSuccessCallback_56, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_57{ OnFailureCallback_57, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_57{ OnSuccessCallback_57, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_59{ OnFailureCallback_59, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_59{ OnSuccessCallback_59, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_61{ OnFailureCallback_61, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_61{ OnSuccessCallback_61, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_63{ OnFailureCallback_63, this };
    chip::Callback::Callback<void (*)(void * context, int16_t int16s)> mOnSuccessCallback_63{ OnSuccessCallback_63, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_64{ OnFailureCallback_64, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_64{ OnSuccessCallback_64, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_66{ OnFailureCallback_66, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_66{ OnSuccessCallback_66, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_68{ OnFailureCallback_68, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_68{ OnSuccessCallback_68, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_70{ OnFailureCallback_70, this };
    chip::Callback::Callback<void (*)(void * context, int32_t int32s)> mOnSuccessCallback_70{ OnSuccessCallback_70, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_71{ OnFailureCallback_71, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_71{ OnSuccessCallback_71, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_73{ OnFailureCallback_73, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_73{ OnSuccessCallback_73, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_75{ OnFailureCallback_75, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_75{ OnSuccessCallback_75, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_77{ OnFailureCallback_77, this };
    chip::Callback::Callback<void (*)(void * context, int64_t int64s)> mOnSuccessCallback_77{ OnSuccessCallback_77, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_78{ OnFailureCallback_78, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enum8)> mOnSuccessCallback_78{ OnSuccessCallback_78, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_80{ OnFailureCallback_80, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enum8)> mOnSuccessCallback_80{ OnSuccessCallback_80, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_82{ OnFailureCallback_82, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t enum8)> mOnSuccessCallback_82{ OnSuccessCallback_82, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_83{ OnFailureCallback_83, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enum16)> mOnSuccessCallback_83{ OnSuccessCallback_83, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_85{ OnFailureCallback_85, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enum16)> mOnSuccessCallback_85{ OnSuccessCallback_85, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_87{ OnFailureCallback_87, this };
    chip::Callback::Callback<void (*)(void * context, uint16_t enum16)> mOnSuccessCallback_87{ OnSuccessCallback_87, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_88{ OnFailureCallback_88, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_88{ OnSuccessCallback_88,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_90{ OnFailureCallback_90, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_90{ OnSuccessCallback_90,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_92{ OnFailureCallback_92, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan octetString)> mOnSuccessCallback_92{ OnSuccessCallback_92,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_94{ OnFailureCallback_94, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan longOctetString)> mOnSuccessCallback_94{ OnSuccessCallback_94,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_96{ OnFailureCallback_96, this };
    chip::Callback::Callback<void (*)(void * context, chip::ByteSpan longOctetString)> mOnSuccessCallback_96{ OnSuccessCallback_96,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_98{ OnFailureCallback_98, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan charString)> mOnSuccessCallback_98{ OnSuccessCallback_98,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_102{ OnFailureCallback_102, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan longCharString)> mOnSuccessCallback_102{ OnSuccessCallback_102,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_104{ OnFailureCallback_104, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan longCharString)> mOnSuccessCallback_104{ OnSuccessCallback_104,
                                                                                                              this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_106{ OnFailureCallback_106, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)>
        mOnSuccessCallback_106{ OnSuccessCallback_106, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_107{ OnFailureCallback_107, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)>
        mOnSuccessCallback_107{ OnSuccessCallback_107, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_108{ OnFailureCallback_108, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)>
        mOnSuccessCallback_108{ OnSuccessCallback_108, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_109{ OnFailureCallback_109, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t epochUs)> mOnSuccessCallback_109{ OnSuccessCallback_109, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_111{ OnFailureCallback_111, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t epochUs)> mOnSuccessCallback_111{ OnSuccessCallback_111, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_113{ OnFailureCallback_113, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t epochUs)> mOnSuccessCallback_113{ OnSuccessCallback_113, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_114{ OnFailureCallback_114, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t epochS)> mOnSuccessCallback_114{ OnSuccessCallback_114, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_116{ OnFailureCallback_116, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t epochS)> mOnSuccessCallback_116{ OnSuccessCallback_116, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_118{ OnFailureCallback_118, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t epochS)> mOnSuccessCallback_118{ OnSuccessCallback_118, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_119{ OnFailureCallback_119, this };
    chip::Callback::Callback<void (*)(void * context, bool unsupported)> mOnSuccessCallback_119{ OnSuccessCallback_119, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_122{ OnFailureCallback_122, this };
    chip::Callback::Callback<void (*)(void * context, chip::VendorId vendorId)> mOnSuccessCallback_122{ OnSuccessCallback_122,
                                                                                                        this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_124{ OnFailureCallback_124, this };
    chip::Callback::Callback<void (*)(void * context, chip::VendorId vendorId)> mOnSuccessCallback_124{ OnSuccessCallback_124,
                                                                                                        this };

    static void OnFailureCallback_5(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_5(status);
    }

    static void OnSuccessCallback_5(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_5(boolean);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_7(status);
    }

    static void OnSuccessCallback_7(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_7(boolean);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_9(status);
    }

    static void OnSuccessCallback_9(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_9(boolean);
    }

    static void OnFailureCallback_10(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_10(status);
    }

    static void OnSuccessCallback_10(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_10(bitmap8);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_12(status);
    }

    static void OnSuccessCallback_12(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_12(bitmap8);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_13(); }

    static void OnFailureCallback_14(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_14(status);
    }

    static void OnSuccessCallback_14(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_14(bitmap8);
    }

    static void OnFailureCallback_15(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_15(status);
    }

    static void OnSuccessCallback_15(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_15(bitmap16);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_16(); }

    static void OnFailureCallback_17(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_17(status);
    }

    static void OnSuccessCallback_17(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_17(bitmap16);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_18(); }

    static void OnFailureCallback_19(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_19(status);
    }

    static void OnSuccessCallback_19(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_19(bitmap16);
    }

    static void OnFailureCallback_20(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_20(status);
    }

    static void OnSuccessCallback_20(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_20(bitmap32);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_21(); }

    static void OnFailureCallback_22(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_22(status);
    }

    static void OnSuccessCallback_22(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_22(bitmap32);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_23(); }

    static void OnFailureCallback_24(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_24(status);
    }

    static void OnSuccessCallback_24(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_24(bitmap32);
    }

    static void OnFailureCallback_25(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_25(status);
    }

    static void OnSuccessCallback_25(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_25(bitmap64);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_26(); }

    static void OnFailureCallback_27(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_27(status);
    }

    static void OnSuccessCallback_27(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_27(bitmap64);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_28(); }

    static void OnFailureCallback_29(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_29(status);
    }

    static void OnSuccessCallback_29(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_29(bitmap64);
    }

    static void OnFailureCallback_30(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_30(status);
    }

    static void OnSuccessCallback_30(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_30(int8u);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_31(); }

    static void OnFailureCallback_32(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_32(status);
    }

    static void OnSuccessCallback_32(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_32(int8u);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_33(); }

    static void OnFailureCallback_34(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_34(status);
    }

    static void OnSuccessCallback_34(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_34(int8u);
    }

    static void OnFailureCallback_35(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_35(status);
    }

    static void OnSuccessCallback_35(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_35(int16u);
    }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_36(); }

    static void OnFailureCallback_37(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_37(status);
    }

    static void OnSuccessCallback_37(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_37(int16u);
    }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_38(); }

    static void OnFailureCallback_39(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_39(status);
    }

    static void OnSuccessCallback_39(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_39(int16u);
    }

    static void OnFailureCallback_40(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_40(status);
    }

    static void OnSuccessCallback_40(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_40(int32u);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_41(); }

    static void OnFailureCallback_42(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_42(status);
    }

    static void OnSuccessCallback_42(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_42(int32u);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_43(); }

    static void OnFailureCallback_44(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_44(status);
    }

    static void OnSuccessCallback_44(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_44(int32u);
    }

    static void OnFailureCallback_45(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_45(status);
    }

    static void OnSuccessCallback_45(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_45(int64u);
    }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_46(); }

    static void OnFailureCallback_47(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_47(status);
    }

    static void OnSuccessCallback_47(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_47(int64u);
    }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_48(); }

    static void OnFailureCallback_49(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_49(status);
    }

    static void OnSuccessCallback_49(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_49(int64u);
    }

    static void OnFailureCallback_50(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_50(status);
    }

    static void OnSuccessCallback_50(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_50(int8s);
    }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_51(); }

    static void OnFailureCallback_52(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_52(status);
    }

    static void OnSuccessCallback_52(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_52(int8s);
    }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_53(); }

    static void OnFailureCallback_54(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_54(status);
    }

    static void OnSuccessCallback_54(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_54(int8s);
    }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_55(); }

    static void OnFailureCallback_56(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_56(status);
    }

    static void OnSuccessCallback_56(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_56(int8s);
    }

    static void OnFailureCallback_57(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_57(status);
    }

    static void OnSuccessCallback_57(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_57(int16s);
    }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_58(); }

    static void OnFailureCallback_59(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_59(status);
    }

    static void OnSuccessCallback_59(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_59(int16s);
    }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_60(); }

    static void OnFailureCallback_61(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_61(status);
    }

    static void OnSuccessCallback_61(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_61(int16s);
    }

    static void OnFailureCallback_62(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_62(chip::to_underlying(status));
    }

    static void OnSuccessCallback_62(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_62(); }

    static void OnFailureCallback_63(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_63(status);
    }

    static void OnSuccessCallback_63(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_63(int16s);
    }

    static void OnFailureCallback_64(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_64(status);
    }

    static void OnSuccessCallback_64(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_64(int32s);
    }

    static void OnFailureCallback_65(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_65(chip::to_underlying(status));
    }

    static void OnSuccessCallback_65(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_65(); }

    static void OnFailureCallback_66(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_66(status);
    }

    static void OnSuccessCallback_66(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_66(int32s);
    }

    static void OnFailureCallback_67(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_67(chip::to_underlying(status));
    }

    static void OnSuccessCallback_67(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_67(); }

    static void OnFailureCallback_68(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_68(status);
    }

    static void OnSuccessCallback_68(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_68(int32s);
    }

    static void OnFailureCallback_69(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_69(chip::to_underlying(status));
    }

    static void OnSuccessCallback_69(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_69(); }

    static void OnFailureCallback_70(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_70(status);
    }

    static void OnSuccessCallback_70(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_70(int32s);
    }

    static void OnFailureCallback_71(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_71(status);
    }

    static void OnSuccessCallback_71(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_71(int64s);
    }

    static void OnFailureCallback_72(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_72(chip::to_underlying(status));
    }

    static void OnSuccessCallback_72(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_72(); }

    static void OnFailureCallback_73(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_73(status);
    }

    static void OnSuccessCallback_73(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_73(int64s);
    }

    static void OnFailureCallback_74(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_74(chip::to_underlying(status));
    }

    static void OnSuccessCallback_74(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_74(); }

    static void OnFailureCallback_75(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_75(status);
    }

    static void OnSuccessCallback_75(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_75(int64s);
    }

    static void OnFailureCallback_76(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_76(chip::to_underlying(status));
    }

    static void OnSuccessCallback_76(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_76(); }

    static void OnFailureCallback_77(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_77(status);
    }

    static void OnSuccessCallback_77(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_77(int64s);
    }

    static void OnFailureCallback_78(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_78(status);
    }

    static void OnSuccessCallback_78(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_78(enum8);
    }

    static void OnFailureCallback_79(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_79(chip::to_underlying(status));
    }

    static void OnSuccessCallback_79(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_79(); }

    static void OnFailureCallback_80(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_80(status);
    }

    static void OnSuccessCallback_80(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_80(enum8);
    }

    static void OnFailureCallback_81(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_81(chip::to_underlying(status));
    }

    static void OnSuccessCallback_81(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_81(); }

    static void OnFailureCallback_82(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_82(status);
    }

    static void OnSuccessCallback_82(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_82(enum8);
    }

    static void OnFailureCallback_83(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_83(status);
    }

    static void OnSuccessCallback_83(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_83(enum16);
    }

    static void OnFailureCallback_84(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_84(chip::to_underlying(status));
    }

    static void OnSuccessCallback_84(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_84(); }

    static void OnFailureCallback_85(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_85(status);
    }

    static void OnSuccessCallback_85(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_85(enum16);
    }

    static void OnFailureCallback_86(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_86(chip::to_underlying(status));
    }

    static void OnSuccessCallback_86(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_86(); }

    static void OnFailureCallback_87(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_87(status);
    }

    static void OnSuccessCallback_87(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_87(enum16);
    }

    static void OnFailureCallback_88(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_88(status);
    }

    static void OnSuccessCallback_88(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_88(octetString);
    }

    static void OnFailureCallback_89(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_89(chip::to_underlying(status));
    }

    static void OnSuccessCallback_89(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_89(); }

    static void OnFailureCallback_90(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_90(status);
    }

    static void OnSuccessCallback_90(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_90(octetString);
    }

    static void OnFailureCallback_91(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_91(chip::to_underlying(status));
    }

    static void OnSuccessCallback_91(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_91(); }

    static void OnFailureCallback_92(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_92(status);
    }

    static void OnSuccessCallback_92(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_92(octetString);
    }

    static void OnFailureCallback_93(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_93(chip::to_underlying(status));
    }

    static void OnSuccessCallback_93(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_93(); }

    static void OnFailureCallback_94(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_94(status);
    }

    static void OnSuccessCallback_94(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_94(longOctetString);
    }

    static void OnFailureCallback_95(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_95(chip::to_underlying(status));
    }

    static void OnSuccessCallback_95(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_95(); }

    static void OnFailureCallback_96(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_96(status);
    }

    static void OnSuccessCallback_96(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_96(longOctetString);
    }

    static void OnFailureCallback_97(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_97(chip::to_underlying(status));
    }

    static void OnSuccessCallback_97(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_97(); }

    static void OnFailureCallback_98(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_98(status);
    }

    static void OnSuccessCallback_98(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_98(charString);
    }

    static void OnFailureCallback_99(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_99(chip::to_underlying(status));
    }

    static void OnSuccessCallback_99(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_99(); }

    static void OnFailureCallback_100(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_100(chip::to_underlying(status));
    }

    static void OnSuccessCallback_100(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_100(); }

    static void OnFailureCallback_101(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_101(chip::to_underlying(status));
    }

    static void OnSuccessCallback_101(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_101(); }

    static void OnFailureCallback_102(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_102(status);
    }

    static void OnSuccessCallback_102(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_102(longCharString);
    }

    static void OnFailureCallback_103(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_103(chip::to_underlying(status));
    }

    static void OnSuccessCallback_103(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_103(); }

    static void OnFailureCallback_104(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_104(status);
    }

    static void OnSuccessCallback_104(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_104(longCharString);
    }

    static void OnFailureCallback_105(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_105(chip::to_underlying(status));
    }

    static void OnSuccessCallback_105(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_105(); }

    static void OnFailureCallback_106(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_106(status);
    }

    static void OnSuccessCallback_106(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_106(listInt8u);
    }

    static void OnFailureCallback_107(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_107(status);
    }

    static void OnSuccessCallback_107(void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_107(listOctetString);
    }

    static void OnFailureCallback_108(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_108(status);
    }

    static void OnSuccessCallback_108(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_108(listStructOctetString);
    }

    static void OnFailureCallback_109(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_109(status);
    }

    static void OnSuccessCallback_109(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_109(epochUs);
    }

    static void OnFailureCallback_110(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_110(chip::to_underlying(status));
    }

    static void OnSuccessCallback_110(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_110(); }

    static void OnFailureCallback_111(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_111(status);
    }

    static void OnSuccessCallback_111(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_111(epochUs);
    }

    static void OnFailureCallback_112(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_112(chip::to_underlying(status));
    }

    static void OnSuccessCallback_112(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_112(); }

    static void OnFailureCallback_113(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_113(status);
    }

    static void OnSuccessCallback_113(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_113(epochUs);
    }

    static void OnFailureCallback_114(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_114(status);
    }

    static void OnSuccessCallback_114(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_114(epochS);
    }

    static void OnFailureCallback_115(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_115(chip::to_underlying(status));
    }

    static void OnSuccessCallback_115(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_115(); }

    static void OnFailureCallback_116(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_116(status);
    }

    static void OnSuccessCallback_116(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_116(epochS);
    }

    static void OnFailureCallback_117(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_117(chip::to_underlying(status));
    }

    static void OnSuccessCallback_117(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_117(); }

    static void OnFailureCallback_118(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_118(status);
    }

    static void OnSuccessCallback_118(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_118(epochS);
    }

    static void OnFailureCallback_119(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_119(status);
    }

    static void OnSuccessCallback_119(void * context, bool unsupported)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_119(unsupported);
    }

    static void OnFailureCallback_120(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_120(chip::to_underlying(status));
    }

    static void OnSuccessCallback_120(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_120(); }

    static void OnFailureCallback_122(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_122(status);
    }

    static void OnSuccessCallback_122(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_122(vendorId);
    }

    static void OnFailureCallback_123(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_123(chip::to_underlying(status));
    }

    static void OnSuccessCallback_123(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_123(); }

    static void OnFailureCallback_124(void * context, uint8_t status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_124(status);
    }

    static void OnSuccessCallback_124(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_124(vendorId);
    }

    static void OnFailureCallback_125(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_125(chip::to_underlying(status));
    }

    static void OnSuccessCallback_125(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_125(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendTestCommand_0()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::Test::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::Test::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestSendTestNotHandledCommand_1()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestSpecificCommand_2()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestSpecific::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestSpecificResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestSpecific::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_2(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("returnValue", returnValue, 7));
        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_3()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_3(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("returnValue", returnValue, 20));
        NextTest();
    }

    CHIP_ERROR TestSendFailingTestAddArgumentsCommand_4()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type request;
        request.arg1 = 250;
        request.arg2 = 6;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_4(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4(uint8_t returnValue) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_5()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBoolean(mOnSuccessCallback_5.Cancel(), mOnFailureCallback_5.Cancel());
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanTrue_6()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool booleanArgument;
        booleanArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanTrue_7()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBoolean(mOnSuccessCallback_7.Cancel(), mOnFailureCallback_7.Cancel());
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 1));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanFalse_8()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool booleanArgument;
        booleanArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanFalse_9()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBoolean(mOnSuccessCallback_9.Cancel(), mOnFailureCallback_9.Cancel());
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_10()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap8(mOnSuccessCallback_10.Cancel(), mOnFailureCallback_10.Cancel());
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MaxValue_11()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t bitmap8Argument;
        bitmap8Argument = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MaxValue_12()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap8(mOnSuccessCallback_12.Cancel(), mOnFailureCallback_12.Cancel());
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MinValue_13()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t bitmap8Argument;
        bitmap8Argument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MinValue_14()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap8(mOnSuccessCallback_14.Cancel(), mOnFailureCallback_14.Cancel());
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_15()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap16(mOnSuccessCallback_15.Cancel(), mOnFailureCallback_15.Cancel());
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MaxValue_16()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t bitmap16Argument;
        bitmap16Argument = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MaxValue_17()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap16(mOnSuccessCallback_17.Cancel(), mOnFailureCallback_17.Cancel());
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MinValue_18()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t bitmap16Argument;
        bitmap16Argument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MinValue_19()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap16(mOnSuccessCallback_19.Cancel(), mOnFailureCallback_19.Cancel());
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_20()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap32(mOnSuccessCallback_20.Cancel(), mOnFailureCallback_20.Cancel());
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MaxValue_21()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t bitmap32Argument;
        bitmap32Argument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MaxValue_22()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap32(mOnSuccessCallback_22.Cancel(), mOnFailureCallback_22.Cancel());
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MinValue_23()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t bitmap32Argument;
        bitmap32Argument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MinValue_24()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap32(mOnSuccessCallback_24.Cancel(), mOnFailureCallback_24.Cancel());
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_25()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap64(mOnSuccessCallback_25.Cancel(), mOnFailureCallback_25.Cancel());
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MaxValue_26()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t bitmap64Argument;
        bitmap64Argument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MaxValue_27()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap64(mOnSuccessCallback_27.Cancel(), mOnFailureCallback_27.Cancel());
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MinValue_28()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t bitmap64Argument;
        bitmap64Argument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MinValue_29()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeBitmap64(mOnSuccessCallback_29.Cancel(), mOnFailureCallback_29.Cancel());
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_30()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8u(mOnSuccessCallback_30.Cancel(), mOnFailureCallback_30.Cancel());
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMaxValue_31()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t int8uArgument;
        int8uArgument = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMaxValue_32()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8u(mOnSuccessCallback_32.Cancel(), mOnFailureCallback_32.Cancel());
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMinValue_33()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t int8uArgument;
        int8uArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMinValue_34()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8u(mOnSuccessCallback_34.Cancel(), mOnFailureCallback_34.Cancel());
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_35()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16u(mOnSuccessCallback_35.Cancel(), mOnFailureCallback_35.Cancel());
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMaxValue_36()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t int16uArgument;
        int16uArgument = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMaxValue_37()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16u(mOnSuccessCallback_37.Cancel(), mOnFailureCallback_37.Cancel());
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMinValue_38()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t int16uArgument;
        int16uArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMinValue_39()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16u(mOnSuccessCallback_39.Cancel(), mOnFailureCallback_39.Cancel());
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_40()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_40.Cancel(), mOnFailureCallback_40.Cancel());
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMaxValue_41()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t int32uArgument;
        int32uArgument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMaxValue_42()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_42.Cancel(), mOnFailureCallback_42.Cancel());
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMinValue_43()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t int32uArgument;
        int32uArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMinValue_44()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_44.Cancel(), mOnFailureCallback_44.Cancel());
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_45()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64u(mOnSuccessCallback_45.Cancel(), mOnFailureCallback_45.Cancel());
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMaxValue_46()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t int64uArgument;
        int64uArgument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_46, OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMaxValue_47()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64u(mOnSuccessCallback_47.Cancel(), mOnFailureCallback_47.Cancel());
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMinValue_48()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t int64uArgument;
        int64uArgument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMinValue_49()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64u(mOnSuccessCallback_49.Cancel(), mOnFailureCallback_49.Cancel());
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_50()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8s(mOnSuccessCallback_50.Cancel(), mOnFailureCallback_50.Cancel());
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMaxValue_51()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int8_t int8sArgument;
        int8sArgument = 127;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_51, OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMaxValue_52()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8s(mOnSuccessCallback_52.Cancel(), mOnFailureCallback_52.Cancel());
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 127));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMinValue_53()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int8_t int8sArgument;
        int8sArgument = -128;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_53, OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMinValue_54()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8s(mOnSuccessCallback_54.Cancel(), mOnFailureCallback_54.Cancel());
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, -128));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_55()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int8_t int8sArgument;
        int8sArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_55, OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_56()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt8s(mOnSuccessCallback_56.Cancel(), mOnFailureCallback_56.Cancel());
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_57()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16s(mOnSuccessCallback_57.Cancel(), mOnFailureCallback_57.Cancel());
    }

    void OnFailureResponse_57(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_57(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMaxValue_58()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t int16sArgument;
        int16sArgument = 32767;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_58, OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMaxValue_59()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16s(mOnSuccessCallback_59.Cancel(), mOnFailureCallback_59.Cancel());
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 32767));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMinValue_60()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t int16sArgument;
        int16sArgument = -32768;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_60, OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_60() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMinValue_61()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16s(mOnSuccessCallback_61.Cancel(), mOnFailureCallback_61.Cancel());
    }

    void OnFailureResponse_61(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_61(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, -32768));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_62()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int16_t int16sArgument;
        int16sArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_62, OnFailureCallback_62);
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_63()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt16s(mOnSuccessCallback_63.Cancel(), mOnFailureCallback_63.Cancel());
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_64()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32s(mOnSuccessCallback_64.Cancel(), mOnFailureCallback_64.Cancel());
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 0L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMaxValue_65()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int32_t int32sArgument;
        int32sArgument = 2147483647L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_65, OnFailureCallback_65);
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMaxValue_66()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32s(mOnSuccessCallback_66.Cancel(), mOnFailureCallback_66.Cancel());
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 2147483647L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMinValue_67()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int32_t int32sArgument;
        int32sArgument = -2147483648L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_67, OnFailureCallback_67);
    }

    void OnFailureResponse_67(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_67() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMinValue_68()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32s(mOnSuccessCallback_68.Cancel(), mOnFailureCallback_68.Cancel());
    }

    void OnFailureResponse_68(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_68(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, -2147483648L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_69()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int32_t int32sArgument;
        int32sArgument = 0L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_69, OnFailureCallback_69);
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_70()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32s(mOnSuccessCallback_70.Cancel(), mOnFailureCallback_70.Cancel());
    }

    void OnFailureResponse_70(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_70(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 0L));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_71()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64s(mOnSuccessCallback_71.Cancel(), mOnFailureCallback_71.Cancel());
    }

    void OnFailureResponse_71(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_71(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 0LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMaxValue_72()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int64_t int64sArgument;
        int64sArgument = 9223372036854775807LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_72, OnFailureCallback_72);
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMaxValue_73()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64s(mOnSuccessCallback_73.Cancel(), mOnFailureCallback_73.Cancel());
    }

    void OnFailureResponse_73(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_73(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMinValue_74()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int64_t int64sArgument;
        int64sArgument = -9223372036854775807LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_74, OnFailureCallback_74);
    }

    void OnFailureResponse_74(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_74() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMinValue_75()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64s(mOnSuccessCallback_75.Cancel(), mOnFailureCallback_75.Cancel());
    }

    void OnFailureResponse_75(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_75(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, -9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_76()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        int64_t int64sArgument;
        int64sArgument = 0LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_76, OnFailureCallback_76);
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_77()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt64s(mOnSuccessCallback_77.Cancel(), mOnFailureCallback_77.Cancel());
    }

    void OnFailureResponse_77(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_77(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 0LL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_78()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum8(mOnSuccessCallback_78.Cancel(), mOnFailureCallback_78.Cancel());
    }

    void OnFailureResponse_78(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_78(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MaxValue_79()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t enum8Argument;
        enum8Argument = static_cast<uint8_t>(255);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_79, OnFailureCallback_79);
    }

    void OnFailureResponse_79(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_79() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MaxValue_80()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum8(mOnSuccessCallback_80.Cancel(), mOnFailureCallback_80.Cancel());
    }

    void OnFailureResponse_80(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_80(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MinValue_81()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint8_t enum8Argument;
        enum8Argument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_81, OnFailureCallback_81);
    }

    void OnFailureResponse_81(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_81() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MinValue_82()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum8(mOnSuccessCallback_82.Cancel(), mOnFailureCallback_82.Cancel());
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_83()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum16(mOnSuccessCallback_83.Cancel(), mOnFailureCallback_83.Cancel());
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MaxValue_84()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t enum16Argument;
        enum16Argument = static_cast<uint16_t>(65535);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_84, OnFailureCallback_84);
    }

    void OnFailureResponse_84(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_84() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MaxValue_85()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum16(mOnSuccessCallback_85.Cancel(), mOnFailureCallback_85.Cancel());
    }

    void OnFailureResponse_85(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_85(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MinValue_86()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t enum16Argument;
        enum16Argument = static_cast<uint16_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_86, OnFailureCallback_86);
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MinValue_87()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEnum16(mOnSuccessCallback_87.Cancel(), mOnFailureCallback_87.Cancel());
    }

    void OnFailureResponse_87(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_87(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValue_88()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOctetString(mOnSuccessCallback_88.Cancel(), mOnFailureCallback_88.Cancel());
    }

    void OnFailureResponse_88(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_88(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_89()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), strlen("TestValue"));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_89, OnFailureCallback_89);
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetString_90()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOctetString(mOnSuccessCallback_90.Cancel(), mOnFailureCallback_90.Cancel());
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, "TestValue"));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_91()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan octetStringArgument;
        octetStringArgument =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValueLongerThan10"), strlen("TestValueLongerThan10"));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_91, OnFailureCallback_91);
    }

    void OnFailureResponse_91(uint8_t status) { NextTest(); }

    void OnSuccessResponse_91() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeOctetString_92()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOctetString(mOnSuccessCallback_92.Cancel(), mOnFailureCallback_92.Cancel());
    }

    void OnFailureResponse_92(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_92(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, "TestValue"));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_93()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char(""), strlen(""));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_93, OnFailureCallback_93);
    }

    void OnFailureResponse_93(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_93() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetStringDefaultValue_94()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeLongOctetString(mOnSuccessCallback_94.Cancel(), mOnFailureCallback_94.Cancel());
    }

    void OnFailureResponse_94(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_94(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString("longOctetString", longOctetString, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_95()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan longOctetStringArgument;
        longOctetStringArgument = chip::ByteSpan(
            chip::Uint8::from_const_char(
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111"),
            strlen("111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                   "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                   "111111111111111111111111111111111111111111111111111111111111111111111111111111"));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            longOctetStringArgument, this, OnSuccessCallback_95, OnFailureCallback_95);
    }

    void OnFailureResponse_95(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_95() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetString_96()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeLongOctetString(mOnSuccessCallback_96.Cancel(), mOnFailureCallback_96.Cancel());
    }

    void OnFailureResponse_96(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_96(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longOctetString", longOctetString,
            "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
            "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
            "1111111111111111111111111111111111111111111111111111111111111111"));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_97()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::ByteSpan longOctetStringArgument;
        longOctetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char(""), strlen(""));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            longOctetStringArgument, this, OnSuccessCallback_97, OnFailureCallback_97);
    }

    void OnFailureResponse_97(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_97() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringDefaultValue_98()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCharString(mOnSuccessCallback_98.Cancel(), mOnFailureCallback_98.Cancel());
    }

    void OnFailureResponse_98(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_98(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharString_99()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("☉T☉", strlen("☉T☉"));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_99, OnFailureCallback_99);
    }

    void OnFailureResponse_99(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_99() { NextTest(); }

    CHIP_ERROR TestWriteAttributeCharStringValueTooLong_100()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("☉TestValueLongerThan10☉", strlen("☉TestValueLongerThan10☉"));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_100, OnFailureCallback_100);
    }

    void OnFailureResponse_100(uint8_t status) { NextTest(); }

    void OnSuccessResponse_100() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteAttributeCharStringEmpty_101()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("", strlen(""));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_101, OnFailureCallback_101);
    }

    void OnFailureResponse_101(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_101() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharStringDefaultValue_102()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeLongCharString(mOnSuccessCallback_102.Cancel(), mOnFailureCallback_102.Cancel());
    }

    void OnFailureResponse_102(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_102(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString("longCharString", longCharString, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_103()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::CharSpan longCharStringArgument;
        longCharStringArgument = chip::Span<const char>(
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉",
            strlen("☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
                   "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
                   "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            longCharStringArgument, this, OnSuccessCallback_103, OnFailureCallback_103);
    }

    void OnFailureResponse_103(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_103() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharString_104()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeLongCharString(mOnSuccessCallback_104.Cancel(), mOnFailureCallback_104.Cancel());
    }

    void OnFailureResponse_104(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_104(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longCharString", longCharString,
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"
            "☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉☉"));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_105()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::CharSpan longCharStringArgument;
        longCharStringArgument = chip::Span<const char>("", strlen(""));

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            longCharStringArgument, this, OnSuccessCallback_105, OnFailureCallback_105);
    }

    void OnFailureResponse_105(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_105() { NextTest(); }

    CHIP_ERROR TestReadAttributeList_106()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeListInt8u(mOnSuccessCallback_106.Cancel(), mOnFailureCallback_106.Cancel());
    }

    void OnFailureResponse_106(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_106(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        auto iter = listInt8u.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 0));
        VerifyOrReturn(CheckValue<uint8_t>("listInt8u[0]", iter.GetValue(), 1));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 1));
        VerifyOrReturn(CheckValue<uint8_t>("listInt8u[1]", iter.GetValue(), 2));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 2));
        VerifyOrReturn(CheckValue<uint8_t>("listInt8u[2]", iter.GetValue(), 3));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 3));
        VerifyOrReturn(CheckValue<uint8_t>("listInt8u[3]", iter.GetValue(), 4));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listInt8u)>("listInt8u", iter, 4));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeListOctetString_107()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeListOctetString(mOnSuccessCallback_107.Cancel(), mOnFailureCallback_107.Cancel());
    }

    void OnFailureResponse_107(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_107(const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        auto iter = listOctetString.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 0));
        VerifyOrReturn(CheckValueAsString("listOctetString[0]", iter.GetValue(), "Test0"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 1));
        VerifyOrReturn(CheckValueAsString("listOctetString[1]", iter.GetValue(), "Test1"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 2));
        VerifyOrReturn(CheckValueAsString("listOctetString[2]", iter.GetValue(), "Test2"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 3));
        VerifyOrReturn(CheckValueAsString("listOctetString[3]", iter.GetValue(), "Test3"));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listOctetString)>("listOctetString", iter, 4));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeListStructOctetString_108()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeListStructOctetString(mOnSuccessCallback_108.Cancel(), mOnFailureCallback_108.Cancel());
    }

    void OnFailureResponse_108(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_108(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        auto iter = listStructOctetString.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 0));
        VerifyOrReturn(CheckValue<>("listStructOctetString[0].fabricIndex", iter.GetValue().fabricIndex, 0ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[0].operationalCert", iter.GetValue().operationalCert, "Test0"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 1));
        VerifyOrReturn(CheckValue<>("listStructOctetString[1].fabricIndex", iter.GetValue().fabricIndex, 1ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[1].operationalCert", iter.GetValue().operationalCert, "Test1"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 2));
        VerifyOrReturn(CheckValue<>("listStructOctetString[2].fabricIndex", iter.GetValue().fabricIndex, 2ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[2].operationalCert", iter.GetValue().operationalCert, "Test2"));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 3));
        VerifyOrReturn(CheckValue<>("listStructOctetString[3].fabricIndex", iter.GetValue().fabricIndex, 3ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[3].operationalCert", iter.GetValue().operationalCert, "Test3"));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listStructOctetString)>("listStructOctetString", iter, 4));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_109()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochUs(mOnSuccessCallback_109.Cancel(), mOnFailureCallback_109.Cancel());
    }

    void OnFailureResponse_109(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_109(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMaxValue_110()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t epochUsArgument;
        epochUsArgument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_110, OnFailureCallback_110);
    }

    void OnFailureResponse_110(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_110() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMaxValue_111()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochUs(mOnSuccessCallback_111.Cancel(), mOnFailureCallback_111.Cancel());
    }

    void OnFailureResponse_111(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_111(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMinValue_112()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint64_t epochUsArgument;
        epochUsArgument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_112, OnFailureCallback_112);
    }

    void OnFailureResponse_112(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_112() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMinValue_113()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochUs(mOnSuccessCallback_113.Cancel(), mOnFailureCallback_113.Cancel());
    }

    void OnFailureResponse_113(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_113(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_114()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochS(mOnSuccessCallback_114.Cancel(), mOnFailureCallback_114.Cancel());
    }

    void OnFailureResponse_114(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_114(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMaxValue_115()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t epochSArgument;
        epochSArgument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_115, OnFailureCallback_115);
    }

    void OnFailureResponse_115(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_115() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMaxValue_116()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochS(mOnSuccessCallback_116.Cancel(), mOnFailureCallback_116.Cancel());
    }

    void OnFailureResponse_116(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_116(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMinValue_117()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t epochSArgument;
        epochSArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_117, OnFailureCallback_117);
    }

    void OnFailureResponse_117(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_117() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMinValue_118()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeEpochS(mOnSuccessCallback_118.Cancel(), mOnFailureCallback_118.Cancel());
    }

    void OnFailureResponse_118(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_118(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeUnsupported_119()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeUnsupported(mOnSuccessCallback_119.Cancel(), mOnFailureCallback_119.Cancel());
    }

    void OnFailureResponse_119(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_119(bool unsupported)
    {
        VerifyOrReturn(CheckValue<bool>("unsupported", unsupported, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteattributeUnsupported_120()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        bool unsupportedArgument;
        unsupportedArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo>(
            unsupportedArgument, this, OnSuccessCallback_120, OnFailureCallback_120);
    }

    void OnFailureResponse_120(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_120() { NextTest(); }

    CHIP_ERROR TestSendTestCommandToUnsupportedEndpoint_121()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 200);

        using requestType  = chip::app::Clusters::TestCluster::Commands::Test::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::TestCluster::Commands::Test::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_121();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_121(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_121(uint8_t status) { NextTest(); }

    void OnSuccessResponse_121() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_122()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeVendorId(mOnSuccessCallback_122.Cancel(), mOnFailureCallback_122.Cancel());
    }

    void OnFailureResponse_122(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_122(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue<chip::VendorId>("vendorId", vendorId, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeVendorId_123()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(17);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_123, OnFailureCallback_123);
    }

    void OnFailureResponse_123(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_123() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorId_124()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeVendorId(mOnSuccessCallback_124.Cancel(), mOnFailureCallback_124.Cancel());
    }

    void OnFailureResponse_124(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_124(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue<chip::VendorId>("vendorId", vendorId, 17U));
        NextTest();
    }

    CHIP_ERROR TestRestoreAttributeVendorId_125()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_125, OnFailureCallback_125);
    }

    void OnFailureResponse_125(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_125() { NextTest(); }

    CHIP_ERROR TestSendACommandWithAVendorIdAndEnum_126()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestEnumsResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type request;
        request.arg1 = static_cast<chip::VendorId>(20003);
        request.arg2 = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(101);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_126(data.arg1, data.arg2);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_126(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_126(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_126(chip::VendorId arg1, chip::app::Clusters::TestCluster::SimpleEnum arg2)
    {
        VerifyOrReturn(CheckValue<chip::VendorId>("arg1", arg1, 20003U));

        VerifyOrReturn(CheckValue<uint8_t>("arg2", arg2, 101));
        NextTest();
    }
};

class TestClusterComplexTypes : public TestCommand
{
public:
    TestClusterComplexTypes() : TestCommand("TestClusterComplexTypes"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestClusterComplexTypes\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestClusterComplexTypes\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Test Command With Struct Argument and arg1.b is true\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsTrue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Command With Struct Argument and arg1.b is false\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsFalse_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Command With List of INT8U and none of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Command With List of INT8U and one of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Test Command With List of INT8U and get it reversed\n");
            err = TestSendTestCommandWithListOfInt8uAndGetItReversed_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Send Test Command With empty List of INT8U and get an empty list back\n");
            err = TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool, " ***** Test Step 6 : Send Test Command With List of Struct Argument and arg1.b of first item is true\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 7 : Send Test Command With List of Struct Argument and arg1.b of first item is false\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Send Test Command with optional arg set.\n");
            err = TestSendTestCommandWithOptionalArgSet_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Send Test Command without its optional arg.\n");
            err = TestSendTestCommandWithoutItsOptionalArg_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Send Test Command with optional arg set to null.\n");
            err = TestSendTestCommandWithOptionalArgSetToNull_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsTrue_0()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type request;

        request.arg1.a = 0;
        request.arg1.b = true;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_string"), strlen("octet_string"));
        request.arg1.e = chip::Span<const char>("char_string", strlen("char_string"));
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_0(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, true));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsFalse_1()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type request;

        request.arg1.a = 0;
        request.arg1.b = false;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_string"), strlen("octet_string"));
        request.arg1.e = chip::Span<const char>("char_string", strlen("char_string"));
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_1(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_1(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, false));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_2()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type request;

        uint8_t arg1List[9];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_2(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_2(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, true));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_3()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type request;

        uint8_t arg1List[10];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        arg1List[9]  = 0;
        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_3(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, false));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndGetItReversed_4()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type request;

        uint8_t arg1List[9];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_4(data.arg1);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_4(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        auto iter = arg1.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 0));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[0]", iter.GetValue(), 9));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 1));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[1]", iter.GetValue(), 8));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 2));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[2]", iter.GetValue(), 7));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 3));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[3]", iter.GetValue(), 6));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 4));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[4]", iter.GetValue(), 5));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 5));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[5]", iter.GetValue(), 4));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 6));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[6]", iter.GetValue(), 3));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 7));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[7]", iter.GetValue(), 2));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 8));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[8]", iter.GetValue(), 1));
        VerifyOrReturn(CheckNoMoreListItems<decltype(arg1)>("arg1", iter, 9));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_5()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type request;

        request.arg1 = chip::app::DataModel::List<uint8_t>();

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_5(data.arg1);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        auto iter = arg1.begin();
        VerifyOrReturn(CheckNoMoreListItems<decltype(arg1)>("arg1", iter, 0));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_6()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type request;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type arg1List[2];

        arg1List[0].a = 0;
        arg1List[0].b = true;
        arg1List[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[0].d = chip::ByteSpan(chip::Uint8::from_const_char("first_octet_string"), strlen("first_octet_string"));
        arg1List[0].e = chip::Span<const char>("first_char_string", strlen("first_char_string"));
        arg1List[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        arg1List[1].a = 1;
        arg1List[1].b = true;
        arg1List[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        arg1List[1].d = chip::ByteSpan(chip::Uint8::from_const_char("second_octet_string"), strlen("second_octet_string"));
        arg1List[1].e = chip::Span<const char>("second_char_string", strlen("second_char_string"));
        arg1List[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_6(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_6(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, true));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_7()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type request;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type arg1List[2];

        arg1List[0].a = 1;
        arg1List[0].b = true;
        arg1List[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        arg1List[0].d = chip::ByteSpan(chip::Uint8::from_const_char("second_octet_string"), strlen("second_octet_string"));
        arg1List[0].e = chip::Span<const char>("second_char_string", strlen("second_char_string"));
        arg1List[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        arg1List[1].a = 0;
        arg1List[1].b = false;
        arg1List[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[1].d = chip::ByteSpan(chip::Uint8::from_const_char("first_octet_string"), strlen("first_octet_string"));
        arg1List[1].e = chip::Span<const char>("first_char_string", strlen("first_char_string"));
        arg1List[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        request.arg1 = arg1List;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_7(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, false));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithOptionalArgSet_8()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type request;
        request.arg1.Emplace().SetNonNull() = 5;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))
                ->OnSuccessResponse_8(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_8(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                             const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue<bool>("wasPresent", wasPresent, true));

        VerifyOrReturn(CheckValuePresent("wasNull", wasNull));
        VerifyOrReturn(CheckValue<bool>("wasNull.Value()", wasNull.Value(), false));

        VerifyOrReturn(CheckValuePresent("value", value));
        VerifyOrReturn(CheckValue<uint8_t>("value.Value()", value.Value(), 5));

        VerifyOrReturn(CheckValuePresent("originalValue", originalValue));
        VerifyOrReturn(CheckValueNonNull("originalValue.Value()", originalValue.Value()));
        VerifyOrReturn(CheckValue<uint8_t>("originalValue.Value().Value()", originalValue.Value().Value(), 5));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithoutItsOptionalArg_9()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))
                ->OnSuccessResponse_9(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_9(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                             const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue<bool>("wasPresent", wasPresent, false));

        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithOptionalArgSetToNull_10()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;
        using responseType = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType;

        chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type request;
        request.arg1.Emplace().SetNull();

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))
                ->OnSuccessResponse_10(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_10(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                              const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue<bool>("wasPresent", wasPresent, true));

        VerifyOrReturn(CheckValuePresent("wasNull", wasNull));
        VerifyOrReturn(CheckValue<bool>("wasNull.Value()", wasNull.Value(), true));

        VerifyOrReturn(CheckValuePresent("originalValue", originalValue));
        VerifyOrReturn(CheckValueNull("originalValue.Value()", originalValue.Value()));
        NextTest();
    }
};

class TestConstraints : public TestCommand
{
public:
    TestConstraints() : TestCommand("TestConstraints"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestConstraints\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestConstraints\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Write attribute INT32U Value\n");
            err = TestWriteAttributeInt32uValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute INT32U Value MinValue Constraints\n");
            err = TestReadAttributeInt32uValueMinValueConstraints_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute INT32U Value MaxValue Constraints\n");
            err = TestReadAttributeInt32uValueMaxValueConstraints_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute INT32U Value NotValue Constraints\n");
            err = TestReadAttributeInt32uValueNotValueConstraints_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, uint32_t int32u)> mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<TestConstraints *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_1(int32u);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_2(int32u);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_3(int32u);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteAttributeInt32uValue_0()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint32_t int32uArgument;
        int32uArgument = 5UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uValueMinValueConstraints_1()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint32_t>("int32u", int32u, 5));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueMaxValueConstraints_2()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("int32u", int32u, 5));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueNotValueConstraints_3()
    {
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeInt32u(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintNotValue<uint32_t>("int32u", int32u, 6));
        NextTest();
    }
};

class TestDelayCommands : public TestCommand
{
public:
    TestDelayCommands() : TestCommand("TestDelayCommands"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDelayCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDelayCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait 100ms\n");
            err = TestWait100ms_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWait100ms_0() { return WaitForMs(100); }
};

class TestLogCommands : public TestCommand
{
public:
    TestLogCommands() : TestCommand("TestLogCommands"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestLogCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestLogCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Log a simple message\n");
            err = TestLogASimpleMessage_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestLogASimpleMessage_0() { return Log("This is a simple message"); }
};

class TestDescriptorCluster : public TestCommand
{
public:
    TestDescriptorCluster() : TestCommand("TestDescriptorCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDescriptorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDescriptorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Device list\n");
            err = TestReadAttributeDeviceList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Server list\n");
            err = TestReadAttributeServerList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute Client list\n");
            err = TestReadAttributeClientList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute Parts list\n");
            err = TestReadAttributePartsList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context,
                                      const chip::app::DataModel::DecodableList<
                                          chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)>
        mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)>
        mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)>
        mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)>
        mOnSuccessCallback_3{ OnSuccessCallback_3, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_0(deviceList);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_1(serverList);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_2(clientList);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_3(partsList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeDeviceList_0()
    {
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeDeviceList(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        auto iter = deviceList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(deviceList)>("deviceList", iter, 0));
        VerifyOrReturn(CheckValue<>("deviceList[0].revision", iter.GetValue().revision, 1U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(deviceList)>("deviceList", iter, 1));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeServerList_1()
    {
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeServerList(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        auto iter = serverList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 0));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[0]", iter.GetValue(), 3UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 1));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[1]", iter.GetValue(), 29UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 2));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[2]", iter.GetValue(), 40UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 3));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[3]", iter.GetValue(), 41UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 4));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[4]", iter.GetValue(), 42UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 5));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[5]", iter.GetValue(), 48UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 6));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[6]", iter.GetValue(), 49UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 7));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[7]", iter.GetValue(), 50UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 8));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[8]", iter.GetValue(), 51UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 9));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[9]", iter.GetValue(), 52UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 10));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[10]", iter.GetValue(), 53UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 11));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[11]", iter.GetValue(), 54UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 12));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[12]", iter.GetValue(), 55UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 13));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[13]", iter.GetValue(), 60UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 14));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[14]", iter.GetValue(), 62UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 15));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[15]", iter.GetValue(), 1029UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 16));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[16]", iter.GetValue(), 61440UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 17));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[17]", iter.GetValue(), 61444UL));
        VerifyOrReturn(CheckNoMoreListItems<decltype(serverList)>("serverList", iter, 18));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeClientList_2()
    {
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeClientList(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        auto iter = clientList.begin();
        VerifyOrReturn(CheckNoMoreListItems<decltype(clientList)>("clientList", iter, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributePartsList_3()
    {
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributePartsList(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        auto iter = partsList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(partsList)>("partsList", iter, 0));
        VerifyOrReturn(CheckValue<chip::EndpointId>("partsList[0]", iter.GetValue(), 1U));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(partsList)>("partsList", iter, 1));
        VerifyOrReturn(CheckValue<chip::EndpointId>("partsList[1]", iter.GetValue(), 2U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(partsList)>("partsList", iter, 2));
        NextTest();
    }
};

class TestBasicInformation : public TestCommand
{
public:
    TestBasicInformation() : TestCommand("TestBasicInformation"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestBasicInformation\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestBasicInformation\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read location\n");
            err = TestReadLocation_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write location\n");
            err = TestWriteLocation_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read back location\n");
            err = TestReadBackLocation_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Restore initial location value\n");
            err = TestRestoreInitialLocationValue_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan location)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan location)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, chip::CharSpan location)
    {
        (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_0(location);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, chip::CharSpan location)
    {
        (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_2(location);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_3(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadLocation_0()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeLocation(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, ""));
        NextTest();
    }

    CHIP_ERROR TestWriteLocation_1()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("us", strlen("us"));

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadBackLocation_2()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeLocation(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, "us"));
        NextTest();
    }

    CHIP_ERROR TestRestoreInitialLocationValue_3()
    {
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, 0);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("", strlen(""));

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }
};

class TestIdentifyCluster : public TestCommand
{
public:
    TestIdentifyCluster() : TestCommand("TestIdentifyCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestIdentifyCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestIdentifyCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Identify command and expect success response\n");
            err = TestSendIdentifyCommandAndExpectSuccessResponse_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendIdentifyCommandAndExpectSuccessResponse_0()
    {
        chip::Controller::IdentifyClusterTest cluster;
        cluster.Associate(mDevice, 0);

        using requestType  = chip::app::Clusters::Identify::Commands::Identify::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::Identify::Commands::Identify::Type request;
        request.identifyTime = 0U;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestIdentifyCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestIdentifyCluster *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }
};

class TestOperationalCredentialsCluster : public TestCommand
{
public:
    TestOperationalCredentialsCluster() : TestCommand("TestOperationalCredentialsCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestOperationalCredentialsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestOperationalCredentialsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read number of supported fabrics\n");
            err = TestReadNumberOfSupportedFabrics_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read number of commissioned fabrics\n");
            err = TestReadNumberOfCommissionedFabrics_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read current fabric index\n");
            err = TestReadCurrentFabricIndex_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t supportedFabrics)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t commissionedFabrics)> mOnSuccessCallback_1{ OnSuccessCallback_1,
                                                                                                          this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, chip::FabricIndex currentFabricIndex)> mOnSuccessCallback_2{
        OnSuccessCallback_2, this
    };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t supportedFabrics)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_0(supportedFabrics);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_1(commissionedFabrics);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, chip::FabricIndex currentFabricIndex)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_2(currentFabricIndex);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadNumberOfSupportedFabrics_0()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeSupportedFabrics(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("supportedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("supportedFabrics", supportedFabrics, 4));
        NextTest();
    }

    CHIP_ERROR TestReadNumberOfCommissionedFabrics_1()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeCommissionedFabrics(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("commissionedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("commissionedFabrics", commissionedFabrics, 1));
        NextTest();
    }

    CHIP_ERROR TestReadCurrentFabricIndex_2()
    {
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, 0);

        return cluster.ReadAttributeCurrentFabricIndex(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::FabricIndex currentFabricIndex)
    {
        VerifyOrReturn(CheckConstraintType("currentFabricIndex", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::FabricIndex>("currentFabricIndex", currentFabricIndex, 1));
        NextTest();
    }
};

class TestModeSelectCluster : public TestCommand
{
public:
    TestModeSelectCluster() : TestCommand("TestModeSelectCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestModeSelectCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestModeSelectCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read CurrentMode\n");
            err = TestReadCurrentMode_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read OnMode\n");
            err = TestReadOnMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read StartUpMode\n");
            err = TestReadStartUpMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read Description\n");
            err = TestReadDescription_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read SupportedModes\n");
            err = TestReadSupportedModes_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Change to Supported Mode\n");
            err = TestChangeToSupportedMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Verify Current Mode Change\n");
            err = TestVerifyCurrentModeChange_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Change to Unsupported Mode\n");
            err = TestChangeToUnsupportedMode_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentMode)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t onMode)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t startUpMode)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_3{ OnFailureCallback_3, this };
    chip::Callback::Callback<void (*)(void * context, chip::CharSpan description)> mOnSuccessCallback_3{ OnSuccessCallback_3,
                                                                                                         this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)>
        mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t currentMode)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_0(currentMode);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint8_t onMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_1(onMode);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint8_t startUpMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_2(startUpMode);
    }

    static void OnFailureCallback_3(void * context, uint8_t status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_3(status);
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan description)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_3(description);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_4(supportedModes);
    }

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_6(currentMode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadCurrentMode_0()
    {
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentMode(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentMode", currentMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadOnMode_1()
    {
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeOnMode(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t onMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("onMode", onMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadStartUpMode_2()
    {
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeStartUpMode(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t startUpMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startUpMode", startUpMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadDescription_3()
    {
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeDescription(mOnSuccessCallback_3.Cancel(), mOnFailureCallback_3.Cancel());
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::CharSpan description)
    {
        VerifyOrReturn(CheckValueAsString("description", description, "Coffee"));
        NextTest();
    }

    CHIP_ERROR TestReadSupportedModes_4()
    {
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeSupportedModes(mOnSuccessCallback_4.Cancel(), mOnFailureCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)
    {
        auto iter = supportedModes.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 0));
        VerifyOrReturn(CheckValueAsString("supportedModes[0].label", iter.GetValue().label, "Black"));
        VerifyOrReturn(CheckValue<>("supportedModes[0].mode", iter.GetValue().mode, 0));
        VerifyOrReturn(CheckValue<>("supportedModes[0].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 1));
        VerifyOrReturn(CheckValueAsString("supportedModes[1].label", iter.GetValue().label, "Cappuccino"));
        VerifyOrReturn(CheckValue<>("supportedModes[1].mode", iter.GetValue().mode, 4));
        VerifyOrReturn(CheckValue<>("supportedModes[1].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 2));
        VerifyOrReturn(CheckValueAsString("supportedModes[2].label", iter.GetValue().label, "Espresso"));
        VerifyOrReturn(CheckValue<>("supportedModes[2].mode", iter.GetValue().mode, 7));
        VerifyOrReturn(CheckValue<>("supportedModes[2].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNoMoreListItems<decltype(supportedModes)>("supportedModes", iter, 3));
        NextTest();
    }

    CHIP_ERROR TestChangeToSupportedMode_5()
    {
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type request;
        request.newMode = 4;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestVerifyCurrentModeChange_6()
    {
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentMode(mOnSuccessCallback_6.Cancel(), mOnFailureCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t currentMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentMode", currentMode, 4));
        NextTest();
    }

    CHIP_ERROR TestChangeToUnsupportedMode_7()
    {
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type request;
        request.newMode = 2;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_7(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_7(uint8_t status) { NextTest(); }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }
};

class Test_TC_DIAGSW_1_1 : public TestCommand
{
public:
    Test_TC_DIAGSW_1_1() : TestCommand("Test_TC_DIAGSW_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGSW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGSW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads CurrentHeapFree non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads CurrentHeapUsed non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapHighWaterMark non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_0{ OnFailureCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t currentHeapFree)> mOnSuccessCallback_0{ OnSuccessCallback_0, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t currentHeapUsed)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint64_t currentHeapHighWatermark)> mOnSuccessCallback_2{ OnSuccessCallback_2,
                                                                                                                this };

    static void OnFailureCallback_0(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_0(status);
    }

    static void OnSuccessCallback_0(void * context, uint64_t currentHeapFree)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_0(currentHeapFree);
    }

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, uint64_t currentHeapUsed)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_1(currentHeapUsed);
    }

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, uint64_t currentHeapHighWatermark)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_2(currentHeapHighWatermark);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_0()
    {
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentHeapFree(mOnSuccessCallback_0.Cancel(), mOnFailureCallback_0.Cancel());
    }

    void OnFailureResponse_0(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_0(uint64_t currentHeapFree)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapFree", "", "uint64"));
        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_1()
    {
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentHeapUsed(mOnSuccessCallback_1.Cancel(), mOnFailureCallback_1.Cancel());
    }

    void OnFailureResponse_1(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint64_t currentHeapUsed)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapUsed", "", "uint64"));
        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_2()
    {
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReadAttributeCurrentHeapHighWatermark(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel());
    }

    void OnFailureResponse_2(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint64_t currentHeapHighWatermark)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapHighWatermark", "", "uint64"));
        NextTest();
    }
};

class TestSubscribe_OnOff : public TestCommand
{
public:
    TestSubscribe_OnOff() : TestCommand("TestSubscribe_OnOff"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSubscribe_OnOff\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSubscribe_OnOff\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Set OnOff Attribute to false\n");
            err = TestSetOnOffAttributeToFalse_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Report: Subscribe OnOff Attribute\n");
            err = TestReportSubscribeOnOffAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Subscribe OnOff Attribute\n");
            err = TestSubscribeOnOffAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check for attribute report\n");
            err = TestCheckForAttributeReport_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check for attribute report\n");
            err = TestCheckForAttributeReport_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_1(onOff);
    }

    bool mReceivedReport_1 = false;

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_4(onOff);
    }

    bool mReceivedReport_4 = false;

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_6(onOff);
    }

    bool mReceivedReport_6 = false;

    //
    // Tests methods
    //

    CHIP_ERROR TestSetOnOffAttributeToFalse_0()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_0(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReportSubscribeOnOffAttribute_1()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        ReturnErrorOnFailure(cluster.ReportAttributeOnOff(mOnSuccessCallback_1.Cancel()));

        return WaitForMs(0);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_1 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_1 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, false));
    }

    CHIP_ERROR TestSubscribeOnOffAttribute_2()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        uint16_t minIntervalArgument;
        minIntervalArgument = 2U;
        uint16_t maxIntervalArgument;
        maxIntervalArgument = 10U;

        return cluster.SubscribeAttributeOnOff(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel(), minIntervalArgument,
                                               maxIntervalArgument);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_1, Exit("Initial report not received!"));

        NextTest();
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_3()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::On::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::On::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_3(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_4()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReportAttributeOnOff(mOnSuccessCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_4 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_4 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, true));
        NextTest();
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_5()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        using requestType  = chip::app::Clusters::OnOff::Commands::Off::Type;
        using responseType = chip::app::DataModel::NullObjectType;

        chip::app::Clusters::OnOff::Commands::Off::Type request;

        auto success = [](void * context, const responseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_5(status);
        };
        return cluster.InvokeCommand<requestType, responseType>(request, this, success, failure);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_6()
    {
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, 1);

        return cluster.ReportAttributeOnOff(mOnSuccessCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_6 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_6 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, false));
        NextTest();
    }
};

void registerCommandsTests(Commands & commands)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
        make_unique<Test_TC_BI_1_1>(),
        make_unique<Test_TC_BI_2_1>(),
        make_unique<Test_TC_BOOL_1_1>(),
        make_unique<Test_TC_BOOL_2_1>(),
        make_unique<Test_TC_CC_1_1>(),
        make_unique<Test_TC_CC_2_1>(),
        make_unique<Test_TC_CC_3_1>(),
        make_unique<Test_TC_CC_3_2>(),
        make_unique<Test_TC_CC_3_3>(),
        make_unique<Test_TC_CC_4_1>(),
        make_unique<Test_TC_CC_4_2>(),
        make_unique<Test_TC_CC_4_3>(),
        make_unique<Test_TC_CC_4_4>(),
        make_unique<Test_TC_CC_5_1>(),
        make_unique<Test_TC_CC_5_2>(),
        make_unique<Test_TC_CC_5_3>(),
        make_unique<Test_TC_CC_6_1>(),
        make_unique<Test_TC_CC_6_2>(),
        make_unique<Test_TC_CC_6_3>(),
        make_unique<Test_TC_CC_7_1>(),
        make_unique<Test_TC_CC_7_2>(),
        make_unique<Test_TC_CC_7_3>(),
        make_unique<Test_TC_CC_7_4>(),
        make_unique<Test_TC_CC_8_1>(),
        make_unique<Test_TC_CC_9_1>(),
        make_unique<Test_TC_CC_9_2>(),
        make_unique<Test_TC_CC_9_3>(),
        make_unique<Test_TC_DM_1_1>(),
        make_unique<Test_TC_DM_3_1>(),
        make_unique<Test_TC_DM_2_2>(),
        make_unique<Test_TC_EMR_1_1>(),
        make_unique<Test_TC_FLW_1_1>(),
        make_unique<Test_TC_FLW_2_1>(),
        make_unique<Test_TC_FLW_2_2>(),
        make_unique<Test_TC_LVL_1_1>(),
        make_unique<Test_TC_LVL_2_1>(),
        make_unique<Test_TC_LVL_3_1>(),
        make_unique<Test_TC_LVL_4_1>(),
        make_unique<Test_TC_LVL_5_1>(),
        make_unique<Test_TC_MC_1_1>(),
        make_unique<Test_TC_MC_2_1>(),
        make_unique<Test_TC_MC_3_1>(),
        make_unique<Test_TC_MC_3_2>(),
        make_unique<Test_TC_MC_3_3>(),
        make_unique<Test_TC_MC_3_4>(),
        make_unique<Test_TC_MC_3_5>(),
        make_unique<Test_TC_MC_3_6>(),
        make_unique<Test_TC_MC_3_7>(),
        make_unique<Test_TC_MC_3_8>(),
        make_unique<Test_TC_MC_3_9>(),
        make_unique<Test_TC_MC_3_10>(),
        make_unique<Test_TC_MC_3_11>(),
        make_unique<Test_TC_OCC_1_1>(),
        make_unique<Test_TC_OCC_2_1>(),
        make_unique<Test_TC_OCC_2_2>(),
        make_unique<Test_TC_OO_1_1>(),
        make_unique<Test_TC_OO_2_1>(),
        make_unique<Test_TC_OO_2_2>(),
        make_unique<Test_TC_OO_2_3>(),
        make_unique<Test_TC_PRS_1_1>(),
        make_unique<Test_TC_PRS_2_1>(),
        make_unique<Test_TC_PCC_1_1>(),
        make_unique<Test_TC_PCC_2_1>(),
        make_unique<Test_TC_PCC_2_2>(),
        make_unique<Test_TC_PCC_2_3>(),
        make_unique<Test_TC_RH_1_1>(),
        make_unique<Test_TC_RH_2_1>(),
        make_unique<Test_TC_RH_2_2>(),
        make_unique<Test_TC_TM_1_1>(),
        make_unique<Test_TC_TM_2_1>(),
        make_unique<Test_TC_TM_2_2>(),
        make_unique<Test_TC_TSTAT_1_1>(),
        make_unique<Test_TC_TSUIC_1_1>(),
        make_unique<Test_TC_TSUIC_2_1>(),
        make_unique<Test_TC_TSUIC_2_2>(),
        make_unique<Test_TC_DIAGTH_1_1>(),
        make_unique<Test_TC_WNCV_1_1>(),
        make_unique<Test_TC_WNCV_2_1>(),
        make_unique<Test_TC_WNCV_2_2>(),
        make_unique<Test_TC_WNCV_2_5>(),
        make_unique<Test_TC_WNCV_3_1>(),
        make_unique<Test_TC_WNCV_3_2>(),
        make_unique<Test_TC_WNCV_3_3>(),
        make_unique<TV_TargetNavigatorCluster>(),
        make_unique<TV_AudioOutputCluster>(),
        make_unique<TV_ApplicationLauncherCluster>(),
        make_unique<TV_KeypadInputCluster>(),
        make_unique<TV_AccountLoginCluster>(),
        make_unique<TV_WakeOnLanCluster>(),
        make_unique<TV_ApplicationBasicCluster>(),
        make_unique<TV_MediaPlaybackCluster>(),
        make_unique<TV_TvChannelCluster>(),
        make_unique<TV_LowPowerCluster>(),
        make_unique<TV_MediaInputCluster>(),
        make_unique<TestCluster>(),
        make_unique<TestClusterComplexTypes>(),
        make_unique<TestConstraints>(),
        make_unique<TestDelayCommands>(),
        make_unique<TestLogCommands>(),
        make_unique<TestDescriptorCluster>(),
        make_unique<TestBasicInformation>(),
        make_unique<TestIdentifyCluster>(),
        make_unique<TestOperationalCredentialsCluster>(),
        make_unique<TestModeSelectCluster>(),
        make_unique<Test_TC_DIAGSW_1_1>(),
        make_unique<TestSubscribe_OnOff>(),
    };

    commands.Register(clusterName, clusterCommands);
}
