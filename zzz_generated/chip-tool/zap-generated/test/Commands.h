/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#if CONFIG_ENABLE_YAML_TESTS

#include <commands/common/CommandInvoker.h>
#include <commands/tests/TestCommand.h>
#include <lib/core/Optional.h>
#include <lib/support/CHIPListUtils.h>
#include <system/SystemClock.h>

#include <math.h> // For INFINITY

class TestList : public Command
{
public:
    TestList() : Command("list"){};
    CHIP_ERROR Run() override
    {
        printf("TestAccessControlCluster\n");
        printf("Test_TC_BI_1_1\n");
        printf("Test_TC_BI_2_1\n");
        printf("Test_TC_BI_2_2\n");
        printf("Test_TC_BOOL_1_1\n");
        printf("Test_TC_BOOL_2_1\n");
        printf("Test_TC_BRAC_1_1\n");
        printf("Test_TC_CC_1_1\n");
        printf("Test_TC_CC_2_1\n");
        printf("Test_TC_CC_3_1\n");
        printf("Test_TC_CC_3_2\n");
        printf("Test_TC_CC_3_3\n");
        printf("Test_TC_CC_4_1\n");
        printf("Test_TC_CC_4_2\n");
        printf("Test_TC_CC_4_3\n");
        printf("Test_TC_CC_4_4\n");
        printf("Test_TC_CC_5_1\n");
        printf("Test_TC_CC_5_2\n");
        printf("Test_TC_CC_5_3\n");
        printf("Test_TC_CC_6_1\n");
        printf("Test_TC_CC_6_2\n");
        printf("Test_TC_CC_6_3\n");
        printf("Test_TC_CC_7_1\n");
        printf("Test_TC_CC_7_2\n");
        printf("Test_TC_CC_7_3\n");
        printf("Test_TC_CC_7_4\n");
        printf("Test_TC_CC_8_1\n");
        printf("Test_TC_CC_9_1\n");
        printf("Test_TC_CC_9_2\n");
        printf("Test_TC_CC_9_3\n");
        printf("Test_TC_DM_1_1\n");
        printf("Test_TC_DM_3_1\n");
        printf("Test_TC_DM_2_2\n");
        printf("Test_TC_EMR_1_1\n");
        printf("Test_TC_ETHDIAG_1_1\n");
        printf("Test_TC_ETHDIAG_2_1\n");
        printf("Test_TC_FLW_1_1\n");
        printf("Test_TC_FLW_2_1\n");
        printf("Test_TC_FLW_2_2\n");
        printf("Test_TC_GC_1_1\n");
        printf("Test_TC_I_1_1\n");
        printf("Test_TC_I_2_1\n");
        printf("Test_TC_I_2_3\n");
        printf("Test_TC_ILL_1_1\n");
        printf("Test_TC_ILL_2_1\n");
        printf("Test_TC_LVL_1_1\n");
        printf("Test_TC_LVL_2_1\n");
        printf("Test_TC_LVL_2_2\n");
        printf("Test_TC_LVL_3_1\n");
        printf("Test_TC_LVL_4_1\n");
        printf("Test_TC_LVL_5_1\n");
        printf("Test_TC_LVL_6_1\n");
        printf("Test_TC_MC_1_1\n");
        printf("Test_TC_MC_1_2\n");
        printf("Test_TC_MC_1_3\n");
        printf("Test_TC_MC_1_4\n");
        printf("Test_TC_MC_1_5\n");
        printf("Test_TC_MC_1_6\n");
        printf("Test_TC_MC_1_7\n");
        printf("Test_TC_MC_1_8\n");
        printf("Test_TC_MC_1_9\n");
        printf("Test_TC_MC_1_10\n");
        printf("Test_TC_MC_1_11\n");
        printf("Test_TC_MC_1_12\n");
        printf("Test_TC_MC_2_1\n");
        printf("Test_TC_MC_3_1\n");
        printf("Test_TC_MC_3_2\n");
        printf("Test_TC_MC_3_3\n");
        printf("Test_TC_MC_3_4\n");
        printf("Test_TC_MC_3_5\n");
        printf("Test_TC_MC_3_6\n");
        printf("Test_TC_MC_3_7\n");
        printf("Test_TC_MC_3_8\n");
        printf("Test_TC_MC_3_9\n");
        printf("Test_TC_MC_3_10\n");
        printf("Test_TC_MC_3_11\n");
        printf("Test_TC_MC_5_1\n");
        printf("Test_TC_MC_5_2\n");
        printf("Test_TC_MC_5_3\n");
        printf("Test_TC_MC_6_1\n");
        printf("Test_TC_MC_6_2\n");
        printf("Test_TC_MC_6_3\n");
        printf("Test_TC_MC_6_4\n");
        printf("Test_TC_MC_7_1\n");
        printf("Test_TC_MC_7_2\n");
        printf("Test_TC_MC_8_1\n");
        printf("Test_TC_MC_9_1\n");
        printf("Test_TC_MC_10_1\n");
        printf("Test_TC_MOD_1_1\n");
        printf("Test_TC_MF_1_3\n");
        printf("Test_TC_MF_1_4\n");
        printf("Test_TC_MF_1_5\n");
        printf("Test_TC_MF_1_6\n");
        printf("Test_TC_MF_1_15\n");
        printf("Test_TC_OCC_1_1\n");
        printf("Test_TC_OCC_2_1\n");
        printf("Test_TC_OCC_2_2\n");
        printf("Test_TC_OO_1_1\n");
        printf("Test_TC_OO_2_1\n");
        printf("Test_TC_OO_2_2\n");
        printf("Test_TC_OO_2_3\n");
        printf("Test_TC_OO_2_4\n");
        printf("Test_TC_PS_1_1\n");
        printf("Test_TC_PS_2_1\n");
        printf("Test_TC_PRS_1_1\n");
        printf("Test_TC_PRS_2_1\n");
        printf("Test_TC_PCC_1_1\n");
        printf("Test_TC_PCC_2_1\n");
        printf("Test_TC_PCC_2_2\n");
        printf("Test_TC_PCC_2_3\n");
        printf("Test_TC_PCC_2_4\n");
        printf("Test_TC_PSCFG_1_1\n");
        printf("Test_TC_RH_1_1\n");
        printf("Test_TC_RH_2_1\n");
        printf("Test_TC_RH_2_2\n");
        printf("Test_TC_SC_4_2\n");
        printf("Test_TC_SWTCH_2_1\n");
        printf("Test_TC_SWTCH_2_2\n");
        printf("Test_TC_TM_1_1\n");
        printf("Test_TC_TM_2_1\n");
        printf("Test_TC_TM_2_2\n");
        printf("Test_TC_TSTAT_1_1\n");
        printf("Test_TC_TSTAT_2_1\n");
        printf("Test_TC_TSTAT_2_2\n");
        printf("Test_TC_TSUIC_1_1\n");
        printf("Test_TC_TSUIC_2_1\n");
        printf("Test_TC_TSUIC_2_2\n");
        printf("Test_TC_DIAG_TH_NW_1_1\n");
        printf("Test_TC_DIAG_TH_NW_1_2\n");
        printf("Test_TC_LC_1_2\n");
        printf("Test_TC_WIFIDIAG_1_1\n");
        printf("Test_TC_WIFIDIAG_3_1\n");
        printf("Test_TC_WNCV_1_1\n");
        printf("Test_TC_WNCV_2_1\n");
        printf("Test_TC_WNCV_2_2\n");
        printf("Test_TC_WNCV_2_3\n");
        printf("Test_TC_WNCV_2_4\n");
        printf("Test_TC_WNCV_2_5\n");
        printf("Test_TC_WNCV_3_1\n");
        printf("Test_TC_WNCV_3_2\n");
        printf("Test_TC_WNCV_3_3\n");
        printf("Test_TC_WNCV_3_4\n");
        printf("Test_TC_WNCV_3_5\n");
        printf("Test_TC_WNCV_4_1\n");
        printf("Test_TC_WNCV_4_2\n");
        printf("Test_TC_WNCV_4_3\n");
        printf("Test_TC_WNCV_4_4\n");
        printf("Test_TC_WNCV_4_5\n");
        printf("TV_TargetNavigatorCluster\n");
        printf("TV_AudioOutputCluster\n");
        printf("TV_ApplicationLauncherCluster\n");
        printf("TV_KeypadInputCluster\n");
        printf("TV_AccountLoginCluster\n");
        printf("TV_WakeOnLanCluster\n");
        printf("TV_ApplicationBasicCluster\n");
        printf("TV_MediaPlaybackCluster\n");
        printf("TV_ChannelCluster\n");
        printf("TV_LowPowerCluster\n");
        printf("TV_ContentLauncherCluster\n");
        printf("TV_MediaInputCluster\n");
        printf("TestCluster\n");
        printf("TestClusterComplexTypes\n");
        printf("TestConstraints\n");
        printf("TestDelayCommands\n");
        printf("TestEvents\n");
        printf("TestDiscovery\n");
        printf("TestLogCommands\n");
        printf("TestSaveAs\n");
        printf("TestConfigVariables\n");
        printf("TestDescriptorCluster\n");
        printf("TestBasicInformation\n");
        printf("TestGeneralCommissioning\n");
        printf("TestIdentifyCluster\n");
        printf("TestOperationalCredentialsCluster\n");
        printf("TestModeSelectCluster\n");
        printf("TestSelfFabricRemoval\n");
        printf("TestSystemCommands\n");
        printf("TestBinding\n");
        printf("TestUserLabelCluster\n");
        printf("TestArmFailSafe\n");
        printf("TestMultiAdmin\n");
        printf("Test_TC_SWDIAG_1_1\n");
        printf("Test_TC_SWDIAG_2_1\n");
        printf("Test_TC_SWDIAG_3_1\n");
        printf("TestSubscribe_OnOff\n");
        printf("DL_UsersAndCredentials\n");
        printf("DL_LockUnlock\n");
        printf("DL_Schedules\n");
        printf("Test_TC_DL_1_3\n");
        printf("TestGroupMessaging\n");
        printf("TestGroupsCluster\n");
        printf("TestGroupKeyManagementCluster\n");

        return CHIP_NO_ERROR;
    }
};

class ManualTestList : public Command
{
public:
    ManualTestList() : Command("list-manual"){};
    CHIP_ERROR Run() override
    {
        printf("Test_TC_DD_1_5\n");
        printf("Test_TC_DD_1_6\n");
        printf("Test_TC_DD_1_7\n");
        printf("Test_TC_DD_1_8\n");
        printf("Test_TC_DD_1_9\n");
        printf("Test_TC_DD_1_10\n");
        printf("Test_TC_DD_2_1\n");
        printf("Test_TC_DD_2_2\n");
        printf("Test_TC_DD_3_1\n");
        printf("Test_TC_DD_3_2\n");
        printf("Test_TC_DD_3_5\n");
        printf("Test_TC_DD_3_6\n");
        printf("Test_TC_DD_3_9\n");
        printf("Test_TC_DD_3_10\n");
        printf("Test_TC_DD_3_11\n");
        printf("Test_TC_DD_3_12\n");
        printf("Test_TC_DD_3_13\n");
        printf("Test_TC_DD_3_14\n");
        printf("Test_TC_DD_4_1\n");
        printf("TestGroupDemoCommand\n");
        printf("TestGroupDemoConfig\n");
        printf("Test_TC_BDX_1_1\n");
        printf("Test_TC_BDX_1_2\n");
        printf("Test_TC_BDX_1_3\n");
        printf("Test_TC_BDX_1_5\n");
        printf("Test_TC_BDX_1_6\n");
        printf("Test_TC_BDX_2_1\n");
        printf("Test_TC_BDX_2_2\n");
        printf("Test_TC_BDX_2_3\n");
        printf("Test_TC_BDX_2_4\n");
        printf("Test_TC_BDX_2_5\n");
        printf("Test_TC_BR_1\n");
        printf("Test_TC_BR_2\n");
        printf("Test_TC_BR_3\n");
        printf("Test_TC_BRAC_2_1\n");
        printf("Test_TC_BRAC_2_2\n");
        printf("Test_TC_DM_1_2\n");
        printf("Test_TC_DM_1_4\n");
        printf("Test_TC_DM_2_3\n");
        printf("Test_TC_DM_2_4\n");
        printf("Test_TC_DM_3_2\n");
        printf("Test_TC_DM_3_4\n");
        printf("Test_TC_DIAG_LOG_1_1\n");
        printf("Test_TC_DIAG_LOG_1_2\n");
        printf("Test_TC_DIAG_LOG_1_3\n");
        printf("Test_TC_DESC_1_1\n");
        printf("Test_TC_ETHDIAG_1_2\n");
        printf("Test_TC_GC_1_2\n");
        printf("Test_TC_GC_1_3\n");
        printf("Test_TC_GENDIAG_1_1\n");
        printf("Test_TC_GENDIAG_1_2\n");
        printf("Test_TC_GENDIAG_2_1\n");
        printf("Test_TC_I_2_2\n");
        printf("Test_TC_ILL_2_2\n");
        printf("Test_TC_IDM_1_1\n");
        printf("Test_TC_IDM_1_2\n");
        printf("Test_TC_IDM_2_1\n");
        printf("Test_TC_IDM_2_2\n");
        printf("Test_TC_IDM_3_1\n");
        printf("Test_TC_IDM_3_2\n");
        printf("Test_TC_IDM_4_1\n");
        printf("Test_TC_IDM_4_2\n");
        printf("Test_TC_IDM_5_1\n");
        printf("Test_TC_IDM_5_2\n");
        printf("Test_TC_IDM_6_1\n");
        printf("Test_TC_IDM_6_2\n");
        printf("Test_TC_IDM_6_3\n");
        printf("Test_TC_IDM_6_4\n");
        printf("Test_TC_MC_3_12\n");
        printf("Test_TC_MC_3_13\n");
        printf("Test_TC_MC_4_1\n");
        printf("Test_TC_MC_8_2\n");
        printf("Test_TC_MC_9_2\n");
        printf("Test_TC_MC_10_2\n");
        printf("Test_TC_MC_10_3\n");
        printf("Test_TC_MC_10_4\n");
        printf("Test_TC_MC_10_5\n");
        printf("Test_TC_MC_10_6\n");
        printf("Test_TC_MF_1_1\n");
        printf("Test_TC_MF_1_2\n");
        printf("Test_TC_MF_1_7\n");
        printf("Test_TC_MF_1_8\n");
        printf("Test_TC_MF_1_9\n");
        printf("Test_TC_MF_1_10\n");
        printf("Test_TC_MF_1_11\n");
        printf("Test_TC_MF_1_12\n");
        printf("Test_TC_MF_1_13\n");
        printf("Test_TC_MF_1_14\n");
        printf("Test_TC_MF_1_16\n");
        printf("Test_TC_MF_1_17\n");
        printf("Test_TC_MF_1_18\n");
        printf("Test_TC_MF_1_19\n");
        printf("Test_TC_MF_1_20\n");
        printf("Test_TC_MF_1_21\n");
        printf("Test_TC_MF_1_22\n");
        printf("Test_TC_MF_1_23\n");
        printf("Test_TC_MF_1_24\n");
        printf("Test_TC_MF_1_25\n");
        printf("Test_TC_MF_1_26\n");
        printf("Test_TC_MF_1_27\n");
        printf("Test_TC_MF_1_28\n");
        printf("Test_TC_MOD_1_2\n");
        printf("Test_TC_MOD_2_1\n");
        printf("Test_TC_MOD_2_2\n");
        printf("Test_TC_MOD_3_1\n");
        printf("Test_TC_MOD_3_2\n");
        printf("Test_TC_MOD_3_3\n");
        printf("Test_TC_SU_1_1\n");
        printf("Test_TC_SU_2_1\n");
        printf("Test_TC_SU_2_2\n");
        printf("Test_TC_SU_2_3\n");
        printf("Test_TC_SU_2_4\n");
        printf("Test_TC_SU_2_5\n");
        printf("Test_TC_SU_2_6\n");
        printf("Test_TC_SU_2_7\n");
        printf("Test_TC_SU_3_1\n");
        printf("Test_TC_SU_3_2\n");
        printf("Test_TC_SU_3_3\n");
        printf("Test_TC_SU_3_4\n");
        printf("Test_TC_SU_4_1\n");
        printf("Test_TC_SU_4_2\n");
        printf("Test_TC_PSCFG_2_1\n");
        printf("Test_TC_PSCFG_3_1\n");
        printf("Test_TC_SC_4_5\n");
        printf("Test_TC_SC_4_6\n");
        printf("Test_TC_SC_4_7\n");
        printf("Test_TC_SC_4_8\n");
        printf("Test_TC_SC_4_9\n");
        printf("Test_TC_SWDIAG_1_2\n");
        printf("Test_TC_WIFIDIAG_1_2\n");
        printf("Test_TC_WIFIDIAG_2_1\n");
        printf("Test_TC_WNCV_6_1\n");
        printf("Test_TC_FLW_3_1\n");
        printf("Test_TC_OCC_2_3\n");
        printf("Test_TC_OCC_2_4\n");
        printf("Test_TC_OCC_3_1\n");
        printf("Test_TC_PRS_2_2\n");
        printf("Test_TC_PRS_2_3\n");
        printf("Test_TC_PS_2_2\n");

        return CHIP_NO_ERROR;
    }
};

class TestAccessControlClusterSuite : public TestCommand
{
public:
    TestAccessControlClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestAccessControlCluster", 22, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestAccessControlClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNonNull("acl[0].targets", iter_0.GetValue().targets));
                    {
                        auto iter_NaN = iter_0.GetValue().targets.Value().begin();
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[0].targets.Value()", iter_NaN, 0));
                        VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[0].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[0].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(
                            CheckValue("acl[0].targets.Value()[0].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 0U));
                        VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[0].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[0].targets.Value()", iter_NaN, 1));
                        VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[1].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(
                            CheckValue("acl[0].targets.Value()[1].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 1UL));
                        VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[1].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[1].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[0].targets.Value()", iter_NaN, 2));
                        VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[2].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(
                            CheckValue("acl[0].targets.Value()[2].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 2UL));
                        VerifyOrReturn(CheckValueNonNull("acl[0].targets.Value()[2].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(
                            CheckValue("acl[0].targets.Value()[2].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 3U));
                        VerifyOrReturn(CheckValueNull("acl[0].targets.Value()[2].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNoMoreListItems<decltype(iter_0.GetValue().targets.Value())>("acl[0].targets.Value()",
                                                                                                         iter_NaN, 3));
                    }
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 1));
                    VerifyOrReturn(CheckValue("acl[1].privilege", iter_0.GetValue().privilege, 1));
                    VerifyOrReturn(CheckValue("acl[1].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNonNull("acl[1].subjects", iter_0.GetValue().subjects));
                    {
                        auto iter_NaN = iter_0.GetValue().subjects.Value().begin();
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>(
                            "acl[1].subjects.Value()", iter_NaN, 0));
                        VerifyOrReturn(CheckValue("acl[1].subjects.Value()[0]", iter_NaN.GetValue(), 4ULL));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>(
                            "acl[1].subjects.Value()", iter_NaN, 1));
                        VerifyOrReturn(CheckValue("acl[1].subjects.Value()[1]", iter_NaN.GetValue(), 5ULL));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>(
                            "acl[1].subjects.Value()", iter_NaN, 2));
                        VerifyOrReturn(CheckValue("acl[1].subjects.Value()[2]", iter_NaN.GetValue(), 6ULL));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>(
                            "acl[1].subjects.Value()", iter_NaN, 3));
                        VerifyOrReturn(CheckValue("acl[1].subjects.Value()[3]", iter_NaN.GetValue(), 7ULL));
                        VerifyOrReturn(CheckNoMoreListItems<decltype(iter_0.GetValue().subjects.Value())>("acl[1].subjects.Value()",
                                                                                                          iter_NaN, 4));
                    }
                    VerifyOrReturn(CheckValueNonNull("acl[1].targets", iter_0.GetValue().targets));
                    {
                        auto iter_NaN = iter_0.GetValue().targets.Value().begin();
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[1].targets.Value()", iter_NaN, 0));
                        VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[0].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[0].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(
                            CheckValue("acl[1].targets.Value()[0].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 8U));
                        VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[0].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[1].targets.Value()", iter_NaN, 1));
                        VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[1].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(
                            CheckValue("acl[1].targets.Value()[1].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 9UL));
                        VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[1].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[1].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[1].targets.Value()", iter_NaN, 2));
                        VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[2].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(
                            CheckValue("acl[1].targets.Value()[2].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 10UL));
                        VerifyOrReturn(CheckValueNonNull("acl[1].targets.Value()[2].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(
                            CheckValue("acl[1].targets.Value()[2].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 11U));
                        VerifyOrReturn(CheckValueNull("acl[1].targets.Value()[2].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNoMoreListItems<decltype(iter_0.GetValue().targets.Value())>("acl[1].targets.Value()",
                                                                                                         iter_NaN, 3));
                    }
                    VerifyOrReturn(CheckValue("acl[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 2));
                    VerifyOrReturn(CheckValue("acl[2].privilege", iter_0.GetValue().privilege, 3));
                    VerifyOrReturn(CheckValue("acl[2].authMode", iter_0.GetValue().authMode, 3));
                    VerifyOrReturn(CheckValueNonNull("acl[2].subjects", iter_0.GetValue().subjects));
                    {
                        auto iter_NaN = iter_0.GetValue().subjects.Value().begin();
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>(
                            "acl[2].subjects.Value()", iter_NaN, 0));
                        VerifyOrReturn(CheckValue("acl[2].subjects.Value()[0]", iter_NaN.GetValue(), 12ULL));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>(
                            "acl[2].subjects.Value()", iter_NaN, 1));
                        VerifyOrReturn(CheckValue("acl[2].subjects.Value()[1]", iter_NaN.GetValue(), 13ULL));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>(
                            "acl[2].subjects.Value()", iter_NaN, 2));
                        VerifyOrReturn(CheckValue("acl[2].subjects.Value()[2]", iter_NaN.GetValue(), 14ULL));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().subjects.Value())>(
                            "acl[2].subjects.Value()", iter_NaN, 3));
                        VerifyOrReturn(CheckValue("acl[2].subjects.Value()[3]", iter_NaN.GetValue(), 15ULL));
                        VerifyOrReturn(CheckNoMoreListItems<decltype(iter_0.GetValue().subjects.Value())>("acl[2].subjects.Value()",
                                                                                                          iter_NaN, 4));
                    }
                    VerifyOrReturn(CheckValueNonNull("acl[2].targets", iter_0.GetValue().targets));
                    {
                        auto iter_NaN = iter_0.GetValue().targets.Value().begin();
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[2].targets.Value()", iter_NaN, 0));
                        VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[0].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(CheckValueNonNull("acl[2].targets.Value()[0].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(
                            CheckValue("acl[2].targets.Value()[0].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 16U));
                        VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[0].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[2].targets.Value()", iter_NaN, 1));
                        VerifyOrReturn(CheckValueNonNull("acl[2].targets.Value()[1].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(
                            CheckValue("acl[2].targets.Value()[1].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 17UL));
                        VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[1].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[1].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().targets.Value())>(
                            "acl[2].targets.Value()", iter_NaN, 2));
                        VerifyOrReturn(CheckValueNonNull("acl[2].targets.Value()[2].cluster", iter_NaN.GetValue().cluster));
                        VerifyOrReturn(
                            CheckValue("acl[2].targets.Value()[2].cluster.Value()", iter_NaN.GetValue().cluster.Value(), 18UL));
                        VerifyOrReturn(CheckValueNonNull("acl[2].targets.Value()[2].endpoint", iter_NaN.GetValue().endpoint));
                        VerifyOrReturn(
                            CheckValue("acl[2].targets.Value()[2].endpoint.Value()", iter_NaN.GetValue().endpoint.Value(), 19U));
                        VerifyOrReturn(CheckValueNull("acl[2].targets.Value()[2].deviceType", iter_NaN.GetValue().deviceType));
                        VerifyOrReturn(CheckNoMoreListItems<decltype(iter_0.GetValue().targets.Value())>("acl[2].targets.Value()",
                                                                                                         iter_NaN, 3));
                    }
                    VerifyOrReturn(CheckValue("acl[2].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 3));
                }
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 1));
                    VerifyOrReturn(CheckValue("acl[1].privilege", iter_0.GetValue().privilege, 1));
                    VerifyOrReturn(CheckValue("acl[1].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[1].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[1].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 2));
                }
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 1));
                }
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 1));
                }
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 1));
                }
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 1));
                }
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 1));
                }
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 1));
                }
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acl", iter_0, 0));
                    VerifyOrReturn(CheckValue("acl[0].privilege", iter_0.GetValue().privilege, 5));
                    VerifyOrReturn(CheckValue("acl[0].authMode", iter_0.GetValue().authMode, 2));
                    VerifyOrReturn(CheckValueNull("acl[0].subjects", iter_0.GetValue().subjects));
                    VerifyOrReturn(CheckValueNull("acl[0].targets", iter_0.GetValue().targets));
                    VerifyOrReturn(CheckValue("acl[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acl", iter_0, 1));
                }
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 4U));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 3U));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 3U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for commissionee");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Write entries");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(3);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(3);
                    listFreer.add(listHolder_3);

                    listHolder_3->mList[0].cluster.SetNull();
                    listHolder_3->mList[0].endpoint.SetNonNull();
                    listHolder_3->mList[0].endpoint.Value() = 0U;
                    listHolder_3->mList[0].deviceType.SetNull();

                    listHolder_3->mList[1].cluster.SetNonNull();
                    listHolder_3->mList[1].cluster.Value() = 1UL;
                    listHolder_3->mList[1].endpoint.SetNull();
                    listHolder_3->mList[1].deviceType.SetNull();

                    listHolder_3->mList[2].cluster.SetNonNull();
                    listHolder_3->mList[2].cluster.Value() = 2UL;
                    listHolder_3->mList[2].endpoint.SetNonNull();
                    listHolder_3->mList[2].endpoint.Value() = 3U;
                    listHolder_3->mList[2].deviceType.SetNull();

                    listHolder_0->mList[0].targets.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList,
                                                                                                              3);
                }
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[1].subjects.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<uint64_t>(4);
                    listFreer.add(listHolder_3);
                    listHolder_3->mList[0]                  = 4ULL;
                    listHolder_3->mList[1]                  = 5ULL;
                    listHolder_3->mList[2]                  = 6ULL;
                    listHolder_3->mList[3]                  = 7ULL;
                    listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 4);
                }
                listHolder_0->mList[1].targets.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(3);
                    listFreer.add(listHolder_3);

                    listHolder_3->mList[0].cluster.SetNull();
                    listHolder_3->mList[0].endpoint.SetNonNull();
                    listHolder_3->mList[0].endpoint.Value() = 8U;
                    listHolder_3->mList[0].deviceType.SetNull();

                    listHolder_3->mList[1].cluster.SetNonNull();
                    listHolder_3->mList[1].cluster.Value() = 9UL;
                    listHolder_3->mList[1].endpoint.SetNull();
                    listHolder_3->mList[1].deviceType.SetNull();

                    listHolder_3->mList[2].cluster.SetNonNull();
                    listHolder_3->mList[2].cluster.Value() = 10UL;
                    listHolder_3->mList[2].endpoint.SetNonNull();
                    listHolder_3->mList[2].endpoint.Value() = 11U;
                    listHolder_3->mList[2].deviceType.SetNull();

                    listHolder_0->mList[1].targets.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList,
                                                                                                              3);
                }
                listHolder_0->mList[1].fabricIndex = 0;

                listHolder_0->mList[2].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(3);
                listHolder_0->mList[2].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(3);
                listHolder_0->mList[2].subjects.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<uint64_t>(4);
                    listFreer.add(listHolder_3);
                    listHolder_3->mList[0]                  = 12ULL;
                    listHolder_3->mList[1]                  = 13ULL;
                    listHolder_3->mList[2]                  = 14ULL;
                    listHolder_3->mList[3]                  = 15ULL;
                    listHolder_0->mList[2].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 4);
                }
                listHolder_0->mList[2].targets.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(3);
                    listFreer.add(listHolder_3);

                    listHolder_3->mList[0].cluster.SetNull();
                    listHolder_3->mList[0].endpoint.SetNonNull();
                    listHolder_3->mList[0].endpoint.Value() = 16U;
                    listHolder_3->mList[0].deviceType.SetNull();

                    listHolder_3->mList[1].cluster.SetNonNull();
                    listHolder_3->mList[1].cluster.Value() = 17UL;
                    listHolder_3->mList[1].endpoint.SetNull();
                    listHolder_3->mList[1].deviceType.SetNull();

                    listHolder_3->mList[2].cluster.SetNonNull();
                    listHolder_3->mList[2].cluster.Value() = 18UL;
                    listHolder_3->mList[2].endpoint.SetNonNull();
                    listHolder_3->mList[2].endpoint.Value() = 19U;
                    listHolder_3->mList[2].deviceType.SetNull();

                    listHolder_0->mList[2].targets.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList,
                                                                                                              3);
                }
                listHolder_0->mList[2].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 3);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 2: {
            LogStep(2, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 3: {
            LogStep(3, "Write entries empty lists");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[1].subjects.SetNonNull();

                listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>();
                listHolder_0->mList[1].targets.SetNonNull();

                listHolder_0->mList[1].targets.Value() =
                    chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>();
                listHolder_0->mList[1].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 4: {
            LogStep(4, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 5: {
            LogStep(5, "Write entry invalid privilege");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(3);
                listHolder_0->mList[1].subjects.SetNull();
                listHolder_0->mList[1].targets.SetNull();
                listHolder_0->mList[1].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 6: {
            LogStep(6, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 7: {
            LogStep(7, "Write entry invalid auth mode");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(1);
                listHolder_0->mList[1].subjects.SetNull();
                listHolder_0->mList[1].targets.SetNull();
                listHolder_0->mList[1].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 8: {
            LogStep(8, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 9: {
            LogStep(9, "Write entry invalid subject");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[1].subjects.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<uint64_t>(1);
                    listFreer.add(listHolder_3);
                    listHolder_3->mList[0]                  = 0ULL;
                    listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 1);
                }
                listHolder_0->mList[1].targets.SetNull();
                listHolder_0->mList[1].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 10: {
            LogStep(10, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 11: {
            LogStep(11, "Write entry invalid target");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[1].subjects.SetNull();
                listHolder_0->mList[1].targets.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(1);
                    listFreer.add(listHolder_3);

                    listHolder_3->mList[0].cluster.SetNull();
                    listHolder_3->mList[0].endpoint.SetNull();
                    listHolder_3->mList[0].deviceType.SetNull();

                    listHolder_0->mList[1].targets.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList,
                                                                                                              1);
                }
                listHolder_0->mList[1].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 12: {
            LogStep(12, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 13: {
            LogStep(13, "Write entry too many subjects");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[1].subjects.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<uint64_t>(20);
                    listFreer.add(listHolder_3);
                    listHolder_3->mList[0]                  = 1ULL;
                    listHolder_3->mList[1]                  = 2ULL;
                    listHolder_3->mList[2]                  = 3ULL;
                    listHolder_3->mList[3]                  = 4ULL;
                    listHolder_3->mList[4]                  = 5ULL;
                    listHolder_3->mList[5]                  = 6ULL;
                    listHolder_3->mList[6]                  = 7ULL;
                    listHolder_3->mList[7]                  = 8ULL;
                    listHolder_3->mList[8]                  = 9ULL;
                    listHolder_3->mList[9]                  = 10ULL;
                    listHolder_3->mList[10]                 = 11ULL;
                    listHolder_3->mList[11]                 = 12ULL;
                    listHolder_3->mList[12]                 = 13ULL;
                    listHolder_3->mList[13]                 = 14ULL;
                    listHolder_3->mList[14]                 = 15ULL;
                    listHolder_3->mList[15]                 = 16ULL;
                    listHolder_3->mList[16]                 = 17ULL;
                    listHolder_3->mList[17]                 = 18ULL;
                    listHolder_3->mList[18]                 = 19ULL;
                    listHolder_3->mList[19]                 = 20ULL;
                    listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 20);
                }
                listHolder_0->mList[1].targets.SetNull();
                listHolder_0->mList[1].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 14: {
            LogStep(14, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 15: {
            LogStep(15, "Write entry too many targets");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(1);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[1].subjects.SetNull();
                listHolder_0->mList[1].targets.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<chip::app::Clusters::AccessControl::Structs::Target::Type>(20);
                    listFreer.add(listHolder_3);

                    listHolder_3->mList[0].cluster.SetNull();
                    listHolder_3->mList[0].endpoint.SetNonNull();
                    listHolder_3->mList[0].endpoint.Value() = 1U;
                    listHolder_3->mList[0].deviceType.SetNull();

                    listHolder_3->mList[1].cluster.SetNull();
                    listHolder_3->mList[1].endpoint.SetNonNull();
                    listHolder_3->mList[1].endpoint.Value() = 2U;
                    listHolder_3->mList[1].deviceType.SetNull();

                    listHolder_3->mList[2].cluster.SetNull();
                    listHolder_3->mList[2].endpoint.SetNonNull();
                    listHolder_3->mList[2].endpoint.Value() = 3U;
                    listHolder_3->mList[2].deviceType.SetNull();

                    listHolder_3->mList[3].cluster.SetNull();
                    listHolder_3->mList[3].endpoint.SetNonNull();
                    listHolder_3->mList[3].endpoint.Value() = 4U;
                    listHolder_3->mList[3].deviceType.SetNull();

                    listHolder_3->mList[4].cluster.SetNull();
                    listHolder_3->mList[4].endpoint.SetNonNull();
                    listHolder_3->mList[4].endpoint.Value() = 5U;
                    listHolder_3->mList[4].deviceType.SetNull();

                    listHolder_3->mList[5].cluster.SetNull();
                    listHolder_3->mList[5].endpoint.SetNonNull();
                    listHolder_3->mList[5].endpoint.Value() = 6U;
                    listHolder_3->mList[5].deviceType.SetNull();

                    listHolder_3->mList[6].cluster.SetNull();
                    listHolder_3->mList[6].endpoint.SetNonNull();
                    listHolder_3->mList[6].endpoint.Value() = 7U;
                    listHolder_3->mList[6].deviceType.SetNull();

                    listHolder_3->mList[7].cluster.SetNull();
                    listHolder_3->mList[7].endpoint.SetNonNull();
                    listHolder_3->mList[7].endpoint.Value() = 8U;
                    listHolder_3->mList[7].deviceType.SetNull();

                    listHolder_3->mList[8].cluster.SetNull();
                    listHolder_3->mList[8].endpoint.SetNonNull();
                    listHolder_3->mList[8].endpoint.Value() = 9U;
                    listHolder_3->mList[8].deviceType.SetNull();

                    listHolder_3->mList[9].cluster.SetNull();
                    listHolder_3->mList[9].endpoint.SetNonNull();
                    listHolder_3->mList[9].endpoint.Value() = 10U;
                    listHolder_3->mList[9].deviceType.SetNull();

                    listHolder_3->mList[10].cluster.SetNull();
                    listHolder_3->mList[10].endpoint.SetNonNull();
                    listHolder_3->mList[10].endpoint.Value() = 11U;
                    listHolder_3->mList[10].deviceType.SetNull();

                    listHolder_3->mList[11].cluster.SetNull();
                    listHolder_3->mList[11].endpoint.SetNonNull();
                    listHolder_3->mList[11].endpoint.Value() = 12U;
                    listHolder_3->mList[11].deviceType.SetNull();

                    listHolder_3->mList[12].cluster.SetNull();
                    listHolder_3->mList[12].endpoint.SetNonNull();
                    listHolder_3->mList[12].endpoint.Value() = 13U;
                    listHolder_3->mList[12].deviceType.SetNull();

                    listHolder_3->mList[13].cluster.SetNull();
                    listHolder_3->mList[13].endpoint.SetNonNull();
                    listHolder_3->mList[13].endpoint.Value() = 14U;
                    listHolder_3->mList[13].deviceType.SetNull();

                    listHolder_3->mList[14].cluster.SetNull();
                    listHolder_3->mList[14].endpoint.SetNonNull();
                    listHolder_3->mList[14].endpoint.Value() = 15U;
                    listHolder_3->mList[14].deviceType.SetNull();

                    listHolder_3->mList[15].cluster.SetNull();
                    listHolder_3->mList[15].endpoint.SetNonNull();
                    listHolder_3->mList[15].endpoint.Value() = 16U;
                    listHolder_3->mList[15].deviceType.SetNull();

                    listHolder_3->mList[16].cluster.SetNull();
                    listHolder_3->mList[16].endpoint.SetNonNull();
                    listHolder_3->mList[16].endpoint.Value() = 17U;
                    listHolder_3->mList[16].deviceType.SetNull();

                    listHolder_3->mList[17].cluster.SetNull();
                    listHolder_3->mList[17].endpoint.SetNonNull();
                    listHolder_3->mList[17].endpoint.Value() = 18U;
                    listHolder_3->mList[17].deviceType.SetNull();

                    listHolder_3->mList[18].cluster.SetNull();
                    listHolder_3->mList[18].endpoint.SetNonNull();
                    listHolder_3->mList[18].endpoint.Value() = 19U;
                    listHolder_3->mList[18].deviceType.SetNull();

                    listHolder_3->mList[19].cluster.SetNull();
                    listHolder_3->mList[19].endpoint.SetNonNull();
                    listHolder_3->mList[19].endpoint.Value() = 20U;
                    listHolder_3->mList[19].deviceType.SetNull();

                    listHolder_0->mList[1].targets.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::Target::Type>(listHolder_3->mList,
                                                                                                              20);
                }
                listHolder_0->mList[1].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 16: {
            LogStep(16, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 17: {
            LogStep(17, "Restore ACL");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 1);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 18: {
            LogStep(18, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id);
        }
        case 19: {
            LogStep(19, "Validate resource minima (SubjectsPerAccessControlEntry)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id,
                                 AccessControl::Attributes::SubjectsPerAccessControlEntry::Id);
        }
        case 20: {
            LogStep(20, "Validate resource minima (TargetsPerAccessControlEntry)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id,
                                 AccessControl::Attributes::TargetsPerAccessControlEntry::Id);
        }
        case 21: {
            LogStep(21, "Validate resource minima (AccessControlEntriesPerFabric)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id,
                                 AccessControl::Attributes::AccessControlEntriesPerFabric::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BI_1_1Suite : public TestCommand
{
public:
    Test_TC_BI_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BI_1_1", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BI_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "write the default values to mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                  BinaryInputBasic::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            LogStep(4, "reads back global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::ClusterRevision::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::AttributeList::Id);
        }
        case 6: {
            LogStep(6, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::AcceptedCommandList::Id);
        }
        case 7: {
            LogStep(7, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::GeneratedCommandList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BI_2_1Suite : public TestCommand
{
public:
    Test_TC_BI_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BI_2_1", 12, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BI_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("outOfService", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("outOfService", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("presentValue", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 15));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read mandatory non-global attribute: OutOfService");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 2: {
            LogStep(2, "Read mandatory non-global attribute constraints: OutOfService");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 3: {
            LogStep(3, "Write the default values to mandatory non-global attribute: OutOfService");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                  BinaryInputBasic::Attributes::OutOfService::Id, value);
        }
        case 4: {
            LogStep(4, "Reads back the mandatory non-global attribute: OutOfService");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 5: {
            LogStep(5, "Read mandatory non-global attribute constraints: PresentValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::PresentValue::Id);
        }
        case 6: {
            LogStep(6, "Write the default values to mandatory non-global attribute: PresentValue");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                  BinaryInputBasic::Attributes::PresentValue::Id, value);
        }
        case 7: {
            LogStep(7, "Reads back the mandatory non-global attribute: PresentValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::PresentValue::Id);
        }
        case 8: {
            LogStep(8, "Read mandatory non-global attribute: StatusFlags");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 9: {
            LogStep(9, "Read mandatory non-global attribute constraints: StatusFlags");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 10: {
            LogStep(10, "Write the default values to mandatory non-global attribute: StatusFlags");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                  BinaryInputBasic::Attributes::StatusFlags::Id, value);
        }
        case 11: {
            LogStep(11, "Reads back the mandatory non-global attribute: StatusFlags");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BI_2_2Suite : public TestCommand
{
public:
    Test_TC_BI_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BI_2_2", 9, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BI_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("presentValue", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("outOfService", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("presentValue", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("outOfService", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusFlags", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads PresentValue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_PRESENTVALUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::PresentValue::Id);
        }
        case 2: {
            LogStep(2, "Reads OutOfService attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OUTOFSERVICE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 3: {
            LogStep(3, "Reads StatusFlags attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_STATUSFLAGS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 4: {
            LogStep(4, "Reads PresentValue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_PRESENTVALUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::PresentValue::Id);
        }
        case 5: {
            LogStep(5, "Reads OutOfService attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OUTOFSERVICE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::OutOfService::Id);
        }
        case 6: {
            LogStep(6, "Reads StatusFlags attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_STATUSFLAGS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 7: {
            LogStep(7, "Reads StatusFlags attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_STATUSFLAGS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        case 8: {
            LogStep(8, "Reads StatusFlags attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_STATUSFLAGS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BinaryInputBasic::Id,
                                 BinaryInputBasic::Attributes::StatusFlags::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BOOL_1_1Suite : public TestCommand
{
public:
    Test_TC_BOOL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BOOL_1_1", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BOOL_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 0));
                    VerifyOrReturn(CheckValue("attributeList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 1));
                    VerifyOrReturn(CheckValue("attributeList[1]", iter_0.GetValue(), 65528UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 2));
                    VerifyOrReturn(CheckValue("attributeList[2]", iter_0.GetValue(), 65529UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 3));
                    VerifyOrReturn(CheckValue("attributeList[3]", iter_0.GetValue(), 65531UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 4));
                    VerifyOrReturn(CheckValue("attributeList[4]", iter_0.GetValue(), 65533UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("attributeList", iter_0, 5));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acceptedCommandList", iter_0, 0));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("generatedCommandList", iter_0, 0));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints : ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::AttributeList::Id);
        }
        case 4: {
            LogStep(4,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 5: {
            LogStep(5, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id,
                                 BooleanState::Attributes::AcceptedCommandList::Id);
        }
        case 6: {
            LogStep(6, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id,
                                 BooleanState::Attributes::GeneratedCommandList::Id);
        }
        case 7: {
            LogStep(7,
                    "Read FeatureMap attribute from the DUT and Verify that the DUT response indicates FeatureMap attribute has "
                    "the value 0");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter '0' for success", "0");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BOOL_2_1Suite : public TestCommand
{
public:
    Test_TC_BOOL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BOOL_2_1", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BOOL_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("stateValue", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read mandatory non-global attribute: StateValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::StateValue::Id);
        }
        case 2: {
            LogStep(2, "Read mandatory non-global attribute constraints: StateValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BooleanState::Id, BooleanState::Attributes::StateValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BRAC_1_1Suite : public TestCommand
{
public:
    Test_TC_BRAC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BRAC_1_1", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BRAC_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BridgedActions::Id,
                                 BridgedActions::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BridgedActions::Id,
                                 BridgedActions::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BridgedActions::Id, BridgedActions::Attributes::AttributeList::Id);
        }
        case 4: {
            LogStep(4, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BridgedActions::Id,
                                 BridgedActions::Attributes::AcceptedCommandList::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), BridgedActions::Id,
                                 BridgedActions::Attributes::GeneratedCommandList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_1_1Suite : public TestCommand
{
public:
    Test_TC_CC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_1_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 5U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 5U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints : ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "write the default values to mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 5U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ClusterRevision::Id,
                                  value);
        }
        case 4: {
            LogStep(4, "reads back global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ClusterRevision::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::AttributeList::Id);
        }
        case 6: {
            LogStep(6,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 7: {
            LogStep(7, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::AcceptedCommandList::Id);
        }
        case 8: {
            LogStep(8, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::GeneratedCommandList::Id);
        }
        case 9: {
            LogStep(9,
                    "Read FeatureMap attribute from the DUT and Verify that the DUT response indicates FeatureMap attribute has "
                    "the value 0");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter '0' for success", "0");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_2_1Suite : public TestCommand
{
public:
    Test_TC_CC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_2_1", 139, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 254));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 254));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 254));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 254));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorControlOptions", value, 0));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 31U));
            }
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 31U));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 46:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 48:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 49:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 50:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 51:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("startUpColorTemperatureMireds", value, 0U));
            }
            break;
        case 52:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 54:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 55:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 4));
            }
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 57:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 4));
            }
            break;
        case 58:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 254));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 60:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 254));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 6));
            }
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 6));
            }
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 102:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 103:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 104:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 105:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 106:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 107:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 108:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("whitePointX", value, 0U));
            }
            break;
        case 109:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 110:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 111:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("whitePointY", value, 0U));
            }
            break;
        case 112:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 113:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 114:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointRX", value, 0U));
            }
            break;
        case 115:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 116:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 117:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointRY", value, 0U));
            }
            break;
        case 118:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 119:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 120:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointRIntensity", value, 0));
            }
            break;
        case 121:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 122:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 123:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointGX", value, 0U));
            }
            break;
        case 124:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 125:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 126:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointGY", value, 0U));
            }
            break;
        case 127:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 128:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 129:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointGIntensity", value, 0));
            }
            break;
        case 130:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 131:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 132:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointBX", value, 0U));
            }
            break;
        case 133:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 134:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 135:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointBY", value, 0U));
            }
            break;
        case 136:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 137:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 138:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorPointBIntensity", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Validate constraints of attribute: current hue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 2: {
            LogStep(2, "Write the default value to mandatory attribute: CurrentHue");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id,
                                  value);
        }
        case 3: {
            LogStep(3, "Reads back mandatory attribute: CurrentHue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 4: {
            LogStep(4, "Validate constraints of attribute: CurrentSaturation");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 5: {
            LogStep(5, "Write the default value to mandatory attribute: CurrentSaturation");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id,
                                  value);
        }
        case 6: {
            LogStep(6, "Reads back mandatory attribute: CurrentSaturation");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentSaturation::Id);
        }
        case 7: {
            LogStep(7, "Validate constraints of attribute: CurrentX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentX::Id);
        }
        case 8: {
            LogStep(8, "Write the default value to mandatory attribute: CurrentX");
            uint16_t value;
            value = 24939U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentX::Id, value);
        }
        case 9: {
            LogStep(9, "Reads back mandatory attribute: CurrentX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentX::Id);
        }
        case 10: {
            LogStep(10, "Validate constraints of attribute: CurrentY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentY::Id);
        }
        case 11: {
            LogStep(11, "Write the default values to mandatory attribute: CurrentY");
            uint16_t value;
            value = 24701U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentY::Id, value);
        }
        case 12: {
            LogStep(12, "Reads back mandatory attribute: CurrentY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentY::Id);
        }
        case 13: {
            LogStep(13, "Validate constraints of attribute: ColorTemperatureMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperature::Id);
        }
        case 14: {
            LogStep(14, "Validate constraints of attribute: ColorMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorMode::Id);
        }
        case 15: {
            LogStep(15, "Validate constraints of attribute: Options");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorControlOptions::Id);
        }
        case 16: {
            LogStep(16, "Write the default values to mandatory attribute: Options");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorControlOptions::Id, value);
        }
        case 17: {
            LogStep(17, "Reads back mandatory attribute: Options");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorControlOptions::Id);
        }
        case 18: {
            LogStep(18, "Validate constraints of attribute: EnhancedCurrentHue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 19: {
            LogStep(19, "Write the default values to mandatory attribute: EnhancedCurrentHue");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::EnhancedCurrentHue::Id, value);
        }
        case 20: {
            LogStep(20, "Reads back mandatory attribute: EnhancedCurrentHue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 21: {
            LogStep(21, "Validate constraints of attribute: EnhancedColorMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::EnhancedColorMode::Id);
        }
        case 22: {
            LogStep(22, "Validate constraints of attribute: ColorLoopActive");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 23: {
            LogStep(23, "Write the default values to mandatory attribute: ColorLoopActive");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id,
                                  value);
        }
        case 24: {
            LogStep(24, "Reads back mandatory attribute: ColorLoopActive");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 25: {
            LogStep(25, "Validate constraints of attribute: ColorLoopDirection");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 26: {
            LogStep(26, "Write the default values to mandatory attribute: ColorLoopDirection");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorLoopDirection::Id, value);
        }
        case 27: {
            LogStep(27, "Reads back mandatory attribute: ColorLoopDirection");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 28: {
            LogStep(28, "Validate constraints of attribute: ColorLoopTime");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 29: {
            LogStep(29, "Write the default values to mandatory attribute: ColorLoopTime");
            uint16_t value;
            value = 25U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id,
                                  value);
        }
        case 30: {
            LogStep(30, "Reads back mandatory attribute: ColorLoopTime");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 31: {
            LogStep(31, "Validate constraints of attribute: ColorLoopStartEnhancedHue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 32: {
            LogStep(32, "Write the default values to mandatory attribute: ColorLoopStartEnhancedHue");
            uint16_t value;
            value = 8960U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorLoopStartEnhancedHue::Id, value);
        }
        case 33: {
            LogStep(33, "Reads back mandatory attribute: ColorLoopStartEnhancedHue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 34: {
            LogStep(34, "Validate constraints of attribute: ColorLoopStoredEnhancedHue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 35: {
            LogStep(35, "Write the default values to mandatory attribute: ColorLoopStoredEnhancedHue");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id, value);
        }
        case 36: {
            LogStep(36, "Reads back mandatory attribute: ColorLoopStoredEnhancedHue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 37: {
            LogStep(37, "Validate constraints of attribute: ColorCapabilities");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorCapabilities::Id);
        }
        case 38: {
            LogStep(38, "Write the default values to mandatory attribute: ColorCapabilities");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorCapabilities::Id,
                                  value);
        }
        case 39: {
            LogStep(39, "Reads back mandatory attribute: ColorCapabilities");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorCapabilities::Id);
        }
        case 40: {
            LogStep(40, "Validate constraints of attribute: ColorTempPhysicalMinMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMin::Id);
        }
        case 41: {
            LogStep(41, "Write the default values to mandatory  attribute: ColorTempPhysicalMinMireds");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorTempPhysicalMin::Id, value);
        }
        case 42: {
            LogStep(42, "Reads back mandatory attribute: ColorTempPhysicalMinMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMin::Id);
        }
        case 43: {
            LogStep(43, "Validate constraints of attribute: ColorTempPhysicalMaxMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMax::Id);
        }
        case 44: {
            LogStep(44, "Write the default values to mandatory attribute: ColorTempPhysicalMaxMireds");
            uint16_t value;
            value = 65279U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorTempPhysicalMax::Id, value);
        }
        case 45: {
            LogStep(45, "Reads back mandatory attribute: ColorTempPhysicalMaxMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorTempPhysicalMax::Id);
        }
        case 46: {
            LogStep(46, "Read the optional attribute: CoupleColorTempToLevelMinMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Id);
        }
        case 47: {
            LogStep(47, "Write the default values to optional attribute: CoupleColorTempToLevelMinMireds");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Id, value);
        }
        case 48: {
            LogStep(48, "Reads back optional attribute: CoupleColorTempToLevelMinMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Id);
        }
        case 49: {
            LogStep(49, "Read the optional attribute: StartUpColorTemperatureMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::StartUpColorTemperatureMireds::Id);
        }
        case 50: {
            LogStep(50, "Write the default values to optional attribute: StartUpColorTemperatureMireds");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::StartUpColorTemperatureMireds::Id, value);
        }
        case 51: {
            LogStep(51, "Reads back optional attribute: StartUpColorTemperatureMireds");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::StartUpColorTemperatureMireds::Id);
        }
        case 52: {
            LogStep(52, "Validate constraints of attribute: RemainingTime");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::RemainingTime::Id);
        }
        case 53: {
            LogStep(53, "Write the default values to optional attribute: RemainingTime");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::RemainingTime::Id,
                                  value);
        }
        case 54: {
            LogStep(54, "Reads back optional attribute: RemainingTime");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::RemainingTime::Id);
        }
        case 55: {
            LogStep(55, "Read the optional attribute: DriftCompensation");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::DriftCompensation::Id);
        }
        case 56: {
            LogStep(56, "Write the default values to optional attribute: DriftCompensation");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::DriftCompensation::Id,
                                  value);
        }
        case 57: {
            LogStep(57, "Reads back optional attribute: DriftCompensation");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::DriftCompensation::Id);
        }
        case 58: {
            LogStep(58, "Read the optional attribute: CompensationText");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CompensationText::Id);
        }
        case 59: {
            LogStep(59, "Write the default values to optional attribute: CompensationText");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CompensationText::Id,
                                  value);
        }
        case 60: {
            LogStep(60, "Reads back optional attribute: CompensationText");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CompensationText::Id);
        }
        case 61: {
            LogStep(61, "Read the mandatory attribute: NumberOfPrimaries");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::NumberOfPrimaries::Id);
        }
        case 62: {
            LogStep(62, "Write the default mandatory attribute: NumberOfPrimaries");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::NumberOfPrimaries::Id,
                                  value);
        }
        case 63: {
            LogStep(63, "Read back the mandatory attribute: NumberOfPrimaries");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::NumberOfPrimaries::Id);
        }
        case 64: {
            LogStep(64, "Read the mandatory attribute: Primary1X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1X::Id);
        }
        case 65: {
            LogStep(65, "Write the default mandatory attribute: Primary1X");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1X::Id, value);
        }
        case 66: {
            LogStep(66, "Read back the mandatory attribute: Primary1X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1X::Id);
        }
        case 67: {
            LogStep(67, "Read the mandatory attribute: Primary1Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1Y::Id);
        }
        case 68: {
            LogStep(68, "Write the default mandatory attribute: Primary1Y");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1Y::Id, value);
        }
        case 69: {
            LogStep(69, "Read back the mandatory attribute: Primary1Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1Y::Id);
        }
        case 70: {
            LogStep(70, "Read the mandatory attribute: Primary1Intensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary1Intensity::Id);
        }
        case 71: {
            LogStep(71, "Read the mandatory attribute: Primary2X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2X::Id);
        }
        case 72: {
            LogStep(72, "Write the default mandatory attribute: Primary2X");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2X::Id, value);
        }
        case 73: {
            LogStep(73, "Read back the mandatory attribute: Primary2X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2X::Id);
        }
        case 74: {
            LogStep(74, "Read the mandatory attribute: Primary2Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2Y::Id);
        }
        case 75: {
            LogStep(75, "Write the default mandatory attribute: Primary2Y");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2Y::Id, value);
        }
        case 76: {
            LogStep(76, "Read back the mandatory attribute: Primary2Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2Y::Id);
        }
        case 77: {
            LogStep(77, "Validate constraints of attribute: Primary2Intensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary2Intensity::Id);
        }
        case 78: {
            LogStep(78, "Read the mandatory attribute: Primary3X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3X::Id);
        }
        case 79: {
            LogStep(79, "Write the default mandatory attribute: Primary3X");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3X::Id, value);
        }
        case 80: {
            LogStep(80, "Read back the mandatory attribute: Primary3X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3X::Id);
        }
        case 81: {
            LogStep(81, "Read the mandatory attribute: Primary3Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3Y::Id);
        }
        case 82: {
            LogStep(82, "Write the default mandatory attribute: Primary3Y");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3Y::Id, value);
        }
        case 83: {
            LogStep(83, "Read back the mandatory attribute: Primary3Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3Y::Id);
        }
        case 84: {
            LogStep(84, "Read the mandatory attribute: Primary3Intensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary3Intensity::Id);
        }
        case 85: {
            LogStep(85, "Read the mandatory attribute: Primary4X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4X::Id);
        }
        case 86: {
            LogStep(86, "Write the default mandatory attribute: Primary4X");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4X::Id, value);
        }
        case 87: {
            LogStep(87, "Read back the mandatory attribute: Primary4X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4X::Id);
        }
        case 88: {
            LogStep(88, "Read the mandatory attribute: Primary4Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4Y::Id);
        }
        case 89: {
            LogStep(89, "Write the default mandatory attribute: Primary4Y");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4Y::Id, value);
        }
        case 90: {
            LogStep(90, "Read back the mandatory attribute: Primary4Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4Y::Id);
        }
        case 91: {
            LogStep(91, "Read the mandatory attribute: Primary4Intensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary4Intensity::Id);
        }
        case 92: {
            LogStep(92, "Read the mandatory attribute: Primary5X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5X::Id);
        }
        case 93: {
            LogStep(93, "Write the default mandatory attribute: Primary5X");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5X::Id, value);
        }
        case 94: {
            LogStep(94, "Read back the mandatory attribute: Primary5X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5X::Id);
        }
        case 95: {
            LogStep(95, "Read the mandatory attribute: Primary5Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5Y::Id);
        }
        case 96: {
            LogStep(96, "Write the default mandatory attribute: Primary5Y");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5Y::Id, value);
        }
        case 97: {
            LogStep(97, "Read back the mandatory attribute: Primary5Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5Y::Id);
        }
        case 98: {
            LogStep(98, "Read the mandatory attribute: Primary5Intensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary5Intensity::Id);
        }
        case 99: {
            LogStep(99, "Read the mandatory attribute: Primary6X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6X::Id);
        }
        case 100: {
            LogStep(100, "Write the default mandatory attribute: Primary6X");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6X::Id, value);
        }
        case 101: {
            LogStep(101, "Read back the mandatory attribute: Primary6X");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6X::Id);
        }
        case 102: {
            LogStep(102, "Read the mandatory attribute: Primary6Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6Y::Id);
        }
        case 103: {
            LogStep(103, "Write the default mandatory attribute: Primary6Y");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6Y::Id, value);
        }
        case 104: {
            LogStep(104, "Read back the mandatory attribute: Primary6Y");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6Y::Id);
        }
        case 105: {
            LogStep(105, "Read the mandatory attribute: Primary6Intensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::Primary6Intensity::Id);
        }
        case 106: {
            LogStep(106, "Read the optional attribute: WhitePointX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointX::Id);
        }
        case 107: {
            LogStep(107, "Write the default optional attribute: WhitePointX");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointX::Id,
                                  value);
        }
        case 108: {
            LogStep(108, "Read back the optional attribute: WhitePointX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointX::Id);
        }
        case 109: {
            LogStep(109, "Read the optional attribute: WhitePointY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointY::Id);
        }
        case 110: {
            LogStep(110, "Write the default optional attribute: WhitePointY");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointY::Id,
                                  value);
        }
        case 111: {
            LogStep(111, "Read back the optional attribute: WhitePointY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::WhitePointY::Id);
        }
        case 112: {
            LogStep(112, "Read the optional attribute: ColorPointRX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRX::Id);
        }
        case 113: {
            LogStep(113, "Write the default optional attribute: ColorPointRX");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRX::Id,
                                  value);
        }
        case 114: {
            LogStep(114, "Read back the optional attribute: ColorPointRX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRX::Id);
        }
        case 115: {
            LogStep(115, "Read the optional attribute: ColorPointRY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRY::Id);
        }
        case 116: {
            LogStep(116, "Write the default optional attribute: ColorPointRY");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRY::Id,
                                  value);
        }
        case 117: {
            LogStep(117, "Read back the optional attribute: ColorPointRY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointRY::Id);
        }
        case 118: {
            LogStep(118, "Read the optional attribute: ColorPointRIntensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointRIntensity::Id);
        }
        case 119: {
            LogStep(119, "Write the default optional attribute: ColorPointRIntensity");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorPointRIntensity::Id, value);
        }
        case 120: {
            LogStep(120, "Read back the optional attribute: ColorPointRIntensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointRIntensity::Id);
        }
        case 121: {
            LogStep(121, "Read the optional attribute: ColorPointGX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGX::Id);
        }
        case 122: {
            LogStep(122, "Write the default optional attribute: ColorPointGX");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGX::Id,
                                  value);
        }
        case 123: {
            LogStep(123, "Read back the optional attribute: ColorPointGX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGX::Id);
        }
        case 124: {
            LogStep(124, "Read the optional attribute: ColorPointGY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGY::Id);
        }
        case 125: {
            LogStep(125, "Write the default optional attribute: ColorPointGY");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGY::Id,
                                  value);
        }
        case 126: {
            LogStep(126, "Read back the optional attribute: ColorPointGY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointGY::Id);
        }
        case 127: {
            LogStep(127, "Read the optional attribute: ColorPointGIntensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointGIntensity::Id);
        }
        case 128: {
            LogStep(128, "Write the default optional attribute: ColorPointGIntensity");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorPointGIntensity::Id, value);
        }
        case 129: {
            LogStep(129, "Read back the optional attribute: ColorPointGIntensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointGIntensity::Id);
        }
        case 130: {
            LogStep(130, "Read the optional attribute: ColorPointBX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBX::Id);
        }
        case 131: {
            LogStep(131, "Write the default optional attribute: ColorPointBX");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBX::Id,
                                  value);
        }
        case 132: {
            LogStep(132, "Read back the optional attribute: ColorPointBX");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBX::Id);
        }
        case 133: {
            LogStep(133, "Read the optional attribute: ColorPointBY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBY::Id);
        }
        case 134: {
            LogStep(134, "Write the default optional attribute: ColorPointBY");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBY::Id,
                                  value);
        }
        case 135: {
            LogStep(135, "Read back the optional attribute: ColorPointBY");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorPointBY::Id);
        }
        case 136: {
            LogStep(136, "Read the optional attribute: ColorPointBIntensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointBIntensity::Id);
        }
        case 137: {
            LogStep(137, "Write the default optional attribute: ColorPointBIntensity");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                  ColorControl::Attributes::ColorPointBIntensity::Id, value);
        }
        case 138: {
            LogStep(138, "Read back the optional attribute: ColorPointBIntensity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorPointBIntensity::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_3_1Suite : public TestCommand
{
public:
    Test_TC_CC_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_3_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 254));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Reads CurrentHue attribute from DUT.");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::CurrentHue::Id);
        }
        case 4: {
            LogStep(4, "Move to hue shortest distance command");
            chip::app::Clusters::ColorControl::Commands::MoveToHue::Type value;
            value.hue             = 150;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id, value);
        }
        case 5: {
            LogStep(5, "Move to hue longest distance command");
            chip::app::Clusters::ColorControl::Commands::MoveToHue::Type value;
            value.hue             = 200;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id, value);
        }
        case 6: {
            LogStep(6, "Move to hue up command");
            chip::app::Clusters::ColorControl::Commands::MoveToHue::Type value;
            value.hue             = 250;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id, value);
        }
        case 7: {
            LogStep(7, "Move to hue down command");
            chip::app::Clusters::ColorControl::Commands::MoveToHue::Type value;
            value.hue             = 225;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHue::Id, value);
        }
        case 8: {
            LogStep(8, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 9: {
            LogStep(9, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_3_2Suite : public TestCommand
{
public:
    Test_TC_CC_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_3_2", 9, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_3_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Move hue up command");
            chip::app::Clusters::ColorControl::Commands::MoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
            value.rate            = 50;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id, value);
        }
        case 4: {
            LogStep(4, "Move hue stop command");
            chip::app::Clusters::ColorControl::Commands::MoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate            = 50;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id, value);
        }
        case 5: {
            LogStep(5, "Move hue down command");
            chip::app::Clusters::ColorControl::Commands::MoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
            value.rate            = 50;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id, value);
        }
        case 6: {
            LogStep(6, "Move hue stop command");
            chip::app::Clusters::ColorControl::Commands::MoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate            = 50;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveHue::Id, value);
        }
        case 7: {
            LogStep(7, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 8: {
            LogStep(8, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_3_3Suite : public TestCommand
{
public:
    Test_TC_CC_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_3_3", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_3_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Step hue up command");
            chip::app::Clusters::ColorControl::Commands::StepHue::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
            value.stepSize        = 5;
            value.transitionTime  = 25;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepHue::Id, value);
        }
        case 4: {
            LogStep(4, "Step hue down command");
            chip::app::Clusters::ColorControl::Commands::StepHue::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
            value.stepSize        = 5;
            value.transitionTime  = 25;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepHue::Id, value);
        }
        case 5: {
            LogStep(5, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            LogStep(6, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_1Suite : public TestCommand
{
public:
    Test_TC_CC_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_4_1", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_4_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Move to saturation command");
            chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type value;
            value.saturation      = 90;
            value.transitionTime  = 10U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToSaturation::Id,
                               value);
        }
        case 4: {
            LogStep(4, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            LogStep(5, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_2Suite : public TestCommand
{
public:
    Test_TC_CC_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_4_2", 11, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_4_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Move saturation up command");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 4: {
            LogStep(4, "Move saturation down command");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 5: {
            LogStep(5, "Move saturation up command");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 6: {
            LogStep(6, "Move saturation stop command");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(0);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 7: {
            LogStep(7, "Move saturation down command");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 8: {
            LogStep(8, "Move saturation stop command");
            chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(0);
            value.rate            = 5;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveSaturation::Id, value);
        }
        case 9: {
            LogStep(9, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 10: {
            LogStep(10, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_3Suite : public TestCommand
{
public:
    Test_TC_CC_4_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_4_3", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_4_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Step saturation up command");
            chip::app::Clusters::ColorControl::Commands::StepSaturation::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(1);
            value.stepSize        = 15;
            value.transitionTime  = 10;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepSaturation::Id, value);
        }
        case 4: {
            LogStep(4, "Step saturation down command");
            chip::app::Clusters::ColorControl::Commands::StepSaturation::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(3);
            value.stepSize        = 20;
            value.transitionTime  = 10;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepSaturation::Id, value);
        }
        case 5: {
            LogStep(5, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            LogStep(6, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_4_4Suite : public TestCommand
{
public:
    Test_TC_CC_4_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_4_4", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_4_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Move To current hue and saturation command");
            chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type value;
            value.hue             = 40;
            value.saturation      = 160;
            value.transitionTime  = 10U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToHueAndSaturation::Id,
                               value);
        }
        case 4: {
            LogStep(4, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            LogStep(5, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_5_1Suite : public TestCommand
{
public:
    Test_TC_CC_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_5_1", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_5_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Move to Color command");
            chip::app::Clusters::ColorControl::Commands::MoveToColor::Type value;
            value.colorX          = 200U;
            value.colorY          = 300U;
            value.transitionTime  = 20U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToColor::Id, value);
        }
        case 4: {
            LogStep(4, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            LogStep(5, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_5_2Suite : public TestCommand
{
public:
    Test_TC_CC_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_5_2", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_5_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Move Color command");
            chip::app::Clusters::ColorControl::Commands::MoveColor::Type value;
            value.rateX           = 15;
            value.rateY           = 20;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColor::Id, value);
        }
        case 4: {
            LogStep(4, "Stop Move Step command");
            chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type value;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StopMoveStep::Id, value);
        }
        case 5: {
            LogStep(5, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            LogStep(6, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_5_3Suite : public TestCommand
{
public:
    Test_TC_CC_5_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_5_3", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_5_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Step Color command");
            chip::app::Clusters::ColorControl::Commands::StepColor::Type value;
            value.stepX           = 15;
            value.stepY           = 20;
            value.transitionTime  = 50U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepColor::Id, value);
        }
        case 4: {
            LogStep(4, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            LogStep(5, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_6_1Suite : public TestCommand
{
public:
    Test_TC_CC_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_6_1", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_6_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Move To Color Temperature command");
            chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type value;
            value.colorTemperature = 100U;
            value.transitionTime   = 10U;
            value.optionsMask      = 0;
            value.optionsOverride  = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveToColorTemperature::Id,
                               value);
        }
        case 4: {
            LogStep(4, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            LogStep(5, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_6_2Suite : public TestCommand
{
public:
    Test_TC_CC_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_6_2", 12, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_6_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65279U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Read current color temprature");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorTemperature::Id);
        }
        case 4: {
            LogStep(4, "Move up color temperature command");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
            value.rate                    = 10U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 5: {
            LogStep(5, "Move down color temperature command");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
            value.rate                    = 20U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 6: {
            LogStep(6, "Move up color temperature command");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
            value.rate                    = 10U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 7: {
            LogStep(7, "Stop Color Temperature command");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate                    = 10U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 8: {
            LogStep(8, "Move down color temperature command");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
            value.rate                    = 20U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 9: {
            LogStep(9, "Stop Color Temperature command");
            chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type value;
            value.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate                    = 10U;
            value.colorTemperatureMinimum = 1U;
            value.colorTemperatureMaximum = 255U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::MoveColorTemperature::Id,
                               value);
        }
        case 10: {
            LogStep(10, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 11: {
            LogStep(11, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_6_3Suite : public TestCommand
{
public:
    Test_TC_CC_6_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_6_3", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_6_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Step up color temperature command");
            chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type value;
            value.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
            value.stepSize                = 5U;
            value.transitionTime          = 50U;
            value.colorTemperatureMinimum = 5U;
            value.colorTemperatureMaximum = 100U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepColorTemperature::Id,
                               value);
        }
        case 4: {
            LogStep(4, "Step down color temperature command");
            chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type value;
            value.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
            value.stepSize                = 5U;
            value.transitionTime          = 50U;
            value.colorTemperatureMinimum = 5U;
            value.colorTemperatureMaximum = 100U;
            value.optionsMask             = 0;
            value.optionsOverride         = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::StepColorTemperature::Id,
                               value);
        }
        case 5: {
            LogStep(5, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            LogStep(6, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_1Suite : public TestCommand
{
public:
    Test_TC_CC_7_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_7_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_7_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Enhanced Move To Hue command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1025U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
            value.transitionTime  = 1U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 4: {
            LogStep(4, "Enhanced Move To Hue command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1100U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 5: {
            LogStep(5, "Enhanced Move To Hue command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1150U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 6: {
            LogStep(6, "Enhanced Move To Hue command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1200U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 7: {
            LogStep(7, "Enhanced Move To Hue command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 1300U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
            value.transitionTime  = 300U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 8: {
            LogStep(8, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 9: {
            LogStep(9, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_2Suite : public TestCommand
{
public:
    Test_TC_CC_7_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_7_2", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_7_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Check EnhancedCurrentHue attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 4: {
            LogStep(4, "Enhanced Move Hue Up command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
            value.rate            = 50U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id,
                               value);
        }
        case 5: {
            LogStep(5, "Enhanced Move Hue Stop command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate            = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id,
                               value);
        }
        case 6: {
            LogStep(6, "Enhanced Move Hue Down command ");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
            value.rate            = 5U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id,
                               value);
        }
        case 7: {
            LogStep(7, "Enhanced Move Hue Stop command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type value;
            value.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
            value.rate            = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveHue::Id,
                               value);
        }
        case 8: {
            LogStep(8, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 9: {
            LogStep(9, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_3Suite : public TestCommand
{
public:
    Test_TC_CC_7_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_7_3", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_7_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Enhanced Step Hue Up command");
            chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(0);
            value.stepSize        = 50U;
            value.transitionTime  = 1U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedStepHue::Id,
                               value);
        }
        case 4: {
            LogStep(4, "Enhanced Step Hue Down command");
            chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type value;
            value.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
            value.stepSize        = 75U;
            value.transitionTime  = 1U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedStepHue::Id,
                               value);
        }
        case 5: {
            LogStep(5, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            LogStep(6, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_7_4Suite : public TestCommand
{
public:
    Test_TC_CC_7_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_7_4", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_7_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Enhanced move to hue and saturation command");
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type value;
            value.enhancedHue     = 1200U;
            value.saturation      = 90;
            value.transitionTime  = 10U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                               ColorControl::Commands::EnhancedMoveToHueAndSaturation::Id, value);
        }
        case 4: {
            LogStep(4, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 5: {
            LogStep(5, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_8_1Suite : public TestCommand
{
public:
    Test_TC_CC_8_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_8_1", 17, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_8_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 100U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 500U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 3500U));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Color Loop Set Command - Set all Attributes");
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(14);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 100U;
            value.startHue        = 500U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 4: {
            LogStep(4, "Check ColorLoopDirection Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 5: {
            LogStep(5, "Check ColorLoopTime Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 6: {
            LogStep(6, "Check ColorLoopStartEnhancedHue Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 7: {
            LogStep(7, "Check ColorLoopActive Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 8: {
            LogStep(8, "Color Loop Set Command - Start Color Loop");
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 9: {
            LogStep(9, "Check ColorLoopActive Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 10: {
            LogStep(10, "Color Loop Set Command - Set direction and time while running");
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(6);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 3500U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 11: {
            LogStep(11, "Check ColorLoopDirection Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 12: {
            LogStep(12, "Check ColorLoopTime Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 13: {
            LogStep(13, "Color Loop Set Command - Set direction while running");
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 14: {
            LogStep(14, "Check ColorLoopDirection Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 15: {
            LogStep(15, "Turn off light that we turned on");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 16: {
            LogStep(16, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_9_1Suite : public TestCommand
{
public:
    Test_TC_CC_9_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_9_1", 54, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_9_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint16_t EnhancedCurrentHueValue1;
    uint16_t ColorLoopStoredEnhancedHueValue1;
    uint16_t EnhancedCurrentHueValue2;
    uint16_t ColorLoopStoredEnhancedHueValue2;
    uint16_t EnhancedCurrentHueValue3;
    uint16_t ColorLoopStoredEnhancedHueValue3;
    uint16_t EnhancedCurrentHueValue4;
    uint16_t ColorLoopStoredEnhancedHue4;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 30U));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 160U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue1 = value;
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue1));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue1 = value;
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue1));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue2 = value;
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue2));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue2 = value;
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue2));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, 40960U));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue3 = value;
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue3));
            }
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue3 = value;
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue3));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue4 = value;
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue4));
            }
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHue4 = value;
            }
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHue4));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Precondition : Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 4: {
            LogStep(4, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 5: {
            LogStep(5, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 6: {
            LogStep(6, "Read ColorLoopDirection attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 7: {
            LogStep(7, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 30U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 8: {
            LogStep(8, "Read ColorLoopTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 9: {
            LogStep(9, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(8);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 160U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 10: {
            LogStep(10, "Read ColorLoopStartEnhancedHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 11: {
            LogStep(11, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 12: {
            LogStep(12, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 13: {
            LogStep(13, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 14: {
            LogStep(14, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 15: {
            LogStep(15, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 16: {
            LogStep(16, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 17: {
            LogStep(17, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 18: {
            LogStep(18, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 19: {
            LogStep(19, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 20: {
            LogStep(20, "Read ColorLoopDirection attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 21: {
            LogStep(21, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 22: {
            LogStep(22, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 23: {
            LogStep(23, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 24: {
            LogStep(24, "Read ColorLoopStoredEnhancedHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 25: {
            LogStep(25, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 26: {
            LogStep(26, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 27: {
            LogStep(27, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 28: {
            LogStep(28, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 29: {
            LogStep(29, "Enhanced Move To Hue command");
            VerifyOrdo(!ShouldSkip("CR_ENHANCEDMOVETOHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type value;
            value.enhancedHue     = 40960U;
            value.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
            value.transitionTime  = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::EnhancedMoveToHue::Id,
                               value);
        }
        case 30: {
            LogStep(30, "Wait 2000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 31: {
            LogStep(31, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 32: {
            LogStep(32, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 33: {
            LogStep(33, "Read ColorLoopDirection attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 34: {
            LogStep(34, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 35: {
            LogStep(35, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 36: {
            LogStep(36, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 37: {
            LogStep(37, "Read ColorLoopStoredEnhancedHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 38: {
            LogStep(38, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 39: {
            LogStep(39, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 40: {
            LogStep(40, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 41: {
            LogStep(41, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 42: {
            LogStep(42, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 43: {
            LogStep(43, "Read ColorLoopDirection attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 44: {
            LogStep(44, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 45: {
            LogStep(45, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 46: {
            LogStep(46, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 47: {
            LogStep(47, "Read ColorLoopStoredEnhancedHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 48: {
            LogStep(48, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 49: {
            LogStep(49, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 50: {
            LogStep(50, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 51: {
            LogStep(51, "Read EnhancedCurrentHue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 52: {
            LogStep(52, "Turn Off light for color control tests");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 53: {
            LogStep(53, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_9_2Suite : public TestCommand
{
public:
    Test_TC_CC_9_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_9_2", 20, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_9_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint16_t EnhancedCurrentHueValue;
    uint16_t ColorLoopStoredEnhancedHueValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 30U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 160U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue = value;
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 1));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue = value;
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Precondition: Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Precondition: Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 30U;
            value.startHue        = 160U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 4: {
            LogStep(4, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 5: {
            LogStep(5, "Read ColorLoopDirection attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 6: {
            LogStep(6, "Read ColorLoopTime attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 7: {
            LogStep(7, "Read ColorLoopStartEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 8: {
            LogStep(8, "Read EnhancedCurrentHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 9: {
            LogStep(9, "Color Loop Set Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 10: {
            LogStep(10, "Read ColorLoopActive attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 11: {
            LogStep(11, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 12: {
            LogStep(12, "Color Loop Set Command - Start Color Loop");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 13: {
            LogStep(13, "Read ColorLoopDirection attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 14: {
            LogStep(14, "Color Loop Set Command - Start Color Loop");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 15: {
            LogStep(15, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 16: {
            LogStep(16, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 17: {
            LogStep(17, "Read EnhancedCurrentHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 18: {
            LogStep(18, "Turn off light for color control tests");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 19: {
            LogStep(19, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_CC_9_3Suite : public TestCommand
{
public:
    Test_TC_CC_9_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_CC_9_3", 20, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_CC_9_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint16_t EnhancedCurrentHueValue;
    uint16_t ColorLoopStoredEnhancedHueValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopDirection", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 30U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStartEnhancedHue", value, 160U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 1));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                EnhancedCurrentHueValue = value;
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopStoredEnhancedHue", value, EnhancedCurrentHueValue));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopTime", value, 60U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("colorLoopActive", value, 0));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                ColorLoopStoredEnhancedHueValue = value;
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enhancedCurrentHue", value, ColorLoopStoredEnhancedHueValue));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Precondition: Turn on light for color control tests");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Precondition: Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Sends ColorLoopSet Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 30U;
            value.startHue        = 160U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 4: {
            LogStep(4, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 5: {
            LogStep(5, "Read ColorLoopDirection attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPDIRECTION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopDirection::Id);
        }
        case 6: {
            LogStep(6, "Read ColorLoopTime attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 7: {
            LogStep(7, "Read ColorLoopStartEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTARTENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStartEnhancedHue::Id);
        }
        case 8: {
            LogStep(8, "Color Loop Set Command - Set all Attributes");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 9: {
            LogStep(9, "Read ColorLoopActive attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 10: {
            LogStep(10, "Read EnhancedCurrentHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 11: {
            LogStep(11, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 12: {
            LogStep(12, "Color Loop Set Command - Start Color Loop");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 60U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 13: {
            LogStep(13, "Read ColorLoopTime attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopTime::Id);
        }
        case 14: {
            LogStep(14, "Color Loop Set Command - Start Color Loop");
            VerifyOrdo(!ShouldSkip("CR_COLORLOOPSET"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type value;
            value.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
            value.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
            value.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
            value.time            = 0U;
            value.startHue        = 0U;
            value.optionsMask     = 0;
            value.optionsOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Commands::ColorLoopSet::Id, value);
        }
        case 15: {
            LogStep(15, "Read ColorLoopActive attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPACTIVE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id, ColorControl::Attributes::ColorLoopActive::Id);
        }
        case 16: {
            LogStep(16, "Read ColorLoopStoredEnhancedHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_COLORLOOPSTOREDENHANCEDHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::ColorLoopStoredEnhancedHue::Id);
        }
        case 17: {
            LogStep(17, "Read EnhancedCurrentHue attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_ENHANCEDCURRENTHUE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ColorControl::Id,
                                 ColorControl::Attributes::EnhancedCurrentHue::Id);
        }
        case 18: {
            LogStep(18, "Turn off light for color control tests");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 19: {
            LogStep(19, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_1_1Suite : public TestCommand
{
public:
    Test_TC_DM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_1_1", 20, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintFormat("value", "", "ISO 3166-1 alpha-2"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 2));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMinLength("value", value.size(), 1));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 64));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintFormat("value", "", "ASCII"));
                VerifyOrReturn(CheckConstraintMinLength("value", value.size(), 1));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 64));
            }
            break;
        case 12:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintFormat("value", "", "ISO 8601"));
                VerifyOrReturn(CheckConstraintMinLength("value", value.size(), 8));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 16));
            }
            break;
        case 13:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 14:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintFormat("value", "", "RFC3986"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 256));
            }
            break;
        case 15:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 64));
            }
            break;
        case 16:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 17:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "boolean"));
            }
            break;
        case 18:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "boolean"));
            }
            break;
        case 19:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Query Data Model Revision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::DataModelRevision::Id);
        }
        case 2: {
            LogStep(2, "Query Vendor Name");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::VendorName::Id);
        }
        case 3: {
            LogStep(3, "Query VendorID");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::VendorID::Id);
        }
        case 4: {
            LogStep(4, "Query Product Name");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ProductName::Id);
        }
        case 5: {
            LogStep(5, "Query ProductID");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ProductID::Id);
        }
        case 6: {
            LogStep(6, "Query Node Label");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 7: {
            LogStep(7, "Query User Location");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id);
        }
        case 8: {
            LogStep(8, "Query HardwareVersion");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::HardwareVersion::Id);
        }
        case 9: {
            LogStep(9, "Query HardwareVersionString");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::HardwareVersionString::Id);
        }
        case 10: {
            LogStep(10, "Query SoftwareVersion");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::SoftwareVersion::Id);
        }
        case 11: {
            LogStep(11, "Query SoftwareVersionString");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::SoftwareVersionString::Id);
        }
        case 12: {
            LogStep(12, "Query ManufacturingDate");
            VerifyOrdo(!ShouldSkip("MANF_DATE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ManufacturingDate::Id);
        }
        case 13: {
            LogStep(13, "Query PartNumber");
            VerifyOrdo(!ShouldSkip("PART_NUM"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::PartNumber::Id);
        }
        case 14: {
            LogStep(14, "Query ProductURL");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ProductURL::Id);
        }
        case 15: {
            LogStep(15, "Query ProductLabel");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::ProductLabel::Id);
        }
        case 16: {
            LogStep(16, "Query SerialNumber");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::SerialNumber::Id);
        }
        case 17: {
            LogStep(17, "Query LocalConfigDisabled");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::LocalConfigDisabled::Id);
        }
        case 18: {
            LogStep(18, "Query Reachable");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Reachable::Id);
        }
        case 19: {
            LogStep(19, "Query UniqueID");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::UniqueID::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_3_1Suite : public TestCommand
{
public:
    Test_TC_DM_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_3_1", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 2:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Query MaxNetworks");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), NetworkCommissioning::Id,
                                 NetworkCommissioning::Attributes::MaxNetworks::Id);
        }
        case 2: {
            LogStep(2, "Query Networks");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), NetworkCommissioning::Id,
                                 NetworkCommissioning::Attributes::Networks::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_2_2Suite : public TestCommand
{
public:
    Test_TC_DM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_2_2", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("supportedFabrics", value, 16));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("commissionedFabrics", value, 1));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Query fabrics list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        case 2: {
            LogStep(2, "Query Supported Fabrics");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::SupportedFabrics::Id);
        }
        case 3: {
            LogStep(3, "Query Commissioned Fabrics");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::CommissionedFabrics::Id);
        }
        case 4: {
            LogStep(4, "Query User Trusted Root Certificates");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::TrustedRootCertificates::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_EMR_1_1Suite : public TestCommand
{
public:
    Test_TC_EMR_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_EMR_1_1", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_EMR_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                 ElectricalMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                 ElectricalMeasurement::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "write the default values to mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                  ElectricalMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            LogStep(4, "reads back global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                 ElectricalMeasurement::Attributes::ClusterRevision::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ElectricalMeasurement::Id,
                                 ElectricalMeasurement::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_ETHDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_ETHDIAG_1_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ETHDIAG_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<bool> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<bool> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read PHYRate attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::PHYRate::Id);
        }
        case 2: {
            LogStep(2, "Read FullDuplex attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::FullDuplex::Id);
        }
        case 3: {
            LogStep(3, "Read PacketRxCount attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::PacketRxCount::Id);
        }
        case 4: {
            LogStep(4, "Read PacketTxCount attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::PacketTxCount::Id);
        }
        case 5: {
            LogStep(5, "Read TxErrCount attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::TxErrCount::Id);
        }
        case 6: {
            LogStep(6, "Read CollisionCount attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::CollisionCount::Id);
        }
        case 7: {
            LogStep(7, "Read OverrunCount attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::OverrunCount::Id);
        }
        case 8: {
            LogStep(8, "Read CarrierDetect attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::CarrierDetect::Id);
        }
        case 9: {
            LogStep(9, "Read TimeSinceReset attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), EthernetNetworkDiagnostics::Id,
                                 EthernetNetworkDiagnostics::Attributes::TimeSinceReset::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_ETHDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_ETHDIAG_2_1", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ETHDIAG_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_FLW_1_1Suite : public TestCommand
{
public:
    Test_TC_FLW_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_FLW_1_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_FLW_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "write the default values to mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                  FlowMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            LogStep(4, "reads back global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::ClusterRevision::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::AttributeList::Id);
        }
        case 6: {
            LogStep(6,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 7: {
            LogStep(7, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::AcceptedCommandList::Id);
        }
        case 8: {
            LogStep(8, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::GeneratedCommandList::Id);
        }
        case 9: {
            LogStep(9,
                    "Read FeatureMap attribute from the DUT and Verify that the DUT response indicates FeatureMap attribute has "
                    "the value 0");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter '0' for success", "0");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_FLW_2_1Suite : public TestCommand
{
public:
    Test_TC_FLW_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_FLW_2_1", 14, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_FLW_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 10:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("tolerance", value, 0U));
            }
            break;
        case 11:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2048U));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 13:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("tolerance", value, 0U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the mandatory attribute: MeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            LogStep(2, "read the mandatory attribute: MinMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 3: {
            LogStep(3, "read the mandatory attribute: MaxMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 4: {
            LogStep(4, "write the default value to optional attribute: MeasuredValue");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                  FlowMeasurement::Attributes::MeasuredValue::Id, value);
        }
        case 5: {
            LogStep(5, "write the default value to optional attribute: MinMeasuredValue");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                  FlowMeasurement::Attributes::MinMeasuredValue::Id, value);
        }
        case 6: {
            LogStep(6, "write the default value to optional attribute: MaxMeasuredValue");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                  FlowMeasurement::Attributes::MaxMeasuredValue::Id, value);
        }
        case 7: {
            LogStep(7, "read the mandatory attribute: MeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MeasuredValue::Id);
        }
        case 8: {
            LogStep(8, "read the mandatory attribute: MinMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 9: {
            LogStep(9, "read the mandatory attribute: MaxMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 10: {
            LogStep(10, "read the optional attribute: Tolerance");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id, FlowMeasurement::Attributes::Tolerance::Id);
        }
        case 11: {
            LogStep(11, "read the optional attribute: Tolerance");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id, FlowMeasurement::Attributes::Tolerance::Id);
        }
        case 12: {
            LogStep(12, "write the default value to optional attribute: Tolerance");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id, FlowMeasurement::Attributes::Tolerance::Id,
                                  value);
        }
        case 13: {
            LogStep(13, "read the optional attribute: Tolerance");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id, FlowMeasurement::Attributes::Tolerance::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_FLW_2_2Suite : public TestCommand
{
public:
    Test_TC_FLW_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_FLW_2_2", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_FLW_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the mandatory attribute: MeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            LogStep(2, "read the mandatory attribute: MeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), FlowMeasurement::Id,
                                 FlowMeasurement::Attributes::MeasuredValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_GC_1_1Suite : public TestCommand
{
public:
    Test_TC_GC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_GC_1_1", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_GC_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 0ULL));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 1ULL));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::RegulatoryLocationType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::RegulatoryLocationType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH1 reads the BreadCrumb Attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 2: {
            LogStep(2, "TH1 writes the BreadCrumb attribute as 1 to the DUT");
            uint64_t value;
            value = 1ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                  GeneralCommissioning::Attributes::Breadcrumb::Id, value);
        }
        case 3: {
            LogStep(3, "TH1 reads the BreadCrumb attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 4: {
            LogStep(4, "TH1 reads the RegulatoryConfig attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::RegulatoryConfig::Id);
        }
        case 5: {
            LogStep(5, "TH1 reads the LocationCapability attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::LocationCapability::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_I_1_1Suite : public TestCommand
{
public:
    Test_TC_I_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_I_1_1", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_I_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 4U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 0));
                    VerifyOrReturn(CheckValue("attributeList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 1));
                    VerifyOrReturn(CheckValue("attributeList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 2));
                    VerifyOrReturn(CheckValue("attributeList[2]", iter_0.GetValue(), 65528UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 3));
                    VerifyOrReturn(CheckValue("attributeList[3]", iter_0.GetValue(), 65529UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 4));
                    VerifyOrReturn(CheckValue("attributeList[4]", iter_0.GetValue(), 65531UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 5));
                    VerifyOrReturn(CheckValue("attributeList[5]", iter_0.GetValue(), 65533UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("attributeList", iter_0, 6));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 0));
                    VerifyOrReturn(CheckValue("acceptedCommandList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 1));
                    VerifyOrReturn(CheckValue("acceptedCommandList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 2));
                    VerifyOrReturn(CheckValue("acceptedCommandList[2]", iter_0.GetValue(), 64UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acceptedCommandList", iter_0, 3));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 0));
                    VerifyOrReturn(CheckValue("generatedCommandList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("generatedCommandList", iter_0, 1));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH reads the ClusterRevision attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints : ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Attributes::AttributeList::Id);
        }
        case 4: {
            LogStep(4, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Attributes::AcceptedCommandList::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Attributes::GeneratedCommandList::Id);
        }
        case 6: {
            LogStep(6,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 7: {
            LogStep(7,
                    "Read FeatureMap attribute from the DUT and Verify that the DUT response indicates FeatureMap attribute has "
                    "the value 0");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter '0' for success", "0");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_I_2_1Suite : public TestCommand
{
public:
    Test_TC_I_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_I_2_1", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_I_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 5));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH reads the IdentifyTime attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Attributes::IdentifyTime::Id);
        }
        case 2: {
            LogStep(2, "TH reads the IdentifyType attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Attributes::IdentifyType::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_I_2_3Suite : public TestCommand
{
public:
    Test_TC_I_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_I_2_3", 21, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_I_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "1.Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0x00 blink and the effect "
                    "variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(0);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 2: {
            LogStep(2, "Manually check DUT executes a blink effect");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT executes a blink effect");
        }
        case 3: {
            LogStep(3,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0x01 breathe and the effect "
                    "variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(1);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 4: {
            LogStep(4, "check DUT executes a breathe effect");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT executes a breathe effect");
        }
        case 5: {
            LogStep(5,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0x02 okay and the effect "
                    "variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(2);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 6: {
            LogStep(6, "check DUT executes an okay effect");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT executes an okay effect");
        }
        case 7: {
            LogStep(7,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0x0b channel change and the "
                    "effect variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(11);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 8: {
            LogStep(8, "check DUT executes a channel change effect");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT executes a channel change effect");
        }
        case 9: {
            LogStep(9,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0x01 breathe and the effect "
                    "variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(1);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 10: {
            LogStep(10, "check DUT executes a breathe effect");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT executes a breathe effect");
        }
        case 11: {
            LogStep(11,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0xfe finish effect and the "
                    "effect variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(254);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 12: {
            LogStep(12, "Manually check DUT stops the breathe effect after the current effect sequence");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT stops the breathe effect after the current effect sequence");
        }
        case 13: {
            LogStep(13,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0x01 breathe and the effect "
                    "variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(1);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 14: {
            LogStep(14, "Manually check DUT executes a breathe effect");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT executes a breathe effect");
        }
        case 15: {
            LogStep(15,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0xff stop effect and the effect "
                    "variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(255);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 16: {
            LogStep(16, "Check DUT stops the breathe effect as soon as possible.");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT stops the breathe effect as soon as possible");
        }
        case 17: {
            LogStep(17,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0x00 blink and the effect "
                    "variant field set to 0x42 unknown");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(0);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(66);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 18: {
            LogStep(18, "Check DUT executes a blink effect.");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT executes a blink effect");
        }
        case 19: {
            LogStep(19,
                    "TH sends TriggerEffect command to DUT with the effect identifier field set to 0xff stop effect and the effect "
                    "variant field set to 0x00 default");
            chip::app::Clusters::Identify::Commands::TriggerEffect::Type value;
            value.effectIdentifier = static_cast<chip::app::Clusters::Identify::IdentifyEffectIdentifier>(255);
            value.effectVariant    = static_cast<chip::app::Clusters::Identify::IdentifyEffectVariant>(0);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Identify::Id, Identify::Commands::TriggerEffect::Id, value);
        }
        case 20: {
            LogStep(20, "Check DUT stops any effect that may be still running as soon as possible");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("DUT stops any effect that may be still running as soon as possible");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_ILL_1_1Suite : public TestCommand
{
public:
    Test_TC_ILL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_ILL_1_1", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ILL_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 0));
                    VerifyOrReturn(CheckValue("attributeList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 1));
                    VerifyOrReturn(CheckValue("attributeList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 2));
                    VerifyOrReturn(CheckValue("attributeList[2]", iter_0.GetValue(), 2UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 3));
                    VerifyOrReturn(CheckValue("attributeList[3]", iter_0.GetValue(), 3UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 4));
                    VerifyOrReturn(CheckValue("attributeList[4]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 5));
                    VerifyOrReturn(CheckValue("attributeList[5]", iter_0.GetValue(), 65528UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 6));
                    VerifyOrReturn(CheckValue("attributeList[6]", iter_0.GetValue(), 65529UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 7));
                    VerifyOrReturn(CheckValue("attributeList[7]", iter_0.GetValue(), 65531UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 8));
                    VerifyOrReturn(CheckValue("attributeList[8]", iter_0.GetValue(), 65533UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("attributeList", iter_0, 9));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acceptedCommandList", iter_0, 0));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("generatedCommandList", iter_0, 0));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints : ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::AttributeList::Id);
        }
        case 4: {
            LogStep(4,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 5: {
            LogStep(5, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::AcceptedCommandList::Id);
        }
        case 6: {
            LogStep(6, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::GeneratedCommandList::Id);
        }
        case 7: {
            LogStep(7,
                    "Read FeatureMap attribute from the DUT and Verify that the DUT response indicates FeatureMap attribute has "
                    "the value 0");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter '0' for success", "0");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_ILL_2_1Suite : public TestCommand
{
public:
    Test_TC_ILL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_ILL_2_1", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ILL_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65533U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 2U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65534U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2048U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH reads MinMeasuredValue attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 2: {
            LogStep(2, "TH reads MaxMeasuredValue attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 3: {
            LogStep(3, "TH reads Tolerance attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::Tolerance::Id);
        }
        case 4: {
            LogStep(4, "TH reads LightSensorType attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), IlluminanceMeasurement::Id,
                                 IlluminanceMeasurement::Attributes::LightSensorType::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_1_1Suite : public TestCommand
{
public:
    Test_TC_LVL_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_1_1", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 5U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 0));
                    VerifyOrReturn(CheckValue("attributeList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 1));
                    VerifyOrReturn(CheckValue("attributeList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 2));
                    VerifyOrReturn(CheckValue("attributeList[2]", iter_0.GetValue(), 2UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 3));
                    VerifyOrReturn(CheckValue("attributeList[3]", iter_0.GetValue(), 3UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 4));
                    VerifyOrReturn(CheckValue("attributeList[4]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 5));
                    VerifyOrReturn(CheckValue("attributeList[5]", iter_0.GetValue(), 5UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 6));
                    VerifyOrReturn(CheckValue("attributeList[6]", iter_0.GetValue(), 6UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 7));
                    VerifyOrReturn(CheckValue("attributeList[7]", iter_0.GetValue(), 10UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 8));
                    VerifyOrReturn(CheckValue("attributeList[8]", iter_0.GetValue(), 11UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 9));
                    VerifyOrReturn(CheckValue("attributeList[9]", iter_0.GetValue(), 12UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 10));
                    VerifyOrReturn(CheckValue("attributeList[10]", iter_0.GetValue(), 13UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 11));
                    VerifyOrReturn(CheckValue("attributeList[11]", iter_0.GetValue(), 14UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 12));
                    VerifyOrReturn(CheckValue("attributeList[12]", iter_0.GetValue(), 15UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 13));
                    VerifyOrReturn(CheckValue("attributeList[13]", iter_0.GetValue(), 16384UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("attributeList", iter_0, 14));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 0));
                    VerifyOrReturn(CheckValue("acceptedCommandList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 1));
                    VerifyOrReturn(CheckValue("acceptedCommandList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 2));
                    VerifyOrReturn(CheckValue("acceptedCommandList[2]", iter_0.GetValue(), 2UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 3));
                    VerifyOrReturn(CheckValue("acceptedCommandList[3]", iter_0.GetValue(), 3UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 4));
                    VerifyOrReturn(CheckValue("acceptedCommandList[4]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 5));
                    VerifyOrReturn(CheckValue("acceptedCommandList[5]", iter_0.GetValue(), 5UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 6));
                    VerifyOrReturn(CheckValue("acceptedCommandList[6]", iter_0.GetValue(), 6UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 7));
                    VerifyOrReturn(CheckValue("acceptedCommandList[7]", iter_0.GetValue(), 7UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acceptedCommandList", iter_0, 8));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("featureMap", value, 3UL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints : ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            VerifyOrdo(!ShouldSkip("PICS_SKIP_SAMPLE_APP"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::AttributeList::Id);
        }
        case 4: {
            LogStep(4,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 5: {
            LogStep(5, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::AcceptedCommandList::Id);
        }
        case 6: {
            LogStep(6, "read the optional global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_2_1Suite : public TestCommand
{
public:
    Test_TC_LVL_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_2_1", 16, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 254));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("remainingTime", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minLevel", value, 0));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentFrequency", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minFrequency", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxFrequency", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOffTransitionTime", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("options", value, 0));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reset level to 254");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 2: {
            LogStep(2, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 3: {
            LogStep(3, "Reads the CurrentLevel attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 4: {
            LogStep(4, "Reads the RemainingTime attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::RemainingTime::Id);
        }
        case 5: {
            LogStep(5, "Reads the MinLevel attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MinLevel::Id);
        }
        case 6: {
            LogStep(6, "Reads the MaxLevel attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MaxLevel::Id);
        }
        case 7: {
            LogStep(7, "Reads the CurrentFrequency attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentFrequency::Id);
        }
        case 8: {
            LogStep(8, "Reads the MinFrequency attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MinFrequency::Id);
        }
        case 9: {
            LogStep(9, "Reads the MaxFrequency attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MaxFrequency::Id);
        }
        case 10: {
            LogStep(10, "Reads the OnOffTransitionTime attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::OnOffTransitionTime::Id);
        }
        case 11: {
            LogStep(11, "Reads the OnLevel attribute ");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnLevel::Id);
        }
        case 12: {
            LogStep(12, "Reads the OnTransitionTime attribute ");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnTransitionTime::Id);
        }
        case 13: {
            LogStep(13, "Reads the OffTransitionTime attribute ");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OffTransitionTime::Id);
        }
        case 14: {
            LogStep(14, "Reads the DefaultMoveRate attribute ");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id);
        }
        case 15: {
            LogStep(15, "Reads the Options attribute ");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::Options::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_2_2Suite : public TestCommand
{
public:
    Test_TC_LVL_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_2_2", 16, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOffTransitionTime", value, 0U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOffTransitionTime", value, 10U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("onLevel", value));
                VerifyOrReturn(CheckValue("onLevel.Value()", value.Value(), 254));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("onTransitionTime", value));
                VerifyOrReturn(CheckValue("onTransitionTime.Value()", value.Value(), 100U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("offTransitionTime", value));
                VerifyOrReturn(CheckValue("offTransitionTime.Value()", value.Value(), 100U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("defaultMoveRate", value));
                VerifyOrReturn(CheckValue("defaultMoveRate.Value()", value.Value(), 50));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("defaultMoveRate", value));
                VerifyOrReturn(CheckValue("defaultMoveRate.Value()", value.Value(), 100));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("startUpCurrentLevel", value));
                VerifyOrReturn(CheckValue("startUpCurrentLevel.Value()", value.Value(), 254));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads the OnOffTransitionTime attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::OnOffTransitionTime::Id);
        }
        case 2: {
            LogStep(2, "writes the OnOffTransitionTime attribute on the DUT");
            uint16_t value;
            value = 10U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                  LevelControl::Attributes::OnOffTransitionTime::Id, value);
        }
        case 3: {
            LogStep(3, "Reads the OnOffTransitionTime attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::OnOffTransitionTime::Id);
        }
        case 4: {
            LogStep(4, "writes default value of OnOffTransitionTime attribute");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                  LevelControl::Attributes::OnOffTransitionTime::Id, value);
        }
        case 5: {
            LogStep(5, "writes the OnLevel attribute on the DUT");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnLevel::Id, value);
        }
        case 6: {
            LogStep(6, "Reads the OnLevel attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnLevel::Id);
        }
        case 7: {
            LogStep(7, "Writes the OnTransitionTime attribute on the DUT");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 100U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnTransitionTime::Id,
                                  value);
        }
        case 8: {
            LogStep(8, "Reads the OnTransitionTime attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OnTransitionTime::Id);
        }
        case 9: {
            LogStep(9, "Writes the OffTransitionTime attribute on the DUT");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 100U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OffTransitionTime::Id,
                                  value);
        }
        case 10: {
            LogStep(10, "Reads the OffTransitionTime attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::OffTransitionTime::Id);
        }
        case 11: {
            LogStep(11, "Reads the DefaultMoveRate attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id);
        }
        case 12: {
            LogStep(12, "Writes the DefaultMoveRate attribute on the DUT");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 100;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id,
                                  value);
        }
        case 13: {
            LogStep(13, "Reads the DefaultMoveRate attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id);
        }
        case 14: {
            LogStep(14, "writes the StartUpCurrentLevel attribute on the DUT");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                  LevelControl::Attributes::StartUpCurrentLevel::Id, value);
        }
        case 15: {
            LogStep(15, "reads the StartUpCurrentLevel attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::StartUpCurrentLevel::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_3_1Suite : public TestCommand
{
public:
    Test_TC_LVL_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_3_1", 16, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 64));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 100));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 128));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 2: {
            LogStep(2, "Reads the MinLevel attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MinLevel::Id);
        }
        case 3: {
            LogStep(3, "Reads the MaxLevel attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MaxLevel::Id);
        }
        case 4: {
            LogStep(4, "sends a Move to level command");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 64;
            value.transitionTime = 65535U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 5: {
            LogStep(5, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 6: {
            LogStep(6, "reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 7: {
            LogStep(7, "sends a Move to level command");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 100;
            value.transitionTime = 100U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 8: {
            LogStep(8, "Wait 11000 second");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(11000);
        }
        case 9: {
            LogStep(9, "reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 10: {
            LogStep(10, "reads On Off Transition Time attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id,
                                 LevelControl::Attributes::OnOffTransitionTime::Id);
        }
        case 11: {
            LogStep(11, "sends a Move to level command");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 128;
            value.transitionTime = 65535U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 12: {
            LogStep(12, "Wait 1000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 13: {
            LogStep(13, "reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 14: {
            LogStep(14, "Reset level to 254");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 15: {
            LogStep(15, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_4_1Suite : public TestCommand
{
public:
    Test_TC_LVL_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_4_1", 18, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_4_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint8_t MaxlevelValue;
    uint8_t MinlevelValue;
    chip::app::DataModel::Nullable<uint8_t> DefaultMoveRateValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                MaxlevelValue = value;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, MaxlevelValue));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                MinlevelValue = value;
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, 1));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 1));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                DefaultMoveRateValue = value;
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 255));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "reads max level attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MaxLevel::Id);
        }
        case 2: {
            LogStep(2, "sends a Move up command");
            chip::app::Clusters::LevelControl::Commands::Move::Type value;
            value.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
            value.rate           = 32;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Move::Id, value);
        }
        case 3: {
            LogStep(3, "user prompt message");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the DUT moves at a rate of 32 units per second or as close as possible to "
                              "this rate and completes moving to its maximum level");
        }
        case 4: {
            LogStep(4, "Wait 3000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 5: {
            LogStep(5, "reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 6: {
            LogStep(6, "reads min level attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::MinLevel::Id);
        }
        case 7: {
            LogStep(7, "sends a Move down command");
            chip::app::Clusters::LevelControl::Commands::Move::Type value;
            value.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
            value.rate           = 64;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Move::Id, value);
        }
        case 8: {
            LogStep(8, "user prompt message");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the DUT moves at a rate of 64 units per second or as close as possible to "
                              "this rate and complete moving to its minimum level");
        }
        case 9: {
            LogStep(9, "Wait 5000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(5000);
        }
        case 10: {
            LogStep(10, "reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 11: {
            LogStep(11, "reads default move rate attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::DefaultMoveRate::Id);
        }
        case 12: {
            LogStep(12, "sends a Move up command at default move rate");
            chip::app::Clusters::LevelControl::Commands::Move::Type value;
            value.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
            value.rate           = 255;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Move::Id, value);
        }
        case 13: {
            LogStep(13, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 14: {
            LogStep(14, "reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 15: {
            LogStep(15, "user prompt message");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the device moves at the rate recorded in step 3a and completes moving to its "
                              "maximum level.");
        }
        case 16: {
            LogStep(16, "Reset level to 254");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 17: {
            LogStep(17, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_5_1Suite : public TestCommand
{
public:
    Test_TC_LVL_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_5_1", 14, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_5_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint8_t CurrentlevelValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                CurrentlevelValue = value;
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, CurrentlevelValue));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentLevel", value, CurrentlevelValue));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Sending on command");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Precondition: DUT level is set to its lowest point");
            chip::app::Clusters::LevelControl::Commands::Step::Type value;
            value.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
            value.stepSize       = 100;
            value.transitionTime = 20U;
            value.optionMask     = 0;
            value.optionOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Step::Id, value);
        }
        case 3: {
            LogStep(3, "Wait 3000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 4: {
            LogStep(4, "Reads current level attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 5: {
            LogStep(5, "Sends step up command to DUT");
            chip::app::Clusters::LevelControl::Commands::Step::Type value;
            value.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
            value.stepSize       = 64;
            value.transitionTime = 2U;
            value.optionMask     = 0;
            value.optionOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Step::Id, value);
        }
        case 6: {
            LogStep(6, "Wait 5000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(5000);
        }
        case 7: {
            LogStep(7, "Reads current level attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 8: {
            LogStep(8, "Sends a Step down command");
            chip::app::Clusters::LevelControl::Commands::Step::Type value;
            value.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
            value.stepSize       = 64;
            value.transitionTime = 2U;
            value.optionMask     = 0;
            value.optionOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Step::Id, value);
        }
        case 9: {
            LogStep(9, "Wait 4000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(4000);
        }
        case 10: {
            LogStep(10, "Reads current level attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 11: {
            LogStep(11, "Reset level to 254");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 12: {
            LogStep(12, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 13: {
            LogStep(13, "Sending off command");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LVL_6_1Suite : public TestCommand
{
public:
    Test_TC_LVL_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LVL_6_1", 12, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LVL_6_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint8_t CurrentLevelValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 1));
                CurrentLevelValue = value;
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, CurrentLevelValue));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Sending on command");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Precondition: set DUT to lowest point");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 0;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 3: {
            LogStep(3, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 4: {
            LogStep(4, "Reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 5: {
            LogStep(5, "Sends a move up command to DUT");
            chip::app::Clusters::LevelControl::Commands::Move::Type value;
            value.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
            value.rate           = 1;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Move::Id, value);
        }
        case 6: {
            LogStep(6, "Wait 2000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 7: {
            LogStep(7, "Sends stop command to DUT");
            chip::app::Clusters::LevelControl::Commands::Stop::Type value;
            value.optionMask     = 0;
            value.optionOverride = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::Stop::Id, value);
        }
        case 8: {
            LogStep(8, "Reads CurrentLevel attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Attributes::CurrentLevel::Id);
        }
        case 9: {
            LogStep(9, "Reset level to 254");
            chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type value;
            value.level          = 254;
            value.transitionTime = 0U;
            value.optionMask     = 1;
            value.optionOverride = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LevelControl::Id, LevelControl::Commands::MoveToLevel::Id, value);
        }
        case 10: {
            LogStep(10, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 11: {
            LogStep(11, "Sending off command");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_1Suite : public TestCommand
{
public:
    Test_TC_MC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_1", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LowPower::Id, LowPower::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LowPower::Id, LowPower::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), LowPower::Id, LowPower::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_2Suite : public TestCommand
{
public:
    Test_TC_MC_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_2", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), KeypadInput::Id, KeypadInput::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), KeypadInput::Id, KeypadInput::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), KeypadInput::Id, KeypadInput::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_3Suite : public TestCommand
{
public:
    Test_TC_MC_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_3", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id,
                                 ApplicationLauncher::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id,
                                 ApplicationLauncher::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id,
                                 ApplicationLauncher::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_4Suite : public TestCommand
{
public:
    Test_TC_MC_1_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_4", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_5Suite : public TestCommand
{
public:
    Test_TC_MC_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_5", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WakeOnLan::Id, WakeOnLan::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WakeOnLan::Id, WakeOnLan::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WakeOnLan::Id, WakeOnLan::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_6Suite : public TestCommand
{
public:
    Test_TC_MC_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_6", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_7Suite : public TestCommand
{
public:
    Test_TC_MC_1_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_7", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_7Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_8Suite : public TestCommand
{
public:
    Test_TC_MC_1_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_8", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_8Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), AudioOutput::Id, AudioOutput::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), AudioOutput::Id, AudioOutput::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), AudioOutput::Id, AudioOutput::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_9Suite : public TestCommand
{
public:
    Test_TC_MC_1_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_9", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_9Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id,
                                 TargetNavigator::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id,
                                 TargetNavigator::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id,
                                 TargetNavigator::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_10Suite : public TestCommand
{
public:
    Test_TC_MC_1_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_10", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_10Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_11Suite : public TestCommand
{
public:
    Test_TC_MC_1_11Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_11", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_11Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_1_12Suite : public TestCommand
{
public:
    Test_TC_MC_1_12Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_1_12", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_1_12Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), AccountLogin::Id, AccountLogin::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), AccountLogin::Id, AccountLogin::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), AccountLogin::Id, AccountLogin::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_2_1Suite : public TestCommand
{
public:
    Test_TC_MC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_2_1", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Put the device into low power mode");
            chip::app::Clusters::LowPower::Commands::Sleep::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LowPower::Id, LowPower::Commands::Sleep::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_1Suite : public TestCommand
{
public:
    Test_TC_MC_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_1", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_2Suite : public TestCommand
{
public:
    Test_TC_MC_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_2", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_3Suite : public TestCommand
{
public:
    Test_TC_MC_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_3", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_4Suite : public TestCommand
{
public:
    Test_TC_MC_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_4", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_5Suite : public TestCommand
{
public:
    Test_TC_MC_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_5", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_6Suite : public TestCommand
{
public:
    Test_TC_MC_3_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_6", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_7Suite : public TestCommand
{
public:
    Test_TC_MC_3_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_7", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_7Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_8Suite : public TestCommand
{
public:
    Test_TC_MC_3_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_8", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_8Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_9Suite : public TestCommand
{
public:
    Test_TC_MC_3_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_9", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_9Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_10Suite : public TestCommand
{
public:
    Test_TC_MC_3_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_10", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_10Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_11Suite : public TestCommand
{
public:
    Test_TC_MC_3_11Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_11", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_11Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_5_1Suite : public TestCommand
{
public:
    Test_TC_MC_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_5_1", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_5_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads the ChannelList attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::ChannelList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_5_2Suite : public TestCommand
{
public:
    Test_TC_MC_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_5_2", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_5_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("verify that the channel has changed on the device.");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_5_3Suite : public TestCommand
{
public:
    Test_TC_MC_5_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_5_3", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_5_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("verify that the channel has changed on the device");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_6_1Suite : public TestCommand
{
public:
    Test_TC_MC_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_6_1", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_6_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that media is paused");
        }
        case 2: {
            LogStep(2, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is playing");
        }
        case 3: {
            LogStep(3, "Reads the playback state attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 4: {
            LogStep(4, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is paused");
        }
        case 5: {
            LogStep(5, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is stoped");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_6_2Suite : public TestCommand
{
public:
    Test_TC_MC_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_6_2", 9, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_6_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that media is paused");
        }
        case 2: {
            LogStep(2, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is playing");
        }
        case 3: {
            LogStep(3, "Reads the CurrentState attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 4: {
            LogStep(4, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Physically verify that the media is started over");
        }
        case 5: {
            LogStep(5, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the next media item in the queue has been loaded");
        }
        case 6: {
            LogStep(6, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the previous media item in the queue has been loaded");
        }
        case 7: {
            LogStep(7, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media has skipped forward 10 seconds");
        }
        case 8: {
            LogStep(8, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media has skipped backward 10 seconds");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_6_3Suite : public TestCommand
{
public:
    Test_TC_MC_6_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_6_3", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_6_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that media is paused");
        }
        case 2: {
            LogStep(2, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media has moved to 10 seconds from the starting point.");
        }
        case 3: {
            LogStep(3, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("User prompt needed to enter the value beyond the furthest valid position");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_6_4Suite : public TestCommand
{
public:
    Test_TC_MC_6_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_6_4", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_6_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("playbackSpeed", value, 0.0f));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that media is paused");
        }
        case 2: {
            LogStep(2, "Reads the PlaybackSpeed attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::PlaybackSpeed::Id);
        }
        case 3: {
            LogStep(3, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media is playing");
        }
        case 4: {
            LogStep(4, "Reads the CurrentState attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 5: {
            LogStep(5, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media play speed has increased");
        }
        case 6: {
            LogStep(6, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media play has reversed direction");
        }
        case 7: {
            LogStep(7, "Reads the CurrentState attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 8: {
            LogStep(8, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media play has reversed direction");
        }
        case 9: {
            LogStep(9, "log a command");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Verify that the media is has resumed playing forward at the default speed");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_7_1Suite : public TestCommand
{
public:
    Test_TC_MC_7_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_7_1", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_7_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_7_2Suite : public TestCommand
{
public:
    Test_TC_MC_7_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_7_2", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_7_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_8_1Suite : public TestCommand
{
public:
    Test_TC_MC_8_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_8_1", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_8_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads the CurrentTarget attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id,
                                 TargetNavigator::Attributes::CurrentTarget::Id);
        }
        case 2: {
            LogStep(2, "Reads the TargetList attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id, TargetNavigator::Attributes::TargetList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_9_1Suite : public TestCommand
{
public:
    Test_TC_MC_9_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_9_1", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_9_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "vendor-id"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 256));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Precondition");
            SetIdentity(kIdentityAlpha);
            return Log("DUT has one or more Content Apps available");
        }
        case 2: {
            LogStep(2, "Reads the VendorName attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::VendorName::Id);
        }
        case 3: {
            LogStep(3, "Reads the VendorID attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id, ApplicationBasic::Attributes::VendorID::Id);
        }
        case 4: {
            LogStep(4, "Reads the ApplicationName attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ApplicationName::Id);
        }
        case 5: {
            LogStep(5, "Reads the ProductID attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id, ApplicationBasic::Attributes::ProductID::Id);
        }
        case 6: {
            LogStep(6, "Reads the Status attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id, ApplicationBasic::Attributes::Status::Id);
        }
        case 7: {
            LogStep(7, "Reads the ApplicationVersion attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ApplicationVersion::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_10_1Suite : public TestCommand
{
public:
    Test_TC_MC_10_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_1", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_10_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH reads the AcceptHeader attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::AcceptHeader::Id);
        }
        case 2: {
            LogStep(2, "TH reads the SupportedStreamingProtocols attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::SupportedStreamingProtocols::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MOD_1_1Suite : public TestCommand
{
public:
    Test_TC_MOD_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_1_1", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MOD_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH reads the ClusterRevision attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "TH reads the AttributeList attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::AttributeList::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::AcceptedCommandList::Id);
        }
        case 4: {
            LogStep(4, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::GeneratedCommandList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_3Suite : public TestCommand
{
public:
    Test_TC_MF_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_3", 13, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("nodeId2", 0, UINT64_MAX, &mNodeId2);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("payload", &mPayload);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::NodeId> mNodeId2;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<chip::CharSpan> mPayload;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("chiptest", 8)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString("fabrics[1].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 2));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("chiptest1", 9)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("chiptest2", 9)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "TH_CR1 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2, "TH_CR1 opens a commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "TH_CR1 writes the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            chip::CharSpan value;
            value = chip::Span<const char>("chiptestgarbage: not in length on purpose", 8);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 4: {
            LogStep(4, "TH_CR1 reads the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 5: {
            LogStep(5, "Commission from beta");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:0000000000I31506010"));
        }
        case 6: {
            LogStep(6, "TH_CR2 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityBeta);
            return WaitForCommissionee(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL);
        }
        case 7: {
            LogStep(7, "Query fabrics list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        case 8: {
            LogStep(8, "Query fabrics list");
            return ReadAttribute(kIdentityBeta, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id, false);
        }
        case 9: {
            LogStep(9, "TH_CR1 writes the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            chip::CharSpan value;
            value = chip::Span<const char>("chiptest1garbage: not in length on purpose", 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 10: {
            LogStep(10, "TH_CR1 reads the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 11: {
            LogStep(11, "TH_CR2 writes the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            chip::CharSpan value;
            value = chip::Span<const char>("chiptest2garbage: not in length on purpose", 9);
            return WriteAttribute(kIdentityBeta, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 12: {
            LogStep(12, "TH_CR2 reads the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            return ReadAttribute(kIdentityBeta, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_4Suite : public TestCommand
{
public:
    Test_TC_MF_1_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_4", 13, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("nodeId2", 0, UINT64_MAX, &mNodeId2);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("payload", &mPayload);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::NodeId> mNodeId2;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<chip::CharSpan> mPayload;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 32));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "TH_CR1 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2, "TH_CR1 opens a commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "TH_CR1 writes the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            chip::CharSpan value;
            value = chip::Span<const char>("chiptestgarbage: not in length on purpose", 8);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 4: {
            LogStep(4, "TH_CR1 reads the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 5: {
            LogStep(5, "Commission from beta");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 6: {
            LogStep(6, "TH_CR2 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityBeta);
            return WaitForCommissionee(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL);
        }
        case 7: {
            LogStep(7, "Query fabrics list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        case 8: {
            LogStep(8, "Query fabrics list");
            return ReadAttribute(kIdentityBeta, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        case 9: {
            LogStep(9, "TH_CR1 writes the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            chip::CharSpan value;
            value = chip::Span<const char>("chiptestgarbage: not in length on purpose", 8);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 10: {
            LogStep(10, "TH_CR1 reads the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 11: {
            LogStep(11, "TH_CR1 writes the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            chip::CharSpan value;
            value = chip::Span<const char>("chiptestgarbage: not in length on purpose", 8);
            return WriteAttribute(kIdentityBeta, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 12: {
            LogStep(12, "TH_CR1 reads the Basic Information Clusters NodeLabel mandatory attribute of DUT_CE");
            return ReadAttribute(kIdentityBeta, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_5Suite : public TestCommand
{
public:
    Test_TC_MF_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_5", 16, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("nodeIdForDuplicateCommissioning", 0, UINT64_MAX, &mNodeIdForDuplicateCommissioning);
        AddArgument("nodeId2", 0, UINT64_MAX, &mNodeId2);
        AddArgument("nodeId3", 0, UINT64_MAX, &mNodeId3);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("payload", &mPayload);
    }

    ~Test_TC_MF_1_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override { return chip::System::Clock::Seconds16(mTimeout.ValueOr(300)); }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<chip::NodeId> mNodeIdForDuplicateCommissioning;
    chip::Optional<chip::NodeId> mNodeId2;
    chip::Optional<chip::NodeId> mNodeId3;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<chip::CharSpan> mPayload;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("chiptest", 8)));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "TH_CR1 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2, "TH_CR1 opens a new commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "Wait for PIXIT_COMM_WIN(180) + 10 seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 4: {
            LogStep(4, "Wait for PIXIT_COMM_WIN(180) + 10 seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 5: {
            LogStep(5, "Wait for PIXIT_COMM_WIN(180) + 10 seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 6: {
            LogStep(6, "Wait for PIXIT_COMM_WIN(180) + 10 seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(28000);
        }
        case 7: {
            LogStep(7, "TH_CR2 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 8: {
            LogStep(8, "TH_CR1 opens a new commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 9: {
            LogStep(9, "TH_CR1 revokes the commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::RevokeCommissioning::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 10: {
            LogStep(10, "TH_CR2 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 11: {
            LogStep(11, "TH_CR1 revokes the commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::RevokeCommissioning::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 12: {
            LogStep(12, "TH_CR1 writes the mandatory attribute NodeLabel of DUT_CE");
            chip::CharSpan value;
            value = chip::Span<const char>("chiptestgarbage: not in length on purpose", 8);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 13: {
            LogStep(13, "TH_CR1 read the mandatory attribute NodeLabel of DUT_CE");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 14: {
            LogStep(14, "TH_CR1 opens a new commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 15: {
            LogStep(15, "TH_CR3 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityGamma);
            return PairWithQRCode(mNodeId3.HasValue() ? mNodeId3.Value() : 12586990ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_6Suite : public TestCommand
{
public:
    Test_TC_MF_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_6", 18, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("nodeIdForDuplicateCommissioning", 0, UINT64_MAX, &mNodeIdForDuplicateCommissioning);
        AddArgument("nodeId2", 0, UINT64_MAX, &mNodeId2);
        AddArgument("nodeId3", 0, UINT64_MAX, &mNodeId3);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("payload", &mPayload);
    }

    ~Test_TC_MF_1_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override { return chip::System::Clock::Seconds16(mTimeout.ValueOr(300)); }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<chip::NodeId> mNodeIdForDuplicateCommissioning;
    chip::Optional<chip::NodeId> mNodeId2;
    chip::Optional<chip::NodeId> mNodeId3;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<chip::CharSpan> mPayload;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("chiptest", 8)));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "TH_CR1 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2, "TH_CR1 opens a commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "Wait for PIXIT_COMM_WIN(180) + 10");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 4: {
            LogStep(4, "Wait for PIXIT_COMM_WIN(180) + 10");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 5: {
            LogStep(5, "Wait for PIXIT_COMM_WIN(180) + 10");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 6: {
            LogStep(6, "Wait for PIXIT_COMM_WIN(180) + 10");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(28000);
        }
        case 7: {
            LogStep(7, "Commission from beta");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 8: {
            LogStep(8, "TH_CR1 opens a commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 9: {
            LogStep(9, "TH_CR1 revokes the commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::RevokeCommissioning::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 10: {
            LogStep(10, "Commission from beta");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 11: {
            LogStep(11, "TH_CR1 revokes the commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::RevokeCommissioning::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 12: {
            LogStep(12, "TH_CR1 writes the mandatory attribute NodeLabel of DUT_CE");
            chip::CharSpan value;
            value = chip::Span<const char>("chiptestgarbage: not in length on purpose", 8);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 13: {
            LogStep(13, "TH_CR1 read the mandatory attribute NodeLabel of DUT_CE");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 14: {
            LogStep(14, "TH_CR1 opens a commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 15: {
            LogStep(15, "Commission from beta");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 16: {
            LogStep(16, "TH_CR2 starts a commissioning process on DUT_CE");
            SetIdentity(kIdentityBeta);
            return WaitForCommissionee(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL);
        }
        case 17: {
            LogStep(17, "TH_CR3 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityGamma);
            return PairWithQRCode(mNodeId3.HasValue() ? mNodeId3.Value() : 12586990ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_15Suite : public TestCommand
{
public:
    Test_TC_MF_1_15Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_15", 24, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
        AddArgument("nodeIdForDuplicateCommissioning", 0, UINT64_MAX, &mNodeIdForDuplicateCommissioning);
        AddArgument("nodeId2", 0, UINT64_MAX, &mNodeId2);
        AddArgument("nodeId3", 0, UINT64_MAX, &mNodeId3);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("payload", &mPayload);
    }

    ~Test_TC_MF_1_15Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override { return chip::System::Clock::Seconds16(mTimeout.ValueOr(500)); }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<uint16_t> mTimeout;
    chip::Optional<chip::NodeId> mNodeIdForDuplicateCommissioning;
    chip::Optional<chip::NodeId> mNodeId2;
    chip::Optional<chip::NodeId> mNodeId3;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<chip::CharSpan> mPayload;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString("fabrics[1].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString("fabrics[2].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 3));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString("fabrics[1].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString("fabrics[2].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 3));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "TH_CR1 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2, "TH_CR1 opens a commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "Commission from gamma");
            SetIdentity(kIdentityGamma);
            return PairWithQRCode(mNodeId3.HasValue() ? mNodeId3.Value() : 12586990ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 4: {
            LogStep(4, "TH_CR3 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityGamma);
            return WaitForCommissionee(mNodeId3.HasValue() ? mNodeId3.Value() : 12586990ULL);
        }
        case 5: {
            LogStep(5, "TH_CR1 opens a commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 6: {
            LogStep(6, "Commission from beta");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 7: {
            LogStep(7, "TH_CR2 starts a commissioning process with DUT_CE");
            SetIdentity(kIdentityBeta);
            return WaitForCommissionee(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL);
        }
        case 8: {
            LogStep(8, "TH_CR1 opens a commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 9: {
            LogStep(9, "TH_CR1 opens a new commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 10: {
            LogStep(10, "TH_CR1 reads the list of Fabrics on DUT_CE");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id, false);
        }
        case 11: {
            LogStep(11, "Wait for the expiration of PIXIT_COMM_WIN seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 12: {
            LogStep(12, "Wait for the expiration of PIXIT_COMM_WIN seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 13: {
            LogStep(13, "Wait for the expiration of PIXIT_COMM_WIN seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 14: {
            LogStep(14, "Wait for the expiration of PIXIT_COMM_WIN seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(18000);
        }
        case 15: {
            LogStep(15, "TH_CR1 re-opens new commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 16: {
            LogStep(16, "TH_CR3 opens a new commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityGamma, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 17: {
            LogStep(17, "TH_CR1 reads the list of Fabrics on DUT_CE");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id, false);
        }
        case 18: {
            LogStep(18, "Wait for the expiration of PIXIT_COMM_WIN seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 19: {
            LogStep(19, "Wait for the expiration of PIXIT_COMM_WIN seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 20: {
            LogStep(20, "Wait for the expiration of PIXIT_COMM_WIN seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(54000);
        }
        case 21: {
            LogStep(21, "Wait for the expiration of PIXIT_COMM_WIN seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(18000);
        }
        case 22: {
            LogStep(22, "TH_CR1 opens a new commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 23: {
            LogStep(23, "TH_CR2 opens a new commissioning window on DUT_CE");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            value.PAKEVerifier         = chip::ByteSpan(
                chip::Uint8::from_const_char("\006\307V\337\374\327\042e4R\241-\315\224]\214T\332+\017<\275\033M\303\361\255\262#"
                                             "\256\262k\004|\322L\226\206o\227\233\035\203\354P\342\264\2560\315\362\375\263+"
                                             "\330\242\021\2707\334\224\355\315V\364\321Cw\031\020v\277\305\235\231\267\3350S\357"
                                             "\326\360,D4\362\275\322z\244\371\316\247\015s\216Lgarbage: not in length on purpose"),
                97);
            value.discriminator = 3840U;
            value.iterations    = 1000UL;
            value.salt = chip::ByteSpan(chip::Uint8::from_const_char("SPAKE2P Key Saltgarbage: not in length on purpose"), 16);
            return SendCommand(kIdentityBeta, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_1_1Suite : public TestCommand
{
public:
    Test_TC_OCC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_1_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "write the default values to mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                  OccupancySensing::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            LogStep(4, "reads back global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::ClusterRevision::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::AttributeList::Id);
        }
        case 6: {
            LogStep(6,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 7: {
            LogStep(7, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::AcceptedCommandList::Id);
        }
        case 8: {
            LogStep(8, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::GeneratedCommandList::Id);
        }
        case 9: {
            LogStep(9, "Read FeatureMap attribute from the DUT and Verify that the DUT response");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter '0' for success", "0");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_2_1Suite : public TestCommand
{
public:
    Test_TC_OCC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_2_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 1));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupancy", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupancySensorType", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 7));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupancySensorTypeBitmap", value, 1));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads mandatory attribute constrains: Occupancy");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id);
        }
        case 2: {
            LogStep(2, "Writes the respective default value to mandatory attribute: Occupancy");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id,
                                  value);
        }
        case 3: {
            LogStep(3, "Reads back mandatory attribute: Occupancy");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id);
        }
        case 4: {
            LogStep(4, "Reads mandatory attribute constrains: OccupancySensorType");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::OccupancySensorType::Id);
        }
        case 5: {
            LogStep(5, "Writes the respective default value to mandatory attribute: OccupancySensorType");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                  OccupancySensing::Attributes::OccupancySensorType::Id, value);
        }
        case 6: {
            LogStep(6, "Reads back mandatory attribute: OccupancySensorType");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::OccupancySensorType::Id);
        }
        case 7: {
            LogStep(7, "Reads mandatory attribute constrains: OccupancySensorTypeBitmap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id);
        }
        case 8: {
            LogStep(8, "Writes the respective default value to mandatory attribute: OccupancySensorTypeBitmap");
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                  OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id, value);
        }
        case 9: {
            LogStep(9, "Reads back mandatory attribute: OccupancySensorTypeBitmap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id,
                                 OccupancySensing::Attributes::OccupancySensorTypeBitmap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_2_2Suite : public TestCommand
{
public:
    Test_TC_OCC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_2_2", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint8_t OccupancyValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupancy", value, 0));

                OccupancyValue = value;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads Occupancy attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OCCUPANCY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id);
        }
        case 2: {
            LogStep(2, "Reads back Occupancy attribute from DUT after few seconds");
            VerifyOrdo(!ShouldSkip("A_OCCUPANCY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OccupancySensing::Id, OccupancySensing::Attributes::Occupancy::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_1_1Suite : public TestCommand
{
public:
    Test_TC_OO_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_1_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 4U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 4U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("featureMap", value, 1UL));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("featureMap", value, 1UL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "write the default values to mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            LogStep(4, "reads back global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::ClusterRevision::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::AttributeList::Id);
        }
        case 6: {
            LogStep(6, "read the optional global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::FeatureMap::Id);
        }
        case 7: {
            LogStep(7, "Read the optional global attribute : FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::FeatureMap::Id);
        }
        case 8: {
            LogStep(8, "write the default values to optional global attribute: FeatureMap");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::FeatureMap::Id, value);
        }
        case 9: {
            LogStep(9, "reads back optional global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_2_1Suite : public TestCommand
{
public:
    Test_TC_OO_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_2_1", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 2:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        case 3:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 5:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffStartUpOnOff> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the mandatory attribute: OnOff");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 2: {
            LogStep(2, "read LT attribute: GlobalSceneControl");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 3: {
            LogStep(3, "read LT attribute: OnTime");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 4: {
            LogStep(4, "read LT attribute: OffWaitTime");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 5: {
            LogStep(5, "read LT attribute: StartUpOnOff");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_2_2Suite : public TestCommand
{
public:
    Test_TC_OO_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_2_2", 21, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Send Off Command");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 2: {
            LogStep(2, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 3: {
            LogStep(3, "Send On Command");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 4: {
            LogStep(4, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 5: {
            LogStep(5, "Send On Command");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 6: {
            LogStep(6, "Check on/off attribute value is true after on command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 7: {
            LogStep(7, "Send Off Command");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 8: {
            LogStep(8, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 9: {
            LogStep(9, "Send Off Command");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 10: {
            LogStep(10, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 11: {
            LogStep(11, "Send Toggle Command");
            chip::app::Clusters::OnOff::Commands::Toggle::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Toggle::Id, value);
        }
        case 12: {
            LogStep(12, "Wait 1000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 13: {
            LogStep(13, "Check on/off attribute value is true after toggle command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 14: {
            LogStep(14, "Send Toggle Command");
            chip::app::Clusters::OnOff::Commands::Toggle::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Toggle::Id, value);
        }
        case 15: {
            LogStep(15, "Wait 1000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 16: {
            LogStep(16, "Check on/off attribute value is false after toggle command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 17: {
            LogStep(17, "User prompt Set OnOff attribute manually to on");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operate on device to set OnOff attribute manually to on");
        }
        case 18: {
            LogStep(18, "User prompt Set OnOff attribute manually to off");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operate on device to set OnOff attribute manually to off");
        }
        case 19: {
            LogStep(19, "Reset Off Command");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 20: {
            LogStep(20, "Check on/off attribute value is false after off command");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_2_3Suite : public TestCommand
{
public:
    Test_TC_OO_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_2_3", 47, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("globalSceneControl", value, 1));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("globalSceneControl", value, 1));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("globalSceneControl", value, 1));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onTime", value, 0U));
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("offWaitTime", value, 0U));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Send On Command");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Wait 1000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 3: {
            LogStep(3, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 4: {
            LogStep(4, "Reads GlobalSceneControl attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_GLOBALSCENECONTROL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 5: {
            LogStep(5, "Send On Command");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 6: {
            LogStep(6, "Wait 1000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 7: {
            LogStep(7, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 8: {
            LogStep(8, "Reads GlobalSceneControl attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_GLOBALSCENECONTROL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 9: {
            LogStep(9, "Send On Command");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 10: {
            LogStep(10, "Wait 1000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 11: {
            LogStep(11, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 12: {
            LogStep(12, "Reads GlobalSceneControl attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_GLOBALSCENECONTROL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::GlobalSceneControl::Id);
        }
        case 13: {
            LogStep(13, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 14: {
            LogStep(14, "Reads OffWaitTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 15: {
            LogStep(15, "Send On Command");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 16: {
            LogStep(16, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 17: {
            LogStep(17, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 18: {
            LogStep(18, "Reads OffWaitTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 19: {
            LogStep(19, "Send Off Command");
            VerifyOrdo(!ShouldSkip("CR_OFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 20: {
            LogStep(20, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 21: {
            LogStep(21, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 22: {
            LogStep(22, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 23: {
            LogStep(23, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 24: {
            LogStep(24, "Reads OffWaitTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 25: {
            LogStep(25, "Send On Command");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 26: {
            LogStep(26, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 27: {
            LogStep(27, "Reads OffWaitTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 28: {
            LogStep(28, "Send Off Command");
            VerifyOrdo(!ShouldSkip("CR_OFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 29: {
            LogStep(29, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 30: {
            LogStep(30, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 31: {
            LogStep(31, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 32: {
            LogStep(32, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 33: {
            LogStep(33, "Send On Command");
            VerifyOrdo(!ShouldSkip("CR_ON"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 34: {
            LogStep(34, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 35: {
            LogStep(35, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 36: {
            LogStep(36, "Reads OffWaitTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 37: {
            LogStep(37, "Send Off Command");
            VerifyOrdo(!ShouldSkip("CR_OFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 38: {
            LogStep(38, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 39: {
            LogStep(39, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 40: {
            LogStep(40, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 41: {
            LogStep(41, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 42: {
            LogStep(42, "Reads OffWaitTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 43: {
            LogStep(43, "Reads OnOff attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONOFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 44: {
            LogStep(44, "Reads OnTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ONTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnTime::Id);
        }
        case 45: {
            LogStep(45, "Reads OffWaitTime attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_OFFWAITTIME"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OffWaitTime::Id);
        }
        case 46: {
            LogStep(46, "Send Off Command");
            VerifyOrdo(!ShouldSkip("CR_OFF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OO_2_4Suite : public TestCommand
{
public:
    Test_TC_OO_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OO_2_4", 26, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OO_2_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffStartUpOnOff> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("startUpOnOff", value));
                VerifyOrReturn(CheckValue("startUpOnOff.Value()", value.Value(), 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH sends On command to DUT");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "TH writes a value of 0 to StartUpOnOff attribute of DUT");
            chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffStartUpOnOff> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::OnOff::OnOffStartUpOnOff>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id, value);
        }
        case 3: {
            LogStep(3, "TH reads the StartUpOnOff attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id);
        }
        case 4: {
            LogStep(4, "Power off DUT");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 5: {
            LogStep(5, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 6: {
            LogStep(6, "TH reads the OnOff attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 7: {
            LogStep(7, "TH writes a value of 1 to StartUpOnOff attribute of DUT");
            chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffStartUpOnOff> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::OnOff::OnOffStartUpOnOff>(1);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id, value);
        }
        case 8: {
            LogStep(8, "Power off DUT");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 9: {
            LogStep(9, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 10: {
            LogStep(10, "TH reads the OnOff attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 11: {
            LogStep(11, "TH writes a value of 2 to StartUpOnOff attribute of DUT");
            chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffStartUpOnOff> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::OnOff::OnOffStartUpOnOff>(2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id, value);
        }
        case 12: {
            LogStep(12, "Power off DUT");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 13: {
            LogStep(13, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 14: {
            LogStep(14, "TH reads the OnOff attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 15: {
            LogStep(15, "Power off DUT");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 16: {
            LogStep(16, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 17: {
            LogStep(17, "TH reads the OnOff attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 18: {
            LogStep(18, "TH writes NULL to StartUpOnOff attribute of DUT");
            chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffStartUpOnOff> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id, value);
        }
        case 19: {
            LogStep(19, "Power off DUT");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 20: {
            LogStep(20, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 21: {
            LogStep(21, "TH reads the OnOff attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 22: {
            LogStep(22, "TH sends Off command to DUT");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 23: {
            LogStep(23, "Power off DUT");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 24: {
            LogStep(24, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 25: {
            LogStep(25, "TH reads the OnOff attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PS_1_1Suite : public TestCommand
{
public:
    Test_TC_PS_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PS_1_1", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PS_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 0));
                    VerifyOrReturn(CheckValue("attributeList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 1));
                    VerifyOrReturn(CheckValue("attributeList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 2));
                    VerifyOrReturn(CheckValue("attributeList[2]", iter_0.GetValue(), 2UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 3));
                    VerifyOrReturn(CheckValue("attributeList[3]", iter_0.GetValue(), 5UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 4));
                    VerifyOrReturn(CheckValue("attributeList[4]", iter_0.GetValue(), 11UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 5));
                    VerifyOrReturn(CheckValue("attributeList[5]", iter_0.GetValue(), 12UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 6));
                    VerifyOrReturn(CheckValue("attributeList[6]", iter_0.GetValue(), 13UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 7));
                    VerifyOrReturn(CheckValue("attributeList[7]", iter_0.GetValue(), 14UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 8));
                    VerifyOrReturn(CheckValue("attributeList[8]", iter_0.GetValue(), 15UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 9));
                    VerifyOrReturn(CheckValue("attributeList[9]", iter_0.GetValue(), 16UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 10));
                    VerifyOrReturn(CheckValue("attributeList[10]", iter_0.GetValue(), 19UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 11));
                    VerifyOrReturn(CheckValue("attributeList[11]", iter_0.GetValue(), 26UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 12));
                    VerifyOrReturn(CheckValue("attributeList[12]", iter_0.GetValue(), 28UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 13));
                    VerifyOrReturn(CheckValue("attributeList[13]", iter_0.GetValue(), 25UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("attributeList", iter_0, 14));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acceptedCommandList", iter_0, 0));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("generatedCommandList", iter_0, 0));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("featureMap", value, 0UL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            VerifyOrdo(!ShouldSkip("PICS_SKIP_SAMPLE_APP"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::AttributeList::Id);
        }
        case 4: {
            LogStep(4,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 5: {
            LogStep(5, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::AcceptedCommandList::Id);
        }
        case 6: {
            LogStep(6, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id,
                                 PowerSource::Attributes::GeneratedCommandList::Id);
        }
        case 7: {
            LogStep(7, "read the optional global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PS_2_1Suite : public TestCommand
{
public:
    Test_TC_PS_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PS_2_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PS_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 200));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Test Harness Client reads Status attribute from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::Status::Id);
        }
        case 2: {
            LogStep(2, "Test Harness Client reads Order attribute from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::Order::Id);
        }
        case 3: {
            LogStep(3, "Test Harness Client reads Description attribute from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::Description::Id);
        }
        case 4: {
            LogStep(4, "Test Harness Client reads BatVoltage from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::BatteryVoltage::Id);
        }
        case 5: {
            LogStep(5, "Test Harness Client reads BatPercentRemaining from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id,
                                 PowerSource::Attributes::BatteryPercentRemaining::Id);
        }
        case 6: {
            LogStep(6, "Test Harness Client reads BatTimeRemaining from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id,
                                 PowerSource::Attributes::BatteryTimeRemaining::Id);
        }
        case 7: {
            LogStep(7, "Test Harness Client reads BatChargeLevel from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::BatteryChargeLevel::Id);
        }
        case 8: {
            LogStep(8, "Test Harness Client reads ActiveBatFaults from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::ActiveBatteryFaults::Id);
        }
        case 9: {
            LogStep(9, "Test Harness Client reads BatChargeState from Server DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PowerSource::Id, PowerSource::Attributes::BatteryChargeState::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PRS_1_1Suite : public TestCommand
{
public:
    Test_TC_PRS_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PRS_1_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PRS_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 3U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::ClusterRevision::Id);
        }
        case 3: {
            LogStep(3, "Write the default values to mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                  PressureMeasurement::Attributes::ClusterRevision::Id, value);
        }
        case 4: {
            LogStep(4, "Reads back global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::ClusterRevision::Id);
        }
        case 5: {
            LogStep(5, "Read the global mandatory attribute constraints: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::AttributeList::Id);
        }
        case 6: {
            LogStep(6,
                    "Read EventList attribute from the DUT and Verify that the DUT response provides a list of supported events.");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 7: {
            LogStep(7, "Read AcceptedCommandList attribute from the DUT and Verify that the DUT response");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 8: {
            LogStep(8, "Read GeneratedCommandList attribute from the DUT and Verify that the DUT response");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter 'y' for success", "y");
        }
        case 9: {
            LogStep(9, "Read FeatureMap attribute from the DUT and Verify that the DUT response");
            VerifyOrdo(!ShouldSkip("PICS_USER_PROMPT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Please enter '0' for success", "0");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PRS_2_1Suite : public TestCommand
{
public:
    Test_TC_PRS_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PRS_2_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PRS_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("measuredValue", value));
                VerifyOrReturn(CheckValue("measuredValue.Value()", value.Value(), 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("minMeasuredValue", value));
                VerifyOrReturn(CheckValue("minMeasuredValue.Value()", value.Value(), 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("maxMeasuredValue", value));
                VerifyOrReturn(CheckValue("maxMeasuredValue.Value()", value.Value(), 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read the mandatory attribute constraints: MeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            LogStep(2, "Write the default values to mandatory attribute: MeasuredValue");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                  PressureMeasurement::Attributes::MeasuredValue::Id, value);
        }
        case 3: {
            LogStep(3, "Reads back mandatory attribute: MeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MeasuredValue::Id);
        }
        case 4: {
            LogStep(4, "Read the mandatory attribute constraints: MinMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 5: {
            LogStep(5, "Write the default values to mandatory attribute: MinMeasuredValue");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                  PressureMeasurement::Attributes::MinMeasuredValue::Id, value);
        }
        case 6: {
            LogStep(6, "Reads back mandatory attribute: MinMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 7: {
            LogStep(7, "Read the mandatory attribute constraints: MaxMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 8: {
            LogStep(8, "Write the default values to mandatory attribute: MaxMeasuredValue");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                  PressureMeasurement::Attributes::MaxMeasuredValue::Id, value);
        }
        case 9: {
            LogStep(9, "Reads back mandatory attribute: MaxMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PressureMeasurement::Id,
                                 PressureMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_1_1Suite : public TestCommand
{
public:
    Test_TC_PCC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_1_1", 10, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("featureMap", value, 0UL));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("featureMap", value, 0UL));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "write the default values to mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 3U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::AttributeList::Id);
        }
        case 4: {
            LogStep(4, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::AcceptedCommandList::Id);
        }
        case 5: {
            LogStep(5, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::GeneratedCommandList::Id);
        }
        case 6: {
            LogStep(6, "read the optional global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::FeatureMap::Id);
        }
        case 7: {
            LogStep(7, "read the optional global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::FeatureMap::Id);
        }
        case 8: {
            LogStep(8, "write the default values to optional global attribute: FeatureMap");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::FeatureMap::Id, value);
        }
        case 9: {
            LogStep(9, "reads back optional global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_2_1Suite : public TestCommand
{
public:
    Test_TC_PCC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_2_1", 50, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 13:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 14:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 15:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 16:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 17:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 18:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 19:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 20:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 21:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -27315));
            }
            break;
        case 22:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -27315));
            }
            break;
        case 23:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("pumpStatus", value, 0U));
            }
            break;
        case 24:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
            }
            break;
        case 25:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 26:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", value));
                VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", value.Value(), 0UL));
            }
            break;
        case 27:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint24"));
            }
            break;
        case 28:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint24"));
            }
            break;
        case 29:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", value));
                VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", value.Value(), 0UL));
            }
            break;
        case 30:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 31:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 32:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 33:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 34:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 35:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 36:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 37:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 38:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 39:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 40:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -27315));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32767));
            }
            break;
        case 41:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -27315));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32767));
            }
            break;
        case 42:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("pumpStatus", value, 0U));
            }
            break;
        case 43:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
            }
            break;
        case 44:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", value));
                VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", value.Value(), 0UL));
            }
            break;
        case 46:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint24"));
            }
            break;
        case 47:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint24"));
            }
            break;
        case 48:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", value));
                VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", value.Value(), 0UL));
            }
            break;
        case 49:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the mandatory attribute: MaxPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxPressure::Id);
        }
        case 2: {
            LogStep(2, "read the mandatory attribute: MaxSpeed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxSpeed::Id);
        }
        case 3: {
            LogStep(3, "read the mandatory attribute: MaxFlow");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxFlow::Id);
        }
        case 4: {
            LogStep(4, "read the mandatory attribute: EffectiveOperationMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        case 5: {
            LogStep(5, "read the mandatory attribute: EffectiveControlMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 6: {
            LogStep(6, "read the mandatory attribute: Capacity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Capacity::Id);
        }
        case 7: {
            LogStep(7, "read the mandatory attribute: MaxPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxPressure::Id);
        }
        case 8: {
            LogStep(8, "read the mandatory attribute: MaxSpeed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxSpeed::Id);
        }
        case 9: {
            LogStep(9, "read the mandatory attribute: MaxFlow");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxFlow::Id);
        }
        case 10: {
            LogStep(10, "read the mandatory attribute: EffectiveOperationMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        case 11: {
            LogStep(11, "read the mandatory attribute: EffectiveControlMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 12: {
            LogStep(12, "read the mandatory attribute: Capacity");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Capacity::Id);
        }
        case 13: {
            LogStep(13, "read the optional attribute: MinConstPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstPressure::Id);
        }
        case 14: {
            LogStep(14, "read the optional attribute: MaxConstPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstPressure::Id);
        }
        case 15: {
            LogStep(15, "read the optional attribute: MinCompPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinCompPressure::Id);
        }
        case 16: {
            LogStep(16, "read the optional attribute: MaxCompPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxCompPressure::Id);
        }
        case 17: {
            LogStep(17, "read the optional attribute: MinConstSpeed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstSpeed::Id);
        }
        case 18: {
            LogStep(18, "read the optional attribute: MaxConstSpeed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstSpeed::Id);
        }
        case 19: {
            LogStep(19, "read the optional attribute: MinConstFlow");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstFlow::Id);
        }
        case 20: {
            LogStep(20, "read the optional attribute: MaxConstFlow");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstFlow::Id);
        }
        case 21: {
            LogStep(21, "read the optional attribute: MinConstTemp");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstTemp::Id);
        }
        case 22: {
            LogStep(22, "read the optional attribute: MaxConstTemp");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstTemp::Id);
        }
        case 23: {
            LogStep(23, "read the optional attribute: PumpStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::PumpStatus::Id);
        }
        case 24: {
            LogStep(24, "read the optional attribute: PumpStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::PumpStatus::Id);
        }
        case 25: {
            LogStep(25, "read the optional attribute: Speed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Speed::Id);
        }
        case 26: {
            LogStep(26, "read the optional attribute: LifetimeRunningHours");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 27: {
            LogStep(27, "read the optional attribute: LifetimeRunningHours");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 28: {
            LogStep(28, "read the optional attribute: Power");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Power::Id);
        }
        case 29: {
            LogStep(29, "read the optional attribute: LifetimeEnergyConsumed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        case 30: {
            LogStep(30, "read the optional attribute: LifetimeEnergyConsumed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        case 31: {
            LogStep(31, "write to the optional attribute: LifetimeEnergyConsumed");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id, value);
        }
        case 32: {
            LogStep(32, "read the optional attribute: MinConstPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstPressure::Id);
        }
        case 33: {
            LogStep(33, "read the optional attribute: MaxConstPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstPressure::Id);
        }
        case 34: {
            LogStep(34, "read the optional attribute: MinCompPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinCompPressure::Id);
        }
        case 35: {
            LogStep(35, "read the optional attribute: MaxCompPressure");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxCompPressure::Id);
        }
        case 36: {
            LogStep(36, "read the optional attribute: MinConstSpeed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstSpeed::Id);
        }
        case 37: {
            LogStep(37, "read the optional attribute: MaxConstSpeed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstSpeed::Id);
        }
        case 38: {
            LogStep(38, "read the optional attribute: MinConstFlow");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstFlow::Id);
        }
        case 39: {
            LogStep(39, "read the optional attribute: MaxConstFlow");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstFlow::Id);
        }
        case 40: {
            LogStep(40, "read the optional attribute: MinConstTemp");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MinConstTemp::Id);
        }
        case 41: {
            LogStep(41, "read the optional attribute: MaxConstTemp");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::MaxConstTemp::Id);
        }
        case 42: {
            LogStep(42, "read the optional attribute: PumpStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::PumpStatus::Id);
        }
        case 43: {
            LogStep(43, "read the optional attribute: PumpStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::PumpStatus::Id);
        }
        case 44: {
            LogStep(44, "read the optional attribute: Speed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Speed::Id);
        }
        case 45: {
            LogStep(45, "read the optional attribute: LifetimeRunningHours");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 46: {
            LogStep(46, "read the optional attribute: LifetimeRunningHours");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 47: {
            LogStep(47, "read the optional attribute: Power");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::Power::Id);
        }
        case 48: {
            LogStep(48, "read the optional attribute: LifetimeEnergyConsumed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        case 49: {
            LogStep(49, "read the optional attribute: LifetimeEnergyConsumed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_2_2Suite : public TestCommand
{
public:
    Test_TC_PCC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_2_2", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveOperationMode", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveOperationMode", value, 2));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveOperationMode", value, 3));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Write 1 to the OperationMode attribute to DUT: OperationMode");
            VerifyOrdo(!ShouldSkip("A_OPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode>(1);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::OperationMode::Id, value);
        }
        case 2: {
            LogStep(2, "Reads the attribute: EffectiveOperationMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVEOPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        case 3: {
            LogStep(3, "Write 2 to the OperationMode attribute to DUT: OperationMode");
            VerifyOrdo(!ShouldSkip("A_OPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode>(2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::OperationMode::Id, value);
        }
        case 4: {
            LogStep(4, "Reads the attribute: EffectiveOperationMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVEOPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        case 5: {
            LogStep(5, "Write 3 to the OperationMode attribute to DUT: OperationMode");
            VerifyOrdo(!ShouldSkip("A_OPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode>(3);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::OperationMode::Id, value);
        }
        case 6: {
            LogStep(6, "Reads the attribute: EffectiveOperationMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVEOPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_2_3Suite : public TestCommand
{
public:
    Test_TC_PCC_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_2_3", 15, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveOperationMode", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveControlMode", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveControlMode", value, 1));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveControlMode", value, 2));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveControlMode", value, 3));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveControlMode", value, 5));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("effectiveControlMode", value, 7));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Write 0 to the OperationMode attribute to DUT");
            VerifyOrdo(!ShouldSkip("A_OPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpOperationMode>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::OperationMode::Id, value);
        }
        case 2: {
            LogStep(2, "Reads the attribute: EffectiveOperationMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVEOPERATIONMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Id);
        }
        case 3: {
            LogStep(3, "Write 0 to the ControlMode attribute to DUT");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 4: {
            LogStep(4, "Reads the attribute: EffectiveControlMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVECONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 5: {
            LogStep(5, "Write 1 to the ControlMode attribute to DUT");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode>(1);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 6: {
            LogStep(6, "Reads the attribute: EffectiveControlMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVECONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 7: {
            LogStep(7, "Write 2 to the ControlMode attribute to DUT");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode>(2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 8: {
            LogStep(8, "Reads the attribute: EffectiveControlMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVECONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 9: {
            LogStep(9, "Write 3 to the ControlMode attribute to DUT");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode>(3);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 10: {
            LogStep(10, "Reads the attribute: EffectiveControlMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVECONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 11: {
            LogStep(11, "Write 5 to the ControlMode attribute to DUT");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode>(5);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 12: {
            LogStep(12, "Reads the attribute: EffectiveControlMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVECONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        case 13: {
            LogStep(13, "Write 7 to the ControlMode attribute to DUT");
            VerifyOrdo(!ShouldSkip("A_CONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode value;
            value = static_cast<chip::app::Clusters::PumpConfigurationAndControl::PumpControlMode>(7);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::ControlMode::Id, value);
        }
        case 14: {
            LogStep(14, "Reads the attribute: EffectiveControlMode");
            VerifyOrdo(!ShouldSkip("A_EFFECTIVECONTROLMODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::EffectiveControlMode::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PCC_2_4Suite : public TestCommand
{
public:
    Test_TC_PCC_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PCC_2_4", 13, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PCC_2_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", value));
                VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", value.Value(), 1UL));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", value));
                VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", value.Value(), 2UL));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeRunningHours", value));
                VerifyOrReturn(CheckValue("lifetimeRunningHours.Value()", value.Value(), 3UL));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", value));
                VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", value.Value(), 1UL));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", value));
                VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", value.Value(), 2UL));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lifetimeEnergyConsumed", value));
                VerifyOrReturn(CheckValue("lifetimeEnergyConsumed.Value()", value.Value(), 3UL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Write 1 to the LifetimeRunningHours attribute to DUT");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 1UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id, value);
        }
        case 2: {
            LogStep(2, "Reads the attribute: LifetimeRunningHours");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 3: {
            LogStep(3, "Write 2 to the LifetimeRunningHours attribute to DUT");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 2UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id, value);
        }
        case 4: {
            LogStep(4, "Reads the attribute: LifetimeRunningHours");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 5: {
            LogStep(5, "Write 3 to the LifetimeRunningHours attribute to DUT");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 3UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id, value);
        }
        case 6: {
            LogStep(6, "Reads the attribute: LifetimeRunningHours");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Id);
        }
        case 7: {
            LogStep(7, "Write 1 to the LifetimeEnergyConsumed attribute to DUT");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 1UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id, value);
        }
        case 8: {
            LogStep(8, "Reads the attribute: LifetimeEnergyConsumed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        case 9: {
            LogStep(9, "Write 2 to the LifetimeEnergyConsumed attribute to DUT");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 2UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id, value);
        }
        case 10: {
            LogStep(10, "Reads the attribute: LifetimeEnergyConsumed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        case 11: {
            LogStep(11, "Write 3 to the LifetimeEnergyConsumed attribute to DUT");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 3UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                  PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id, value);
        }
        case 12: {
            LogStep(12, "Reads the attribute: LifetimeEnergyConsumed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), PumpConfigurationAndControl::Id,
                                 PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PSCFG_1_1Suite : public TestCommand
{
public:
    Test_TC_PSCFG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PSCFG_1_1", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PSCFG_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("clusterRevision", value, 1U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Commission DUT to TH");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH reads the ClusterRevision attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), PowerSourceConfiguration::Id,
                                 PowerSourceConfiguration::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "TH reads the AttributeList attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), PowerSourceConfiguration::Id,
                                 PowerSourceConfiguration::Attributes::AttributeList::Id);
        }
        case 3: {
            LogStep(3, "TH reads the AcceptedCommandList attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), PowerSourceConfiguration::Id,
                                 PowerSourceConfiguration::Attributes::AcceptedCommandList::Id);
        }
        case 4: {
            LogStep(4, "TH reads the GeneratedCommandList attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), PowerSourceConfiguration::Id,
                                 PowerSourceConfiguration::Attributes::GeneratedCommandList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_RH_1_1Suite : public TestCommand
{
public:
    Test_TC_RH_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_RH_1_1", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_RH_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::AttributeList::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::AcceptedCommandList::Id);
        }
        case 4: {
            LogStep(4, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::GeneratedCommandList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_RH_2_1Suite : public TestCommand
{
public:
    Test_TC_RH_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_RH_2_1", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_RH_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9999U));
            }
            break;
        case 3:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2048U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads constraints of attribute: MeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            LogStep(2, "Reads constraints of attribute: MinMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 3: {
            LogStep(3, "Reads constraints of attribute: Tolerance");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::Tolerance::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_RH_2_2Suite : public TestCommand
{
public:
    Test_TC_RH_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_RH_2_2", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_RH_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9999U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads constraints of attribute: MinMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 2: {
            LogStep(2, "Reads MeasuredValue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_RELATIVEHUMIDITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MeasuredValue::Id);
        }
        case 3: {
            LogStep(3, "Read the mandatory attribute: MeasuredValue");
            VerifyOrdo(!ShouldSkip("A_RELATIVEHUMIDITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), RelativeHumidityMeasurement::Id,
                                 RelativeHumidityMeasurement::Attributes::MeasuredValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SC_4_2Suite : public TestCommand
{
public:
    Test_TC_SC_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_2", 21, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("vendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("productId", 0, UINT16_MAX, &mProductId);
        AddArgument("deviceType", 0, UINT16_MAX, &mDeviceType);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SC_4_2Suite()
    {
        if (deviceInstanceNameBeforeReboot1Buffer != nullptr)
        {
            chip::Platform::MemoryFree(deviceInstanceNameBeforeReboot1Buffer);
            deviceInstanceNameBeforeReboot1Buffer = nullptr;
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<uint16_t> mVendorId;
    chip::Optional<uint16_t> mProductId;
    chip::Optional<uint16_t> mDeviceType;
    chip::Optional<uint16_t> mTimeout;

    char * deviceInstanceNameBeforeReboot1Buffer = nullptr;
    chip::CharSpan deviceInstanceNameBeforeReboot1;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintIsUpperCase("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintIsHexString("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintMinLength("value.instanceName", value.instanceName.size(), 16));
                VerifyOrReturn(CheckConstraintMaxLength("value.instanceName", value.instanceName.size(), 16));
                if (deviceInstanceNameBeforeReboot1Buffer != nullptr)
                {
                    chip::Platform::MemoryFree(deviceInstanceNameBeforeReboot1Buffer);
                }
                deviceInstanceNameBeforeReboot1Buffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.instanceName.size()));
                memcpy(deviceInstanceNameBeforeReboot1Buffer, value.instanceName.data(), value.instanceName.size());
                deviceInstanceNameBeforeReboot1 = chip::CharSpan(deviceInstanceNameBeforeReboot1Buffer, value.instanceName.size());
            }
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("vendorId", value.vendorId, mVendorId.HasValue() ? mVendorId.Value() : 65521U));
            }
            shouldContinue = true;
            break;
        case 9:
            if (IsUnsupported(status.mStatus))
            {
                shouldContinue = true;
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("productId", value.productId, mProductId.HasValue() ? mProductId.Value() : 32769U));
            }
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValuePresent("value.mrpRetryIntervalIdle", value.mrpRetryIntervalIdle));
                VerifyOrReturn(
                    CheckConstraintMaxValue("value.mrpRetryIntervalIdle.Value()", value.mrpRetryIntervalIdle.Value(), 3600000UL));
            }
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValuePresent("value.mrpRetryIntervalActive", value.mrpRetryIntervalActive));
                VerifyOrReturn(CheckConstraintMaxValue("value.mrpRetryIntervalActive.Value()", value.mrpRetryIntervalActive.Value(),
                                                       3600000UL));
            }
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("commissioningMode", value.commissioningMode, 1));
            }
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxLength("value.deviceName", value.deviceName.size(), 32));
            }
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxValue("value.rotatingIdLen", value.rotatingIdLen, 100ULL));
            }
            shouldContinue = true;
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintNotValue("value.pairingHint", value.pairingHint, 0U));
            }
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxLength("value.pairingInstruction", value.pairingInstruction.size(), 128));
            }
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMinValue("value.numIPs", value.numIPs, 1));
            }
            shouldContinue = true;
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2,
                    "TH is put in Commissioning Mode using Open Basic Commissioning Window command and starts advertising "
                    "Commissionable Node Discovery service using DNS-SD");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "Check Instance Name");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 4: {
            LogStep(4, "Check Long Discriminator _L");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByLongDiscriminator(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 5: {
            LogStep(5, "Check Short Discriminator (_S)");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByShortDiscriminator(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 6: {
            LogStep(6, "Check Vendor ID (_V)");
            VerifyOrdo(!ShouldSkip("VENDOR_SUBTYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByVendorId(mVendorId.HasValue() ? mVendorId.Value() : 65521U);
        }
        case 7: {
            LogStep(7, "Check Commissioning Mode (_CM)");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByCommissioningMode();
        }
        case 8: {
            LogStep(8, "TXT key for Vendor ID and Product ID (VP)");
            VerifyOrdo(!ShouldSkip("VP_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 9: {
            LogStep(9, "TXT key for Vendor ID and Product ID (VP)");
            VerifyOrdo(!ShouldSkip("VP_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 10: {
            LogStep(10, "Optional TXT key for MRP Retry Interval Idle (CRI)");
            VerifyOrdo(!ShouldSkip("CRI_COMM_DISCOVERY_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 11: {
            LogStep(11, "Optional TXT key for MRP Retry Interval Active (CRA)");
            VerifyOrdo(!ShouldSkip("CRA_COMM_DISCOVERY_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 12: {
            LogStep(12, "TXT key for commissioning mode (CM)");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 13: {
            LogStep(13, "Optional TXT key for device name (DN)");
            VerifyOrdo(!ShouldSkip("DN_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 14: {
            LogStep(14, "Optional TXT key for rotating device identifier (RI)");
            VerifyOrdo(!ShouldSkip("RI_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 15: {
            LogStep(15, "Optional TXT key for pairing hint (PH)");
            VerifyOrdo(!ShouldSkip("PH_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 16: {
            LogStep(16, "Optional TXT key for pairing instructions (PI)");
            VerifyOrdo(!ShouldSkip("PI_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 17: {
            LogStep(17, "Check IPs");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 18: {
            LogStep(18, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 19: {
            LogStep(19, "Log commands");
            SetIdentity(kIdentityAlpha);
            return Log("TH adds an unknown key/value pair in the advertised data");
        }
        case 20: {
            LogStep(20, "Log commands");
            SetIdentity(kIdentityAlpha);
            return Log("Scan for DNS-SD commissioner advertisements from TH");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWTCH_2_1Suite : public TestCommand
{
public:
    Test_TC_SWTCH_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWTCH_2_1", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWTCH_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfPositions", value, 2));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 2));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentPosition", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("multiPressMax", value, 2));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 2));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read NumberOfPositions attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::NumberOfPositions::Id);
        }
        case 2: {
            LogStep(2, "Read NumberOfPositions attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::NumberOfPositions::Id);
        }
        case 3: {
            LogStep(3, "Read CurrentPosition attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::CurrentPosition::Id);
        }
        case 4: {
            LogStep(4, "Read CurrentPosition attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::CurrentPosition::Id);
        }
        case 5: {
            LogStep(5, "Read MultiPressMax attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::MultiPressMax::Id);
        }
        case 6: {
            LogStep(6, "Read MultiPressMax attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::MultiPressMax::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWTCH_2_2Suite : public TestCommand
{
public:
    Test_TC_SWTCH_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWTCH_2_2", 38, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWTCH_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentPosition", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentPosition", value, 0));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to SwitchLatched event");
        }
        case 2: {
            LogStep(2, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator sets switch to first position");
        }
        case 3: {
            LogStep(3, "Read CurrentPosition attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::CurrentPosition::Id);
        }
        case 4: {
            LogStep(4, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator sets switch to second position");
        }
        case 5: {
            LogStep(5, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to InitialPress event");
        }
        case 6: {
            LogStep(6, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch");
        }
        case 7: {
            LogStep(7, "Read CurrentPosition attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Switch::Id, Switch::Attributes::CurrentPosition::Id);
        }
        case 8: {
            LogStep(8, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator sets switch to second position");
        }
        case 9: {
            LogStep(9, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch (release switch)");
        }
        case 10: {
            LogStep(10, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to InitialPress and ShortRelease events");
        }
        case 11: {
            LogStep(11, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch");
        }
        case 12: {
            LogStep(12, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch (press briefly)");
        }
        case 13: {
            LogStep(13, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 14: {
            LogStep(14, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch for 5 seconds");
        }
        case 15: {
            LogStep(15, "Wait 3000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 16: {
            LogStep(16, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 17: {
            LogStep(17, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to InitialPress, LongPress, ShortRelease, LongRelease events");
        }
        case 18: {
            LogStep(18, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch");
        }
        case 19: {
            LogStep(19, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch (press briefly)");
        }
        case 20: {
            LogStep(20, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 21: {
            LogStep(21, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch for 5 seconds");
        }
        case 22: {
            LogStep(22, "Wait 3000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 23: {
            LogStep(23, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 24: {
            LogStep(24, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Set up subscription to InitialPress, ShortRelease, MultiPressOngoing, MultiPressComplete events");
        }
        case 25: {
            LogStep(25, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator does not operate switch");
        }
        case 26: {
            LogStep(26, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch (press briefly)");
        }
        case 27: {
            LogStep(27, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 28: {
            LogStep(28, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch (press briefly)");
        }
        case 29: {
            LogStep(29, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 30: {
            LogStep(30, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch again (press briefly)");
        }
        case 31: {
            LogStep(31, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 32: {
            LogStep(32, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch again (press briefly)");
        }
        case 33: {
            LogStep(33, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 34: {
            LogStep(34, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch again (press briefly)");
        }
        case 35: {
            LogStep(35, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        case 36: {
            LogStep(36, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator operates switch again (press briefly)");
        }
        case 37: {
            LogStep(37, "User interaction needed");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("Operator releases switch");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TM_1_1Suite : public TestCommand
{
public:
    Test_TC_TM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TM_1_1", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TM_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::AttributeList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TM_2_1Suite : public TestCommand
{
public:
    Test_TC_TM_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TM_2_1", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TM_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -27315));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32766));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -27314));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32767));
            }
            break;
        case 4:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2048U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the mandatory attribute: MeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MeasuredValue::Id);
        }
        case 2: {
            LogStep(2, "read the mandatory attribute: MinMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 3: {
            LogStep(3, "read the mandatory attribute: MaxMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 4: {
            LogStep(4, "read the optional attribute: Tolerance");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::Tolerance::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TM_2_2Suite : public TestCommand
{
public:
    Test_TC_TM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TM_2_2", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TM_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -27315));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32766));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -27314));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32767));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the mandatory attribute: MinMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MinMeasuredValue::Id);
        }
        case 2: {
            LogStep(2, "read the mandatory attribute: MaxMeasuredValue");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MaxMeasuredValue::Id);
        }
        case 3: {
            LogStep(3, "Reads MeasuredValue attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MeasuredValue::Id);
        }
        case 4: {
            LogStep(4, "Read the mandatory attribute: MeasuredValue");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TemperatureMeasurement::Id,
                                 TemperatureMeasurement::Attributes::MeasuredValue::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSTAT_1_1Suite : public TestCommand
{
public:
    Test_TC_TSTAT_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSTAT_1_1", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSTAT_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map32"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::AttributeList::Id);
        }
        case 3: {
            LogStep(3, "Read the optional global attribute constraints: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSTAT_2_1Suite : public TestCommand
{
public:
    Test_TC_TSTAT_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSTAT_2_1", 18, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSTAT_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3000));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3000));
            }
            break;
        case 4:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3200));
            }
            break;
        case 5:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3200));
            }
            break;
        case 6:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2600));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2600));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3000));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3000));
            }
            break;
        case 10:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3200));
            }
            break;
        case 11:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3200));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Thermostat::ThermostatControlSequence value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 5));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9));
            }
            break;
        case 14:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 25));
            }
            break;
        case 15:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 6));
            }
            break;
        case 16:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 17:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads constraints of mandatory attributes from DUT: LocalTemperature");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::LocalTemperature::Id);
        }
        case 2: {
            LogStep(2, "Reads constraints of mandatory attributes from DUT: AbsMinHeatSetpointLimit");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMinHeatSetpointLimit::Id);
        }
        case 3: {
            LogStep(3, "Reads constraints of mandatory attributes from DUT: AbsMaxHeatSetpointLimit");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMaxHeatSetpointLimit::Id);
        }
        case 4: {
            LogStep(4, "Reads constraints of optional attributes from DUT: AbsMinCoolSetpointLimit");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMinCoolSetpointLimit::Id);
        }
        case 5: {
            LogStep(5, "Reads constraints of optional attributes from DUT: AbsMaxCoolSetpointLimit");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::AbsMaxCoolSetpointLimit::Id);
        }
        case 6: {
            LogStep(6, "Reads constraints of optional attributes from DUT: OccupiedCoolingSetpoint");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedCoolingSetpoint::Id);
        }
        case 7: {
            LogStep(7, "Reads constraints of mandatory attributes from DUT: OccupiedHeatingSetpoint");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedHeatingSetpoint::Id);
        }
        case 8: {
            LogStep(8, "Reads constraints of mandatory attributes from DUT: MinHeatSetpointLimit");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id);
        }
        case 9: {
            LogStep(9, "Reads constraints of mandatory attributes from DUT: MaxHeatSetpointLimit");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id);
        }
        case 10: {
            LogStep(10, "Reads constraints of optional attributes from DUT: MinCoolSetpointLimit");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id);
        }
        case 11: {
            LogStep(11, "Reads constraints of optional attributes from DUT: MaxCoolSetpointLimit");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id);
        }
        case 12: {
            LogStep(12, "Reads constraints of mandatory attributes from DUT: ControlSequenceOfOperation");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::ControlSequenceOfOperation::Id);
        }
        case 13: {
            LogStep(13, "Reads constraints of mandatory attributes from DUT: SystemMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::SystemMode::Id);
        }
        case 14: {
            LogStep(14, "Reads constraints of optional attributes from DUT: MinSetpointDeadBand");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinSetpointDeadBand::Id);
        }
        case 15: {
            LogStep(15, "Reads constraints of optional attributes from DUT: StartOfWeek");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::StartOfWeek::Id);
        }
        case 16: {
            LogStep(16, "Reads constraints of optional attributes from DUT: NumberOfWeeklyTransitions");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::NumberOfWeeklyTransitions::Id);
        }
        case 17: {
            LogStep(17, "Reads constraints of optional attributes from DUT: NumberOfDailyTransitions");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::NumberOfDailyTransitions::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSTAT_2_2Suite : public TestCommand
{
public:
    Test_TC_TSTAT_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSTAT_2_2", 50, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSTAT_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", value, 2600));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2600));
            }
            break;
        case 2:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedCoolingSetpoint", value, 2000));
            }
            break;
        case 4:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", value, 2000));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3000));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("occupiedHeatingSetpoint", value, 2100));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minHeatSetpointLimit", value, 700));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3000));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minHeatSetpointLimit", value, 2000));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxHeatSetpointLimit", value, 3000));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 700));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3000));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxHeatSetpointLimit", value, 2000));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minCoolSetpointLimit", value, 1600));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3200));
            }
            break;
        case 22:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("minCoolSetpointLimit", value, 2000));
            }
            break;
        case 24:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 25:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxCoolSetpointLimit", value, 3200));
                VerifyOrReturn(CheckConstraintType("value", "", "int16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1600));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 3200));
            }
            break;
        case 27:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 28:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxCoolSetpointLimit", value, 2000));
            }
            break;
        case 29:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 30:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 35:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 36:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 37:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Thermostat::ThermostatControlSequence value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("controlSequenceOfOperation", value, 4));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 5));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Thermostat::ThermostatControlSequence value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("controlSequenceOfOperation", value, 2));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 44:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 45:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 46:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 48:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads OccupiedCoolingSetpoint attribute from Server DUT and verifies that the value is within range");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedCoolingSetpoint::Id);
        }
        case 2: {
            LogStep(2, "Writes a value back that is different but valid for OccupiedCoolingSetpoint attribute");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 3: {
            LogStep(3, "Reads it back again to confirm the successful write of OccupiedCoolingSetpoint attribute");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedCoolingSetpoint::Id);
        }
        case 4: {
            LogStep(4, "Writes the limit of MinCoolSetpointLimit to OccupiedCoolingSetpoint attribute");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 5: {
            LogStep(5, "Writes the limit of MaxCoolSetpointLimit to OccupiedCoolingSetpoint attribute");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 6: {
            LogStep(6, "Reads OccupiedHeatingSetpoint attribute from Server DUT and verifies that the value is within range");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedHeatingSetpoint::Id);
        }
        case 7: {
            LogStep(7, "Writes a value back that is different but valid for OccupiedHeatingSetpoint attribute");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2100;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 8: {
            LogStep(8, "Reads it back again to confirm the successful write of OccupiedHeatingSetpoint attribute");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::OccupiedHeatingSetpoint::Id);
        }
        case 9: {
            LogStep(9, "Writes the limit of MinHeatSetpointLimit to OccupiedHeatingSetpoint attribute");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 10: {
            LogStep(10, "Writes the limit of MaxHeatSetpointLimit to OccupiedHeatingSetpoint attribute");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 11: {
            LogStep(11, "Reads MinHeatSetpointLimit attribute from Server DUT and verifies that the value is within range");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id);
        }
        case 12: {
            LogStep(12, "Writes a value back that is different but valid for MinHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 13: {
            LogStep(13, "Reads it back again to confirm the successful write of MinHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id);
        }
        case 14: {
            LogStep(14, "Writes the limit of AbsMinHeatSetpointLimit to MinHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 15: {
            LogStep(15, "Writes the limit of AbsMaxHeatSetpointLimit to MinHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 16: {
            LogStep(16, "Reads MaxHeatSetpointLimit attribute from Server DUT and verifies that the value is within range");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id);
        }
        case 17: {
            LogStep(17, "Writes a value back that is different but valid for MaxHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 18: {
            LogStep(18, "Reads it back again to confirm the successful write of MaxHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id);
        }
        case 19: {
            LogStep(19, "Writes the limit of AbsMinHeatSetpointLimit to MaxHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 20: {
            LogStep(20, "Writes the limit of AbsMaxHeatSetpointLimit to MaxHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 21: {
            LogStep(21, "Reads MinCoolSetpointLimit attribute from Server DUT and verifies that the value is within range");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id);
        }
        case 22: {
            LogStep(22, "Writes a value back that is different but valid for MinCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 23: {
            LogStep(23, "Reads it back again to confirm the successful write of MinCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id);
        }
        case 24: {
            LogStep(24, "Writes the limit of AbsMinCoolSetpointLimit to MinCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 25: {
            LogStep(25, "Writes the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 26: {
            LogStep(26, "Reads MaxCoolSetpointLimit attribute from Server DUT and verifies that the value is within range");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id);
        }
        case 27: {
            LogStep(27, "Writes a value back that is different but valid for MaxCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 28: {
            LogStep(28, "Reads it back again to confirm the successful write of MaxCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id);
        }
        case 29: {
            LogStep(29, "Writes the limit of AbsMinCoolSetpointLimit to MaxCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 30: {
            LogStep(30, "Writes the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 31: {
            LogStep(31, "Writes (sets back) the limit of MinHeatSetpointLimit to MinHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 32: {
            LogStep(32, "Writes (sets back) the limit of MaxHeatSetpointLimit to MinHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinHeatSetpointLimit::Id,
                                  value);
        }
        case 33: {
            LogStep(33, "Writes (sets back) the limit of MinHeatSetpointLimit to MaxHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 700;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 34: {
            LogStep(34, "Writes (sets back) the limit of MaxHeatSetpointLimit to MaxHeatSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINHEATSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxHeatSetpointLimit::Id,
                                  value);
        }
        case 35: {
            LogStep(35, "Writes (sets back) the limit of MinCoolSetpointLimit to MinCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 36: {
            LogStep(36, "Writes (sets back) the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MINCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MinCoolSetpointLimit::Id,
                                  value);
        }
        case 37: {
            LogStep(37, "Writes (sets back) the limit of MinCoolSetpointLimit to MaxCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 1600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 38: {
            LogStep(38, "Writes (sets back) the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute");
            VerifyOrdo(!ShouldSkip("A_MAXCOOLSETPOINTLIMIT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 3200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id, Thermostat::Attributes::MaxCoolSetpointLimit::Id,
                                  value);
        }
        case 39: {
            LogStep(39, "Reads ControlSequenceOfOperation from Server DUT and verifies that the value is valid");
            VerifyOrdo(!ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::ControlSequenceOfOperation::Id);
        }
        case 40: {
            LogStep(40, "Write Attribute command for ControlSequenceOfOperation with a new valid value");
            VerifyOrdo(!ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::Thermostat::ThermostatControlSequence value;
            value = static_cast<chip::app::Clusters::Thermostat::ThermostatControlSequence>(2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::ControlSequenceOfOperation::Id, value);
        }
        case 41: {
            LogStep(41, "Read it back again to confirm the successful write");
            VerifyOrdo(!ShouldSkip("A_CONTROLSEQUENCEOFOPERATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                 Thermostat::Attributes::ControlSequenceOfOperation::Id);
        }
        case 42: {
            LogStep(42, "Sets OccupiedHeatingSetpoint to default value");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 43: {
            LogStep(43, "Sets OccupiedHeatingSetpoint to default value");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 44: {
            LogStep(44, "Sets OccupiedCoolingSetpoint to default value");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 45: {
            LogStep(45, "Sets OccupiedCoolingSetpoint to default value");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 46: {
            LogStep(46, "Sets OccupiedCoolingSetpoint to default value");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 47: {
            LogStep(47, "Sets OccupiedHeatingSetpoint to default value");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        case 48: {
            LogStep(48, "Sets OccupiedCoolingSetpoint to default value");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDCOOLINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2600;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedCoolingSetpoint::Id, value);
        }
        case 49: {
            LogStep(49, "Sets OccupiedHeatingSetpoint to default value");
            VerifyOrdo(!ShouldSkip("A_OCCUPIEDHEATINGSETPOINT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            int16_t value;
            value = 2000;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Thermostat::Id,
                                  Thermostat::Attributes::OccupiedHeatingSetpoint::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSUIC_1_1Suite : public TestCommand
{
public:
    Test_TC_TSUIC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSUIC_1_1", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSUIC_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read the global attribute constraints: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::AttributeList::Id);
        }
        case 3: {
            LogStep(3, "Read the global attribute: AcceptedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::AcceptedCommandList::Id);
        }
        case 4: {
            LogStep(4, "Read the global attribute: GeneratedCommandList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::GeneratedCommandList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSUIC_2_1Suite : public TestCommand
{
public:
    Test_TC_TSUIC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSUIC_2_1", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSUIC_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("temperatureDisplayMode", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("keypadLockout", value, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 5));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("scheduleProgrammingVisibility", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 1));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "read the mandatory attribute: TemperatureDisplayMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id);
        }
        case 2: {
            LogStep(2, "read the mandatory attribute: TemperatureDisplayMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id);
        }
        case 3: {
            LogStep(3, "read the mandatory attribute: KeypadLockout");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id);
        }
        case 4: {
            LogStep(4, "read the mandatory attribute: KeypadLockout");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id);
        }
        case 5: {
            LogStep(5, "read the optional attribute: ScheduleProgrammingVisibility");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id);
        }
        case 6: {
            LogStep(6, "read the optional attribute: ScheduleProgrammingVisibility");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                 ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_TSUIC_2_2Suite : public TestCommand
{
public:
    Test_TC_TSUIC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_TSUIC_2_2", 14, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_TSUIC_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Writes a value of 0 to TemperatureDisplayMode attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE_DISPLAY_MODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id, value);
        }
        case 2: {
            LogStep(2, "Writes a value of 1 to TemperatureDisplayMode attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE_DISPLAY_MODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id, value);
        }
        case 3: {
            LogStep(3, "Writes a value of greater than 1 to TemperatureDisplayMode attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_TEMPERATURE_DISPLAY_MODE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Id, value);
        }
        case 4: {
            LogStep(4, "Writes a value of 0 to KeypadLockout attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 5: {
            LogStep(5, "Writes a value of 1 to KeypadLockout attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 6: {
            LogStep(6, "Writes a value of 2 to KeypadLockout attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 7: {
            LogStep(7, "Writes a value of 3 to KeypadLockout attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 3;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 8: {
            LogStep(8, "Writes a value of 4 to KeypadLockout attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 4;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 9: {
            LogStep(9, "Writes a value of 5 to KeypadLockout attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 5;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 10: {
            LogStep(10, "Writes a value of greater than 5 to KeypadLockout attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_KEYPAD_LOCKOUT"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 6;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Id, value);
        }
        case 11: {
            LogStep(11, "Writes a value of 0 to ScheduleProgrammingVisibility attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id, value);
        }
        case 12: {
            LogStep(12, "Writes a value of 1 to ScheduleProgrammingVisibility attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id, value);
        }
        case 13: {
            LogStep(13, "Writes a value of greater than 1 to ScheduleProgrammingVisibility attribute of DUT");
            VerifyOrdo(!ShouldSkip("A_SCHEDULE_PROGRAMMING_VISIBILITY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            uint8_t value;
            value = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ThermostatUserInterfaceConfiguration::Id,
                                  ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DIAG_TH_NW_1_1Suite : public TestCommand
{
public:
    Test_TC_DIAG_TH_NW_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_TH_NW_1_1", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DIAG_TH_NW_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("overrunCount", value, 0ULL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Sends ResetCounts command");
            chip::app::Clusters::ThreadNetworkDiagnostics::Commands::ResetCounts::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                               ThreadNetworkDiagnostics::Commands::ResetCounts::Id, value);
        }
        case 2: {
            LogStep(2, "Read the Overruncount attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::OverrunCount::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DIAG_TH_NW_1_2Suite : public TestCommand
{
public:
    Test_TC_DIAG_TH_NW_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_TH_NW_1_2", 102, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DIAG_TH_NW_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "string"));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 16));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("partitionId", value, 0UL));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weighting", value, 0));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("dataVersion", value, 0));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("stableDataVersion", value, 0));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("leaderRouterId", value, 0));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("detachedRoleCount", value, 0U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("childRoleCount", value, 0U));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("routerRoleCount", value, 0U));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("leaderRoleCount", value, 0U));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("attachAttemptCount", value, 0U));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("partitionIdChangeCount", value, 0U));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("betterPartitionAttachAttemptCount", value, 0U));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("parentChangeCount", value, 0U));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txTotalCount", value, 0UL));
            }
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txUnicastCount", value, 0UL));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txBroadcastCount", value, 0UL));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txNoAckRequestedCount", value, 0UL));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txDataCount", value, 0UL));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txDataPollCount", value, 0UL));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txBeaconCount", value, 0UL));
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txBeaconRequestCount", value, 0UL));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txOtherCount", value, 0UL));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txRetryCount", value, 0UL));
            }
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txDirectMaxRetryExpiryCount", value, 0UL));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txIndirectMaxRetryExpiryCount", value, 0UL));
            }
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txErrCcaCount", value, 0UL));
            }
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txErrAbortCount", value, 0UL));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("txErrBusyChannelCount", value, 0UL));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxTotalCount", value, 0UL));
            }
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxUnicastCount", value, 0UL));
            }
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxBroadcastCount", value, 0UL));
            }
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxDataCount", value, 0UL));
            }
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxDataPollCount", value, 0UL));
            }
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxBeaconCount", value, 0UL));
            }
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxBeaconRequestCount", value, 0UL));
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxOtherCount", value, 0UL));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxAddressFilteredCount", value, 0UL));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxDestAddrFilteredCount", value, 0UL));
            }
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxDuplicatedCount", value, 0UL));
            }
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxErrNoFrameCount", value, 0UL));
            }
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxErrUnknownNeighborCount", value, 0UL));
            }
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxErrInvalidSrcAddrCount", value, 0UL));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxErrSecCount", value, 0UL));
            }
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxErrFcsCount", value, 0UL));
            }
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rxErrOtherCount", value, 0UL));
            }
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("activeTimestamp", value, 0ULL));
            }
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("pendingTimestamp", value, 0ULL));
            }
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("delay", value, 0UL));
            }
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Validate constraints of attribute: Channel");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::Channel::Id);
        }
        case 2: {
            LogStep(2, "Validate constraints of attribute: NetworkName");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::NetworkName::Id);
        }
        case 3: {
            LogStep(3, "Validate constraints of attribute: PanId");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::PanId::Id);
        }
        case 4: {
            LogStep(4, "Validate constraints of attribute: ExtendedPanId");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::ExtendedPanId::Id);
        }
        case 5: {
            LogStep(5, "Validate constraints of attribute: OverrunCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::OverrunCount::Id);
        }
        case 6: {
            LogStep(6, "read PartitionId attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::PartitionId::Id);
        }
        case 7: {
            LogStep(7, "Validate constraints of attribute: PartitionId");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::PartitionId::Id);
        }
        case 8: {
            LogStep(8, "read Weighting attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::Weighting::Id);
        }
        case 9: {
            LogStep(9, "Validate constraints of attribute: weighting");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::Weighting::Id);
        }
        case 10: {
            LogStep(10, "read DataVersion attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::DataVersion::Id);
        }
        case 11: {
            LogStep(11, "Validate constraints of attribute: DataVersion");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::DataVersion::Id);
        }
        case 12: {
            LogStep(12, "read StableDataVersion attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::StableDataVersion::Id);
        }
        case 13: {
            LogStep(13, "Validate constraints of attribute: StableDataVersion");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::StableDataVersion::Id);
        }
        case 14: {
            LogStep(14, "read LeaderRouterId attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::LeaderRouterId::Id);
        }
        case 15: {
            LogStep(15, "Validate constraints of attribute: LeaderRouterId");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::LeaderRouterId::Id);
        }
        case 16: {
            LogStep(16, "read DetachedRoleCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::DetachedRoleCount::Id);
        }
        case 17: {
            LogStep(17, "Validate constraints of attribute: DetachedRoleCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::DetachedRoleCount::Id);
        }
        case 18: {
            LogStep(18, "read ChildRoleCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::ChildRoleCount::Id);
        }
        case 19: {
            LogStep(19, "Validate constraints of attribute: ChildRoleCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::ChildRoleCount::Id);
        }
        case 20: {
            LogStep(20, "read RouterRoleCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RouterRoleCount::Id);
        }
        case 21: {
            LogStep(21, "Validate constraints of attribute: RouterRoleCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RouterRoleCount::Id);
        }
        case 22: {
            LogStep(22, "read LeaderRoleCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::LeaderRoleCount::Id);
        }
        case 23: {
            LogStep(23, "Validate constraints of attribute: LeaderRoleCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::LeaderRoleCount::Id);
        }
        case 24: {
            LogStep(24, "read AttachAttemptCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::AttachAttemptCount::Id);
        }
        case 25: {
            LogStep(25, "Validate constraints of attribute: AttachAttemptCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::AttachAttemptCount::Id);
        }
        case 26: {
            LogStep(26, "read PartitionIdChangeCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::PartitionIdChangeCount::Id);
        }
        case 27: {
            LogStep(27, "Validate constraints of attribute: PartitionIdChangeCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::PartitionIdChangeCount::Id);
        }
        case 28: {
            LogStep(28, "read BetterPartitionAttachAttemptCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::BetterPartitionAttachAttemptCount::Id);
        }
        case 29: {
            LogStep(29, "Validate constraints of attribute: BetterPartitionAttachAttemptCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::BetterPartitionAttachAttemptCount::Id);
        }
        case 30: {
            LogStep(30, "read ParentChangeCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::ParentChangeCount::Id);
        }
        case 31: {
            LogStep(31, "Validate constraints of attribute: ParentChangeCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::ParentChangeCount::Id);
        }
        case 32: {
            LogStep(32, "read TxTotalCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxTotalCount::Id);
        }
        case 33: {
            LogStep(33, "Validate constraints of attribute: TxTotalCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxTotalCount::Id);
        }
        case 34: {
            LogStep(34, "read TxUnicastCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxUnicastCount::Id);
        }
        case 35: {
            LogStep(35, "Validate constraints of attribute: TxUnicastCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxUnicastCount::Id);
        }
        case 36: {
            LogStep(36, "read TxBroadcastCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxBroadcastCount::Id);
        }
        case 37: {
            LogStep(37, "Validate constraints of attribute: TxBroadcastCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxBroadcastCount::Id);
        }
        case 38: {
            LogStep(38, "read TxNoAckRequestedCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxNoAckRequestedCount::Id);
        }
        case 39: {
            LogStep(39, "Validate constraints of attribute: TxNoAckRequestedCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxNoAckRequestedCount::Id);
        }
        case 40: {
            LogStep(40, "read TxDataCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxDataCount::Id);
        }
        case 41: {
            LogStep(41, "Validate constraints of attribute: TxDataCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxDataCount::Id);
        }
        case 42: {
            LogStep(42, "read TxDataPollCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxDataPollCount::Id);
        }
        case 43: {
            LogStep(43, "Validate constraints of attribute: TxDataPollCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxDataPollCount::Id);
        }
        case 44: {
            LogStep(44, "read TxBeaconCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxBeaconCount::Id);
        }
        case 45: {
            LogStep(45, "Validate constraints of attribute: TxBeaconCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxBeaconCount::Id);
        }
        case 46: {
            LogStep(46, "read TxBeaconRequestCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxBeaconRequestCount::Id);
        }
        case 47: {
            LogStep(47, "Validate constraints of attribute: TxBeaconRequestCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxBeaconRequestCount::Id);
        }
        case 48: {
            LogStep(48, "read TxOtherCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxOtherCount::Id);
        }
        case 49: {
            LogStep(49, "Validate constraints of attribute: TxOtherCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxOtherCount::Id);
        }
        case 50: {
            LogStep(50, "read TxRetryCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxRetryCount::Id);
        }
        case 51: {
            LogStep(51, "Validate constraints of attribute: TxRetryCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxRetryCount::Id);
        }
        case 52: {
            LogStep(52, "read TxDirectMaxRetryExpiryCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxDirectMaxRetryExpiryCount::Id);
        }
        case 53: {
            LogStep(53, "Validate constraints of attribute: TxDirectMaxRetryExpiryCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxDirectMaxRetryExpiryCount::Id);
        }
        case 54: {
            LogStep(54, "read TxIndirectMaxRetryExpiryCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxIndirectMaxRetryExpiryCount::Id);
        }
        case 55: {
            LogStep(55, "Validate constraints of attribute: TxIndirectMaxRetryExpiryCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxIndirectMaxRetryExpiryCount::Id);
        }
        case 56: {
            LogStep(56, "read TxErrCcaCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxErrCcaCount::Id);
        }
        case 57: {
            LogStep(57, "Validate constraints of attribute: TxErrCcaCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxErrCcaCount::Id);
        }
        case 58: {
            LogStep(58, "read TxErrAbortCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxErrAbortCount::Id);
        }
        case 59: {
            LogStep(59, "Validate constraints of attribute: TxErrAbortCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxErrAbortCount::Id);
        }
        case 60: {
            LogStep(60, "read TxErrBusyChannelCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxErrBusyChannelCount::Id);
        }
        case 61: {
            LogStep(61, "Validate constraints of attribute: TxErrBusyChannelCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::TxErrBusyChannelCount::Id);
        }
        case 62: {
            LogStep(62, "read RxTotalCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxTotalCount::Id);
        }
        case 63: {
            LogStep(63, "Validate constraints of attribute: RxTotalCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxTotalCount::Id);
        }
        case 64: {
            LogStep(64, "read RxUnicastCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxUnicastCount::Id);
        }
        case 65: {
            LogStep(65, "Validate constraints of attribute: RxUnicastCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxUnicastCount::Id);
        }
        case 66: {
            LogStep(66, "read RxBroadcastCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxBroadcastCount::Id);
        }
        case 67: {
            LogStep(67, "Validate constraints of attribute: RxBroadcastCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxBroadcastCount::Id);
        }
        case 68: {
            LogStep(68, "read RxDataCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxDataCount::Id);
        }
        case 69: {
            LogStep(69, "Validate constraints of attribute: RxDataCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxDataCount::Id);
        }
        case 70: {
            LogStep(70, "read RxDataPollCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxDataPollCount::Id);
        }
        case 71: {
            LogStep(71, "Validate constraints of attribute: RxDataPollCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxDataPollCount::Id);
        }
        case 72: {
            LogStep(72, "read RxBeaconCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxBeaconCount::Id);
        }
        case 73: {
            LogStep(73, "Validate constraints of attribute: RxBeaconCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxBeaconCount::Id);
        }
        case 74: {
            LogStep(74, "read RxBeaconRequestCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxBeaconRequestCount::Id);
        }
        case 75: {
            LogStep(75, "Validate constraints of attribute: RxBeaconRequestCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxBeaconRequestCount::Id);
        }
        case 76: {
            LogStep(76, "read RxOtherCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxOtherCount::Id);
        }
        case 77: {
            LogStep(77, "Validate constraints of attribute: RxOtherCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxOtherCount::Id);
        }
        case 78: {
            LogStep(78, "read RxAddressFilteredCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxAddressFilteredCount::Id);
        }
        case 79: {
            LogStep(79, "Validate constraints of attribute: RxAddressFilteredCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxAddressFilteredCount::Id);
        }
        case 80: {
            LogStep(80, "read RxDestAddrFilteredCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxDestAddrFilteredCount::Id);
        }
        case 81: {
            LogStep(81, "Validate constraints of attribute: RxDestAddrFilteredCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxDestAddrFilteredCount::Id);
        }
        case 82: {
            LogStep(82, "read RxDuplicatedCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxDuplicatedCount::Id);
        }
        case 83: {
            LogStep(83, "Validate constraints of attribute: RxDuplicatedCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxDuplicatedCount::Id);
        }
        case 84: {
            LogStep(84, "read RxErrNoFrameCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrNoFrameCount::Id);
        }
        case 85: {
            LogStep(85, "Validate constraints of attribute: RxErrNoFrameCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrNoFrameCount::Id);
        }
        case 86: {
            LogStep(86, "read RxErrUnknownNeighborCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrUnknownNeighborCount::Id);
        }
        case 87: {
            LogStep(87, "Validate constraints of attribute: RxErrUnknownNeighborCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrUnknownNeighborCount::Id);
        }
        case 88: {
            LogStep(88, "read RxErrInvalidScrAddrCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrInvalidSrcAddrCount::Id);
        }
        case 89: {
            LogStep(89, "Validate constraints of attribute: RxErrInvalidSrcAddrCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrInvalidSrcAddrCount::Id);
        }
        case 90: {
            LogStep(90, "read RxErrSecCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrSecCount::Id);
        }
        case 91: {
            LogStep(91, "Validate constraints of attribute: RxErrInvalidSrcAddrCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrSecCount::Id);
        }
        case 92: {
            LogStep(92, "read RxErrFcsCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrFcsCount::Id);
        }
        case 93: {
            LogStep(93, "Validate constraints of attribute: RxErrFcsCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrFcsCount::Id);
        }
        case 94: {
            LogStep(94, "read RxErrOtherCount attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrOtherCount::Id);
        }
        case 95: {
            LogStep(95, "Validate constraints of attribute: RxErrOtherCount");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::RxErrOtherCount::Id);
        }
        case 96: {
            LogStep(96, "read ActiveTimestamp attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::ActiveTimestamp::Id);
        }
        case 97: {
            LogStep(97, "Validate constraints of attribute: ActiveTimestamp");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::ActiveTimestamp::Id);
        }
        case 98: {
            LogStep(98, "read PendingTimestamp attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::PendingTimestamp::Id);
        }
        case 99: {
            LogStep(99, "Validate constraints of attribute: PendingTimestamp");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::PendingTimestamp::Id);
        }
        case 100: {
            LogStep(100, "read Delay attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::Delay::Id);
        }
        case 101: {
            LogStep(101, "Validate constraints of attribute: delay");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), ThreadNetworkDiagnostics::Id,
                                 ThreadNetworkDiagnostics::Attributes::Delay::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_LC_1_2Suite : public TestCommand
{
public:
    Test_TC_LC_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_LC_1_2", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_LC_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "TH1 reads LabelList attribute from the DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), UserLabel::Id, UserLabel::Attributes::LabelList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WIFIDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WIFIDIAG_1_1", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WIFIDIAG_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("securityType", value));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum"));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 5));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "int8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -120));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads NetworkInterface structure attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralDiagnostics::Id,
                                 GeneralDiagnostics::Attributes::NetworkInterfaces::Id);
        }
        case 2: {
            LogStep(2, "Reads SecurityType attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), WiFiNetworkDiagnostics::Id,
                                 WiFiNetworkDiagnostics::Attributes::SecurityType::Id);
        }
        case 3: {
            LogStep(3, "Reads SecurityType attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), WiFiNetworkDiagnostics::Id,
                                 WiFiNetworkDiagnostics::Attributes::SecurityType::Id);
        }
        case 4: {
            LogStep(4, "Reads WiFiVersion attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), WiFiNetworkDiagnostics::Id,
                                 WiFiNetworkDiagnostics::Attributes::WiFiVersion::Id);
        }
        case 5: {
            LogStep(5, "Reads ChannelNumber attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), WiFiNetworkDiagnostics::Id,
                                 WiFiNetworkDiagnostics::Attributes::ChannelNumber::Id);
        }
        case 6: {
            LogStep(6, "Reads RSSI attribute constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), WiFiNetworkDiagnostics::Id,
                                 WiFiNetworkDiagnostics::Attributes::Rssi::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WIFIDIAG_3_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WIFIDIAG_3_1", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WIFIDIAG_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_1_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_1_1", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 5U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 200U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 201U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0UL));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32768UL));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint32"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 32769UL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "2: read the global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::ClusterRevision::Id);
        }
        case 2: {
            LogStep(2, "3a: write a value into the RO mandatory global attribute: ClusterRevision");
            uint16_t value;
            value = 201U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::ClusterRevision::Id, value);
        }
        case 3: {
            LogStep(3, "3b: reads back global attribute: ClusterRevision");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::ClusterRevision::Id);
        }
        case 4: {
            LogStep(4, "Read the global attribute: AttributeList");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::AttributeList::Id);
        }
        case 5: {
            LogStep(5, "2: read the global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::FeatureMap::Id);
        }
        case 6: {
            LogStep(6, "3a: write the default value to optional global attribute: FeatureMap");
            uint32_t value;
            value = 32769UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::FeatureMap::Id,
                                  value);
        }
        case 7: {
            LogStep(7, "3b: reads back global attribute: FeatureMap");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::FeatureMap::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_1", 55, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::WindowCovering::Type value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::WindowCovering::Type value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 250));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 63));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 128));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 63));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 128));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::WindowCovering::EndProductType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 23));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::WindowCovering::EndProductType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 250));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 15));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("mode", value, 8));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 20000U));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 20000U));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 20000U));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent100ths"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 20000U));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2047U));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map16"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 4096U));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65535U));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 100));
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 200));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 100));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_WRITE));
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "Percent"));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 200));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "2: read the RO mandatory attribute default: Type");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        case 2: {
            LogStep(2, "3a: write a value into the RO mandatory attribute: Type");
            chip::app::Clusters::WindowCovering::Type value;
            value = static_cast<chip::app::Clusters::WindowCovering::Type>(250);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id, value);
        }
        case 3: {
            LogStep(3, "3b: reads back the RO mandatory attribute: Type");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        case 4: {
            LogStep(4, "2: read the RO mandatory attribute default: ConfigStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 5: {
            LogStep(5, "3a: write a value into the RO mandatory attribute: ConfigStatus");
            chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus>>(128);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id,
                                  value);
        }
        case 6: {
            LogStep(6, "3b: reads back the RO mandatory attribute: ConfigStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 7: {
            LogStep(7, "2: read the RO mandatory attribute default: OperationalStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 8: {
            LogStep(8, "3a: write a value into the RO mandatory attribute: OperationalStatus");
            uint8_t value;
            value = 128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::OperationalStatus::Id, value);
        }
        case 9: {
            LogStep(9, "3b: reads back the RO mandatory attribute: OperationalStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 10: {
            LogStep(10, "2: read the RO mandatory attribute default: EndProductType");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::EndProductType::Id);
        }
        case 11: {
            LogStep(11, "3a: write a value into the RO mandatory attribute: EndProductType");
            chip::app::Clusters::WindowCovering::EndProductType value;
            value = static_cast<chip::app::Clusters::WindowCovering::EndProductType>(250);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::EndProductType::Id, value);
        }
        case 12: {
            LogStep(12, "3b: reads back the RO mandatory attribute: EndProductType");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::EndProductType::Id);
        }
        case 13: {
            LogStep(13, "2: read the RW mandatory attribute default: Mode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id);
        }
        case 14: {
            LogStep(14, "3a: write a value into the RW mandatory attribute:: Mode");
            chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::WindowCovering::Mode>>(8);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id, value);
        }
        case 15: {
            LogStep(15, "3b: reads back the RW mandatory attribute: Mode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id);
        }
        case 16: {
            LogStep(16, "2: read the RO optional attribute default: TargetPositionLiftPercent100ths");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 17: {
            LogStep(17, "3a: write a value into the RO optional attribute: TargetPositionLiftPercent100ths");
            chip::app::DataModel::Nullable<chip::Percent100ths> value;
            value.SetNonNull();
            value.Value() = 20000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id, value);
        }
        case 18: {
            LogStep(18, "3b: reads back the RO optional attribute: TargetPositionLiftPercent100ths");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 19: {
            LogStep(19, "2: read the RO optional attribute default: TargetPositionTiltPercent100ths");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        case 20: {
            LogStep(20, "3a: write a value into the RO optional attribute: TargetPositionTiltPercent100ths");
            chip::app::DataModel::Nullable<chip::Percent100ths> value;
            value.SetNonNull();
            value.Value() = 20000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id, value);
        }
        case 21: {
            LogStep(21, "3b: reads back the RO optional attribute: TargetPositionTiltPercent100ths");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        case 22: {
            LogStep(22, "2: read the RO optional attribute default: CurrentPositionLiftPercent100ths");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 23: {
            LogStep(23, "3a: write a value into the RO optional attribute: CurrentPositionLiftPercent100ths");
            chip::app::DataModel::Nullable<chip::Percent100ths> value;
            value.SetNonNull();
            value.Value() = 20000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id, value);
        }
        case 24: {
            LogStep(24, "3b: reads back the RO optional attribute: CurrentPositionLiftPercent100ths");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 25: {
            LogStep(25, "2: read the RO optional attribute default: CurrentPositionTiltPercent100ths");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 26: {
            LogStep(26, "3a: write a value into the RO optional attribute: CurrentPositionTiltPercent100ths");
            chip::app::DataModel::Nullable<chip::Percent100ths> value;
            value.SetNonNull();
            value.Value() = 20000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id, value);
        }
        case 27: {
            LogStep(27, "3b: reads back the RO optional attribute: CurrentPositionTiltPercent100ths");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 28: {
            LogStep(28, "2: read the RO optional attribute default: InstalledOpenLimitLift");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledOpenLimitLift::Id);
        }
        case 29: {
            LogStep(29, "3a: write a value into the RO optional attribute: InstalledOpenLimitLift");
            uint16_t value;
            value = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::InstalledOpenLimitLift::Id, value);
        }
        case 30: {
            LogStep(30, "3b: reads back the RO optional attribute: InstalledOpenLimitLift");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledOpenLimitLift::Id);
        }
        case 31: {
            LogStep(31, "2: read the RO optional attribute default: InstalledClosedLimitLift");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledClosedLimitLift::Id);
        }
        case 32: {
            LogStep(32, "3a: write a value into the RO optional attribute: InstalledClosedLimitLift");
            uint16_t value;
            value = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::InstalledClosedLimitLift::Id, value);
        }
        case 33: {
            LogStep(33, "3b: reads back the RO optional attribute: InstalledClosedLimitLift");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledClosedLimitLift::Id);
        }
        case 34: {
            LogStep(34, "2: read the RO optional attribute default: InstalledOpenLimitTilt");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledOpenLimitTilt::Id);
        }
        case 35: {
            LogStep(35, "3a: write a value into the RO optional attribute: InstalledOpenLimitTilt");
            uint16_t value;
            value = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::InstalledOpenLimitTilt::Id, value);
        }
        case 36: {
            LogStep(36, "3b: reads back the RO optional attribute: InstalledOpenLimitTilt");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledOpenLimitTilt::Id);
        }
        case 37: {
            LogStep(37, "2: read the RO optional attribute default: InstalledClosedLimitTilt");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledClosedLimitTilt::Id);
        }
        case 38: {
            LogStep(38, "3a: write a value into the RO optional attribute: InstalledClosedLimitTilt");
            uint16_t value;
            value = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::InstalledClosedLimitTilt::Id, value);
        }
        case 39: {
            LogStep(39, "3b: reads back the RO optional attribute: InstalledClosedLimitTilt");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::InstalledClosedLimitTilt::Id);
        }
        case 40: {
            LogStep(40, "4: read the RO mandatory attribute default: SafetyStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::SafetyStatus::Id);
        }
        case 41: {
            LogStep(41, "5a: write a value into the RO mandatory attribute: SafetyStatus");
            uint16_t value;
            value = 4096U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::SafetyStatus::Id,
                                  value);
        }
        case 42: {
            LogStep(42, "5b: reads back the RO mandatory attribute: SafetyStatus");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::SafetyStatus::Id);
        }
        case 43: {
            LogStep(43, "4: read the RO optional attribute default: CurrentPositionLift");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLift::Id);
        }
        case 44: {
            LogStep(44, "5a: write a value into the RO optional attribute: CurrentPositionLift");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionLift::Id, value);
        }
        case 45: {
            LogStep(45, "5b: reads back the RO optional attribute: CurrentPositionLift");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLift::Id);
        }
        case 46: {
            LogStep(46, "4: read the RO optional attribute default: CurrentPositionTilt");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTilt::Id);
        }
        case 47: {
            LogStep(47, "5a: write a value into the RO optional attribute: CurrentPositionTilt");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 255U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionTilt::Id, value);
        }
        case 48: {
            LogStep(48, "5b: reads back the RO optional attribute: CurrentPositionTilt");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTilt::Id);
        }
        case 49: {
            LogStep(49, "4: read the RO optional attribute default: CurrentPositionLiftPercentage");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 50: {
            LogStep(50, "5a: write a value into the RO optional attribute: CurrentPositionLiftPercentage");
            chip::app::DataModel::Nullable<chip::Percent> value;
            value.SetNonNull();
            value.Value() = 200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionLiftPercentage::Id, value);
        }
        case 51: {
            LogStep(51, "5b: reads back the RO optional attribute: CurrentPositionLiftPercentage");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 52: {
            LogStep(52, "4: read the RO optional attribute default: CurrentPositionTiltPercentage");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 53: {
            LogStep(53, "5a: write a value into the RO optional attribute: CurrentPositionTiltPercentage");
            chip::app::DataModel::Nullable<chip::Percent> value;
            value.SetNonNull();
            value.Value() = 200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                  WindowCovering::Attributes::CurrentPositionTiltPercentage::Id, value);
        }
        case 54: {
            LogStep(54, "5b: reads back the RO optional attribute: CurrentPositionTiltPercentage");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_2Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_2", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_3", 19, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> configStatusValA;
    chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> configStatusValB;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 4));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
                configStatusValA = value;
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
                configStatusValB = value;
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_BUSY));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::ConfigStatus> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: TH set the Mode Attribute bit0 of the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_REVERSAL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::WindowCovering::Mode>>(1);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id, value);
        }
        case 2: {
            LogStep(2, "1b: TH reads ConfigStatus attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_REVERSAL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 3: {
            LogStep(3, "1c: TH clear the Mode Attribute bit0 of the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_REVERSAL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::WindowCovering::Mode>>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id, value);
        }
        case 4: {
            LogStep(4, "1d: TH reads ConfigStatus attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_REVERSAL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 5: {
            LogStep(5, "2a: TH set the Mode Attribute bit1 of the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_CALIBRATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::WindowCovering::Mode>>(2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id, value);
        }
        case 6: {
            LogStep(6, "2b: TH reads ConfigStatus attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_CALIBRATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 7: {
            LogStep(7, "2c: If (ConfigStatus bit0 == 0) TH send DownOrClose command to the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_CALIBRATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 8: {
            LogStep(8, "2d: TH clear the Mode Attribute bit1 of the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_CALIBRATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::WindowCovering::Mode>>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id, value);
        }
        case 9: {
            LogStep(9, "2e: TH reads ConfigStatus attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_CALIBRATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 10: {
            LogStep(10, "2f: TH reads the Mode Attribute from the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_CALIBRATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id);
        }
        case 11: {
            LogStep(11, "2g: TH send DownOrClose command to the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_CALIBRATION"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 12: {
            LogStep(12, "3a: TH set the Mode Attribute bit2 of the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_MAINTENANCE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::WindowCovering::Mode>>(4);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id, value);
        }
        case 13: {
            LogStep(13, "3c: TH reads ConfigStatus attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_MAINTENANCE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 14: {
            LogStep(14, "3c: TH send DownOrClose command to the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_MAINTENANCE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 15: {
            LogStep(15, "3d: TH clear the Mode Attribute bit2 of the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_MAINTENANCE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::BitFlags<chip::app::Clusters::WindowCovering::Mode> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::WindowCovering::Mode>>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id, value);
        }
        case 16: {
            LogStep(16, "3e: TH reads ConfigStatus attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_MAINTENANCE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::ConfigStatus::Id);
        }
        case 17: {
            LogStep(17, "3f: TH reads the Mode Attribute from the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_MAINTENANCE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Mode::Id);
        }
        case 18: {
            LogStep(18, "3g: TH send DownOrClose command to the DUT");
            VerifyOrdo(!ShouldSkip("WNCV_MAINTENANCE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_4", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::WindowCovering::Type value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("type", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::WindowCovering::Type value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads Type attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_TYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        case 2: {
            LogStep(2, "Reads Type attribute constraints");
            VerifyOrdo(!ShouldSkip("A_TYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Attributes::Type::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_2_5Suite : public TestCommand
{
public:
    Test_TC_WNCV_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_2_5", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_2_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::WindowCovering::EndProductType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("endProductType", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::WindowCovering::EndProductType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "enum8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 23));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads EndProductType attribute from DUT");
            VerifyOrdo(!ShouldSkip("A_ENDPRODUCTTYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::EndProductType::Id);
        }
        case 2: {
            LogStep(2, "Reads EndProductType attribute constraints from DUT");
            VerifyOrdo(!ShouldSkip("A_ENDPRODUCTTYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::EndProductType::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_3_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_1", 24, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 100));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 100));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("targetPositionLiftPercent100ths.Value()", value.Value(), 0U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 5));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 21));
            }
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9999U));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 99));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9999U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 99));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9999U));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9999U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: TH sends DownOrClose command to preposition the DUT in the opposite direction");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 2: {
            LogStep(2, "1b: TH Waits for 10 seconds movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(10000);
        }
        case 3: {
            LogStep(3, "1c: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 4: {
            LogStep(4, "1d: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 5: {
            LogStep(5, "1e: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 6: {
            LogStep(6, "1f: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 7: {
            LogStep(7, "2: Subscribe to DUT reports on OperationalStatus attribute");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                      WindowCovering::Attributes::OperationalStatus::Id, 4, 5);
        }
        case 8: {
            LogStep(8, "2a: TH sends UpOrOpen command to DUT");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 9: {
            LogStep(9, "2b: DUT updates its attributes");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 10: {
            LogStep(10, "2c: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 11: {
            LogStep(11, "2e: TH leave the device moving for 2 seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 12: {
            LogStep(12, "3a1: Verify DUT reports OperationalStatus attribute to TH after a UpOrOpen");
            return WaitForReport();
        }
        case 13: {
            LogStep(13, "3a2: DUT updates its attributes");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 14: {
            LogStep(14, "3b: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 15: {
            LogStep(15, "3c: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 16: {
            LogStep(16, "3d: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 17: {
            LogStep(17, "3e: If (PA & LF) TH reads CurrentPositionTiltPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 18: {
            LogStep(18, "4a: TH sends a StopMotion command to DUT");
            chip::app::Clusters::WindowCovering::Commands::StopMotion::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id, value);
        }
        case 19: {
            LogStep(19, "4b: TH waits for 3 seconds the end of inertial movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 20: {
            LogStep(20, "4c: Verify DUT update OperationalStatus attribute to TH after a StopMotion");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 21: {
            LogStep(21, "5a: TH waits for x seconds attributes update on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 22: {
            LogStep(22, "5b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 23: {
            LogStep(23, "5c: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_3_2Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_2", 24, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_3_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9999U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 99));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9999U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 99));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("targetPositionLiftPercent100ths.Value()", value.Value(), 10000U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 10));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 42));
            }
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 100));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 100));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint16"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: TH sends UpOrOpen command to preposition the DUT in the opposite direction");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 2: {
            LogStep(2, "1b: TH Waits for 10 seconds movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(10000);
        }
        case 3: {
            LogStep(3, "1c: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 4: {
            LogStep(4, "1d: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 5: {
            LogStep(5, "1e: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 6: {
            LogStep(6, "1f: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 7: {
            LogStep(7, "2: Subscribe to DUT reports on OperationalStatus attribute");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                      WindowCovering::Attributes::OperationalStatus::Id, 4, 5);
        }
        case 8: {
            LogStep(8, "2a: TH sends DownOrClose command to DUT");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 9: {
            LogStep(9, "2b: DUT updates its attributes");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 10: {
            LogStep(10, "2c: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 11: {
            LogStep(11, "2e: TH leave the device moving for 2 seconds");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 12: {
            LogStep(12, "3a: Verify DUT reports OperationalStatus attribute to TH after a DownOrClose");
            return WaitForReport();
        }
        case 13: {
            LogStep(13, "3a2: DUT updates its attributes");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 14: {
            LogStep(14, "3b: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 15: {
            LogStep(15, "3c: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 16: {
            LogStep(16, "3d: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 17: {
            LogStep(17, "3e: If (PA & LF) TH reads CurrentPositionTiltPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 18: {
            LogStep(18, "4a: TH sends a StopMotion command to DUT");
            chip::app::Clusters::WindowCovering::Commands::StopMotion::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id, value);
        }
        case 19: {
            LogStep(19, "4b: TH waits for 3 seconds the end of inertial movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 20: {
            LogStep(20, "4c: Verify DUT update OperationalStatus attribute to TH after a StopMotion");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 21: {
            LogStep(21, "5a: TH waits for x seconds attributes update on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 22: {
            LogStep(22, "5b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 23: {
            LogStep(23, "5c: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_3_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_3", 15, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_3_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionLift;
    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionTilt;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "map8"));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
                attrCurrentPositionLift = value;
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                if (attrCurrentPositionLift.IsNull())
                {
                    VerifyOrReturn(CheckValueNull("targetPositionLiftPercent100ths", value));
                }
                else
                {
                    VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", value));
                    VerifyOrReturn(
                        CheckValue("targetPositionLiftPercent100ths.Value()", value.Value(), attrCurrentPositionLift.Value()));
                }
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
                attrCurrentPositionTilt = value;
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                if (attrCurrentPositionTilt.IsNull())
                {
                    VerifyOrReturn(CheckValueNull("targetPositionTiltPercent100ths", value));
                }
                else
                {
                    VerifyOrReturn(CheckValueNonNull("targetPositionTiltPercent100ths", value));
                    VerifyOrReturn(
                        CheckValue("targetPositionTiltPercent100ths.Value()", value.Value(), attrCurrentPositionTilt.Value()));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: TH sends DownOrClose command to preposition the DUT in the opposite direction");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 2: {
            LogStep(2, "1b: TH Waits for 6-8 seconds movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(6000);
        }
        case 3: {
            LogStep(3, "1c: TH sends UpOrOpen command to preposition the DUT in the opposite direction");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 4: {
            LogStep(4, "1d: TH Waits for 2 seconds movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 5: {
            LogStep(5, "2: Subscribe to DUT reports on OperationalStatus attribute");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                      WindowCovering::Attributes::OperationalStatus::Id, 4, 5);
        }
        case 6: {
            LogStep(6, "2a: TH sends a StopMotion command to DUT");
            chip::app::Clusters::WindowCovering::Commands::StopMotion::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id, value);
        }
        case 7: {
            LogStep(7, "2b: TH waits for 3 seconds the end of inertial movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(3000);
        }
        case 8: {
            LogStep(8, "2c: Verify DUT reports OperationalStatus attribute to TH after a StopMotion");
            return WaitForReport();
        }
        case 9: {
            LogStep(9, "2d: TH waits for 100ms - 3s attributes update on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(2000);
        }
        case 10: {
            LogStep(10, "2e: TH reads OperationalStatus attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 11: {
            LogStep(11, "3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 12: {
            LogStep(12,
                    "3b: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute 3c: it Must be equal with "
                    "CurrentPositionLiftPercent100ths from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 13: {
            LogStep(13, "4a: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 14: {
            LogStep(14,
                    "4b: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute 4c: it Must be equal with "
                    "CurrentPositionTiltPercent100ths from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_3_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_4", 9, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fastMotionDuration", 0, UINT16_MAX, &mFastMotionDuration);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_3_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFastMotionDuration;
    chip::Optional<uint16_t> mFullMotionDuration;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("currentPositionLiftPercent100ths.Value()", value.Value(), 0U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercentage", value));
                VerifyOrReturn(CheckValue("currentPositionLiftPercentage.Value()", value.Value(), 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercent100ths", value));
                VerifyOrReturn(CheckValue("currentPositionTiltPercent100ths.Value()", value.Value(), 0U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercentage", value));
                VerifyOrReturn(CheckValue("currentPositionTiltPercentage.Value()", value.Value(), 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: TH sends DownOrClose command to preposition the DUT in the opposite direction");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 2: {
            LogStep(2, "1b: TH Waits for fastMotionDuration seconds movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFastMotionDuration.HasValue() ? mFastMotionDuration.Value() : 3000U);
        }
        case 3: {
            LogStep(3, "2a: TH sends UpOrOpen command to DUT");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 4: {
            LogStep(4, "2b: TH Waits for fullMotionDuration seconds movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 5: {
            LogStep(5, "3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 6: {
            LogStep(6, "3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 7: {
            LogStep(7, "3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 8: {
            LogStep(8, "3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_3_5Suite : public TestCommand
{
public:
    Test_TC_WNCV_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_3_5", 9, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fastMotionDuration", 0, UINT16_MAX, &mFastMotionDuration);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_3_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFastMotionDuration;
    chip::Optional<uint16_t> mFullMotionDuration;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("currentPositionLiftPercent100ths.Value()", value.Value(), 10000U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercentage", value));
                VerifyOrReturn(CheckValue("currentPositionLiftPercentage.Value()", value.Value(), 100));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercent100ths", value));
                VerifyOrReturn(CheckValue("currentPositionTiltPercent100ths.Value()", value.Value(), 10000U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercentage", value));
                VerifyOrReturn(CheckValue("currentPositionTiltPercentage.Value()", value.Value(), 100));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: TH sends UpOrOpen command to preposition the DUT in the opposite direction");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 2: {
            LogStep(2, "1b: TH Waits for fastMotionDuration seconds movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFastMotionDuration.HasValue() ? mFastMotionDuration.Value() : 3000U);
        }
        case 3: {
            LogStep(3, "2a: TH sends DownOrClose command to DUT");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 4: {
            LogStep(4, "2b: TH Waits for fullMotionDuration seconds movement(s) on the device");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 5: {
            LogStep(5, "3a: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 6: {
            LogStep(6, "3b: If (PA & LF) TH reads CurrentPositionLiftPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 7: {
            LogStep(7, "3c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 8: {
            LogStep(8, "3d: If (PA & TL) TH reads CurrentPositionTiltPercentage optional attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_4_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_4_1", 13, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_4_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFullMotionDuration;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 0U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("targetPositionLiftPercent100ths", value));
                VerifyOrReturn(CheckValue("targetPositionLiftPercent100ths.Value()", value.Value(), 2500U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: TH sends DownOrClose command to preposition the DUT in the opposite direction");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 2: {
            LogStep(2, "1b: TH waits for x seconds movement(s) on the DUT");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 3: {
            LogStep(3, "1c: If (PA & LF) TH reads CurrentPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_PA_LF && WNCV_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 4: {
            LogStep(4, "2a: TH sends GoToLiftPercentage command with 25 percent to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && CR_GOTOLIFTPERCENTAGE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue = 25;
            value.liftPercent100thsValue.Emplace();
            value.liftPercent100thsValue.Value() = 2500U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        case 5: {
            LogStep(5, "2b: DUT updates its attributes");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 6: {
            LogStep(6, "2c: If (PA & LF) TH reads TargetPositionLiftPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_PA_LF && WNCV_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionLiftPercent100ths::Id);
        }
        case 7: {
            LogStep(7, "3a: TH set a timeout of X minutes for failure");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 8: {
            LogStep(8, "3b: TH reads OperationalStatus attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 9: {
            LogStep(9, "4a: TH sends GoToLiftPercentage command with 75.20 percent to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && CR_GOTOLIFTPERCENTAGE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue = 75;
            value.liftPercent100thsValue.Emplace();
            value.liftPercent100thsValue.Value() = 7520U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        case 10: {
            LogStep(10, "4b: DUT updates its attributes");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 11: {
            LogStep(11, "5a: TH waits for x seconds movement(s) on the DUT");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 12: {
            LogStep(12, "5b: TH reads OperationalStatus attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_4_2Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_4_2", 13, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("fullMotionDuration", 0, UINT16_MAX, &mFullMotionDuration);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_4_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mFullMotionDuration;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 0U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("targetPositionTiltPercent100ths", value));
                VerifyOrReturn(CheckValue("targetPositionTiltPercent100ths.Value()", value.Value(), 3000U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("operationalStatus", value, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: TH sends DownOrClose command to preposition the DUT in the opposite direction");
            chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::DownOrClose::Id,
                               value);
        }
        case 2: {
            LogStep(2, "1b: TH waits for x seconds movement(s) on the DUT");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 3: {
            LogStep(3, "1c: If (PA & TL) TH reads CurrentPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_PA_TL && WNCV_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 4: {
            LogStep(4, "2a: TH sends GoToTiltPercentage command with 30 percent to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && CR_GOTOTILTPERCENTAGE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue = 30;
            value.tiltPercent100thsValue.Emplace();
            value.tiltPercent100thsValue.Value() = 3000U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        case 5: {
            LogStep(5, "2b: DUT updates its attributes");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 6: {
            LogStep(6, "2c: If (PA & TL) TH reads TargetPositionTiltPercent100ths attribute from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_PA_TL && WNCV_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::TargetPositionTiltPercent100ths::Id);
        }
        case 7: {
            LogStep(7, "3a: TH set a timeout of X minutes for failure");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 8: {
            LogStep(8, "3b: TH reads OperationalStatus attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        case 9: {
            LogStep(9, "4a: TH sends GoToTiltPercentage command with 60.20 percent to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && CR_GOTOTILTPERCENTAGE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue = 60;
            value.tiltPercent100thsValue.Emplace();
            value.tiltPercent100thsValue.Value() = 6005U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        case 10: {
            LogStep(10, "4b: DUT updates its attributes");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        case 11: {
            LogStep(11, "5a: TH waits for x seconds movement(s) on the DUT");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(mFullMotionDuration.HasValue() ? mFullMotionDuration.Value() : 6000U);
        }
        case 12: {
            LogStep(12, "5b: TH reads OperationalStatus attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::OperationalStatus::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_4_3Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_4_3", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_4_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionLiftPercent100ths;
    chip::app::DataModel::Nullable<chip::Percent> attrCurrentPositionLiftPercentage;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
                attrCurrentPositionLiftPercent100ths = value;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 100));
                attrCurrentPositionLiftPercentage = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: If (PA_LF & LF) TH reads CurrentPositionLiftPercent100ths from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 2: {
            LogStep(2, "1b: If (PA_LF & LF) TH reads CurrentPositionLiftPercentage from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF && A_CURRENTPOSITIONLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercentage::Id);
        }
        case 3: {
            LogStep(3, "2b: TH sends GoToLiftPercentage command with BadParam to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && CR_GOTOLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue = 63;
            value.liftPercent100thsValue.Emplace();
            value.liftPercent100thsValue.Value() = 12288U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        case 4: {
            LogStep(4, "3a: TH sends GoToLiftPercentage command with 10001 to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && CR_GOTOLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue = 100;
            value.liftPercent100thsValue.Emplace();
            value.liftPercent100thsValue.Value() = 10001U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        case 5: {
            LogStep(5, "4a: TH sends GoToLiftPercentage command with 0xFFFF to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF || WNCV_LF && CR_GOTOLIFTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue = 255;
            value.liftPercent100thsValue.Emplace();
            value.liftPercent100thsValue.Value() = 65535U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_4_4Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_4_4", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_4_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionTiltPercent100ths;
    chip::app::DataModel::Nullable<chip::Percent> attrCurrentPositionTiltPercentage;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 10000U));
                attrCurrentPositionTiltPercent100ths = value;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 100));
                attrCurrentPositionTiltPercentage = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "1a: If (PA_TL & TL) TH reads CurrentPositionTiltPercent100ths from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 2: {
            LogStep(2, "1b: If (PA_TL & TL) TH reads CurrentPositionTiltPercentage from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL && A_CURRENTPOSITIONTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercentage::Id);
        }
        case 3: {
            LogStep(3, "2b: TH sends GoToTiltPercentage command with BadParam to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && CR_GOTOTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue = 63;
            value.tiltPercent100thsValue.Emplace();
            value.tiltPercent100thsValue.Value() = 12288U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        case 4: {
            LogStep(4, "3a: TH sends GoToTiltPercentage command with 10001 to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && CR_GOTOTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue = 100;
            value.tiltPercent100thsValue.Emplace();
            value.tiltPercent100thsValue.Value() = 10001U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        case 5: {
            LogStep(5, "4a: TH sends GoToTiltPercentage command with 0xFFFF to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL || WNCV_TL && CR_GOTOTILTPERCENTAGE"),
                       return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue = 255;
            value.tiltPercent100thsValue.Emplace();
            value.tiltPercent100thsValue.Value() = 65535U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_4_5Suite : public TestCommand
{
public:
    Test_TC_WNCV_4_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_4_5", 16, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_4_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<uint16_t> mTimeout;

    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionLiftPercent100ths;
    chip::app::DataModel::Nullable<chip::Percent100ths> attrCurrentPositionTiltPercent100ths;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 0U));

                attrCurrentPositionLiftPercent100ths = value;
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 0U));

                attrCurrentPositionTiltPercent100ths = value;
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                if (attrCurrentPositionLiftPercent100ths.IsNull())
                {
                    VerifyOrReturn(CheckValueNull("currentPositionLiftPercent100ths", value));
                }
                else
                {
                    VerifyOrReturn(CheckValueNonNull("currentPositionLiftPercent100ths", value));
                    VerifyOrReturn(CheckValue("currentPositionLiftPercent100ths.Value()", value.Value(),
                                              attrCurrentPositionLiftPercent100ths.Value()));
                }
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::Percent100ths> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                if (attrCurrentPositionTiltPercent100ths.IsNull())
                {
                    VerifyOrReturn(CheckValueNull("currentPositionTiltPercent100ths", value));
                }
                else
                {
                    VerifyOrReturn(CheckValueNonNull("currentPositionTiltPercent100ths", value));
                    VerifyOrReturn(CheckValue("currentPositionTiltPercent100ths.Value()", value.Value(),
                                              attrCurrentPositionTiltPercent100ths.Value()));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "0a: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "0b: TH sends UpOrOpen command to preposition the DUT");
            chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::UpOrOpen::Id, value);
        }
        case 2: {
            LogStep(2, "1a: If (PA_LF & LF) TH sends GoToLiftPercentage command with 90%% to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToLiftPercentage::Type value;
            value.liftPercentageValue = 90;
            value.liftPercent100thsValue.Emplace();
            value.liftPercent100thsValue.Value() = 9000U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToLiftPercentage::Id,
                               value);
        }
        case 3: {
            LogStep(3, "1b: TH Waits for 100ms-1s");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(500);
        }
        case 4: {
            LogStep(4, "1c: TH sends StopMotion command to DUT");
            chip::app::Clusters::WindowCovering::Commands::StopMotion::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id, value);
        }
        case 5: {
            LogStep(5, "1d: TH Waits for 100ms-1s");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(500);
        }
        case 6: {
            LogStep(6, "2a: If (PA_TL & TL) TH sends GoToTiltPercentage command with 90%% to DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::WindowCovering::Commands::GoToTiltPercentage::Type value;
            value.tiltPercentageValue = 90;
            value.tiltPercent100thsValue.Emplace();
            value.tiltPercent100thsValue.Value() = 9000U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::GoToTiltPercentage::Id,
                               value);
        }
        case 7: {
            LogStep(7, "2b: TH Waits for 100ms-1s");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(500);
        }
        case 8: {
            LogStep(8, "2c: TH sends StopMotion command to DUT");
            chip::app::Clusters::WindowCovering::Commands::StopMotion::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id, WindowCovering::Commands::StopMotion::Id, value);
        }
        case 9: {
            LogStep(9, "2d: TH Waits for 100ms-1s");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(500);
        }
        case 10: {
            LogStep(10, "3a: TH reads CurrentPositionLiftPercent100ths from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 11: {
            LogStep(11, "3b: TH reads CurrentPositionTiltPercent100ths from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        case 12: {
            LogStep(12, "3c: reboot/restart the DUT");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 13: {
            LogStep(13, "3d: Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 14: {
            LogStep(14, "3e: TH reads CurrentPositionLiftPercent100ths from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_LF && WNCV_PA_LF"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Id);
        }
        case 15: {
            LogStep(15, "3f: TH reads CurrentPositionTiltPercent100ths from DUT");
            VerifyOrdo(!ShouldSkip("WNCV_TL && WNCV_PA_TL"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WindowCovering::Id,
                                 WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_TargetNavigatorClusterSuite : public TestCommand
{
public:
    TV_TargetNavigatorClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_TargetNavigatorCluster", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_TargetNavigatorClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("targetList", iter_0, 0));
                    VerifyOrReturn(CheckValue("targetList[0].identifier", iter_0.GetValue().identifier, 1));
                    VerifyOrReturn(
                        CheckValueAsString("targetList[0].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("targetList", iter_0, 1));
                    VerifyOrReturn(CheckValue("targetList[1].identifier", iter_0.GetValue().identifier, 2));
                    VerifyOrReturn(
                        CheckValueAsString("targetList[1].name", iter_0.GetValue().name, chip::CharSpan("exampleName", 11)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("targetList", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentTarget", value, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute Target Navigator list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id, TargetNavigator::Attributes::TargetList::Id);
        }
        case 2: {
            LogStep(2, "Read attribute current navigator target");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id,
                                 TargetNavigator::Attributes::CurrentTarget::Id);
        }
        case 3: {
            LogStep(3, "Navigate Target Request Command");
            chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type value;
            value.target = 1;
            value.data.Emplace();
            value.data.Value() = chip::Span<const char>("1garbage: not in length on purpose", 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TargetNavigator::Id, TargetNavigator::Commands::NavigateTarget::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_AudioOutputClusterSuite : public TestCommand
{
public:
    TV_AudioOutputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_AudioOutputCluster", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_AudioOutputClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 0));
                    VerifyOrReturn(CheckValue("outputList[0].index", iter_0.GetValue().index, 1));
                    VerifyOrReturn(CheckValue("outputList[0].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(CheckValueAsString("outputList[0].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 1));
                    VerifyOrReturn(CheckValue("outputList[1].index", iter_0.GetValue().index, 2));
                    VerifyOrReturn(CheckValue("outputList[1].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(CheckValueAsString("outputList[1].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 2));
                    VerifyOrReturn(CheckValue("outputList[2].index", iter_0.GetValue().index, 3));
                    VerifyOrReturn(CheckValue("outputList[2].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(CheckValueAsString("outputList[2].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("outputList", iter_0, 3));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentOutput", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 0));
                    VerifyOrReturn(CheckValue("outputList[0].index", iter_0.GetValue().index, 1));
                    VerifyOrReturn(CheckValue("outputList[0].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(
                        CheckValueAsString("outputList[0].name", iter_0.GetValue().name, chip::CharSpan("HDMI Test", 9)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 1));
                    VerifyOrReturn(CheckValue("outputList[1].index", iter_0.GetValue().index, 2));
                    VerifyOrReturn(CheckValue("outputList[1].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(CheckValueAsString("outputList[1].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("outputList", iter_0, 2));
                    VerifyOrReturn(CheckValue("outputList[2].index", iter_0.GetValue().index, 3));
                    VerifyOrReturn(CheckValue("outputList[2].outputType", iter_0.GetValue().outputType, 0));
                    VerifyOrReturn(CheckValueAsString("outputList[2].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("outputList", iter_0, 3));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute Audio Output list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Attributes::OutputList::Id);
        }
        case 2: {
            LogStep(2, "Read attribute current audio output");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Attributes::CurrentOutput::Id);
        }
        case 3: {
            LogStep(3, "Select Output Command");
            chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type value;
            value.index = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Commands::SelectOutput::Id, value);
        }
        case 4: {
            LogStep(4, "Rename Output Command");
            chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type value;
            value.index = 1;
            value.name  = chip::Span<const char>("HDMI Testgarbage: not in length on purpose", 9);
            return SendCommand(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Commands::RenameOutput::Id, value);
        }
        case 5: {
            LogStep(5, "Read attribute Audio Output list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(2), AudioOutput::Id, AudioOutput::Attributes::OutputList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_ApplicationLauncherClusterSuite : public TestCommand
{
public:
    TV_ApplicationLauncherClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ApplicationLauncherCluster", 6, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_ApplicationLauncherClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("catalogList", iter_0, 0));
                    VerifyOrReturn(CheckValue("catalogList[0]", iter_0.GetValue(), 123U));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("catalogList", iter_0, 1));
                    VerifyOrReturn(CheckValue("catalogList[1]", iter_0.GetValue(), 456U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("catalogList", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEP::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("currentApp", value));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueAsString("data", value.data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueAsString("data", value.data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueAsString("data", value.data, chip::ByteSpan(chip::Uint8::from_const_char("data"), 4)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute Application Launcher list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id,
                                 ApplicationLauncher::Attributes::CatalogList::Id);
        }
        case 2: {
            LogStep(2, "Read attribute application launcher app");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id,
                                 ApplicationLauncher::Attributes::CurrentApp::Id);
        }
        case 3: {
            LogStep(3, "Launch App Command");
            chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type value;

            value.application.catalogVendorId = 123U;
            value.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

            value.data.Emplace();
            value.data.Value() = chip::ByteSpan(chip::Uint8::from_const_char("datagarbage: not in length on purpose"), 4);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id,
                               ApplicationLauncher::Commands::LaunchApp::Id, value);
        }
        case 4: {
            LogStep(4, "Stop App Command");
            chip::app::Clusters::ApplicationLauncher::Commands::StopApp::Type value;

            value.application.catalogVendorId = 123U;
            value.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id, ApplicationLauncher::Commands::StopApp::Id,
                               value);
        }
        case 5: {
            LogStep(5, "Hide App Command");
            chip::app::Clusters::ApplicationLauncher::Commands::HideApp::Type value;

            value.application.catalogVendorId = 123U;
            value.application.applicationId   = chip::Span<const char>("applicationIdgarbage: not in length on purpose", 13);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), ApplicationLauncher::Id, ApplicationLauncher::Commands::HideApp::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_KeypadInputClusterSuite : public TestCommand
{
public:
    TV_KeypadInputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_KeypadInputCluster", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_KeypadInputClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Send Key Command");
            chip::app::Clusters::KeypadInput::Commands::SendKey::Type value;
            value.keyCode = static_cast<chip::app::Clusters::KeypadInput::CecKeyCode>(3);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), KeypadInput::Id, KeypadInput::Commands::SendKey::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_AccountLoginClusterSuite : public TestCommand
{
public:
    TV_AccountLoginClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_AccountLoginCluster", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_AccountLoginClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("setupPIN", value.setupPIN, chip::CharSpan("tempPin123", 10)));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Get Setup PIN Command");
            chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type value;
            value.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);
            return SendCommand(kIdentityAlpha, GetEndpoint(3), AccountLogin::Id, AccountLogin::Commands::GetSetupPIN::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 2: {
            LogStep(2, "Login Command");
            chip::app::Clusters::AccountLogin::Commands::Login::Type value;
            value.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);
            value.setupPIN              = chip::Span<const char>("tempPin123garbage: not in length on purpose", 10);
            return SendCommand(kIdentityAlpha, GetEndpoint(3), AccountLogin::Id, AccountLogin::Commands::Login::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "Logout Command");
            chip::app::Clusters::AccountLogin::Commands::Logout::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), AccountLogin::Id, AccountLogin::Commands::Logout::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_WakeOnLanClusterSuite : public TestCommand
{
public:
    TV_WakeOnLanClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_WakeOnLanCluster", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_WakeOnLanClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("MACAddress", value, chip::CharSpan("00:00:00:00:00", 14)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read mac address");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), WakeOnLan::Id, WakeOnLan::Attributes::MACAddress::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_ApplicationBasicClusterSuite : public TestCommand
{
public:
    TV_ApplicationBasicClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ApplicationBasicCluster", 9, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_ApplicationBasicClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("vendorName", value, chip::CharSpan("exampleVendorName1", 18)));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorID", value, 1U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("applicationName", value, chip::CharSpan("exampleName1", 12)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("productID", value, 1U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value, 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApplication::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("application.catalogVendorId", value.catalogVendorId, 123U));
                VerifyOrReturn(
                    CheckValueAsString("application.applicationId", value.applicationId, chip::CharSpan("applicationId", 13)));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("applicationVersion", value, chip::CharSpan("exampleVersion", 14)));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::VendorId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("allowedVendorList", iter_0, 0));
                    VerifyOrReturn(CheckValue("allowedVendorList[0]", iter_0.GetValue(), 1U));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("allowedVendorList", iter_0, 1));
                    VerifyOrReturn(CheckValue("allowedVendorList[1]", iter_0.GetValue(), 456U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("allowedVendorList", iter_0, 2));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute vendor name");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::VendorName::Id);
        }
        case 2: {
            LogStep(2, "Read attribute vendor id");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id, ApplicationBasic::Attributes::VendorID::Id);
        }
        case 3: {
            LogStep(3, "Read attribute application name");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ApplicationName::Id);
        }
        case 4: {
            LogStep(4, "Read attribute product id");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id, ApplicationBasic::Attributes::ProductID::Id);
        }
        case 5: {
            LogStep(5, "Read attribute application status");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id, ApplicationBasic::Attributes::Status::Id);
        }
        case 6: {
            LogStep(6, "Read attribute application status");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::Application::Id);
        }
        case 7: {
            LogStep(7, "Read attribute application version");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::ApplicationVersion::Id);
        }
        case 8: {
            LogStep(8, "Read attribute application allowed vendor list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), ApplicationBasic::Id,
                                 ApplicationBasic::Attributes::AllowedVendorList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_MediaPlaybackClusterSuite : public TestCommand
{
public:
    TV_MediaPlaybackClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_MediaPlaybackCluster", 22, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_MediaPlaybackClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::PlaybackStateEnum value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentState", value, 0));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("startTime", value));
                VerifyOrReturn(CheckValue("startTime.Value()", value.Value(), 0ULL));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("duration", value));
                VerifyOrReturn(CheckValue("duration.Value()", value.Value(), 80000ULL));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("sampledPosition", value));
                VerifyOrReturn(CheckValue("sampledPosition.Value().updatedAt", value.Value().updatedAt, 0ULL));
                VerifyOrReturn(CheckValueNonNull("sampledPosition.Value().position", value.Value().position));
                VerifyOrReturn(CheckValue("sampledPosition.Value().position.Value()", value.Value().position.Value(), 0ULL));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("playbackSpeed", value, 0.0f));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("seekRangeEnd", value));
                VerifyOrReturn(CheckValue("seekRangeEnd.Value()", value.Value(), 80000ULL));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("seekRangeStart", value));
                VerifyOrReturn(CheckValue("seekRangeStart.Value()", value.Value(), 0ULL));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("sampledPosition", value));
                VerifyOrReturn(CheckValue("sampledPosition.Value().updatedAt", value.Value().updatedAt, 0ULL));
                VerifyOrReturn(CheckValueNonNull("sampledPosition.Value().position", value.Value().position));
                VerifyOrReturn(CheckValue("sampledPosition.Value().position.Value()", value.Value().position.Value(), 500ULL));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("sampledPosition", value));
                VerifyOrReturn(CheckValue("sampledPosition.Value().updatedAt", value.Value().updatedAt, 0ULL));
                VerifyOrReturn(CheckValueNonNull("sampledPosition.Value().position", value.Value().position));
                VerifyOrReturn(CheckValue("sampledPosition.Value().position.Value()", value.Value().position.Value(), 400ULL));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPosition::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("sampledPosition", value));
                VerifyOrReturn(CheckValue("sampledPosition.Value().updatedAt", value.Value().updatedAt, 0ULL));
                VerifyOrReturn(CheckValueNonNull("sampledPosition.Value().position", value.Value().position));
                VerifyOrReturn(CheckValue("sampledPosition.Value().position.Value()", value.Value().position.Value(), 1000ULL));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute playback state");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::CurrentState::Id);
        }
        case 2: {
            LogStep(2, "Read attribute start time");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::StartTime::Id);
        }
        case 3: {
            LogStep(3, "Read attribute duration");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::Duration::Id);
        }
        case 4: {
            LogStep(4, "Read attribute position");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::SampledPosition::Id);
        }
        case 5: {
            LogStep(5, "Read attribute playback speed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::PlaybackSpeed::Id);
        }
        case 6: {
            LogStep(6, "Read attribute seek range end");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::SeekRangeEnd::Id);
        }
        case 7: {
            LogStep(7, "Read attribute seek range start");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::SeekRangeStart::Id);
        }
        case 8: {
            LogStep(8, "Media Playback Play Command");
            chip::app::Clusters::MediaPlayback::Commands::Play::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Play::Id, value);
        }
        case 9: {
            LogStep(9, "Media Playback Pause Command");
            chip::app::Clusters::MediaPlayback::Commands::Pause::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Pause::Id, value);
        }
        case 10: {
            LogStep(10, "Media Playback Stop Command");
            chip::app::Clusters::MediaPlayback::Commands::StopPlayback::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::StopPlayback::Id, value);
        }
        case 11: {
            LogStep(11, "Media Playback Start Over Command");
            chip::app::Clusters::MediaPlayback::Commands::StartOver::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::StartOver::Id, value);
        }
        case 12: {
            LogStep(12, "Media Playback Previous Command");
            chip::app::Clusters::MediaPlayback::Commands::Previous::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Previous::Id, value);
        }
        case 13: {
            LogStep(13, "Media Playback Next Command");
            chip::app::Clusters::MediaPlayback::Commands::Next::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Next::Id, value);
        }
        case 14: {
            LogStep(14, "Media Playback Rewind Command");
            chip::app::Clusters::MediaPlayback::Commands::Rewind::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Rewind::Id, value);
        }
        case 15: {
            LogStep(15, "Media Playback Fast Forward Command");
            chip::app::Clusters::MediaPlayback::Commands::FastForward::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::FastForward::Id, value);
        }
        case 16: {
            LogStep(16, "Media Playback Skip Forward Command");
            chip::app::Clusters::MediaPlayback::Commands::SkipForward::Type value;
            value.deltaPositionMilliseconds = 500ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::SkipForward::Id, value);
        }
        case 17: {
            LogStep(17, "Read attribute position after skip forward");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::SampledPosition::Id);
        }
        case 18: {
            LogStep(18, "Media Playback Skip Backward Command");
            chip::app::Clusters::MediaPlayback::Commands::SkipBackward::Type value;
            value.deltaPositionMilliseconds = 100ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::SkipBackward::Id, value);
        }
        case 19: {
            LogStep(19, "Read attribute position after skip backward");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::SampledPosition::Id);
        }
        case 20: {
            LogStep(20, "Media Playback Seek Command");
            chip::app::Clusters::MediaPlayback::Commands::Seek::Type value;
            value.position = 1000ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Commands::Seek::Id, value);
        }
        case 21: {
            LogStep(21, "Read attribute position after seek");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(3), MediaPlayback::Id, MediaPlayback::Attributes::SampledPosition::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_ChannelClusterSuite : public TestCommand
{
public:
    TV_ChannelClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TV_ChannelCluster", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_ChannelClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("channelList", iter_0, 0));
                    VerifyOrReturn(CheckValue("channelList[0].majorNumber", iter_0.GetValue().majorNumber, 6U));
                    VerifyOrReturn(CheckValue("channelList[0].minorNumber", iter_0.GetValue().minorNumber, 0U));
                    VerifyOrReturn(CheckValuePresent("channelList[0].name", iter_0.GetValue().name));
                    VerifyOrReturn(CheckValueAsString("channelList[0].name.Value()", iter_0.GetValue().name.Value(),
                                                      chip::CharSpan("ABC", 3)));
                    VerifyOrReturn(CheckValuePresent("channelList[0].callSign", iter_0.GetValue().callSign));
                    VerifyOrReturn(CheckValueAsString("channelList[0].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                                      chip::CharSpan("KAAL-TV", 7)));
                    VerifyOrReturn(CheckValuePresent("channelList[0].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
                    VerifyOrReturn(CheckValueAsString("channelList[0].affiliateCallSign.Value()",
                                                      iter_0.GetValue().affiliateCallSign.Value(), chip::CharSpan("KAAL", 4)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("channelList", iter_0, 1));
                    VerifyOrReturn(CheckValue("channelList[1].majorNumber", iter_0.GetValue().majorNumber, 9U));
                    VerifyOrReturn(CheckValue("channelList[1].minorNumber", iter_0.GetValue().minorNumber, 1U));
                    VerifyOrReturn(CheckValuePresent("channelList[1].name", iter_0.GetValue().name));
                    VerifyOrReturn(CheckValueAsString("channelList[1].name.Value()", iter_0.GetValue().name.Value(),
                                                      chip::CharSpan("PBS", 3)));
                    VerifyOrReturn(CheckValuePresent("channelList[1].callSign", iter_0.GetValue().callSign));
                    VerifyOrReturn(CheckValueAsString("channelList[1].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                                      chip::CharSpan("KCTS-TV", 7)));
                    VerifyOrReturn(CheckValuePresent("channelList[1].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
                    VerifyOrReturn(CheckValueAsString("channelList[1].affiliateCallSign.Value()",
                                                      iter_0.GetValue().affiliateCallSign.Value(), chip::CharSpan("KCTS", 4)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("channelList", iter_0, 2));
                    VerifyOrReturn(CheckValue("channelList[2].majorNumber", iter_0.GetValue().majorNumber, 9U));
                    VerifyOrReturn(CheckValue("channelList[2].minorNumber", iter_0.GetValue().minorNumber, 2U));
                    VerifyOrReturn(CheckValuePresent("channelList[2].name", iter_0.GetValue().name));
                    VerifyOrReturn(CheckValueAsString("channelList[2].name.Value()", iter_0.GetValue().name.Value(),
                                                      chip::CharSpan("PBS Kids", 8)));
                    VerifyOrReturn(CheckValuePresent("channelList[2].callSign", iter_0.GetValue().callSign));
                    VerifyOrReturn(CheckValueAsString("channelList[2].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                                      chip::CharSpan("KCTS-TV", 7)));
                    VerifyOrReturn(CheckValuePresent("channelList[2].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
                    VerifyOrReturn(CheckValueAsString("channelList[2].affiliateCallSign.Value()",
                                                      iter_0.GetValue().affiliateCallSign.Value(), chip::CharSpan("KCTS", 4)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("channelList", iter_0, 3));
                    VerifyOrReturn(CheckValue("channelList[3].majorNumber", iter_0.GetValue().majorNumber, 9U));
                    VerifyOrReturn(CheckValue("channelList[3].minorNumber", iter_0.GetValue().minorNumber, 3U));
                    VerifyOrReturn(CheckValuePresent("channelList[3].name", iter_0.GetValue().name));
                    VerifyOrReturn(CheckValueAsString("channelList[3].name.Value()", iter_0.GetValue().name.Value(),
                                                      chip::CharSpan("World Channel", 13)));
                    VerifyOrReturn(CheckValuePresent("channelList[3].callSign", iter_0.GetValue().callSign));
                    VerifyOrReturn(CheckValueAsString("channelList[3].callSign.Value()", iter_0.GetValue().callSign.Value(),
                                                      chip::CharSpan("KCTS-TV", 7)));
                    VerifyOrReturn(CheckValuePresent("channelList[3].affiliateCallSign", iter_0.GetValue().affiliateCallSign));
                    VerifyOrReturn(CheckValueAsString("channelList[3].affiliateCallSign.Value()",
                                                      iter_0.GetValue().affiliateCallSign.Value(), chip::CharSpan("KCTS", 4)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("channelList", iter_0, 4));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lineup", value));
                VerifyOrReturn(
                    CheckValueAsString("lineup.Value().operatorName", value.Value().operatorName, chip::CharSpan("Comcast", 7)));
                VerifyOrReturn(CheckValuePresent("lineup.Value().lineupName", value.Value().lineupName));
                VerifyOrReturn(CheckValueAsString("lineup.Value().lineupName.Value()", value.Value().lineupName.Value(),
                                                  chip::CharSpan("Comcast King County", 19)));
                VerifyOrReturn(CheckValuePresent("lineup.Value().postalCode", value.Value().postalCode));
                VerifyOrReturn(CheckValueAsString("lineup.Value().postalCode.Value()", value.Value().postalCode.Value(),
                                                  chip::CharSpan("98052", 5)));
                VerifyOrReturn(CheckValue("lineup.Value().lineupInfoType", value.Value().lineupInfoType, 0));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("currentChannel", value));
                VerifyOrReturn(CheckValue("currentChannel.Value().majorNumber", value.Value().majorNumber, 6U));
                VerifyOrReturn(CheckValue("currentChannel.Value().minorNumber", value.Value().minorNumber, 0U));
                VerifyOrReturn(CheckValuePresent("currentChannel.Value().name", value.Value().name));
                VerifyOrReturn(CheckValueAsString("currentChannel.Value().name.Value()", value.Value().name.Value(),
                                                  chip::CharSpan("ABC", 3)));
                VerifyOrReturn(CheckValuePresent("currentChannel.Value().callSign", value.Value().callSign));
                VerifyOrReturn(CheckValueAsString("currentChannel.Value().callSign.Value()", value.Value().callSign.Value(),
                                                  chip::CharSpan("KAAL-TV", 7)));
                VerifyOrReturn(CheckValuePresent("currentChannel.Value().affiliateCallSign", value.Value().affiliateCallSign));
                VerifyOrReturn(CheckValueAsString("currentChannel.Value().affiliateCallSign.Value()",
                                                  value.Value().affiliateCallSign.Value(), chip::CharSpan("KAAL", 4)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Channel::Commands::ChangeChannelResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("data response", 13)));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute Channel list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::ChannelList::Id);
        }
        case 2: {
            LogStep(2, "Read attribute channel lineup");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::Lineup::Id);
        }
        case 3: {
            LogStep(3, "Read attribute current channel");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Attributes::CurrentChannel::Id);
        }
        case 4: {
            LogStep(4, "Change Channel Command");
            chip::app::Clusters::Channel::Commands::ChangeChannel::Type value;
            value.match = chip::Span<const char>("PBSgarbage: not in length on purpose", 3);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Commands::ChangeChannel::Id, value);
        }
        case 5: {
            LogStep(5, "Change Channel By Number Command");
            chip::app::Clusters::Channel::Commands::ChangeChannelByNumber::Type value;
            value.majorNumber = 6U;
            value.minorNumber = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Commands::ChangeChannelByNumber::Id, value);
        }
        case 6: {
            LogStep(6, "Skip Channel Command");
            chip::app::Clusters::Channel::Commands::SkipChannel::Type value;
            value.count = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Channel::Id, Channel::Commands::SkipChannel::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_LowPowerClusterSuite : public TestCommand
{
public:
    TV_LowPowerClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TV_LowPowerCluster", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_LowPowerClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Sleep Input Status Command");
            chip::app::Clusters::LowPower::Commands::Sleep::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), LowPower::Id, LowPower::Commands::Sleep::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_ContentLauncherClusterSuite : public TestCommand
{
public:
    TV_ContentLauncherClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_ContentLauncherCluster", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_ContentLauncherClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptHeader", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("acceptHeader[0]", iter_0.GetValue(), chip::CharSpan("example", 7)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptHeader", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString("acceptHeader[1]", iter_0.GetValue(), chip::CharSpan("example", 7)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acceptHeader", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("supportedStreamingProtocols", value, 0UL));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ContentLauncher::Commands::LaunchResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("exampleData", 11)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::ContentLauncher::Commands::LaunchResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("data", value.data));
                VerifyOrReturn(CheckValueAsString("data.Value()", value.data.Value(), chip::CharSpan("exampleData", 11)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute accept header list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::AcceptHeader::Id);
        }
        case 2: {
            LogStep(2, "Read attribute supported streaming protocols");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id,
                                 ContentLauncher::Attributes::SupportedStreamingProtocols::Id);
        }
        case 3: {
            LogStep(3, "Launch Content Command");
            ListFreer listFreer;
            chip::app::Clusters::ContentLauncher::Commands::LaunchContent::Type value;

            {
                auto * listHolder_1 = new ListHolder<chip::app::Clusters::ContentLauncher::Structs::Parameter::Type>(1);
                listFreer.add(listHolder_1);

                listHolder_1->mList[0].type  = static_cast<chip::app::Clusters::ContentLauncher::ParameterEnum>(1);
                listHolder_1->mList[0].value = chip::Span<const char>("exampleValuegarbage: not in length on purpose", 12);
                listHolder_1->mList[0].externalIDList.Emplace();

                {
                    auto * listHolder_4 = new ListHolder<chip::app::Clusters::ContentLauncher::Structs::AdditionalInfo::Type>(1);
                    listFreer.add(listHolder_4);

                    listHolder_4->mList[0].name  = chip::Span<const char>("namegarbage: not in length on purpose", 4);
                    listHolder_4->mList[0].value = chip::Span<const char>("valuegarbage: not in length on purpose", 5);

                    listHolder_1->mList[0].externalIDList.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::ContentLauncher::Structs::AdditionalInfo::Type>(
                            listHolder_4->mList, 1);
                }

                value.search.parameterList =
                    chip::app::DataModel::List<chip::app::Clusters::ContentLauncher::Structs::Parameter::Type>(listHolder_1->mList,
                                                                                                               1);
            }

            value.autoPlay = true;
            value.data.Emplace();
            value.data.Value() = chip::Span<const char>("exampleDatagarbage: not in length on purpose", 11);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id, ContentLauncher::Commands::LaunchContent::Id,
                               value);
        }
        case 4: {
            LogStep(4, "Launch URL Command");
            chip::app::Clusters::ContentLauncher::Commands::LaunchURL::Type value;
            value.contentURL = chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.displayString.Emplace();
            value.displayString.Value() = chip::Span<const char>("exampleDisplayStringgarbage: not in length on purpose", 20);
            value.brandingInformation.Emplace();

            value.brandingInformation.Value().providerName =
                chip::Span<const char>("exampleNamegarbage: not in length on purpose", 11);
            value.brandingInformation.Value().background.Emplace();

            value.brandingInformation.Value().background.Value().imageUrl.Emplace();
            value.brandingInformation.Value().background.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().background.Value().color.Emplace();
            value.brandingInformation.Value().background.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().background.Value().size.Emplace();

            value.brandingInformation.Value().background.Value().size.Value().width  = 0;
            value.brandingInformation.Value().background.Value().size.Value().height = 0;
            value.brandingInformation.Value().background.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            value.brandingInformation.Value().logo.Emplace();

            value.brandingInformation.Value().logo.Value().imageUrl.Emplace();
            value.brandingInformation.Value().logo.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().logo.Value().color.Emplace();
            value.brandingInformation.Value().logo.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().logo.Value().size.Emplace();

            value.brandingInformation.Value().logo.Value().size.Value().width  = 0;
            value.brandingInformation.Value().logo.Value().size.Value().height = 0;
            value.brandingInformation.Value().logo.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            value.brandingInformation.Value().progressBar.Emplace();

            value.brandingInformation.Value().progressBar.Value().imageUrl.Emplace();
            value.brandingInformation.Value().progressBar.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().progressBar.Value().color.Emplace();
            value.brandingInformation.Value().progressBar.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().progressBar.Value().size.Emplace();

            value.brandingInformation.Value().progressBar.Value().size.Value().width  = 0;
            value.brandingInformation.Value().progressBar.Value().size.Value().height = 0;
            value.brandingInformation.Value().progressBar.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            value.brandingInformation.Value().splash.Emplace();

            value.brandingInformation.Value().splash.Value().imageUrl.Emplace();
            value.brandingInformation.Value().splash.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().splash.Value().color.Emplace();
            value.brandingInformation.Value().splash.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().splash.Value().size.Emplace();

            value.brandingInformation.Value().splash.Value().size.Value().width  = 0;
            value.brandingInformation.Value().splash.Value().size.Value().height = 0;
            value.brandingInformation.Value().splash.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            value.brandingInformation.Value().waterMark.Emplace();

            value.brandingInformation.Value().waterMark.Value().imageUrl.Emplace();
            value.brandingInformation.Value().waterMark.Value().imageUrl.Value() =
                chip::Span<const char>("exampleUrlgarbage: not in length on purpose", 10);
            value.brandingInformation.Value().waterMark.Value().color.Emplace();
            value.brandingInformation.Value().waterMark.Value().color.Value() =
                chip::Span<const char>("exampleColorgarbage: not in length on purpose", 12);
            value.brandingInformation.Value().waterMark.Value().size.Emplace();

            value.brandingInformation.Value().waterMark.Value().size.Value().width  = 0;
            value.brandingInformation.Value().waterMark.Value().size.Value().height = 0;
            value.brandingInformation.Value().waterMark.Value().size.Value().metric =
                static_cast<chip::app::Clusters::ContentLauncher::MetricTypeEnum>(0);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), ContentLauncher::Id, ContentLauncher::Commands::LaunchURL::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TV_MediaInputClusterSuite : public TestCommand
{
public:
    TV_MediaInputClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TV_MediaInputCluster", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TV_MediaInputClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("inputList", iter_0, 0));
                    VerifyOrReturn(CheckValue("inputList[0].index", iter_0.GetValue().index, 1));
                    VerifyOrReturn(CheckValue("inputList[0].inputType", iter_0.GetValue().inputType, 4));
                    VerifyOrReturn(CheckValueAsString("inputList[0].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
                    VerifyOrReturn(CheckValueAsString("inputList[0].description", iter_0.GetValue().description,
                                                      chip::CharSpan("High-Definition Multimedia Interface", 36)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("inputList", iter_0, 1));
                    VerifyOrReturn(CheckValue("inputList[1].index", iter_0.GetValue().index, 2));
                    VerifyOrReturn(CheckValue("inputList[1].inputType", iter_0.GetValue().inputType, 4));
                    VerifyOrReturn(CheckValueAsString("inputList[1].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
                    VerifyOrReturn(CheckValueAsString("inputList[1].description", iter_0.GetValue().description,
                                                      chip::CharSpan("High-Definition Multimedia Interface", 36)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("inputList", iter_0, 2));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentInput", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfo::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("inputList", iter_0, 0));
                    VerifyOrReturn(CheckValue("inputList[0].index", iter_0.GetValue().index, 1));
                    VerifyOrReturn(CheckValue("inputList[0].inputType", iter_0.GetValue().inputType, 4));
                    VerifyOrReturn(CheckValueAsString("inputList[0].name", iter_0.GetValue().name, chip::CharSpan("HDMI Test", 9)));
                    VerifyOrReturn(CheckValueAsString("inputList[0].description", iter_0.GetValue().description,
                                                      chip::CharSpan("High-Definition Multimedia Interface", 36)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("inputList", iter_0, 1));
                    VerifyOrReturn(CheckValue("inputList[1].index", iter_0.GetValue().index, 2));
                    VerifyOrReturn(CheckValue("inputList[1].inputType", iter_0.GetValue().inputType, 4));
                    VerifyOrReturn(CheckValueAsString("inputList[1].name", iter_0.GetValue().name, chip::CharSpan("HDMI", 4)));
                    VerifyOrReturn(CheckValueAsString("inputList[1].description", iter_0.GetValue().description,
                                                      chip::CharSpan("High-Definition Multimedia Interface", 36)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("inputList", iter_0, 2));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute media input list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::InputList::Id);
        }
        case 2: {
            LogStep(2, "Read current media input");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::CurrentInput::Id);
        }
        case 3: {
            LogStep(3, "Select Input Command");
            chip::app::Clusters::MediaInput::Commands::SelectInput::Type value;
            value.index = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Commands::SelectInput::Id, value);
        }
        case 4: {
            LogStep(4, "Hide Input Status Command");
            chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Commands::HideInputStatus::Id, value);
        }
        case 5: {
            LogStep(5, "Show Input Status Command");
            chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Commands::ShowInputStatus::Id, value);
        }
        case 6: {
            LogStep(6, "Rename Input Command");
            chip::app::Clusters::MediaInput::Commands::RenameInput::Type value;
            value.index = 1;
            value.name  = chip::Span<const char>("HDMI Testgarbage: not in length on purpose", 9);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Commands::RenameInput::Id, value);
        }
        case 7: {
            LogStep(7, "Read attribute media input list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), MediaInput::Id, MediaInput::Attributes::InputList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestClusterSuite : public TestCommand
{
public:
    TestClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestCluster", 481, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestSpecificResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, 7));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, 20));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, 0));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, 1));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, 0));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, 0));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, 255));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, 0));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, 0U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, 65535U));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, 0U));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, 0UL));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, 4294967295UL));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, 0UL));
            }
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, 0ULL));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, 18446744073709551615ULL));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, 0ULL));
            }
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, 0));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, 255));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, 0));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, 0U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, 65535U));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, 0U));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, 0UL));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, 4294967295UL));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, 0UL));
            }
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, 0ULL));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, 18446744073709551615ULL));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, 0ULL));
            }
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, 0));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, 127));
            }
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, -128));
            }
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, 0));
            }
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, 0));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, 32767));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, -32768));
            }
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, 0));
            }
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, 0L));
            }
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, 2147483647L));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, -2147483648L));
            }
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, 0L));
            }
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, 0LL));
            }
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, 9223372036854775807LL));
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, -9223372036854775807LL));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, 0LL));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 0.0f));
            }
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 0.1f));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 17000000000.0f));
            }
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 1.7e-10f));
            }
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                float value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatSingle", value, 0.0f));
            }
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 0));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 0.1234567890123));
            }
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 1.7e+200));
            }
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 1.7e-200));
            }
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                double value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("floatDouble", value, 0));
            }
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, 0));
            }
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, 255));
            }
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, 0));
            }
            break;
        case 102:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, 0U));
            }
            break;
        case 103:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 104:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, 65535U));
            }
            break;
        case 105:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 106:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, 0U));
            }
            break;
        case 107:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
            }
            break;
        case 108:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 109:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("Tes\000ti\000ng"), 9)));
            }
            break;
        case 110:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 111:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value,
                                                  chip::ByteSpan(chip::Uint8::from_const_char("\015\012\377\042\240"), 5)));
            }
            break;
        case 112:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 113:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
            }
            break;
        case 114:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 115:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
            }
            break;
        case 116:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 117:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("longOctetString", value, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
            }
            break;
        case 118:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 119:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString(
                    "longOctetString", value,
                    chip::ByteSpan(
                        chip::Uint8::from_const_char(
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                            "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"),
                        300)));
            }
            break;
        case 120:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 121:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("", 0)));
            }
            break;
        case 122:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 123:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("T", 7)));
            }
            break;
        case 124:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 125:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("T", 7)));
            }
            break;
        case 126:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 127:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("longCharString", value, chip::CharSpan("", 0)));
            }
            break;
        case 128:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 129:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString(
                    "longCharString", value,
                    chip::CharSpan(
                        ""
                        ""
                        "",
                        900)));
            }
            break;
        case 130:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 131:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[0]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[1]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[2]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 3));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[3]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listLongOctetString", iter_0, 4));
                }
            }
            break;
        case 132:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 133:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[0]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[1]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[2]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 3));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[3]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listLongOctetString", iter_0, 4));
                    VerifyOrReturn(CheckValueAsString(
                        "listLongOctetString[4]", iter_0.GetValue(),
                        chip::ByteSpan(chip::Uint8::from_const_char(
                                           "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456"
                                           "789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                                           "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234"
                                           "56789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789ab"
                                           "cdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef012"
                                           "3456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
                                       512)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listLongOctetString", iter_0, 5));
                }
            }
            break;
        case 134:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, 0ULL));
            }
            break;
        case 135:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 136:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, 18446744073709551615ULL));
            }
            break;
        case 137:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 138:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, 0ULL));
            }
            break;
        case 139:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, 0UL));
            }
            break;
        case 140:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 141:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, 4294967295UL));
            }
            break;
        case 142:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 143:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, 0UL));
            }
            break;
        case 144:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("unsupported", value, 0));
            }
            break;
        case 145:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 146:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ENDPOINT));
            break;
        case 147:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER));
            break;
        case 148:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorId", value, 0U));
            }
            break;
        case 149:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 150:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorId", value, 17U));
            }
            break;
        case 151:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 152:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestEnumsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("arg1", value.arg1, 20003U));

                VerifyOrReturn(CheckValue("arg2", value.arg2, 101));
            }
            break;
        case 153:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 154:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 155:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 156:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 157:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 158:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 159:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::SimpleStructResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("arg1.a", value.arg1.a, 17));
                VerifyOrReturn(CheckValue("arg1.b", value.arg1.b, false));
                VerifyOrReturn(CheckValue("arg1.c", value.arg1.c, 2));
                VerifyOrReturn(
                    CheckValueAsString("arg1.d", value.arg1.d, chip::ByteSpan(chip::Uint8::from_const_char("octet_string"), 12)));
                VerifyOrReturn(CheckValueAsString("arg1.e", value.arg1.e, chip::CharSpan("char_string", 11)));
                VerifyOrReturn(CheckValue("arg1.f", value.arg1.f, 1));
                VerifyOrReturn(CheckValue("arg1.g", value.arg1.g, 0.1f));
                VerifyOrReturn(CheckValue("arg1.h", value.arg1.h, 0.1));
            }
            break;
        case 160:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 161:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 162:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.arg1.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 0));
                    VerifyOrReturn(CheckValue("arg1[0]", iter_0.GetValue(), 9));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 1));
                    VerifyOrReturn(CheckValue("arg1[1]", iter_0.GetValue(), 8));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 2));
                    VerifyOrReturn(CheckValue("arg1[2]", iter_0.GetValue(), 7));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 3));
                    VerifyOrReturn(CheckValue("arg1[3]", iter_0.GetValue(), 6));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 4));
                    VerifyOrReturn(CheckValue("arg1[4]", iter_0.GetValue(), 5));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 5));
                    VerifyOrReturn(CheckValue("arg1[5]", iter_0.GetValue(), 4));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 6));
                    VerifyOrReturn(CheckValue("arg1[6]", iter_0.GetValue(), 3));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 7));
                    VerifyOrReturn(CheckValue("arg1[7]", iter_0.GetValue(), 2));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.arg1)>("arg1", iter_0, 8));
                    VerifyOrReturn(CheckValue("arg1[8]", iter_0.GetValue(), 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.arg1)>("arg1", iter_0, 9));
                }
            }
            break;
        case 163:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.arg1.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.arg1)>("arg1", iter_0, 0));
                }
            }
            break;
        case 164:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 165:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 166:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, true));
            }
            break;
        case 167:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::BooleanResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, false));
            }
            break;
        case 168:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 169:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 0));
                    VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 1));
                    VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 2));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 2));
                    VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 3));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 3));
                    VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 4));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listInt8u", iter_0, 4));
                }
            }
            break;
        case 170:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 171:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listOctetString", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("listOctetString[0]", iter_0.GetValue(),
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listOctetString", iter_0, 1));
                    VerifyOrReturn(CheckValueAsString("listOctetString[1]", iter_0.GetValue(),
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listOctetString", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString("listOctetString[2]", iter_0.GetValue(),
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listOctetString", iter_0, 3));
                    VerifyOrReturn(CheckValueAsString("listOctetString[3]", iter_0.GetValue(),
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listOctetString", iter_0, 4));
                }
            }
            break;
        case 172:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 173:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listStructOctetString", iter_0, 0));
                    VerifyOrReturn(CheckValue("listStructOctetString[0].fabricIndex", iter_0.GetValue().fabricIndex, 0ULL));
                    VerifyOrReturn(CheckValueAsString("listStructOctetString[0].operationalCert", iter_0.GetValue().operationalCert,
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listStructOctetString", iter_0, 1));
                    VerifyOrReturn(CheckValue("listStructOctetString[1].fabricIndex", iter_0.GetValue().fabricIndex, 1ULL));
                    VerifyOrReturn(CheckValueAsString("listStructOctetString[1].operationalCert", iter_0.GetValue().operationalCert,
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listStructOctetString", iter_0, 2));
                    VerifyOrReturn(CheckValue("listStructOctetString[2].fabricIndex", iter_0.GetValue().fabricIndex, 2ULL));
                    VerifyOrReturn(CheckValueAsString("listStructOctetString[2].operationalCert", iter_0.GetValue().operationalCert,
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listStructOctetString", iter_0, 3));
                    VerifyOrReturn(CheckValue("listStructOctetString[3].fabricIndex", iter_0.GetValue().fabricIndex, 3ULL));
                    VerifyOrReturn(CheckValueAsString("listStructOctetString[3].operationalCert", iter_0.GetValue().operationalCert,
                                                      chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listStructOctetString", iter_0, 4));
                }
            }
            break;
        case 174:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("wasPresent", value.wasPresent, true));

                VerifyOrReturn(CheckValuePresent("wasNull", value.wasNull));
                VerifyOrReturn(CheckValue("wasNull.Value()", value.wasNull.Value(), false));

                VerifyOrReturn(CheckValuePresent("value", value.value));
                VerifyOrReturn(CheckValue("value.Value()", value.value.Value(), 5));

                VerifyOrReturn(CheckValuePresent("originalValue", value.originalValue));
                VerifyOrReturn(CheckValueNonNull("originalValue.Value()", value.originalValue.Value()));
                VerifyOrReturn(CheckValue("originalValue.Value().Value()", value.originalValue.Value().Value(), 5));
            }
            break;
        case 175:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("wasPresent", value.wasPresent, false));
            }
            break;
        case 176:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listNullablesAndOptionalsStruct", iter_0, 0));
                    VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableInt", iter_0.GetValue().nullableInt));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableString", iter_0.GetValue().nullableString));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableStruct", iter_0.GetValue().nullableStruct));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableList", iter_0.GetValue().nullableList));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listNullablesAndOptionalsStruct", iter_0, 1));
                }
            }
            break;
        case 177:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 178:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listNullablesAndOptionalsStruct", iter_0, 0));
                    VerifyOrReturn(CheckValueNull("listNullablesAndOptionalsStruct[0].nullableInt", iter_0.GetValue().nullableInt));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableString", iter_0.GetValue().nullableString));
                    VerifyOrReturn(
                        CheckValueNull("listNullablesAndOptionalsStruct[0].nullableStruct", iter_0.GetValue().nullableStruct));
                    VerifyOrReturn(
                        CheckValueNonNull("listNullablesAndOptionalsStruct[0].nullableList", iter_0.GetValue().nullableList));
                    {
                        auto iter_NaN = iter_0.GetValue().nullableList.Value().begin();
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().nullableList.Value())>(
                            "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 0));
                        VerifyOrReturn(
                            CheckValue("listNullablesAndOptionalsStruct[0].nullableList.Value()[0]", iter_NaN.GetValue(), 1));
                        VerifyOrReturn(CheckNextListItemDecodes<decltype(iter_0.GetValue().nullableList.Value())>(
                            "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 1));
                        VerifyOrReturn(
                            CheckValue("listNullablesAndOptionalsStruct[0].nullableList.Value()[1]", iter_NaN.GetValue(), 2));
                        VerifyOrReturn(CheckNoMoreListItems<decltype(iter_0.GetValue().nullableList.Value())>(
                            "listNullablesAndOptionalsStruct[0].nullableList.Value()", iter_NaN, 2));
                    }
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listNullablesAndOptionalsStruct", iter_0, 1));
                }
            }
            break;
        case 179:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 180:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<bool> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBoolean", value));
            }
            break;
        case 181:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 182:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<bool> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBoolean", value));
                VerifyOrReturn(CheckValue("nullableBoolean.Value()", value.Value(), true));
            }
            break;
        case 183:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 184:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap8", value));
                VerifyOrReturn(CheckValue("nullableBitmap8.Value()", value.Value(), 254));
            }
            break;
        case 185:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 186:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap8", value));
                VerifyOrReturn(CheckValue("nullableBitmap8.Value()", value.Value(), 254));
            }
            break;
        case 187:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 188:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBitmap8", value));
            }
            break;
        case 189:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 190:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap16", value));
                VerifyOrReturn(CheckValue("nullableBitmap16.Value()", value.Value(), 65534U));
            }
            break;
        case 191:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 192:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap16", value));
                VerifyOrReturn(CheckValue("nullableBitmap16.Value()", value.Value(), 65534U));
            }
            break;
        case 193:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 194:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBitmap16", value));
            }
            break;
        case 195:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 196:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap32", value));
                VerifyOrReturn(CheckValue("nullableBitmap32.Value()", value.Value(), 4294967294UL));
            }
            break;
        case 197:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 198:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap32", value));
                VerifyOrReturn(CheckValue("nullableBitmap32.Value()", value.Value(), 4294967294UL));
            }
            break;
        case 199:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 200:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBitmap32", value));
            }
            break;
        case 201:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 202:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap64", value));
                VerifyOrReturn(CheckValue("nullableBitmap64.Value()", value.Value(), 18446744073709551614ULL));
            }
            break;
        case 203:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 204:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableBitmap64", value));
                VerifyOrReturn(CheckValue("nullableBitmap64.Value()", value.Value(), 18446744073709551614ULL));
            }
            break;
        case 205:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 206:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableBitmap64", value));
            }
            break;
        case 207:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 208:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8u", value));
                VerifyOrReturn(CheckValue("nullableInt8u.Value()", value.Value(), 0));
            }
            break;
        case 209:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 210:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8u", value));
                VerifyOrReturn(CheckValue("nullableInt8u.Value()", value.Value(), 254));
            }
            break;
        case 211:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 212:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8u", value));
                VerifyOrReturn(CheckValue("nullableInt8u.Value()", value.Value(), 254));
            }
            break;
        case 213:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("value", value));
            }
            break;
        case 214:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 215:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt8u", value));
            }
            break;
        case 216:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 254));
            }
            break;
        case 217:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 254));
            }
            break;
        case 218:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 219:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 254));
            }
            break;
        case 220:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 129));
            }
            break;
        case 221:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 222:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16u", value));
                VerifyOrReturn(CheckValue("nullableInt16u.Value()", value.Value(), 0U));
            }
            break;
        case 223:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 224:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16u", value));
                VerifyOrReturn(CheckValue("nullableInt16u.Value()", value.Value(), 65534U));
            }
            break;
        case 225:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 226:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16u", value));
                VerifyOrReturn(CheckValue("nullableInt16u.Value()", value.Value(), 65534U));
            }
            break;
        case 227:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 228:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt16u", value));
            }
            break;
        case 229:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65534U));
            }
            break;
        case 230:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 65534U));
            }
            break;
        case 231:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 232:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 65534U));
            }
            break;
        case 233:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 32001U));
            }
            break;
        case 234:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 235:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32u", value));
                VerifyOrReturn(CheckValue("nullableInt32u.Value()", value.Value(), 0UL));
            }
            break;
        case 236:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 237:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32u", value));
                VerifyOrReturn(CheckValue("nullableInt32u.Value()", value.Value(), 4294967294UL));
            }
            break;
        case 238:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 239:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32u", value));
                VerifyOrReturn(CheckValue("nullableInt32u.Value()", value.Value(), 4294967294UL));
            }
            break;
        case 240:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 241:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt32u", value));
            }
            break;
        case 242:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0UL));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 4294967294UL));
            }
            break;
        case 243:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 4294967294UL));
            }
            break;
        case 244:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 245:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0UL));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 4294967294UL));
            }
            break;
        case 246:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 2147483648UL));
            }
            break;
        case 247:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 248:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64u", value));
                VerifyOrReturn(CheckValue("nullableInt64u.Value()", value.Value(), 0ULL));
            }
            break;
        case 249:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 250:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64u", value));
                VerifyOrReturn(CheckValue("nullableInt64u.Value()", value.Value(), 18446744073709551614ULL));
            }
            break;
        case 251:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 252:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64u", value));
                VerifyOrReturn(CheckValue("nullableInt64u.Value()", value.Value(), 18446744073709551614ULL));
            }
            break;
        case 253:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 254:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt64u", value));
            }
            break;
        case 255:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0ULL));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 18446744073709551614ULL));
            }
            break;
        case 256:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 18446744073709551614ULL));
            }
            break;
        case 257:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 258:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 0ULL));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 18446744073709551614ULL));
            }
            break;
        case 259:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 18000000000000000001ULL));
            }
            break;
        case 260:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 261:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8s", value));
                VerifyOrReturn(CheckValue("nullableInt8s.Value()", value.Value(), -127));
            }
            break;
        case 262:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 263:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt8s", value));
                VerifyOrReturn(CheckValue("nullableInt8s.Value()", value.Value(), -127));
            }
            break;
        case 264:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 265:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt8s", value));
            }
            break;
        case 266:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -127));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
            }
            break;
        case 267:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -127));
            }
            break;
        case 268:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 269:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -127));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 127));
            }
            break;
        case 270:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -126));
            }
            break;
        case 271:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 272:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16s", value));
                VerifyOrReturn(CheckValue("nullableInt16s.Value()", value.Value(), -32767));
            }
            break;
        case 273:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 274:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt16s", value));
                VerifyOrReturn(CheckValue("nullableInt16s.Value()", value.Value(), -32767));
            }
            break;
        case 275:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 276:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt16s", value));
            }
            break;
        case 277:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -32767));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32767));
            }
            break;
        case 278:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -32767));
            }
            break;
        case 279:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 280:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -32767));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 32767));
            }
            break;
        case 281:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -32766));
            }
            break;
        case 282:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 283:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32s", value));
                VerifyOrReturn(CheckValue("nullableInt32s.Value()", value.Value(), -2147483647L));
            }
            break;
        case 284:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 285:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt32s", value));
                VerifyOrReturn(CheckValue("nullableInt32s.Value()", value.Value(), -2147483647L));
            }
            break;
        case 286:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 287:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt32s", value));
            }
            break;
        case 288:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -2147483647L));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2147483647L));
            }
            break;
        case 289:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -2147483647L));
            }
            break;
        case 290:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 291:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -2147483647L));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 2147483647L));
            }
            break;
        case 292:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int32_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -2147483646L));
            }
            break;
        case 293:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 294:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64s", value));
                VerifyOrReturn(CheckValue("nullableInt64s.Value()", value.Value(), -9223372036854775807LL));
            }
            break;
        case 295:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 296:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableInt64s", value));
                VerifyOrReturn(CheckValue("nullableInt64s.Value()", value.Value(), -9223372036854775807LL));
            }
            break;
        case 297:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 298:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableInt64s", value));
            }
            break;
        case 299:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -9223372036854775807LL));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9223372036854775807LL));
            }
            break;
        case 300:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -9223372036854775807LL));
            }
            break;
        case 301:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 302:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, -9223372036854775807LL));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 9223372036854775807LL));
            }
            break;
        case 303:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int64_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, -9223372036854775806LL));
            }
            break;
        case 304:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 305:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", value));
                VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", value.Value(), 0.1f));
            }
            break;
        case 306:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 307:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", value));
                VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", value.Value(), INFINITY));
            }
            break;
        case 308:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 309:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", value));
                VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", value.Value(), -INFINITY));
            }
            break;
        case 310:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 311:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableFloatSingle", value));
            }
            break;
        case 312:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 313:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<float> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatSingle", value));
                VerifyOrReturn(CheckValue("nullableFloatSingle.Value()", value.Value(), 0.0f));
            }
            break;
        case 314:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 315:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", value));
                VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", value.Value(), 0.1234567890123));
            }
            break;
        case 316:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 317:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", value));
                VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", value.Value(), INFINITY));
            }
            break;
        case 318:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 319:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", value));
                VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", value.Value(), -INFINITY));
            }
            break;
        case 320:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 321:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableFloatDouble", value));
            }
            break;
        case 322:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 323:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<double> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableFloatDouble", value));
                VerifyOrReturn(CheckValue("nullableFloatDouble.Value()", value.Value(), 0));
            }
            break;
        case 324:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 325:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum8", value));
                VerifyOrReturn(CheckValue("nullableEnum8.Value()", value.Value(), 0));
            }
            break;
        case 326:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 327:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum8", value));
                VerifyOrReturn(CheckValue("nullableEnum8.Value()", value.Value(), 254));
            }
            break;
        case 328:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 329:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum8", value));
                VerifyOrReturn(CheckValue("nullableEnum8.Value()", value.Value(), 254));
            }
            break;
        case 330:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 331:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableEnum8", value));
            }
            break;
        case 332:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 333:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum16", value));
                VerifyOrReturn(CheckValue("nullableEnum16.Value()", value.Value(), 0U));
            }
            break;
        case 334:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 335:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum16", value));
                VerifyOrReturn(CheckValue("nullableEnum16.Value()", value.Value(), 65534U));
            }
            break;
        case 336:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 337:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnum16", value));
                VerifyOrReturn(CheckValue("nullableEnum16.Value()", value.Value(), 65534U));
            }
            break;
        case 338:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 339:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableEnum16", value));
            }
            break;
        case 340:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 341:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", value));
                VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", value.Value(), 0));
            }
            break;
        case 342:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 343:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", value));
                VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", value.Value(), 254));
            }
            break;
        case 344:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 345:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableEnumAttr", value));
                VerifyOrReturn(CheckValue("nullableEnumAttr.Value()", value.Value(), 254));
            }
            break;
        case 346:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 347:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableEnumAttr", value));
            }
            break;
        case 348:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableOctetString", value));
                VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", value.Value(),
                                                  chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
            }
            break;
        case 349:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 350:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableOctetString", value));
                VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", value.Value(),
                                                  chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
            }
            break;
        case 351:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 352:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableOctetString", value));
            }
            break;
        case 353:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 354:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::ByteSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableOctetString", value));
                VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", value.Value(),
                                                  chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
            }
            break;
        case 355:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableCharString", value));
                VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", value.Value(), chip::CharSpan("", 0)));
            }
            break;
        case 356:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 357:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableCharString", value));
                VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", value.Value(), chip::CharSpan("T", 7)));
            }
            break;
        case 358:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 359:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableCharString", value));
            }
            break;
        case 360:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 361:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::CharSpan> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableCharString", value));
                VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", value.Value(), chip::CharSpan("", 0)));
            }
            break;
        case 362:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ENDPOINT));
            break;
        case 363:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_CLUSTER));
            break;
        case 364:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_VALUE));
            break;
        case 365:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 366:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 0));
                    VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 1));
                    VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 2));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 2));
                    VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 3));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 3));
                    VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 4));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listInt8u", iter_0, 4));
                }
            }
            break;
        case 367:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 368:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 0));
                    VerifyOrReturn(CheckValue("listInt8u[0]", iter_0.GetValue(), 5));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 1));
                    VerifyOrReturn(CheckValue("listInt8u[1]", iter_0.GetValue(), 6));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 2));
                    VerifyOrReturn(CheckValue("listInt8u[2]", iter_0.GetValue(), 7));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("listInt8u", iter_0, 3));
                    VerifyOrReturn(CheckValue("listInt8u[3]", iter_0.GetValue(), 8));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("listInt8u", iter_0, 4));
                }
            }
            shouldContinue = true;
            break;
        case 369:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 70));
            }
            break;
        case 370:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 371:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 372:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 373:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 374:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 70));
            }
            break;
        case 375:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 376:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 20));
            }
            break;
        case 377:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 378:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 100));
            }
            break;
        case 379:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 380:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8u", value, 50));
            }
            break;
        case 381:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 200U));
            }
            break;
        case 382:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 383:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 384:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 385:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 386:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 200U));
            }
            break;
        case 387:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 388:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 100U));
            }
            break;
        case 389:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 390:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 1000U));
            }
            break;
        case 391:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 392:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16u", value, 500U));
            }
            break;
        case 393:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, -20));
            }
            break;
        case 394:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 395:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 396:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 397:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 398:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, -20));
            }
            break;
        case 399:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 400:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, -40));
            }
            break;
        case 401:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 402:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, 50));
            }
            break;
        case 403:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 404:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt8s", value, 6));
            }
            break;
        case 405:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, -100));
            }
            break;
        case 406:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 407:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 408:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 409:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 410:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, -100));
            }
            break;
        case 411:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 412:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, -150));
            }
            break;
        case 413:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 414:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, 200));
            }
            break;
        case 415:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 416:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("rangeRestrictedInt16s", value, 7));
            }
            break;
        case 417:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 70));
            }
            break;
        case 418:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 419:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 420:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 421:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 422:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 70));
            }
            break;
        case 423:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 424:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 20));
            }
            break;
        case 425:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 426:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 100));
            }
            break;
        case 427:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 428:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8u.Value()", value.Value(), 50));
            }
            break;
        case 429:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 430:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt8u", value));
            }
            break;
        case 431:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 200U));
            }
            break;
        case 432:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 433:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 434:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 435:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 436:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 200U));
            }
            break;
        case 437:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 438:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 100U));
            }
            break;
        case 439:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 440:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 1000U));
            }
            break;
        case 441:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 442:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16u", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16u.Value()", value.Value(), 500U));
            }
            break;
        case 443:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 444:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt16u", value));
            }
            break;
        case 445:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), -20));
            }
            break;
        case 446:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 447:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 448:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 449:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 450:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), -20));
            }
            break;
        case 451:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 452:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), -40));
            }
            break;
        case 453:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 454:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), 50));
            }
            break;
        case 455:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 456:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt8s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt8s.Value()", value.Value(), 6));
            }
            break;
        case 457:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 458:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt8s", value));
            }
            break;
        case 459:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), -100));
            }
            break;
        case 460:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 461:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 462:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 463:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 464:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), -100));
            }
            break;
        case 465:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 466:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), -150));
            }
            break;
        case 467:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 468:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), 200));
            }
            break;
        case 469:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 470:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("nullableRangeRestrictedInt16s", value));
                VerifyOrReturn(CheckValue("nullableRangeRestrictedInt16s.Value()", value.Value(), 7));
            }
            break;
        case 471:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 472:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<int16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("nullableRangeRestrictedInt16s", value));
            }
            break;
        case 473:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_DATA_TYPE));
            break;
        case 474:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 475:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_DATA_TYPE));
            break;
        case 476:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 477:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 0));
                    VerifyOrReturn(CheckValue("acceptedCommandList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 1));
                    VerifyOrReturn(CheckValue("acceptedCommandList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 2));
                    VerifyOrReturn(CheckValue("acceptedCommandList[2]", iter_0.GetValue(), 2UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 3));
                    VerifyOrReturn(CheckValue("acceptedCommandList[3]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 4));
                    VerifyOrReturn(CheckValue("acceptedCommandList[4]", iter_0.GetValue(), 7UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 5));
                    VerifyOrReturn(CheckValue("acceptedCommandList[5]", iter_0.GetValue(), 8UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 6));
                    VerifyOrReturn(CheckValue("acceptedCommandList[6]", iter_0.GetValue(), 9UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 7));
                    VerifyOrReturn(CheckValue("acceptedCommandList[7]", iter_0.GetValue(), 10UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 8));
                    VerifyOrReturn(CheckValue("acceptedCommandList[8]", iter_0.GetValue(), 11UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 9));
                    VerifyOrReturn(CheckValue("acceptedCommandList[9]", iter_0.GetValue(), 12UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 10));
                    VerifyOrReturn(CheckValue("acceptedCommandList[10]", iter_0.GetValue(), 13UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 11));
                    VerifyOrReturn(CheckValue("acceptedCommandList[11]", iter_0.GetValue(), 14UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 12));
                    VerifyOrReturn(CheckValue("acceptedCommandList[12]", iter_0.GetValue(), 15UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 13));
                    VerifyOrReturn(CheckValue("acceptedCommandList[13]", iter_0.GetValue(), 17UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 14));
                    VerifyOrReturn(CheckValue("acceptedCommandList[14]", iter_0.GetValue(), 18UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 15));
                    VerifyOrReturn(CheckValue("acceptedCommandList[15]", iter_0.GetValue(), 19UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 16));
                    VerifyOrReturn(CheckValue("acceptedCommandList[16]", iter_0.GetValue(), 20UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("acceptedCommandList", iter_0, 17));
                    VerifyOrReturn(CheckValue("acceptedCommandList[17]", iter_0.GetValue(), 21UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("acceptedCommandList", iter_0, 18));
                }
            }
            break;
        case 478:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::CommandId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 0));
                    VerifyOrReturn(CheckValue("generatedCommandList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 1));
                    VerifyOrReturn(CheckValue("generatedCommandList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 2));
                    VerifyOrReturn(CheckValue("generatedCommandList[2]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 3));
                    VerifyOrReturn(CheckValue("generatedCommandList[3]", iter_0.GetValue(), 5UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 4));
                    VerifyOrReturn(CheckValue("generatedCommandList[4]", iter_0.GetValue(), 6UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 5));
                    VerifyOrReturn(CheckValue("generatedCommandList[5]", iter_0.GetValue(), 9UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 6));
                    VerifyOrReturn(CheckValue("generatedCommandList[6]", iter_0.GetValue(), 10UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("generatedCommandList", iter_0, 7));
                    VerifyOrReturn(CheckValue("generatedCommandList[7]", iter_0.GetValue(), 11UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("generatedCommandList", iter_0, 8));
                }
            }
            break;
        case 479:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 480:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("structAttr.a", value.a, 5));
                VerifyOrReturn(CheckValue("structAttr.b", value.b, true));
                VerifyOrReturn(CheckValue("structAttr.c", value.c, 2));
                VerifyOrReturn(CheckValueAsString("structAttr.d", value.d, chip::ByteSpan(chip::Uint8::from_const_char("abc"), 3)));
                VerifyOrReturn(CheckValueAsString("structAttr.e", value.e, chip::CharSpan("", 0)));
                VerifyOrReturn(CheckValue("structAttr.f", value.f, 17));
                VerifyOrReturn(CheckValue("structAttr.g", value.g, 1.5f));
                VerifyOrReturn(CheckValue("structAttr.h", value.h, 3.14159265358979));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Send Test Command");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::Test::Id, value);
        }
        case 2: {
            LogStep(2, "Send Test Not Handled Command");
            chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestNotHandled::Id, value);
        }
        case 3: {
            LogStep(3, "Send Test Specific Command");
            chip::app::Clusters::TestCluster::Commands::TestSpecific::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestSpecific::Id, value);
        }
        case 4: {
            LogStep(4, "Send Test Add Arguments Command");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = 17;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 5: {
            LogStep(5, "Send failing Test Add Arguments Command");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 250;
            value.arg2 = 6;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 6: {
            LogStep(6, "Read attribute BOOLEAN Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 7: {
            LogStep(7, "Write attribute BOOLEAN True");
            bool value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        case 8: {
            LogStep(8, "Read attribute BOOLEAN True");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 9: {
            LogStep(9, "Write attribute BOOLEAN False");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        case 10: {
            LogStep(10, "Read attribute BOOLEAN False");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 11: {
            LogStep(11, "Read attribute BITMAP8 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 12: {
            LogStep(12, "Write attribute BITMAP8 Max Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>>(255);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id, value);
        }
        case 13: {
            LogStep(13, "Read attribute BITMAP8 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 14: {
            LogStep(14, "Write attribute BITMAP8 Min Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id, value);
        }
        case 15: {
            LogStep(15, "Read attribute BITMAP8 Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 16: {
            LogStep(16, "Read attribute BITMAP16 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 17: {
            LogStep(17, "Write attribute BITMAP16 Max Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>>(65535U);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id, value);
        }
        case 18: {
            LogStep(18, "Read attribute BITMAP16 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 19: {
            LogStep(19, "Write attribute BITMAP16 Min Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>>(0U);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id, value);
        }
        case 20: {
            LogStep(20, "Read attribute BITMAP16 Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 21: {
            LogStep(21, "Read attribute BITMAP32 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 22: {
            LogStep(22, "Write attribute BITMAP32 Max Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>>(4294967295UL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id, value);
        }
        case 23: {
            LogStep(23, "Read attribute BITMAP32 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 24: {
            LogStep(24, "Write attribute BITMAP32 Min Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>>(0UL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id, value);
        }
        case 25: {
            LogStep(25, "Read attribute BITMAP32 Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 26: {
            LogStep(26, "Read attribute BITMAP64 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 27: {
            LogStep(27, "Write attribute BITMAP64 Max Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>>(18446744073709551615ULL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id, value);
        }
        case 28: {
            LogStep(28, "Read attribute BITMAP64 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 29: {
            LogStep(29, "Write attribute BITMAP64 Min Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>>(0ULL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id, value);
        }
        case 30: {
            LogStep(30, "Read attribute BITMAP64 Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 31: {
            LogStep(31, "Read attribute INT8U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 32: {
            LogStep(32, "Write attribute INT8U Max Value");
            uint8_t value;
            value = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id, value);
        }
        case 33: {
            LogStep(33, "Read attribute INT8U Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 34: {
            LogStep(34, "Write attribute INT8U Min Value");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id, value);
        }
        case 35: {
            LogStep(35, "Read attribute INT8U Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 36: {
            LogStep(36, "Read attribute INT16U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 37: {
            LogStep(37, "Write attribute INT16U Max Value");
            uint16_t value;
            value = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id, value);
        }
        case 38: {
            LogStep(38, "Read attribute INT16U Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 39: {
            LogStep(39, "Write attribute INT16U Min Value");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id, value);
        }
        case 40: {
            LogStep(40, "Read attribute INT16U Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 41: {
            LogStep(41, "Read attribute INT32U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 42: {
            LogStep(42, "Write attribute INT32U Max Value");
            uint32_t value;
            value = 4294967295UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 43: {
            LogStep(43, "Read attribute INT32U Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 44: {
            LogStep(44, "Write attribute INT32U Min Value");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 45: {
            LogStep(45, "Read attribute INT32U Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 46: {
            LogStep(46, "Read attribute INT64U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 47: {
            LogStep(47, "Write attribute INT64U Max Value");
            uint64_t value;
            value = 18446744073709551615ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id, value);
        }
        case 48: {
            LogStep(48, "Read attribute INT64U Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 49: {
            LogStep(49, "Write attribute INT64U Min Value");
            uint64_t value;
            value = 0ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id, value);
        }
        case 50: {
            LogStep(50, "Read attribute INT64U Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 51: {
            LogStep(51, "Read attribute INT8S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 52: {
            LogStep(52, "Write attribute INT8S Max Value");
            int8_t value;
            value = 127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 53: {
            LogStep(53, "Read attribute INT8S Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 54: {
            LogStep(54, "Write attribute INT8S Min Value");
            int8_t value;
            value = -128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 55: {
            LogStep(55, "Read attribute INT8S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 56: {
            LogStep(56, "Write attribute INT8S Default Value");
            int8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 57: {
            LogStep(57, "Read attribute INT8S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 58: {
            LogStep(58, "Read attribute INT16S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 59: {
            LogStep(59, "Write attribute INT16S Max Value");
            int16_t value;
            value = 32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 60: {
            LogStep(60, "Read attribute INT16S Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 61: {
            LogStep(61, "Write attribute INT16S Min Value");
            int16_t value;
            value = -32768;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 62: {
            LogStep(62, "Read attribute INT16S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 63: {
            LogStep(63, "Write attribute INT16S Default Value");
            int16_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 64: {
            LogStep(64, "Read attribute INT16S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 65: {
            LogStep(65, "Read attribute INT32S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 66: {
            LogStep(66, "Write attribute INT32S Max Value");
            int32_t value;
            value = 2147483647L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 67: {
            LogStep(67, "Read attribute INT32S Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 68: {
            LogStep(68, "Write attribute INT32S Min Value");
            int32_t value;
            value = -2147483648L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 69: {
            LogStep(69, "Read attribute INT32S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 70: {
            LogStep(70, "Write attribute INT32S Default Value");
            int32_t value;
            value = 0L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 71: {
            LogStep(71, "Read attribute INT32S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 72: {
            LogStep(72, "Read attribute INT64S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 73: {
            LogStep(73, "Write attribute INT64S Max Value");
            int64_t value;
            value = 9223372036854775807LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 74: {
            LogStep(74, "Read attribute INT64S Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 75: {
            LogStep(75, "Write attribute INT64S Min Value");
            int64_t value;
            value = -9223372036854775807LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 76: {
            LogStep(76, "Read attribute INT64S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 77: {
            LogStep(77, "Write attribute INT64S Default Value");
            int64_t value;
            value = 0LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 78: {
            LogStep(78, "Read attribute INT64S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 79: {
            LogStep(79, "Read attribute SINGLE Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 80: {
            LogStep(80, "Write attribute SINGLE medium Value");
            float value;
            value = 0.1f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id, value);
        }
        case 81: {
            LogStep(81, "Read attribute SINGLE medium Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 82: {
            LogStep(82, "Write attribute SINGLE large Value");
            float value;
            value = 17000000000.0f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id, value);
        }
        case 83: {
            LogStep(83, "Read attribute SINGLE large Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 84: {
            LogStep(84, "Write attribute SINGLE small Value");
            float value;
            value = 1.7e-10f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id, value);
        }
        case 85: {
            LogStep(85, "Read attribute SINGLE small Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 86: {
            LogStep(86, "Write attribute SINGLE Default Value");
            float value;
            value = 0.0f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id, value);
        }
        case 87: {
            LogStep(87, "Read attribute SINGLE Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatSingle::Id);
        }
        case 88: {
            LogStep(88, "Read attribute DOUBLE Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 89: {
            LogStep(89, "Write attribute DOUBLE medium Value");
            double value;
            value = 0.1234567890123;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id, value);
        }
        case 90: {
            LogStep(90, "Read attribute DOUBLE medium Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 91: {
            LogStep(91, "Write attribute DOUBLE large Value");
            double value;
            value = 1.7e+200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id, value);
        }
        case 92: {
            LogStep(92, "Read attribute DOUBLE large Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 93: {
            LogStep(93, "Write attribute DOUBLE small Value");
            double value;
            value = 1.7e-200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id, value);
        }
        case 94: {
            LogStep(94, "Read attribute DOUBLE small Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 95: {
            LogStep(95, "Write attribute DOUBLE Default Value");
            double value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id, value);
        }
        case 96: {
            LogStep(96, "Read attribute DOUBLE Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::FloatDouble::Id);
        }
        case 97: {
            LogStep(97, "Read attribute ENUM8 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 98: {
            LogStep(98, "Write attribute ENUM8 Max Value");
            uint8_t value;
            value = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id, value);
        }
        case 99: {
            LogStep(99, "Read attribute ENUM8 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 100: {
            LogStep(100, "Write attribute ENUM8 Min Value");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id, value);
        }
        case 101: {
            LogStep(101, "Read attribute ENUM8 Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 102: {
            LogStep(102, "Read attribute ENUM16 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 103: {
            LogStep(103, "Write attribute ENUM16 Max Value");
            uint16_t value;
            value = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id, value);
        }
        case 104: {
            LogStep(104, "Read attribute ENUM16 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 105: {
            LogStep(105, "Write attribute ENUM16 Min Value");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id, value);
        }
        case 106: {
            LogStep(106, "Read attribute ENUM16 Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 107: {
            LogStep(107, "Read attribute OCTET_STRING Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 108: {
            LogStep(108, "Write attribute OCTET_STRING with embedded null");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("Tes\000ti\000nggarbage: not in length on purpose"), 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 109: {
            LogStep(109, "Read attribute OCTET_STRING with embedded null");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 110: {
            LogStep(110, "Write attribute OCTET_STRING with weird chars");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("\015\012\377\042\240garbage: not in length on purpose"), 5);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 111: {
            LogStep(111, "Read attribute OCTET_STRING with weird chars");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 112: {
            LogStep(112, "Write attribute OCTET_STRING");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 113: {
            LogStep(113, "Read attribute OCTET_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 114: {
            LogStep(114, "Write attribute OCTET_STRING");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("TestValueLongerThan10garbage: not in length on purpose"), 21);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 115: {
            LogStep(115, "Read attribute OCTET_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 116: {
            LogStep(116, "Write attribute OCTET_STRING");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 117: {
            LogStep(117, "Read attribute LONG_OCTET_STRING Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongOctetString::Id);
        }
        case 118: {
            LogStep(118, "Write attribute LONG_OCTET_STRING");
            chip::ByteSpan value;
            value = chip::ByteSpan(
                chip::Uint8::from_const_char("1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                                             "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                                             "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                                             "111111111111111111111111111111111111111111111garbage: not in length on purpose"),
                300);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongOctetString::Id,
                                  value);
        }
        case 119: {
            LogStep(119, "Read attribute LONG_OCTET_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongOctetString::Id);
        }
        case 120: {
            LogStep(120, "Write attribute LONG_OCTET_STRING");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongOctetString::Id,
                                  value);
        }
        case 121: {
            LogStep(121, "Read attribute CHAR_STRING Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 122: {
            LogStep(122, "Write attribute CHAR_STRING");
            chip::CharSpan value;
            value = chip::Span<const char>("Tgarbage: not in length on purpose", 7);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 123: {
            LogStep(123, "Read attribute CHAR_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 124: {
            LogStep(124, "Write attribute CHAR_STRING - Value too long");
            chip::CharSpan value;
            value = chip::Span<const char>("TestValueLongerThan10garbage: not in length on purpose", 27);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 125: {
            LogStep(125, "Read attribute CHAR_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 126: {
            LogStep(126, "Write attribute CHAR_STRING - Empty");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 127: {
            LogStep(127, "Read attribute LONG_CHAR_STRING Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongCharString::Id);
        }
        case 128: {
            LogStep(128, "Write attribute LONG_CHAR_STRING");
            chip::CharSpan value;
            value = chip::Span<const char>(
                ""
                ""
                "garbage: not in length on purpose",
                900);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongCharString::Id,
                                  value);
        }
        case 129: {
            LogStep(129, "Read attribute LONG_CHAR_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongCharString::Id);
        }
        case 130: {
            LogStep(130, "Write attribute LONG_CHAR_STRING");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::LongCharString::Id,
                                  value);
        }
        case 131: {
            LogStep(131, "Read attribute LIST_LONG_OCTET_STRING (for chunked read)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListLongOctetString::Id);
        }
        case 132: {
            LogStep(132, "Write attribute LIST_LONG_OCTET_STRING (for chunked write)");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::ByteSpan> value;

            {
                auto * listHolder_0 = new ListHolder<chip::ByteSpan>(5);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                listHolder_0->mList[1] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                listHolder_0->mList[2] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                listHolder_0->mList[3] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                listHolder_0->mList[4] = chip::ByteSpan(
                    chip::Uint8::from_const_char(
                        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789"
                        "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123"
                        "456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd"
                        "ef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef01234567"
                        "89abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdefgarbage: not in "
                        "length on purpose"),
                    512);
                value = chip::app::DataModel::List<chip::ByteSpan>(listHolder_0->mList, 5);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListLongOctetString::Id,
                                  value);
        }
        case 133: {
            LogStep(133, "Read attribute LIST_LONG_OCTET_STRING (for chunked read)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListLongOctetString::Id);
        }
        case 134: {
            LogStep(134, "Read attribute EPOCH_US Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 135: {
            LogStep(135, "Write attribute EPOCH_US Max Value");
            uint64_t value;
            value = 18446744073709551615ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id, value);
        }
        case 136: {
            LogStep(136, "Read attribute EPOCH_US Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 137: {
            LogStep(137, "Write attribute EPOCH_US Min Value");
            uint64_t value;
            value = 0ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id, value);
        }
        case 138: {
            LogStep(138, "Read attribute EPOCH_US Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 139: {
            LogStep(139, "Read attribute EPOCH_S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 140: {
            LogStep(140, "Write attribute EPOCH_S Max Value");
            uint32_t value;
            value = 4294967295UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id, value);
        }
        case 141: {
            LogStep(141, "Read attribute EPOCH_S Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 142: {
            LogStep(142, "Write attribute EPOCH_S Min Value");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id, value);
        }
        case 143: {
            LogStep(143, "Read attribute EPOCH_S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 144: {
            LogStep(144, "Read attribute UNSUPPORTED");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Unsupported::Id);
        }
        case 145: {
            LogStep(145, "Writeattribute UNSUPPORTED");
            bool value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Unsupported::Id, value);
        }
        case 146: {
            LogStep(146, "Send Test Command to unsupported endpoint");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(200), TestCluster::Id, TestCluster::Commands::Test::Id, value);
        }
        case 147: {
            LogStep(147, "Send Test Command to unsupported cluster");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), TestCluster::Id, TestCluster::Commands::Test::Id, value);
        }
        case 148: {
            LogStep(148, "Read attribute vendor_id Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 149: {
            LogStep(149, "Write attribute vendor_id");
            chip::VendorId value;
            value = static_cast<chip::VendorId>(17);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id, value);
        }
        case 150: {
            LogStep(150, "Read attribute vendor_id");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 151: {
            LogStep(151, "Restore attribute vendor_id");
            chip::VendorId value;
            value = static_cast<chip::VendorId>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id, value);
        }
        case 152: {
            LogStep(152, "Send a command with a vendor_id and enum");
            chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type value;
            value.arg1 = static_cast<chip::VendorId>(20003);
            value.arg2 = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(101);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestEnumsRequest::Id, value);
        }
        case 153: {
            LogStep(153, "Send Test Command With Struct Argument and arg1.b is true");
            chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;
            value.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.g = 0.0f;
            value.arg1.h = 0;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestStructArgumentRequest::Id, value);
        }
        case 154: {
            LogStep(154, "Send Test Command With Struct Argument and arg1.b is false");
            chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = false;
            value.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.g = 0.0f;
            value.arg1.h = 0;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestStructArgumentRequest::Id, value);
        }
        case 155: {
            LogStep(155, "Send Test Command With Nested Struct Argument and arg1.c.b is true");
            chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;

            value.arg1.c.a = 0;
            value.arg1.c.b = true;
            value.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.c.g = 0.0f;
            value.arg1.c.h = 0;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNestedStructArgumentRequest::Id, value);
        }
        case 156: {
            LogStep(156, "Send Test Command With Nested Struct Argument arg1.c.b is false");
            chip::app::Clusters::TestCluster::Commands::TestNestedStructArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;

            value.arg1.c.a = 0;
            value.arg1.c.b = false;
            value.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.c.g = 0.0f;
            value.arg1.c.h = 0;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNestedStructArgumentRequest::Id, value);
        }
        case 157: {
            LogStep(157, "Send Test Command With Nested Struct List Argument and all fields b of arg1.d are true");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;

            value.arg1.c.a = 0;
            value.arg1.c.b = true;
            value.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.c.g = 0.0f;
            value.arg1.c.h = 0;

            {
                auto * listHolder_1 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_1);

                listHolder_1->mList[0].a = 1;
                listHolder_1->mList[0].b = true;
                listHolder_1->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_1->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_1->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_1->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_1->mList[0].g = 0.0f;
                listHolder_1->mList[0].h = 0;

                listHolder_1->mList[1].a = 2;
                listHolder_1->mList[1].b = true;
                listHolder_1->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_1->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_1->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_1->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_1->mList[1].g = 0.0f;
                listHolder_1->mList[1].h = 0;

                value.arg1.d = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                    listHolder_1->mList, 2);
            }

            {
                auto * listHolder_1 = new ListHolder<uint32_t>(3);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] = 1UL;
                listHolder_1->mList[1] = 2UL;
                listHolder_1->mList[2] = 3UL;
                value.arg1.e           = chip::app::DataModel::List<uint32_t>(listHolder_1->mList, 3);
            }

            {
                auto * listHolder_1 = new ListHolder<chip::ByteSpan>(3);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                listHolder_1->mList[1] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                listHolder_1->mList[2] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                value.arg1.f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_1->mList, 3);
            }

            {
                auto * listHolder_1 = new ListHolder<uint8_t>(2);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] = 0;
                listHolder_1->mList[1] = 255;
                value.arg1.g           = chip::app::DataModel::List<uint8_t>(listHolder_1->mList, 2);
            }

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNestedStructListArgumentRequest::Id, value);
        }
        case 158: {
            LogStep(158, "Send Test Command With Nested Struct List Argument and some fields b of arg1.d are false");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestNestedStructListArgumentRequest::Type value;

            value.arg1.a = 0;
            value.arg1.b = true;

            value.arg1.c.a = 0;
            value.arg1.c.b = true;
            value.arg1.c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.c.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.c.g = 0.0f;
            value.arg1.c.h = 0;

            {
                auto * listHolder_1 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_1);

                listHolder_1->mList[0].a = 1;
                listHolder_1->mList[0].b = true;
                listHolder_1->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_1->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_1->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_1->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_1->mList[0].g = 0.0f;
                listHolder_1->mList[0].h = 0;

                listHolder_1->mList[1].a = 2;
                listHolder_1->mList[1].b = false;
                listHolder_1->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_1->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_1->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                listHolder_1->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_1->mList[1].g = 0.0f;
                listHolder_1->mList[1].h = 0;

                value.arg1.d = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                    listHolder_1->mList, 2);
            }

            {
                auto * listHolder_1 = new ListHolder<uint32_t>(3);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] = 1UL;
                listHolder_1->mList[1] = 2UL;
                listHolder_1->mList[2] = 3UL;
                value.arg1.e           = chip::app::DataModel::List<uint32_t>(listHolder_1->mList, 3);
            }

            {
                auto * listHolder_1 = new ListHolder<chip::ByteSpan>(3);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                listHolder_1->mList[1] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                listHolder_1->mList[2] =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                value.arg1.f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_1->mList, 3);
            }

            {
                auto * listHolder_1 = new ListHolder<uint8_t>(2);
                listFreer.add(listHolder_1);
                listHolder_1->mList[0] = 0;
                listHolder_1->mList[1] = 255;
                value.arg1.g           = chip::app::DataModel::List<uint8_t>(listHolder_1->mList, 2);
            }

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNestedStructListArgumentRequest::Id, value);
        }
        case 159: {
            LogStep(159, "Send Test Command With Struct Argument and see what we get back");
            chip::app::Clusters::TestCluster::Commands::SimpleStructEchoRequest::Type value;

            value.arg1.a = 17;
            value.arg1.b = false;
            value.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
            value.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
            value.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
            value.arg1.g = 0.1f;
            value.arg1.h = 0.1;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::SimpleStructEchoRequest::Id,
                               value);
        }
        case 160: {
            LogStep(160, "Send Test Command With List of INT8U and none of them is set to 0");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(9);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1;
                listHolder_0->mList[1] = 2;
                listHolder_0->mList[2] = 3;
                listHolder_0->mList[3] = 4;
                listHolder_0->mList[4] = 5;
                listHolder_0->mList[5] = 6;
                listHolder_0->mList[6] = 7;
                listHolder_0->mList[7] = 8;
                listHolder_0->mList[8] = 9;
                value.arg1             = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 9);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListInt8UArgumentRequest::Id, value);
        }
        case 161: {
            LogStep(161, "Send Test Command With List of INT8U and one of them is set to 0");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(10);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1;
                listHolder_0->mList[1] = 2;
                listHolder_0->mList[2] = 3;
                listHolder_0->mList[3] = 4;
                listHolder_0->mList[4] = 5;
                listHolder_0->mList[5] = 6;
                listHolder_0->mList[6] = 7;
                listHolder_0->mList[7] = 8;
                listHolder_0->mList[8] = 9;
                listHolder_0->mList[9] = 0;
                value.arg1             = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 10);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListInt8UArgumentRequest::Id, value);
        }
        case 162: {
            LogStep(162, "Send Test Command With List of INT8U and get it reversed");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(9);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1;
                listHolder_0->mList[1] = 2;
                listHolder_0->mList[2] = 3;
                listHolder_0->mList[3] = 4;
                listHolder_0->mList[4] = 5;
                listHolder_0->mList[5] = 6;
                listHolder_0->mList[6] = 7;
                listHolder_0->mList[7] = 8;
                listHolder_0->mList[8] = 9;
                value.arg1             = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 9);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListInt8UReverseRequest::Id, value);
        }
        case 163: {
            LogStep(163, "Send Test Command With empty List of INT8U and get an empty list back");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type value;

            value.arg1 = chip::app::DataModel::List<uint8_t>();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListInt8UReverseRequest::Id, value);
        }
        case 164: {
            LogStep(164, "Send Test Command With List of Struct Argument and arg1.b of first item is true");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].a = 0;
                listHolder_0->mList[0].b = true;
                listHolder_0->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
                listHolder_0->mList[0].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
                listHolder_0->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[0].g = 0.0f;
                listHolder_0->mList[0].h = 0;

                listHolder_0->mList[1].a = 1;
                listHolder_0->mList[1].b = true;
                listHolder_0->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_0->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_0->mList[1].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
                listHolder_0->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[1].g = 0.0f;
                listHolder_0->mList[1].h = 0;

                value.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                    listHolder_0->mList, 2);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListStructArgumentRequest::Id, value);
        }
        case 165: {
            LogStep(165, "Send Test Command With List of Struct Argument and arg1.b of first item is false");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].a = 1;
                listHolder_0->mList[0].b = true;
                listHolder_0->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                listHolder_0->mList[0].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
                listHolder_0->mList[0].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
                listHolder_0->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[0].g = 0.0f;
                listHolder_0->mList[0].h = 0;

                listHolder_0->mList[1].a = 0;
                listHolder_0->mList[1].b = false;
                listHolder_0->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[1].d =
                    chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
                listHolder_0->mList[1].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
                listHolder_0->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[1].g = 0.0f;
                listHolder_0->mList[1].h = 0;

                value.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                    listHolder_0->mList, 2);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListStructArgumentRequest::Id, value);
        }
        case 166: {
            LogStep(166,
                    "Send Test Command With List of Nested Struct List Argument and all fields b of elements of arg1.d are true");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].a = 0;
                listHolder_0->mList[0].b = true;

                listHolder_0->mList[0].c.a = 0;
                listHolder_0->mList[0].c.b = true;
                listHolder_0->mList[0].c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[0].c.d =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
                listHolder_0->mList[0].c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
                listHolder_0->mList[0].c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[0].c.g = 0.0f;
                listHolder_0->mList[0].c.h = 0;

                {
                    auto * listHolder_2 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                    listFreer.add(listHolder_2);

                    listHolder_2->mList[0].a = 1;
                    listHolder_2->mList[0].b = true;
                    listHolder_2->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                    listHolder_2->mList[0].d =
                        chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                    listHolder_2->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                    listHolder_2->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                    listHolder_2->mList[0].g = 0.0f;
                    listHolder_2->mList[0].h = 0;

                    listHolder_2->mList[1].a = 2;
                    listHolder_2->mList[1].b = true;
                    listHolder_2->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                    listHolder_2->mList[1].d =
                        chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                    listHolder_2->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                    listHolder_2->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                    listHolder_2->mList[1].g = 0.0f;
                    listHolder_2->mList[1].h = 0;

                    listHolder_0->mList[0].d =
                        chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                            listHolder_2->mList, 2);
                }

                {
                    auto * listHolder_2 = new ListHolder<uint32_t>(3);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0]   = 1UL;
                    listHolder_2->mList[1]   = 2UL;
                    listHolder_2->mList[2]   = 3UL;
                    listHolder_0->mList[0].e = chip::app::DataModel::List<uint32_t>(listHolder_2->mList, 3);
                }

                {
                    auto * listHolder_2 = new ListHolder<chip::ByteSpan>(3);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                    listHolder_2->mList[1] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                    listHolder_2->mList[2] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                    listHolder_0->mList[0].f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_2->mList, 3);
                }

                {
                    auto * listHolder_2 = new ListHolder<uint8_t>(2);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0]   = 0;
                    listHolder_2->mList[1]   = 255;
                    listHolder_0->mList[0].g = chip::app::DataModel::List<uint8_t>(listHolder_2->mList, 2);
                }

                value.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(
                    listHolder_0->mList, 1);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListNestedStructListArgumentRequest::Id, value);
        }
        case 167: {
            LogStep(167, "Send Test Command With Nested Struct List Argument and some fields b of elements of arg1.d are false");
            ListFreer listFreer;
            chip::app::Clusters::TestCluster::Commands::TestListNestedStructListArgumentRequest::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].a = 0;
                listHolder_0->mList[0].b = true;

                listHolder_0->mList[0].c.a = 0;
                listHolder_0->mList[0].c.b = true;
                listHolder_0->mList[0].c.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                listHolder_0->mList[0].c.d =
                    chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
                listHolder_0->mList[0].c.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
                listHolder_0->mList[0].c.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                listHolder_0->mList[0].c.g = 0.0f;
                listHolder_0->mList[0].c.h = 0;

                {
                    auto * listHolder_2 = new ListHolder<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(2);
                    listFreer.add(listHolder_2);

                    listHolder_2->mList[0].a = 1;
                    listHolder_2->mList[0].b = true;
                    listHolder_2->mList[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                    listHolder_2->mList[0].d =
                        chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                    listHolder_2->mList[0].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                    listHolder_2->mList[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                    listHolder_2->mList[0].g = 0.0f;
                    listHolder_2->mList[0].h = 0;

                    listHolder_2->mList[1].a = 2;
                    listHolder_2->mList[1].b = false;
                    listHolder_2->mList[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
                    listHolder_2->mList[1].d =
                        chip::ByteSpan(chip::Uint8::from_const_char("nested_octet_stringgarbage: not in length on purpose"), 19);
                    listHolder_2->mList[1].e = chip::Span<const char>("nested_char_stringgarbage: not in length on purpose", 18);
                    listHolder_2->mList[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);
                    listHolder_2->mList[1].g = 0.0f;
                    listHolder_2->mList[1].h = 0;

                    listHolder_0->mList[0].d =
                        chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>(
                            listHolder_2->mList, 2);
                }

                {
                    auto * listHolder_2 = new ListHolder<uint32_t>(3);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0]   = 1UL;
                    listHolder_2->mList[1]   = 2UL;
                    listHolder_2->mList[2]   = 3UL;
                    listHolder_0->mList[0].e = chip::app::DataModel::List<uint32_t>(listHolder_2->mList, 3);
                }

                {
                    auto * listHolder_2 = new ListHolder<chip::ByteSpan>(3);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octet_string_1garbage: not in length on purpose"), 14);
                    listHolder_2->mList[1] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octect_string_2garbage: not in length on purpose"), 15);
                    listHolder_2->mList[2] =
                        chip::ByteSpan(chip::Uint8::from_const_char("octet_string_3garbage: not in length on purpose"), 14);
                    listHolder_0->mList[0].f = chip::app::DataModel::List<chip::ByteSpan>(listHolder_2->mList, 3);
                }

                {
                    auto * listHolder_2 = new ListHolder<uint8_t>(2);
                    listFreer.add(listHolder_2);
                    listHolder_2->mList[0]   = 0;
                    listHolder_2->mList[1]   = 255;
                    listHolder_0->mList[0].g = chip::app::DataModel::List<uint8_t>(listHolder_2->mList, 2);
                }

                value.arg1 = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NestedStructList::Type>(
                    listHolder_0->mList, 1);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestListNestedStructListArgumentRequest::Id, value);
        }
        case 168: {
            LogStep(168, "Write attribute LIST With List of INT8U and none of them is set to 0");
            ListFreer listFreer;
            chip::app::DataModel::List<const uint8_t> value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(4);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1;
                listHolder_0->mList[1] = 2;
                listHolder_0->mList[2] = 3;
                listHolder_0->mList[3] = 4;
                value                  = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id, value);
        }
        case 169: {
            LogStep(169, "Read attribute LIST With List of INT8U");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id);
        }
        case 170: {
            LogStep(170, "Write attribute LIST With List of OCTET_STRING");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::ByteSpan> value;

            {
                auto * listHolder_0 = new ListHolder<chip::ByteSpan>(4);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);
                listHolder_0->mList[1] = chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);
                listHolder_0->mList[2] = chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);
                listHolder_0->mList[3] = chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);
                value                  = chip::app::DataModel::List<chip::ByteSpan>(listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListOctetString::Id,
                                  value);
        }
        case 171: {
            LogStep(171, "Read attribute LIST With List of OCTET_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListOctetString::Id);
        }
        case 172: {
            LogStep(172, "Write attribute LIST With List of LIST_STRUCT_OCTET_STRING");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>(4);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].fabricIndex = 0ULL;
                listHolder_0->mList[0].operationalCert =
                    chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);

                listHolder_0->mList[1].fabricIndex = 1ULL;
                listHolder_0->mList[1].operationalCert =
                    chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);

                listHolder_0->mList[2].fabricIndex = 2ULL;
                listHolder_0->mList[2].operationalCert =
                    chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);

                listHolder_0->mList[3].fabricIndex = 3ULL;
                listHolder_0->mList[3].operationalCert =
                    chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);

                value = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>(
                    listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::ListStructOctetString::Id, value);
        }
        case 173: {
            LogStep(173, "Read attribute LIST With List of LIST_STRUCT_OCTET_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::ListStructOctetString::Id);
        }
        case 174: {
            LogStep(174, "Send Test Command with optional arg set.");
            chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type value;
            value.arg1.Emplace();
            value.arg1.Value().SetNonNull();
            value.arg1.Value().Value() = 5;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNullableOptionalRequest::Id, value);
        }
        case 175: {
            LogStep(175, "Send Test Command without its optional arg.");
            chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNullableOptionalRequest::Id, value);
        }
        case 176: {
            LogStep(176, "Read list of structs containing nullables and optionals");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::ListNullablesAndOptionalsStruct::Id);
        }
        case 177: {
            LogStep(177, "Write list of structs containing nullables and optionals");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type> value;

            {
                auto * listHolder_0 =
                    new ListHolder<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].nullableInt.SetNull();
                listHolder_0->mList[0].nullableString.SetNull();
                listHolder_0->mList[0].nullableStruct.SetNull();
                listHolder_0->mList[0].nullableList.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                    listFreer.add(listHolder_3);
                    listHolder_3->mList[0] = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(1);
                    listHolder_3->mList[1] = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
                    listHolder_0->mList[0].nullableList.Value() =
                        chip::app::DataModel::List<chip::app::Clusters::TestCluster::SimpleEnum>(listHolder_3->mList, 2);
                }

                value = chip::app::DataModel::List<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>(
                    listHolder_0->mList, 1);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::ListNullablesAndOptionalsStruct::Id, value);
        }
        case 178: {
            LogStep(178, "Read list of structs containing nullables and optionals after writing");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::ListNullablesAndOptionalsStruct::Id);
        }
        case 179: {
            LogStep(179, "Write attribute NULLABLE_BOOLEAN null");
            chip::app::DataModel::Nullable<bool> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBoolean::Id,
                                  value);
        }
        case 180: {
            LogStep(180, "Read attribute NULLABLE_BOOLEAN null");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBoolean::Id);
        }
        case 181: {
            LogStep(181, "Write attribute NULLABLE_BOOLEAN True");
            chip::app::DataModel::Nullable<bool> value;
            value.SetNonNull();
            value.Value() = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBoolean::Id,
                                  value);
        }
        case 182: {
            LogStep(182, "Read attribute NULLABLE_BOOLEAN True");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBoolean::Id);
        }
        case 183: {
            LogStep(183, "Write attribute NULLABLE_BITMAP8 Max Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>>(254);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id,
                                  value);
        }
        case 184: {
            LogStep(184, "Read attribute NULLABLE_BITMAP8 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id);
        }
        case 185: {
            LogStep(185, "Write attribute NULLABLE_BITMAP8 Invalid Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>>(255);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id,
                                  value);
        }
        case 186: {
            LogStep(186, "Read attribute NULLABLE_BITMAP8 unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id);
        }
        case 187: {
            LogStep(187, "Write attribute NULLABLE_BITMAP8 null Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id,
                                  value);
        }
        case 188: {
            LogStep(188, "Read attribute NULLABLE_BITMAP8 null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap8::Id);
        }
        case 189: {
            LogStep(189, "Write attribute NULLABLE_BITMAP16 Max Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>>(65534U);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id,
                                  value);
        }
        case 190: {
            LogStep(190, "Read attribute NULLABLE_BITMAP16 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id);
        }
        case 191: {
            LogStep(191, "Write attribute NULLABLE_BITMAP16 Invalid Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>>(65535U);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id,
                                  value);
        }
        case 192: {
            LogStep(192, "Read attribute NULLABLE_BITMAP16 unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id);
        }
        case 193: {
            LogStep(193, "Write attribute NULLABLE_BITMAP16 null Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id,
                                  value);
        }
        case 194: {
            LogStep(194, "Read attribute NULLABLE_BITMAP16 null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap16::Id);
        }
        case 195: {
            LogStep(195, "Write attribute NULLABLE_BITMAP32 Max Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>>(4294967294UL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id,
                                  value);
        }
        case 196: {
            LogStep(196, "Read attribute NULLABLE_BITMAP32 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id);
        }
        case 197: {
            LogStep(197, "Write attribute NULLABLE_BITMAP32 Invalid Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>>(4294967295UL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id,
                                  value);
        }
        case 198: {
            LogStep(198, "Read attribute NULLABLE_BITMAP32 unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id);
        }
        case 199: {
            LogStep(199, "Write attribute NULLABLE_BITMAP32 null Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id,
                                  value);
        }
        case 200: {
            LogStep(200, "Read attribute NULLABLE_BITMAP32 null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap32::Id);
        }
        case 201: {
            LogStep(201, "Write attribute NULLABLE_BITMAP64 Max Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>>(18446744073709551614ULL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id,
                                  value);
        }
        case 202: {
            LogStep(202, "Read attribute NULLABLE_BITMAP64 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id);
        }
        case 203: {
            LogStep(203, "Write attribute NULLABLE_BITMAP64 Invalid Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>>(18446744073709551615ULL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id,
                                  value);
        }
        case 204: {
            LogStep(204, "Read attribute NULLABLE_BITMAP64 unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id);
        }
        case 205: {
            LogStep(205, "Write attribute NULLABLE_BITMAP64 null Value");
            chip::app::DataModel::Nullable<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id,
                                  value);
        }
        case 206: {
            LogStep(206, "Read attribute NULLABLE_BITMAP64 null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableBitmap64::Id);
        }
        case 207: {
            LogStep(207, "Write attribute NULLABLE_INT8U Min Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 208: {
            LogStep(208, "Read attribute NULLABLE_INT8U Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 209: {
            LogStep(209, "Write attribute NULLABLE_INT8U Max Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 210: {
            LogStep(210, "Read attribute NULLABLE_INT8U Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 211: {
            LogStep(211, "Write attribute NULLABLE_INT8U Invalid Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 212: {
            LogStep(212, "Read attribute NULLABLE_INT8U unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 213: {
            LogStep(213, "Read attribute NULLABLE_INT8U unchanged Value with constraint");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 214: {
            LogStep(214, "Write attribute NULLABLE_INT8U null Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 215: {
            LogStep(215, "Read attribute NULLABLE_INT8U null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 216: {
            LogStep(216, "Read attribute NULLABLE_INT8U null Value & range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 217: {
            LogStep(217, "Read attribute NULLABLE_INT8U null Value & not");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 218: {
            LogStep(218, "Write attribute NULLABLE_INT8U Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id,
                                  value);
        }
        case 219: {
            LogStep(219, "Read attribute NULLABLE_INT8U Value in range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 220: {
            LogStep(220, "Read attribute NULLABLE_INT8U notValue OK");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8u::Id);
        }
        case 221: {
            LogStep(221, "Write attribute NULLABLE_INT16U Min Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 222: {
            LogStep(222, "Read attribute NULLABLE_INT16U Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 223: {
            LogStep(223, "Write attribute NULLABLE_INT16U Max Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65534U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 224: {
            LogStep(224, "Read attribute NULLABLE_INT16U Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 225: {
            LogStep(225, "Write attribute NULLABLE_INT16U Invalid Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 226: {
            LogStep(226, "Read attribute NULLABLE_INT16U unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 227: {
            LogStep(227, "Write attribute NULLABLE_INT16U null Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 228: {
            LogStep(228, "Read attribute NULLABLE_INT16U null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 229: {
            LogStep(229, "Read attribute NULLABLE_INT16U null Value & range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 230: {
            LogStep(230, "Read attribute NULLABLE_INT16U null Value & not");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 231: {
            LogStep(231, "Write attribute NULLABLE_INT16U Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 32000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id,
                                  value);
        }
        case 232: {
            LogStep(232, "Read attribute NULLABLE_INT16U Value in range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 233: {
            LogStep(233, "Read attribute NULLABLE_INT16U notValue OK");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16u::Id);
        }
        case 234: {
            LogStep(234, "Write attribute NULLABLE_INT32U Min Value");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 235: {
            LogStep(235, "Read attribute NULLABLE_INT32U Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 236: {
            LogStep(236, "Write attribute NULLABLE_INT32U Max Value");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 4294967294UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 237: {
            LogStep(237, "Read attribute NULLABLE_INT32U Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 238: {
            LogStep(238, "Write attribute NULLABLE_INT32U Invalid Value");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 4294967295UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 239: {
            LogStep(239, "Read attribute NULLABLE_INT32U unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 240: {
            LogStep(240, "Write attribute NULLABLE_INT32U null Value");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 241: {
            LogStep(241, "Read attribute NULLABLE_INT32U null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 242: {
            LogStep(242, "Read attribute NULLABLE_INT32U null Value & range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 243: {
            LogStep(243, "Read attribute NULLABLE_INT32U null Value & not");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 244: {
            LogStep(244, "Write attribute NULLABLE_INT32U Value");
            chip::app::DataModel::Nullable<uint32_t> value;
            value.SetNonNull();
            value.Value() = 2147483647UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id,
                                  value);
        }
        case 245: {
            LogStep(245, "Read attribute NULLABLE_INT32U Value in range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 246: {
            LogStep(246, "Read attribute NULLABLE_INT32U notValue OK");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32u::Id);
        }
        case 247: {
            LogStep(247, "Write attribute NULLABLE_INT64U Min Value");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 0ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 248: {
            LogStep(248, "Read attribute NULLABLE_INT64U Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 249: {
            LogStep(249, "Write attribute NULLABLE_INT64U Max Value");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 18446744073709551614ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 250: {
            LogStep(250, "Read attribute NULLABLE_INT64U Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 251: {
            LogStep(251, "Write attribute NULLABLE_INT64U Invalid Value");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 18446744073709551615ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 252: {
            LogStep(252, "Read attribute NULLABLE_INT64U unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 253: {
            LogStep(253, "Write attribute NULLABLE_INT64U null Value");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 254: {
            LogStep(254, "Read attribute NULLABLE_INT64U null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 255: {
            LogStep(255, "Read attribute NULLABLE_INT64U null Value & range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 256: {
            LogStep(256, "Read attribute NULLABLE_INT64U null Value & not");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 257: {
            LogStep(257, "Write attribute NULLABLE_INT64U Value");
            chip::app::DataModel::Nullable<uint64_t> value;
            value.SetNonNull();
            value.Value() = 18000000000000000000ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id,
                                  value);
        }
        case 258: {
            LogStep(258, "Read attribute NULLABLE_INT64U Value in range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 259: {
            LogStep(259, "Read attribute NULLABLE_INT64U notValue OK");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64u::Id);
        }
        case 260: {
            LogStep(260, "Write attribute NULLABLE_INT8S Min Value");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id,
                                  value);
        }
        case 261: {
            LogStep(261, "Read attribute NULLABLE_INT8S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 262: {
            LogStep(262, "Write attribute NULLABLE_INT8S Invalid Value");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id,
                                  value);
        }
        case 263: {
            LogStep(263, "Read attribute NULLABLE_INT8S unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 264: {
            LogStep(264, "Write attribute NULLABLE_INT8S null Value");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id,
                                  value);
        }
        case 265: {
            LogStep(265, "Read attribute NULLABLE_INT8S null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 266: {
            LogStep(266, "Read attribute NULLABLE_INT8S null Value & range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 267: {
            LogStep(267, "Read attribute NULLABLE_INT8S null Value & not");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 268: {
            LogStep(268, "Write attribute NULLABLE_INT8S Value");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id,
                                  value);
        }
        case 269: {
            LogStep(269, "Read attribute NULLABLE_INT8S Value in range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 270: {
            LogStep(270, "Read attribute NULLABLE_INT8S notValue OK");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt8s::Id);
        }
        case 271: {
            LogStep(271, "Write attribute NULLABLE_INT16S Min Value");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id,
                                  value);
        }
        case 272: {
            LogStep(272, "Read attribute NULLABLE_INT16S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 273: {
            LogStep(273, "Write attribute NULLABLE_INT16S Invalid Value");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -32768;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id,
                                  value);
        }
        case 274: {
            LogStep(274, "Read attribute NULLABLE_INT16S unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 275: {
            LogStep(275, "Write attribute NULLABLE_INT16S null Value");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id,
                                  value);
        }
        case 276: {
            LogStep(276, "Read attribute NULLABLE_INT16S null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 277: {
            LogStep(277, "Read attribute NULLABLE_INT16S null Value & range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 278: {
            LogStep(278, "Read attribute NULLABLE_INT16S null Value & not");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 279: {
            LogStep(279, "Write attribute NULLABLE_INT16S Value");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id,
                                  value);
        }
        case 280: {
            LogStep(280, "Read attribute NULLABLE_INT16S Value in range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 281: {
            LogStep(281, "Read attribute NULLABLE_INT16S notValue OK");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt16s::Id);
        }
        case 282: {
            LogStep(282, "Write attribute NULLABLE_INT32S Min Value");
            chip::app::DataModel::Nullable<int32_t> value;
            value.SetNonNull();
            value.Value() = -2147483647L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id,
                                  value);
        }
        case 283: {
            LogStep(283, "Read attribute NULLABLE_INT32S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 284: {
            LogStep(284, "Write attribute NULLABLE_INT32S Invalid Value");
            chip::app::DataModel::Nullable<int32_t> value;
            value.SetNonNull();
            value.Value() = -2147483648L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id,
                                  value);
        }
        case 285: {
            LogStep(285, "Read attribute NULLABLE_INT32S unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 286: {
            LogStep(286, "Write attribute NULLABLE_INT32S null Value");
            chip::app::DataModel::Nullable<int32_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id,
                                  value);
        }
        case 287: {
            LogStep(287, "Read attribute NULLABLE_INT32S null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 288: {
            LogStep(288, "Read attribute NULLABLE_INT32S null Value & range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 289: {
            LogStep(289, "Read attribute NULLABLE_INT32S null Value & not");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 290: {
            LogStep(290, "Write attribute NULLABLE_INT32S Value");
            chip::app::DataModel::Nullable<int32_t> value;
            value.SetNonNull();
            value.Value() = -2147483647L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id,
                                  value);
        }
        case 291: {
            LogStep(291, "Read attribute NULLABLE_INT32S Value in range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 292: {
            LogStep(292, "Read attribute NULLABLE_INT32S notValue OK");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt32s::Id);
        }
        case 293: {
            LogStep(293, "Write attribute NULLABLE_INT64S Min Value");
            chip::app::DataModel::Nullable<int64_t> value;
            value.SetNonNull();
            value.Value() = -9223372036854775807LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id,
                                  value);
        }
        case 294: {
            LogStep(294, "Read attribute NULLABLE_INT64S Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 295: {
            LogStep(295, "Write attribute NULLABLE_INT64S Invalid Value");
            chip::app::DataModel::Nullable<int64_t> value;
            value.SetNonNull();
            value.Value() = -9223372036854775807LL - 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id,
                                  value);
        }
        case 296: {
            LogStep(296, "Read attribute NULLABLE_INT64S unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 297: {
            LogStep(297, "Write attribute NULLABLE_INT64S null Value");
            chip::app::DataModel::Nullable<int64_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id,
                                  value);
        }
        case 298: {
            LogStep(298, "Read attribute NULLABLE_INT64S null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 299: {
            LogStep(299, "Read attribute NULLABLE_INT64S null Value & range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 300: {
            LogStep(300, "Read attribute NULLABLE_INT64S null Value & not");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 301: {
            LogStep(301, "Write attribute NULLABLE_INT64S Value");
            chip::app::DataModel::Nullable<int64_t> value;
            value.SetNonNull();
            value.Value() = -9223372036854775807LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id,
                                  value);
        }
        case 302: {
            LogStep(302, "Read attribute NULLABLE_INT64S Value in range");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 303: {
            LogStep(303, "Read attribute NULLABLE_INT64S notValue OK");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableInt64s::Id);
        }
        case 304: {
            LogStep(304, "Write attribute NULLABLE_SINGLE medium Value");
            chip::app::DataModel::Nullable<float> value;
            value.SetNonNull();
            value.Value() = 0.1f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 305: {
            LogStep(305, "Read attribute NULLABLE_SINGLE medium Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 306: {
            LogStep(306, "Write attribute NULLABLE_SINGLE largest Value");
            chip::app::DataModel::Nullable<float> value;
            value.SetNonNull();
            value.Value() = INFINITY;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 307: {
            LogStep(307, "Read attribute NULLABLE_SINGLE largest Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 308: {
            LogStep(308, "Write attribute NULLABLE_SINGLE smallest Value");
            chip::app::DataModel::Nullable<float> value;
            value.SetNonNull();
            value.Value() = -INFINITY;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 309: {
            LogStep(309, "Read attribute NULLABLE_SINGLE smallest Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 310: {
            LogStep(310, "Write attribute NULLABLE_SINGLE null Value");
            chip::app::DataModel::Nullable<float> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 311: {
            LogStep(311, "Read attribute NULLABLE_SINGLE null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 312: {
            LogStep(312, "Write attribute NULLABLE_SINGLE 0 Value");
            chip::app::DataModel::Nullable<float> value;
            value.SetNonNull();
            value.Value() = 0.0f;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id,
                                  value);
        }
        case 313: {
            LogStep(313, "Read attribute NULLABLE_SINGLE 0 Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatSingle::Id);
        }
        case 314: {
            LogStep(314, "Write attribute NULLABLE_DOUBLE medium Value");
            chip::app::DataModel::Nullable<double> value;
            value.SetNonNull();
            value.Value() = 0.1234567890123;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 315: {
            LogStep(315, "Read attribute NULLABLE_DOUBLE medium Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 316: {
            LogStep(316, "Write attribute NULLABLE_DOUBLE largest Value");
            chip::app::DataModel::Nullable<double> value;
            value.SetNonNull();
            value.Value() = INFINITY;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 317: {
            LogStep(317, "Read attribute NULLABLE_DOUBLE largest Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 318: {
            LogStep(318, "Write attribute NULLABLE_DOUBLE smallest Value");
            chip::app::DataModel::Nullable<double> value;
            value.SetNonNull();
            value.Value() = -INFINITY;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 319: {
            LogStep(319, "Read attribute NULLABLE_DOUBLE smallest Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 320: {
            LogStep(320, "Write attribute NULLABLE_DOUBLE null Value");
            chip::app::DataModel::Nullable<double> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 321: {
            LogStep(321, "Read attribute NULLABLE_DOUBLE null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 322: {
            LogStep(322, "Write attribute NULLABLE_DOUBLE 0 Value");
            chip::app::DataModel::Nullable<double> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id,
                                  value);
        }
        case 323: {
            LogStep(323, "Read attribute NULLABLE_DOUBLE 0 Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableFloatDouble::Id);
        }
        case 324: {
            LogStep(324, "Write attribute NULLABLE_ENUM8 Min Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id,
                                  value);
        }
        case 325: {
            LogStep(325, "Read attribute NULLABLE_ENUM8 Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id);
        }
        case 326: {
            LogStep(326, "Write attribute NULLABLE_ENUM8 Max Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id,
                                  value);
        }
        case 327: {
            LogStep(327, "Read attribute NULLABLE_ENUM8 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id);
        }
        case 328: {
            LogStep(328, "Write attribute NULLABLE_ENUM8 Invalid Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id,
                                  value);
        }
        case 329: {
            LogStep(329, "Read attribute NULLABLE_ENUM8 unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id);
        }
        case 330: {
            LogStep(330, "Write attribute NULLABLE_ENUM8 null Value");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id,
                                  value);
        }
        case 331: {
            LogStep(331, "Read attribute NULLABLE_ENUM8 null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum8::Id);
        }
        case 332: {
            LogStep(332, "Write attribute NULLABLE_ENUM16 Min Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id,
                                  value);
        }
        case 333: {
            LogStep(333, "Read attribute NULLABLE_ENUM16 Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id);
        }
        case 334: {
            LogStep(334, "Write attribute NULLABLE_ENUM16 Max Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65534U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id,
                                  value);
        }
        case 335: {
            LogStep(335, "Read attribute NULLABLE_ENUM16 Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id);
        }
        case 336: {
            LogStep(336, "Write attribute NULLABLE_ENUM16 Invalid Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id,
                                  value);
        }
        case 337: {
            LogStep(337, "Read attribute NULLABLE_ENUM16 unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id);
        }
        case 338: {
            LogStep(338, "Write attribute NULLABLE_ENUM16 null Value");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id,
                                  value);
        }
        case 339: {
            LogStep(339, "Read attribute NULLABLE_ENUM16 null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnum16::Id);
        }
        case 340: {
            LogStep(340, "Write attribute NULLABLE_SIMPLE_ENUM Min Value");
            chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id,
                                  value);
        }
        case 341: {
            LogStep(341, "Read attribute NULLABLE_SIMPLE_ENUM Min Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id);
        }
        case 342: {
            LogStep(342, "Write attribute NULLABLE_SIMPLE_ENUM Max Value");
            chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(254);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id,
                                  value);
        }
        case 343: {
            LogStep(343, "Read attribute NULLABLE_SIMPLE_ENUM Max Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id);
        }
        case 344: {
            LogStep(344, "Write attribute NULLABLE_SIMPLE_ENUM Invalid Value");
            chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(255);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id,
                                  value);
        }
        case 345: {
            LogStep(345, "Read attribute NULLABLE_SIMPLE_ENUM unchanged Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id);
        }
        case 346: {
            LogStep(346, "Write attribute NULLABLE_SIMPLE_ENUM null Value");
            chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id,
                                  value);
        }
        case 347: {
            LogStep(347, "Read attribute NULLABLE_SIMPLE_ENUM null Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableEnumAttr::Id);
        }
        case 348: {
            LogStep(348, "Read attribute NULLABLE_OCTET_STRING Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id);
        }
        case 349: {
            LogStep(349, "Write attribute NULLABLE_OCTET_STRING");
            chip::app::DataModel::Nullable<chip::ByteSpan> value;
            value.SetNonNull();
            value.Value() = chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id,
                                  value);
        }
        case 350: {
            LogStep(350, "Read attribute NULLABLE_OCTET_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id);
        }
        case 351: {
            LogStep(351, "Write attribute NULLABLE_OCTET_STRING");
            chip::app::DataModel::Nullable<chip::ByteSpan> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id,
                                  value);
        }
        case 352: {
            LogStep(352, "Read attribute NULLABLE_OCTET_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id);
        }
        case 353: {
            LogStep(353, "Write attribute NULLABLE_OCTET_STRING");
            chip::app::DataModel::Nullable<chip::ByteSpan> value;
            value.SetNonNull();
            value.Value() = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id,
                                  value);
        }
        case 354: {
            LogStep(354, "Read attribute NULLABLE_OCTET_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableOctetString::Id);
        }
        case 355: {
            LogStep(355, "Read attribute NULLABLE_CHAR_STRING Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id);
        }
        case 356: {
            LogStep(356, "Write attribute NULLABLE_CHAR_STRING");
            chip::app::DataModel::Nullable<chip::CharSpan> value;
            value.SetNonNull();
            value.Value() = chip::Span<const char>("Tgarbage: not in length on purpose", 7);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id,
                                  value);
        }
        case 357: {
            LogStep(357, "Read attribute NULLABLE_CHAR_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id);
        }
        case 358: {
            LogStep(358, "Write attribute NULLABLE_CHAR_STRING - Value too long");
            chip::app::DataModel::Nullable<chip::CharSpan> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id,
                                  value);
        }
        case 359: {
            LogStep(359, "Read attribute NULLABLE_CHAR_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id);
        }
        case 360: {
            LogStep(360, "Write attribute NULLABLE_CHAR_STRING - Empty");
            chip::app::DataModel::Nullable<chip::CharSpan> value;
            value.SetNonNull();
            value.Value() = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id,
                                  value);
        }
        case 361: {
            LogStep(361, "Read attribute NULLABLE_CHAR_STRING");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::NullableCharString::Id);
        }
        case 362: {
            LogStep(362, "Read attribute from nonexistent endpoint.");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(200), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id);
        }
        case 363: {
            LogStep(363, "Read attribute from nonexistent cluster.");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id);
        }
        case 364: {
            LogStep(364, "Send a command that takes an optional parameter but do not set it.");
            chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestSimpleOptionalArgumentRequest::Id, value);
        }
        case 365: {
            LogStep(365, "Send a command that takes an optional parameter but do not set it.");
            chip::app::Clusters::TestCluster::Commands::TestSimpleOptionalArgumentRequest::Type value;
            value.arg1.Emplace();
            value.arg1.Value() = 1;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestSimpleOptionalArgumentRequest::Id, value);
        }
        case 366: {
            LogStep(366, "Subscribe to list attribute");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id, 2,
                                      5);
        }
        case 367: {
            LogStep(367, "Write subscribed-to list attribute");
            ListFreer listFreer;
            chip::app::DataModel::List<const uint8_t> value;

            {
                auto * listHolder_0 = new ListHolder<uint8_t>(4);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 5;
                listHolder_0->mList[1] = 6;
                listHolder_0->mList[2] = 7;
                listHolder_0->mList[3] = 8;
                value                  = chip::app::DataModel::List<uint8_t>(listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ListInt8u::Id, value);
        }
        case 368: {
            LogStep(368, "Check for list attribute report");
            return WaitForReport();
        }
        case 369: {
            LogStep(369, "Read range-restricted unsigned 8-bit integer");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 370: {
            LogStep(370, "Write min value to a range-restricted unsigned 8-bit integer");
            uint8_t value;
            value = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 371: {
            LogStep(371, "Write just-below-range value to a range-restricted unsigned 8-bit integer");
            uint8_t value;
            value = 19;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 372: {
            LogStep(372, "Write just-above-range value to a range-restricted unsigned 8-bit integer");
            uint8_t value;
            value = 101;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 373: {
            LogStep(373, "Write max value to a range-restricted unsigned 8-bit integer");
            uint8_t value;
            value = 255;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 374: {
            LogStep(374, "Verify range-restricted unsigned 8-bit integer value has not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 375: {
            LogStep(375, "Write min valid value to a range-restricted unsigned 8-bit integer");
            uint8_t value;
            value = 20;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 376: {
            LogStep(376, "Verify range-restricted unsigned 8-bit integer value is at min valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 377: {
            LogStep(377, "Write max valid value to a range-restricted unsigned 8-bit integer");
            uint8_t value;
            value = 100;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 378: {
            LogStep(378, "Verify range-restricted unsigned 8-bit integer value is at max valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 379: {
            LogStep(379, "Write middle valid value to a range-restricted unsigned 8-bit integer");
            uint8_t value;
            value = 50;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8u::Id, value);
        }
        case 380: {
            LogStep(380, "Verify range-restricted unsigned 8-bit integer value is at mid valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8u::Id);
        }
        case 381: {
            LogStep(381, "Read range-restricted unsigned 16-bit integer");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 382: {
            LogStep(382, "Write min value to a range-restricted unsigned 16-bit integer");
            uint16_t value;
            value = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 383: {
            LogStep(383, "Write just-below-range value to a range-restricted unsigned 16-bit integer");
            uint16_t value;
            value = 99U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 384: {
            LogStep(384, "Write just-above-range value to a range-restricted unsigned 16-bit integer");
            uint16_t value;
            value = 1001U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 385: {
            LogStep(385, "Write max value to a range-restricted unsigned 16-bit integer");
            uint16_t value;
            value = 65535U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 386: {
            LogStep(386, "Verify range-restricted unsigned 16-bit integer value has not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 387: {
            LogStep(387, "Write min valid value to a range-restricted unsigned 16-bit integer");
            uint16_t value;
            value = 100U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 388: {
            LogStep(388, "Verify range-restricted unsigned 16-bit integer value is at min valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 389: {
            LogStep(389, "Write max valid value to a range-restricted unsigned 16-bit integer");
            uint16_t value;
            value = 1000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 390: {
            LogStep(390, "Verify range-restricted unsigned 16-bit integer value is at max valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 391: {
            LogStep(391, "Write middle valid value to a range-restricted unsigned 16-bit integer");
            uint16_t value;
            value = 500U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16u::Id, value);
        }
        case 392: {
            LogStep(392, "Verify range-restricted unsigned 16-bit integer value is at mid valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16u::Id);
        }
        case 393: {
            LogStep(393, "Read range-restricted signed 8-bit integer");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 394: {
            LogStep(394, "Write min value to a range-restricted signed 8-bit integer");
            int8_t value;
            value = -128;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 395: {
            LogStep(395, "Write just-below-range value to a range-restricted signed 8-bit integer");
            int8_t value;
            value = -41;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 396: {
            LogStep(396, "Write just-above-range value to a range-restricted signed 8-bit integer");
            int8_t value;
            value = 51;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 397: {
            LogStep(397, "Write max value to a range-restricted signed 8-bit integer");
            int8_t value;
            value = 127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 398: {
            LogStep(398, "Verify range-restricted signed 8-bit integer value has not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 399: {
            LogStep(399, "Write min valid value to a range-restricted signed 8-bit integer");
            int8_t value;
            value = -40;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 400: {
            LogStep(400, "Verify range-restricted signed 8-bit integer value is at min valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 401: {
            LogStep(401, "Write max valid value to a range-restricted signed 8-bit integer");
            int8_t value;
            value = 50;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 402: {
            LogStep(402, "Verify range-restricted signed 8-bit integer value is at max valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 403: {
            LogStep(403, "Write middle valid value to a range-restricted signed 8-bit integer");
            int8_t value;
            value = 6;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt8s::Id, value);
        }
        case 404: {
            LogStep(404, "Verify range-restricted signed 8-bit integer value is at mid valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt8s::Id);
        }
        case 405: {
            LogStep(405, "Read range-restricted signed 16-bit integer");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 406: {
            LogStep(406, "Write min value to a range-restricted signed 16-bit integer");
            int16_t value;
            value = -32768;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 407: {
            LogStep(407, "Write just-below-range value to a range-restricted signed 16-bit integer");
            int16_t value;
            value = -151;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 408: {
            LogStep(408, "Write just-above-range value to a range-restricted signed 16-bit integer");
            int16_t value;
            value = 201;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 409: {
            LogStep(409, "Write max value to a range-restricted signed 16-bit integer");
            int16_t value;
            value = 32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 410: {
            LogStep(410, "Verify range-restricted signed 16-bit integer value has not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 411: {
            LogStep(411, "Write min valid value to a range-restricted signed 16-bit integer");
            int16_t value;
            value = -150;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 412: {
            LogStep(412, "Verify range-restricted signed 16-bit integer value is at min valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 413: {
            LogStep(413, "Write max valid value to a range-restricted signed 16-bit integer");
            int16_t value;
            value = 200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 414: {
            LogStep(414, "Verify range-restricted signed 16-bit integer value is at max valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 415: {
            LogStep(415, "Write middle valid value to a range-restricted signed 16-bit integer");
            int16_t value;
            value = 7;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::RangeRestrictedInt16s::Id, value);
        }
        case 416: {
            LogStep(416, "Verify range-restricted signed 16-bit integer value is at mid valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::RangeRestrictedInt16s::Id);
        }
        case 417: {
            LogStep(417, "Read nullable range-restricted unsigned 8-bit integer");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 418: {
            LogStep(418, "Write min value to a nullable range-restricted unsigned 8-bit integer");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 0;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 419: {
            LogStep(419, "Write just-below-range value to a nullable range-restricted unsigned 8-bit integer");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 19;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 420: {
            LogStep(420, "Write just-above-range value to a nullable range-restricted unsigned 8-bit integer");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 101;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 421: {
            LogStep(421, "Write max value to a nullable range-restricted unsigned 8-bit integer");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 254;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 422: {
            LogStep(422, "Verify nullable range-restricted unsigned 8-bit integer value has not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 423: {
            LogStep(423, "Write min valid value to a nullable range-restricted unsigned 8-bit integer");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 20;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 424: {
            LogStep(424, "Verify nullable range-restricted unsigned 8-bit integer value is at min valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 425: {
            LogStep(425, "Write max valid value to a nullable range-restricted unsigned 8-bit integer");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 100;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 426: {
            LogStep(426, "Verify nullable range-restricted unsigned 8-bit integer value is at max valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 427: {
            LogStep(427, "Write middle valid value to a nullable range-restricted unsigned 8-bit integer");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 50;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 428: {
            LogStep(428, "Verify nullable range-restricted unsigned 8-bit integer value is at mid valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 429: {
            LogStep(429, "Write null value to a nullable range-restricted unsigned 8-bit integer");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8u::Id, value);
        }
        case 430: {
            LogStep(430, "Verify nullable range-restricted unsigned 8-bit integer value is null");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8u::Id);
        }
        case 431: {
            LogStep(431, "Read nullable range-restricted unsigned 16-bit integer");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 432: {
            LogStep(432, "Write min value to a nullable range-restricted unsigned 16-bit integer");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 0U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 433: {
            LogStep(433, "Write just-below-range value to a nullable range-restricted unsigned 16-bit integer");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 99U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 434: {
            LogStep(434, "Write just-above-range value to a nullable range-restricted unsigned 16-bit integer");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 1001U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 435: {
            LogStep(435, "Write max value to a nullable range-restricted unsigned 16-bit integer");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 65534U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 436: {
            LogStep(436, "Verify nullable range-restricted unsigned 16-bit integer value has not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 437: {
            LogStep(437, "Write min valid value to a nullable range-restricted unsigned 16-bit integer");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 100U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 438: {
            LogStep(438, "Verify nullable range-restricted unsigned 16-bit integer value is at min valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 439: {
            LogStep(439, "Write max valid value to a nullable range-restricted unsigned 16-bit integer");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 1000U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 440: {
            LogStep(440, "Verify nullable range-restricted unsigned 16-bit integer value is at max valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 441: {
            LogStep(441, "Write middle valid value to a nullable range-restricted unsigned 16-bit integer");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNonNull();
            value.Value() = 500U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 442: {
            LogStep(442, "Verify nullable range-restricted unsigned 16-bit integer value is at mid valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 443: {
            LogStep(443, "Write null value to a nullable range-restricted unsigned 16-bit integer");
            chip::app::DataModel::Nullable<uint16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16u::Id, value);
        }
        case 444: {
            LogStep(444, "Verify nullable range-restricted unsigned 16-bit integer value is null");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16u::Id);
        }
        case 445: {
            LogStep(445, "Read nullable range-restricted signed 8-bit integer");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 446: {
            LogStep(446, "Write min value to a nullable range-restricted signed 8-bit integer");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 447: {
            LogStep(447, "Write just-below-range value to a nullable range-restricted signed 8-bit integer");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -41;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 448: {
            LogStep(448, "Write just-above-range value to a nullable range-restricted signed 8-bit integer");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = 51;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 449: {
            LogStep(449, "Write max value to a nullable range-restricted signed 8-bit integer");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = 127;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 450: {
            LogStep(450, "Verify nullable range-restricted signed 8-bit integer value has not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 451: {
            LogStep(451, "Write min valid value to a nullable range-restricted signed 8-bit integer");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = -40;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 452: {
            LogStep(452, "Verify nullable range-restricted signed 8-bit integer value is at min valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 453: {
            LogStep(453, "Write max valid value to a nullable range-restricted signed 8-bit integer");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = 50;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 454: {
            LogStep(454, "Verify nullable range-restricted signed 8-bit integer value is at max valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 455: {
            LogStep(455, "Write middle valid value to a nullable range-restricted signed 8-bit integer");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNonNull();
            value.Value() = 6;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 456: {
            LogStep(456, "Verify nullable range-restricted signed 8-bit integer value is at mid valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 457: {
            LogStep(457, "Write null value to a nullable range-restricted signed 8-bit integer");
            chip::app::DataModel::Nullable<int8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt8s::Id, value);
        }
        case 458: {
            LogStep(458, "Verify nullable range-restricted signed 8-bit integer value is at null");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt8s::Id);
        }
        case 459: {
            LogStep(459, "Read nullable range-restricted signed 16-bit integer");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 460: {
            LogStep(460, "Write min value to a nullable range-restricted signed 16-bit integer");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 461: {
            LogStep(461, "Write just-below-range value to a nullable range-restricted signed 16-bit integer");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -151;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 462: {
            LogStep(462, "Write just-above-range value to a nullable range-restricted signed 16-bit integer");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 201;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 463: {
            LogStep(463, "Write max value to a nullable range-restricted signed 16-bit integer");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 32767;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 464: {
            LogStep(464, "Verify nullable range-restricted signed 16-bit integer value has not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 465: {
            LogStep(465, "Write min valid value to a nullable range-restricted signed 16-bit integer");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = -150;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 466: {
            LogStep(466, "Verify nullable range-restricted signed 16-bit integer value is at min valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 467: {
            LogStep(467, "Write max valid value to a nullable range-restricted signed 16-bit integer");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 200;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 468: {
            LogStep(468, "Verify nullable range-restricted signed 16-bit integer value is at max valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 469: {
            LogStep(469, "Write middle valid value to a nullable range-restricted signed 16-bit integer");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNonNull();
            value.Value() = 7;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 470: {
            LogStep(470, "Verify nullable range-restricted signed 16-bit integer value is at mid valid");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 471: {
            LogStep(471, "Write null value to a nullable range-restricted signed 16-bit integer");
            chip::app::DataModel::Nullable<int16_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                  TestCluster::Attributes::NullableRangeRestrictedInt16s::Id, value);
        }
        case 472: {
            LogStep(472, "Verify nullable range-restricted signed 16-bit integer value is null");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::NullableRangeRestrictedInt16s::Id);
        }
        case 473: {
            LogStep(473, "Write attribute that returns general status on write");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::GeneralErrorBoolean::Id,
                                  value);
        }
        case 474: {
            LogStep(474, "Write attribute that returns cluster-specific status on write");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ClusterErrorBoolean::Id,
                                  value);
        }
        case 475: {
            LogStep(475, "Read attribute that returns general status on read");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::GeneralErrorBoolean::Id);
        }
        case 476: {
            LogStep(476, "read attribute that returns cluster-specific status on read");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::ClusterErrorBoolean::Id);
        }
        case 477: {
            LogStep(477, "read AcceptedCommandList attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::AcceptedCommandList::Id);
        }
        case 478: {
            LogStep(478, "read GeneratedCommandList attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                 TestCluster::Attributes::GeneratedCommandList::Id);
        }
        case 479: {
            LogStep(479, "Write struct-typed attribute");
            chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type value;

            value.a = 5;
            value.b = true;
            value.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.d = chip::ByteSpan(chip::Uint8::from_const_char("abcgarbage: not in length on purpose"), 3);
            value.e = chip::Span<const char>("garbage: not in length on purpose", 0);
            value.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(17);
            value.g = 1.5f;
            value.h = 3.14159265358979;

            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::StructAttr::Id, value);
        }
        case 480: {
            LogStep(480, "Read struct-typed attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::StructAttr::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestClusterComplexTypesSuite : public TestCommand
{
public:
    TestClusterComplexTypesSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestClusterComplexTypes", 21, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestClusterComplexTypesSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("wasPresent", value.wasPresent, true));

                VerifyOrReturn(CheckValuePresent("wasNull", value.wasNull));
                VerifyOrReturn(CheckValue("wasNull.Value()", value.wasNull.Value(), true));

                VerifyOrReturn(CheckValuePresent("originalValue", value.originalValue));
                VerifyOrReturn(CheckValueNull("originalValue.Value()", value.originalValue.Value()));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NEEDS_TIMED_INTERACTION));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("timedWriteBoolean", value, false));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NEEDS_TIMED_INTERACTION));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("timedWriteBoolean", value, false));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("timedWriteBoolean", value, false));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("timedWriteBoolean", value, true));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, false));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_UNSUPPORTED_ACCESS));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, false));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, true));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Send Test Command with optional arg set to null.");
            chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type value;
            value.arg1.Emplace();
            value.arg1.Value().SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                               TestCluster::Commands::TestNullableOptionalRequest::Id, value);
        }
        case 2: {
            LogStep(2, "Send command that needs timed invoke without a timeout value");
            chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TimedInvokeRequest::Id,
                               value, chip::NullOptional);
        }
        case 3: {
            LogStep(3, "Send command that needs timed invoke with a long timeout value");
            chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TimedInvokeRequest::Id,
                               value, chip::Optional<uint16_t>(10000));
        }
        case 4: {
            LogStep(4, "Send command that needs timed invoke with a too-short timeout value");
            chip::app::Clusters::TestCluster::Commands::TimedInvokeRequest::Type value;
            ReturnErrorOnFailure(SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                             TestCluster::Commands::TimedInvokeRequest::Id, value, chip::Optional<uint16_t>(1)));

            using namespace chip::System::Clock::Literals;
            return BusyWaitFor(100_ms);
        }
        case 5: {
            LogStep(5, "Send command that does not need timed invoke with a long timeout value");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::Test::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 6: {
            LogStep(6, "Send command that does not need timed invoke with a too-short timeout value");
            chip::app::Clusters::TestCluster::Commands::Test::Type value;
            ReturnErrorOnFailure(SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::Test::Id,
                                             value, chip::Optional<uint16_t>(1)));

            using namespace chip::System::Clock::Literals;
            return BusyWaitFor(100_ms);
        }
        case 7: {
            LogStep(7, "Read attribute that needs timed write initial state");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id);
        }
        case 8: {
            LogStep(8, "Write attribute that needs timed write without a timeout value");
            bool value;
            value = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id,
                                  value, chip::NullOptional);
        }
        case 9: {
            LogStep(9, "Read attribute that needs timed write state unchanged 1");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id);
        }
        case 10: {
            LogStep(10, "Write attribute that needs timed write with a too-short timeout value");
            bool value;
            value = true;
            ReturnErrorOnFailure(WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                                TestCluster::Attributes::TimedWriteBoolean::Id, value,
                                                chip::Optional<uint16_t>(1)));

            using namespace chip::System::Clock::Literals;
            return BusyWaitFor(100_ms);
        }
        case 11: {
            LogStep(11, "Read attribute that needs timed write state unchanged 2");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id);
        }
        case 12: {
            LogStep(12, "Write attribute that needs timed write with a long timeout value");
            bool value;
            value = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id,
                                  value, chip::Optional<uint16_t>(10000));
        }
        case 13: {
            LogStep(13, "Read attribute that needs timed write state changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id);
        }
        case 14: {
            LogStep(14, "Write attribute that needs timed write reset to default");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::TimedWriteBoolean::Id,
                                  value, chip::Optional<uint16_t>(10000));
        }
        case 15: {
            LogStep(15, "Read attribute that does not need timed write initial value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 16: {
            LogStep(16, "Write attribute that does not need timed write with a too-short timeout value");
            bool value;
            value = true;
            ReturnErrorOnFailure(WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id,
                                                TestCluster::Attributes::Boolean::Id, value, chip::Optional<uint16_t>(1)));

            using namespace chip::System::Clock::Literals;
            return BusyWaitFor(100_ms);
        }
        case 17: {
            LogStep(17, "Read attribute that does not need timed write unchanged value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 18: {
            LogStep(18, "Write attribute that does not need timed write with a long timeout value");
            bool value;
            value = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value,
                                  chip::Optional<uint16_t>(10000));
        }
        case 19: {
            LogStep(19, "Read attribute that does not need timed write changed value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 20: {
            LogStep(20, "Write attribute that does not need timed write reset to default");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestConstraintsSuite : public TestCommand
{
public:
    TestConstraintsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestConstraints", 22, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestConstraintsSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 5UL));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMaxValue("value", value, 5UL));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, 6UL));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinLength("value", value.size(), 5));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMaxLength("value", value.size(), 20));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintStartsWith("value", value, "**"));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintEndsWith("value", value, "**"));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsUpperCase("value", value, false));
                VerifyOrReturn(CheckConstraintIsLowerCase("value", value, true));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsUpperCase("value", value, true));
                VerifyOrReturn(CheckConstraintIsLowerCase("value", value, false));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsUpperCase("value", value, false));
                VerifyOrReturn(CheckConstraintIsLowerCase("value", value, false));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsHexString("value", value, false));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintIsHexString("value", value, true));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Write attribute INT32U Value");
            uint32_t value;
            value = 5UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 2: {
            LogStep(2, "Read attribute INT32U Value MinValue Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 3: {
            LogStep(3, "Read attribute INT32U Value MaxValue Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 4: {
            LogStep(4, "Read attribute INT32U Value NotValue Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 5: {
            LogStep(5, "Write attribute INT32U Value Back to Default Value");
            uint32_t value;
            value = 0UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 6: {
            LogStep(6, "Write attribute CHAR_STRING Value");
            chip::CharSpan value;
            value = chip::Span<const char>("** Test **garbage: not in length on purpose", 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 7: {
            LogStep(7, "Read attribute CHAR_STRING Value MinLength Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 8: {
            LogStep(8, "Read attribute CHAR_STRING Value MaxLength Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 9: {
            LogStep(9, "Read attribute CHAR_STRING Value StartsWith Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 10: {
            LogStep(10, "Read attribute CHAR_STRING Value EndsWith Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 11: {
            LogStep(11, "Write attribute CHAR_STRING Value");
            chip::CharSpan value;
            value = chip::Span<const char>("lowercasegarbage: not in length on purpose", 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 12: {
            LogStep(12, "Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 13: {
            LogStep(13, "Write attribute CHAR_STRING Value");
            chip::CharSpan value;
            value = chip::Span<const char>("UPPERCASEgarbage: not in length on purpose", 9);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 14: {
            LogStep(14, "Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 15: {
            LogStep(15, "Write attribute CHAR_STRING Value");
            chip::CharSpan value;
            value = chip::Span<const char>("lowUPPERgarbage: not in length on purpose", 8);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 16: {
            LogStep(16, "Read attribute CHAR_STRING Value isLowerCase/isUpperCase Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 17: {
            LogStep(17, "Write attribute CHAR_STRING Value");
            chip::CharSpan value;
            value = chip::Span<const char>("ABCDEF012Vgarbage: not in length on purpose", 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 18: {
            LogStep(18, "Read attribute CHAR_STRING Value isHexString Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 19: {
            LogStep(19, "Write attribute CHAR_STRING Value");
            chip::CharSpan value;
            value = chip::Span<const char>("ABCDEF0123garbage: not in length on purpose", 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 20: {
            LogStep(20, "Read attribute CHAR_STRING Value isHexString Constraints");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 21: {
            LogStep(21, "Write attribute CHAR_STRING Value Back to Default Value");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestDelayCommandsSuite : public TestCommand
{
public:
    TestDelayCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestDelayCommands", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestDelayCommandsSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(100);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestEventsSuite : public TestCommand
{
public:
    TestEventsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestEvents", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestEventsSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint64_t eventNumber;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestEmitTestEventResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                eventNumber = value.value;
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("testEvent.arg1", value.arg1, 1));
                VerifyOrReturn(CheckValue("testEvent.arg2", value.arg2, 2));
                VerifyOrReturn(CheckValue("testEvent.arg3", value.arg3, true));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestEmitTestEventResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("value", value.value, eventNumber + 1));
            }
            break;
        case 6:
            switch (mTestSubStepIndex)
            {
            case 0:
                VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
                {
                    chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType value;
                    VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                    VerifyOrReturn(CheckValue("testEvent.arg1", value.arg1, 1));
                    VerifyOrReturn(CheckValue("testEvent.arg2", value.arg2, 2));
                    VerifyOrReturn(CheckValue("testEvent.arg3", value.arg3, true));
                }
                mTestSubStepIndex++;
                break;
            case 1:
                VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
                {
                    chip::app::Clusters::TestCluster::Events::TestEvent::DecodableType value;
                    VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                    VerifyOrReturn(CheckValue("testEvent.arg1", value.arg1, 3));
                    VerifyOrReturn(CheckValue("testEvent.arg2", value.arg2, 4));
                    VerifyOrReturn(CheckValue("testEvent.arg3", value.arg3, false));
                }
                mTestSubStepIndex++;
                break;
            default:
                LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
                break;
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Check there is no event on the target endpoint");
            return ReadEvent(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Events::TestEvent::Id, false

            );
        }
        case 2: {
            LogStep(2, "Check reading events from an invalid endpoint");
            return ReadEvent(kIdentityAlpha, GetEndpoint(0), TestCluster::Id, TestCluster::Events::TestEvent::Id, false

            );
        }
        case 3: {
            LogStep(3, "Generate an event on the accessory");
            chip::app::Clusters::TestCluster::Commands::TestEmitTestEventRequest::Type value;
            value.arg1 = 1;
            value.arg2 = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
            value.arg3 = true;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestEmitTestEventRequest::Id,
                               value);
        }
        case 4: {
            LogStep(4, "Read the event back");
            return ReadEvent(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Events::TestEvent::Id, false

            );
        }
        case 5: {
            LogStep(5, "Generate a second event on the accessory");
            chip::app::Clusters::TestCluster::Commands::TestEmitTestEventRequest::Type value;
            value.arg1 = 3;
            value.arg2 = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(4);
            value.arg3 = false;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestEmitTestEventRequest::Id,
                               value);
        }
        case 6: {
            LogStep(6, "Read the event back");
            mTestSubStepCount = 2;
            return ReadEvent(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Events::TestEvent::Id, false

            );
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestDiscoverySuite : public TestCommand
{
public:
    TestDiscoverySuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestDiscovery", 25, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("vendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("productId", 0, UINT16_MAX, &mProductId);
        AddArgument("deviceType", 0, UINT16_MAX, &mDeviceType);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestDiscoverySuite()
    {
        if (deviceInstanceNameBeforeRebootBuffer != nullptr)
        {
            chip::Platform::MemoryFree(deviceInstanceNameBeforeRebootBuffer);
            deviceInstanceNameBeforeRebootBuffer = nullptr;
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<uint16_t> mVendorId;
    chip::Optional<uint16_t> mProductId;
    chip::Optional<uint16_t> mDeviceType;
    chip::Optional<uint16_t> mTimeout;

    char * deviceInstanceNameBeforeRebootBuffer = nullptr;
    chip::CharSpan deviceInstanceNameBeforeReboot;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintIsUpperCase("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintIsHexString("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintMinLength("value.instanceName", value.instanceName.size(), 16));
                VerifyOrReturn(CheckConstraintMaxLength("value.instanceName", value.instanceName.size(), 16));
                if (deviceInstanceNameBeforeRebootBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(deviceInstanceNameBeforeRebootBuffer);
                }
                deviceInstanceNameBeforeRebootBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.instanceName.size()));
                memcpy(deviceInstanceNameBeforeRebootBuffer, value.instanceName.data(), value.instanceName.size());
                deviceInstanceNameBeforeReboot = chip::CharSpan(deviceInstanceNameBeforeRebootBuffer, value.instanceName.size());
            }
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("longDiscriminator", value.longDiscriminator,
                                          mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U));
                VerifyOrReturn(CheckConstraintMinValue("value.longDiscriminator", value.longDiscriminator, 0U));
                VerifyOrReturn(CheckConstraintMaxValue("value.longDiscriminator", value.longDiscriminator, 4096U));
            }
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("vendorId", value.vendorId, mVendorId.HasValue() ? mVendorId.Value() : 65521U));
            }
            shouldContinue = true;
            break;
        case 12:
            if (IsUnsupported(status.mStatus))
            {
                shouldContinue = true;
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("productId", value.productId, mProductId.HasValue() ? mProductId.Value() : 32769U));
            }
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValuePresent("value.mrpRetryIntervalIdle", value.mrpRetryIntervalIdle));
                VerifyOrReturn(
                    CheckConstraintMaxValue("value.mrpRetryIntervalIdle.Value()", value.mrpRetryIntervalIdle.Value(), 3600000UL));
            }
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValuePresent("value.mrpRetryIntervalActive", value.mrpRetryIntervalActive));
                VerifyOrReturn(CheckConstraintMaxValue("value.mrpRetryIntervalActive.Value()", value.mrpRetryIntervalActive.Value(),
                                                       3600000UL));
            }
            shouldContinue = true;
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckValue("commissioningMode", value.commissioningMode, 1));
            }
            shouldContinue = true;
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxLength("value.deviceName", value.deviceName.size(), 32));
            }
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxValue("value.rotatingIdLen", value.rotatingIdLen, 100ULL));
            }
            shouldContinue = true;
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintNotValue("value.pairingHint", value.pairingHint, 0U));
            }
            shouldContinue = true;
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMaxLength("value.pairingInstruction", value.pairingInstruction.size(), 128));
            }
            shouldContinue = true;
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintMinValue("value.numIPs", value.numIPs, 1));
            }
            shouldContinue = true;
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DiscoveryCommands::Commands::DiscoveryCommandResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));

                VerifyOrReturn(CheckConstraintIsUpperCase("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintIsHexString("value.instanceName", value.instanceName, true));
                VerifyOrReturn(CheckConstraintMinLength("value.instanceName", value.instanceName.size(), 16));
                VerifyOrReturn(CheckConstraintMaxLength("value.instanceName", value.instanceName.size(), 16));
                VerifyOrReturn(CheckConstraintNotValue("value.instanceName", value.instanceName, deviceInstanceNameBeforeReboot));
            }
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2, "Open Commissioning Window with too-short timeout");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 120U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "Open Commissioning Window with too-long timeout");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 1000U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 4: {
            LogStep(4, "Open Commissioning Window");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 5: {
            LogStep(5, "Check Instance Name");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 6: {
            LogStep(6, "Check Long Discriminator _L");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByLongDiscriminator(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 7: {
            LogStep(7, "Check Short Discriminator (_S)");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByShortDiscriminator(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 8: {
            LogStep(8, "Check Commissioning Mode (_CM)");
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByCommissioningMode();
        }
        case 9: {
            LogStep(9, "Check Vendor ID (_V)");
            VerifyOrdo(!ShouldSkip("VENDOR_SUBTYPE"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionableByVendorId(mVendorId.HasValue() ? mVendorId.Value() : 65521U);
        }
        case 10: {
            LogStep(10, "TXT key for discriminator (D)");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 11: {
            LogStep(11, "TXT key for Vendor ID and Product ID (VP)");
            VerifyOrdo(!ShouldSkip("VP_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 12: {
            LogStep(12, "TXT key for Vendor ID and Product ID (VP)");
            VerifyOrdo(!ShouldSkip("VP_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 13: {
            LogStep(13, "Optional TXT key for MRP Retry Interval Idle (CRI)");
            VerifyOrdo(!ShouldSkip("CRI_COMM_DISCOVERY_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 14: {
            LogStep(14, "Optional TXT key for MRP Retry Interval Active (CRA)");
            VerifyOrdo(!ShouldSkip("CRA_COMM_DISCOVERY_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 15: {
            LogStep(15, "TXT key for commissioning mode (CM)");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 16: {
            LogStep(16, "Optional TXT key for device name (DN)");
            VerifyOrdo(!ShouldSkip("DN_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 17: {
            LogStep(17, "Optional TXT key for rotating device identifier (RI)");
            VerifyOrdo(!ShouldSkip("RI_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 18: {
            LogStep(18, "Optional TXT key for pairing hint (PH)");
            VerifyOrdo(!ShouldSkip("PH_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 19: {
            LogStep(19, "Optional TXT key for pairing instructions (PI)");
            VerifyOrdo(!ShouldSkip("PI_KEY"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 20: {
            LogStep(20, "Check IPs");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        case 21: {
            LogStep(21, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 22: {
            LogStep(22, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 23: {
            LogStep(23, "Open Commissioning Window");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 24: {
            LogStep(24, "Check Instance Name");
            SetIdentity(kIdentityAlpha);
            return FindCommissionable();
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestLogCommandsSuite : public TestCommand
{
public:
    TestLogCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestLogCommands", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestLogCommandsSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Log a simple message");
            SetIdentity(kIdentityAlpha);
            return Log("This is a simple message");
        }
        case 2: {
            LogStep(2, "Do a simple user prompt message");
            SetIdentity(kIdentityAlpha);
            return UserPrompt("This is a simple message");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestSaveAsSuite : public TestCommand
{
public:
    TestSaveAsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestSaveAs", 110, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestSaveAsSuite()
    {
        if (readAttributeCharStringDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeCharStringDefaultValueBuffer);
            readAttributeCharStringDefaultValueBuffer = nullptr;
        }
        if (readAttributeCharStringNotDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeCharStringNotDefaultValueBuffer);
            readAttributeCharStringNotDefaultValueBuffer = nullptr;
        }
        if (readAttributeOctetStringDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeOctetStringDefaultValueBuffer);
            readAttributeOctetStringDefaultValueBuffer = nullptr;
        }
        if (readAttributeOctetStringNotDefaultValueBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readAttributeOctetStringNotDefaultValueBuffer);
            readAttributeOctetStringNotDefaultValueBuffer = nullptr;
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint8_t TestAddArgumentDefaultValue;
    bool readAttributeBooleanDefaultValue;
    chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> readAttributeBitmap8DefaultValue;
    chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> readAttributeBitmap16DefaultValue;
    chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> readAttributeBitmap32DefaultValue;
    chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> readAttributeBitmap64DefaultValue;
    uint8_t readAttributeInt8uDefaultValue;
    uint16_t readAttributeInt16uDefaultValue;
    uint32_t readAttributeInt32uDefaultValue;
    uint64_t readAttributeInt64uDefaultValue;
    int8_t readAttributeInt8sDefaultValue;
    int16_t readAttributeInt16sDefaultValue;
    int32_t readAttributeInt32sDefaultValue;
    int64_t readAttributeInt64sDefaultValue;
    uint8_t readAttributeEnum8DefaultValue;
    uint16_t readAttributeEnum16DefaultValue;
    uint64_t readAttributeEpochUSDefaultValue;
    uint32_t readAttributeEpochSDefaultValue;
    chip::VendorId readAttributeVendorIdDefaultValue;
    char * readAttributeCharStringDefaultValueBuffer = nullptr;
    chip::CharSpan readAttributeCharStringDefaultValue;
    char * readAttributeCharStringNotDefaultValueBuffer = nullptr;
    chip::CharSpan readAttributeCharStringNotDefaultValue;
    uint8_t * readAttributeOctetStringDefaultValueBuffer = nullptr;
    chip::ByteSpan readAttributeOctetStringDefaultValue;
    uint8_t * readAttributeOctetStringNotDefaultValueBuffer = nullptr;
    chip::ByteSpan readAttributeOctetStringNotDefaultValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, 20));

                TestAddArgumentDefaultValue = value.returnValue;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, TestAddArgumentDefaultValue));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value.returnValue", value.returnValue, TestAddArgumentDefaultValue));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, 0));

                readAttributeBooleanDefaultValue = value;
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBooleanDefaultValue));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("boolean", value, readAttributeBooleanDefaultValue));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, 0));

                readAttributeBitmap8DefaultValue = value;
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBitmap8DefaultValue));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap8", value, readAttributeBitmap8DefaultValue));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, 0U));

                readAttributeBitmap16DefaultValue = value;
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBitmap16DefaultValue));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap16", value, readAttributeBitmap16DefaultValue));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, 0UL));

                readAttributeBitmap32DefaultValue = value;
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBitmap32DefaultValue));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap32", value, readAttributeBitmap32DefaultValue));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, 0ULL));

                readAttributeBitmap64DefaultValue = value;
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeBitmap64DefaultValue));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("bitmap64", value, readAttributeBitmap64DefaultValue));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, 0));

                readAttributeInt8uDefaultValue = value;
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt8uDefaultValue));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8u", value, readAttributeInt8uDefaultValue));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, 0U));

                readAttributeInt16uDefaultValue = value;
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt16uDefaultValue));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16u", value, readAttributeInt16uDefaultValue));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, 0UL));

                readAttributeInt32uDefaultValue = value;
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt32uDefaultValue));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32u", value, readAttributeInt32uDefaultValue));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, 0ULL));

                readAttributeInt64uDefaultValue = value;
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt64uDefaultValue));
            }
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64u", value, readAttributeInt64uDefaultValue));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, 0));

                readAttributeInt8sDefaultValue = value;
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt8sDefaultValue));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int8s", value, readAttributeInt8sDefaultValue));
            }
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, 0));

                readAttributeInt16sDefaultValue = value;
            }
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt16sDefaultValue));
            }
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int16s", value, readAttributeInt16sDefaultValue));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, 0L));

                readAttributeInt32sDefaultValue = value;
            }
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt32sDefaultValue));
            }
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int32s", value, readAttributeInt32sDefaultValue));
            }
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, 0LL));

                readAttributeInt64sDefaultValue = value;
            }
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeInt64sDefaultValue));
            }
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                int64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("int64s", value, readAttributeInt64sDefaultValue));
            }
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, 0));

                readAttributeEnum8DefaultValue = value;
            }
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeEnum8DefaultValue));
            }
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum8", value, readAttributeEnum8DefaultValue));
            }
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, 0U));

                readAttributeEnum16DefaultValue = value;
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeEnum16DefaultValue));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("enum16", value, readAttributeEnum16DefaultValue));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, 0ULL));

                readAttributeEpochUSDefaultValue = value;
            }
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeEpochUSDefaultValue));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochUs", value, readAttributeEpochUSDefaultValue));
            }
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, 0UL));

                readAttributeEpochSDefaultValue = value;
            }
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeEpochSDefaultValue));
            }
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("epochS", value, readAttributeEpochSDefaultValue));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorId", value, 0U));

                readAttributeVendorIdDefaultValue = value;
            }
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeVendorIdDefaultValue));
            }
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::VendorId value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("vendorId", value, readAttributeVendorIdDefaultValue));
            }
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("", 0)));

                if (readAttributeCharStringDefaultValueBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readAttributeCharStringDefaultValueBuffer);
                }
                readAttributeCharStringDefaultValueBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readAttributeCharStringDefaultValueBuffer, value.data(), value.size());
                readAttributeCharStringDefaultValue = chip::CharSpan(readAttributeCharStringDefaultValueBuffer, value.size());
            }
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, readAttributeCharStringDefaultValue));
            }
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("NotDefault", 10)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeCharStringDefaultValue));

                if (readAttributeCharStringNotDefaultValueBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readAttributeCharStringNotDefaultValueBuffer);
                }
                readAttributeCharStringNotDefaultValueBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readAttributeCharStringNotDefaultValueBuffer, value.data(), value.size());
                readAttributeCharStringNotDefaultValue = chip::CharSpan(readAttributeCharStringNotDefaultValueBuffer, value.size());
            }
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, readAttributeCharStringNotDefaultValue));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeCharStringDefaultValue));
            }
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("charString", value, chip::CharSpan("NotDefault", 10)));
            }
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 102:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));

                if (readAttributeOctetStringDefaultValueBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readAttributeOctetStringDefaultValueBuffer);
                }
                readAttributeOctetStringDefaultValueBuffer = static_cast<uint8_t *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readAttributeOctetStringDefaultValueBuffer, value.data(), value.size());
                readAttributeOctetStringDefaultValue = chip::ByteSpan(readAttributeOctetStringDefaultValueBuffer, value.size());
            }
            break;
        case 103:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value, readAttributeOctetStringDefaultValue));
            }
            break;
        case 104:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 105:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("NotDefault"), 10)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeOctetStringDefaultValue));

                if (readAttributeOctetStringNotDefaultValueBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readAttributeOctetStringNotDefaultValueBuffer);
                }
                readAttributeOctetStringNotDefaultValueBuffer = static_cast<uint8_t *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readAttributeOctetStringNotDefaultValueBuffer, value.data(), value.size());
                readAttributeOctetStringNotDefaultValue =
                    chip::ByteSpan(readAttributeOctetStringNotDefaultValueBuffer, value.size());
            }
            break;
        case 106:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("octetString", value, readAttributeOctetStringNotDefaultValue));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readAttributeOctetStringDefaultValue));
            }
            break;
        case 107:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 108:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::ByteSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(
                    CheckValueAsString("octetString", value, chip::ByteSpan(chip::Uint8::from_const_char("NotDefault"), 10)));
            }
            break;
        case 109:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Send Test Add Arguments Command");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = 17;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 2: {
            LogStep(2, "Send Test Add Arguments Command");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = 17;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 3: {
            LogStep(3, "Send Test Add Arguments Command");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = TestAddArgumentDefaultValue;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 4: {
            LogStep(4, "Read attribute BOOLEAN Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 5: {
            LogStep(5, "Write attribute BOOLEAN Not Default Value");
            bool value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        case 6: {
            LogStep(6, "Read attribute BOOLEAN Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 7: {
            LogStep(7, "Write attribute BOOLEAN DefaultValue");
            bool value;
            value = readAttributeBooleanDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id, value);
        }
        case 8: {
            LogStep(8, "Read attribute BOOLEAN False");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Boolean::Id);
        }
        case 9: {
            LogStep(9, "Read attribute BITMAP8 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 10: {
            LogStep(10, "Write attribute BITMAP8 Not Default Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap>>(1);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id, value);
        }
        case 11: {
            LogStep(11, "Read attribute BITMAP8 Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 12: {
            LogStep(12, "Write attribute BITMAP8 Default Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap8MaskMap> value;
            value = readAttributeBitmap8DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id, value);
        }
        case 13: {
            LogStep(13, "Read attribute BITMAP8 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap8::Id);
        }
        case 14: {
            LogStep(14, "Read attribute BITMAP16 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 15: {
            LogStep(15, "Write attribute BITMAP16 Not Default Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap>>(1U);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id, value);
        }
        case 16: {
            LogStep(16, "Read attribute BITMAP16 Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 17: {
            LogStep(17, "Write attribute BITMAP16 Default Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap16MaskMap> value;
            value = readAttributeBitmap16DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id, value);
        }
        case 18: {
            LogStep(18, "Read attribute BITMAP16 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap16::Id);
        }
        case 19: {
            LogStep(19, "Read attribute BITMAP32 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 20: {
            LogStep(20, "Write attribute BITMAP32 Not Default Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap>>(1UL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id, value);
        }
        case 21: {
            LogStep(21, "Read attribute BITMAP32 Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 22: {
            LogStep(22, "Write attribute BITMAP32 Default Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap32MaskMap> value;
            value = readAttributeBitmap32DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id, value);
        }
        case 23: {
            LogStep(23, "Read attribute BITMAP32 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap32::Id);
        }
        case 24: {
            LogStep(24, "Read attribute BITMAP64 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 25: {
            LogStep(25, "Write attribute BITMAP64 Not Default Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
            value = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap>>(1ULL);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id, value);
        }
        case 26: {
            LogStep(26, "Read attribute BITMAP64 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 27: {
            LogStep(27, "Write attribute BITMAP64 Default Value");
            chip::BitFlags<chip::app::Clusters::TestCluster::Bitmap64MaskMap> value;
            value = readAttributeBitmap64DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id, value);
        }
        case 28: {
            LogStep(28, "Read attribute BITMAP64 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Bitmap64::Id);
        }
        case 29: {
            LogStep(29, "Read attribute INT8U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 30: {
            LogStep(30, "Write attribute INT8U Not Default Value");
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id, value);
        }
        case 31: {
            LogStep(31, "Read attribute INT8U Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 32: {
            LogStep(32, "Write attribute INT8U Default Value");
            uint8_t value;
            value = readAttributeInt8uDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id, value);
        }
        case 33: {
            LogStep(33, "Read attribute INT8U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8u::Id);
        }
        case 34: {
            LogStep(34, "Read attribute INT16U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 35: {
            LogStep(35, "Write attribute INT16U Not Default Value");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id, value);
        }
        case 36: {
            LogStep(36, "Read attribute INT16U Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 37: {
            LogStep(37, "Write attribute INT16U Default Value");
            uint16_t value;
            value = readAttributeInt16uDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id, value);
        }
        case 38: {
            LogStep(38, "Read attribute INT16U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16u::Id);
        }
        case 39: {
            LogStep(39, "Read attribute INT32U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 40: {
            LogStep(40, "Write attribute INT32U Not Default Value");
            uint32_t value;
            value = 1UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 41: {
            LogStep(41, "Read attribute INT32U Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 42: {
            LogStep(42, "Write attribute INT32U Default Value");
            uint32_t value;
            value = readAttributeInt32uDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id, value);
        }
        case 43: {
            LogStep(43, "Read attribute INT32U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32u::Id);
        }
        case 44: {
            LogStep(44, "Read attribute INT64U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 45: {
            LogStep(45, "Write attribute INT64U Not Default Value");
            uint64_t value;
            value = 1ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id, value);
        }
        case 46: {
            LogStep(46, "Read attribute INT64U Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 47: {
            LogStep(47, "Write attribute INT64U Default Value");
            uint64_t value;
            value = readAttributeInt64uDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id, value);
        }
        case 48: {
            LogStep(48, "Read attribute INT64U Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64u::Id);
        }
        case 49: {
            LogStep(49, "Read attribute INT8S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 50: {
            LogStep(50, "Write attribute INT8S Not Default Value");
            int8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 51: {
            LogStep(51, "Read attribute INT8S Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 52: {
            LogStep(52, "Write attribute INT8S Default Value");
            int8_t value;
            value = readAttributeInt8sDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id, value);
        }
        case 53: {
            LogStep(53, "Read attribute INT8S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int8s::Id);
        }
        case 54: {
            LogStep(54, "Read attribute INT16S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 55: {
            LogStep(55, "Write attribute INT16S Not Default Value");
            int16_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 56: {
            LogStep(56, "Read attribute INT16S Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 57: {
            LogStep(57, "Write attribute INT16S Default Value");
            int16_t value;
            value = readAttributeInt16sDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id, value);
        }
        case 58: {
            LogStep(58, "Read attribute INT16S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int16s::Id);
        }
        case 59: {
            LogStep(59, "Read attribute INT32S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 60: {
            LogStep(60, "Write attribute INT32S Not Default Value");
            int32_t value;
            value = 1L;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 61: {
            LogStep(61, "Read attribute INT32S Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 62: {
            LogStep(62, "Write attribute INT32S Default Value");
            int32_t value;
            value = readAttributeInt32sDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id, value);
        }
        case 63: {
            LogStep(63, "Read attribute INT32S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int32s::Id);
        }
        case 64: {
            LogStep(64, "Read attribute INT64S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 65: {
            LogStep(65, "Write attribute INTS Not Default Value");
            int64_t value;
            value = 1LL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 66: {
            LogStep(66, "Read attribute INT64S Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 67: {
            LogStep(67, "Write attribute INT64S Default Value");
            int64_t value;
            value = readAttributeInt64sDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id, value);
        }
        case 68: {
            LogStep(68, "Read attribute INT64S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Int64s::Id);
        }
        case 69: {
            LogStep(69, "Read attribute ENUM8 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 70: {
            LogStep(70, "Write attribute ENUM8 Not Default Value");
            uint8_t value;
            value = 1;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id, value);
        }
        case 71: {
            LogStep(71, "Read attribute ENUM8 Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 72: {
            LogStep(72, "Write attribute ENUM8 Default Value");
            uint8_t value;
            value = readAttributeEnum8DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id, value);
        }
        case 73: {
            LogStep(73, "Read attribute ENUM8 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum8::Id);
        }
        case 74: {
            LogStep(74, "Read attribute ENUM16 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 75: {
            LogStep(75, "Write attribute ENUM16 Not Default Value");
            uint16_t value;
            value = 1U;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id, value);
        }
        case 76: {
            LogStep(76, "Read attribute ENUM16 Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 77: {
            LogStep(77, "Write attribute ENUM16 Default Value");
            uint16_t value;
            value = readAttributeEnum16DefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id, value);
        }
        case 78: {
            LogStep(78, "Read attribute ENUM16 Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::Enum16::Id);
        }
        case 79: {
            LogStep(79, "Read attribute EPOCH_US Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 80: {
            LogStep(80, "Write attribute EPOCH_US Not Default Value");
            uint64_t value;
            value = 1ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id, value);
        }
        case 81: {
            LogStep(81, "Read attribute EPOCH_US Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 82: {
            LogStep(82, "Write attribute EPOCH_US Default Value");
            uint64_t value;
            value = readAttributeEpochUSDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id, value);
        }
        case 83: {
            LogStep(83, "Read attribute EPOCH_US Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochUs::Id);
        }
        case 84: {
            LogStep(84, "Read attribute EPOCH_S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 85: {
            LogStep(85, "Write attribute EPOCH_S Not Default Value");
            uint32_t value;
            value = 1UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id, value);
        }
        case 86: {
            LogStep(86, "Read attribute EPOCH_S Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 87: {
            LogStep(87, "Write attribute EPOCH_S Default Value");
            uint32_t value;
            value = readAttributeEpochSDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id, value);
        }
        case 88: {
            LogStep(88, "Read attribute EPOCH_S Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::EpochS::Id);
        }
        case 89: {
            LogStep(89, "Read attribute vendor_id Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 90: {
            LogStep(90, "Write attribute vendor_id Not Default Value");
            chip::VendorId value;
            value = static_cast<chip::VendorId>(1);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id, value);
        }
        case 91: {
            LogStep(91, "Read attribute vendor_id Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 92: {
            LogStep(92, "Write attribute vendor_id Default Value");
            chip::VendorId value;
            value = readAttributeVendorIdDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id, value);
        }
        case 93: {
            LogStep(93, "Read attribute vendor_id Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::VendorId::Id);
        }
        case 94: {
            LogStep(94, "Read attribute char_string Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 95: {
            LogStep(95, "Read attribute char_string Default Value and compare to saved value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 96: {
            LogStep(96, "Write attribute char_string Not Default Value");
            chip::CharSpan value;
            value = chip::Span<const char>("NotDefaultgarbage: not in length on purpose", 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 97: {
            LogStep(97, "Read attribute char_string Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 98: {
            LogStep(98, "Read attribute char_string Not Default Value and compare to saved value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 99: {
            LogStep(99, "Write attribute char_string Not Default Value from saved value");
            chip::CharSpan value;
            value = readAttributeCharStringNotDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 100: {
            LogStep(100, "Read attribute char_string Not Default Value and compare to expected value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id);
        }
        case 101: {
            LogStep(101, "Write attribute char_string Default Value");
            chip::CharSpan value;
            value = readAttributeCharStringDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::CharString::Id, value);
        }
        case 102: {
            LogStep(102, "Read attribute octet_string Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 103: {
            LogStep(103, "Read attribute octet_string Default Value and compare to saved value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 104: {
            LogStep(104, "Write attribute octet_string Not Default Value");
            chip::ByteSpan value;
            value = chip::ByteSpan(chip::Uint8::from_const_char("NotDefaultgarbage: not in length on purpose"), 10);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 105: {
            LogStep(105, "Read attribute octet_string Not Default Value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 106: {
            LogStep(106, "Read attribute octet_string Not Default Value and compare to saved value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 107: {
            LogStep(107, "Write attribute octet_string Not Default Value from saved value");
            chip::ByteSpan value;
            value = readAttributeOctetStringNotDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        case 108: {
            LogStep(108, "Read attribute octet_string Not Default Value and compare to expected value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id);
        }
        case 109: {
            LogStep(109, "Write attribute octet_string Default Value");
            chip::ByteSpan value;
            value = readAttributeOctetStringDefaultValue;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Attributes::OctetString::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestConfigVariablesSuite : public TestCommand
{
public:
    TestConfigVariablesSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestConfigVariables", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("returnValueWithArg1", 0, UINT8_MAX, &mReturnValueWithArg1);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestConfigVariablesSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint8_t> mArg1;
    chip::Optional<uint8_t> mReturnValueWithArg1;
    chip::Optional<uint16_t> mTimeout;

    uint8_t TestAddArgumentDefaultValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue, 20));

                TestAddArgumentDefaultValue = value.returnValue;
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("returnValue", value.returnValue,
                                          mReturnValueWithArg1.HasValue() ? mReturnValueWithArg1.Value() : 25));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Send Test Add Arguments Command");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = 3;
            value.arg2 = 17;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        case 2: {
            LogStep(2, "Send Test Add Arguments Command");
            chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type value;
            value.arg1 = mArg1.HasValue() ? mArg1.Value() : 5;
            value.arg2 = TestAddArgumentDefaultValue;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), TestCluster::Id, TestCluster::Commands::TestAddArguments::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestDescriptorClusterSuite : public TestCommand
{
public:
    TestDescriptorClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestDescriptorCluster", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestDescriptorClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("deviceList", iter_0, 0));
                    VerifyOrReturn(CheckValue("deviceList[0].type", iter_0.GetValue().type, 22UL));
                    VerifyOrReturn(CheckValue("deviceList[0].revision", iter_0.GetValue().revision, 1U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("deviceList", iter_0, 1));
                }
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ClusterId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 0));
                    VerifyOrReturn(CheckValue("serverList[0]", iter_0.GetValue(), 3UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 1));
                    VerifyOrReturn(CheckValue("serverList[1]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 2));
                    VerifyOrReturn(CheckValue("serverList[2]", iter_0.GetValue(), 29UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 3));
                    VerifyOrReturn(CheckValue("serverList[3]", iter_0.GetValue(), 30UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 4));
                    VerifyOrReturn(CheckValue("serverList[4]", iter_0.GetValue(), 31UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 5));
                    VerifyOrReturn(CheckValue("serverList[5]", iter_0.GetValue(), 40UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 6));
                    VerifyOrReturn(CheckValue("serverList[6]", iter_0.GetValue(), 42UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 7));
                    VerifyOrReturn(CheckValue("serverList[7]", iter_0.GetValue(), 43UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 8));
                    VerifyOrReturn(CheckValue("serverList[8]", iter_0.GetValue(), 44UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 9));
                    VerifyOrReturn(CheckValue("serverList[9]", iter_0.GetValue(), 45UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 10));
                    VerifyOrReturn(CheckValue("serverList[10]", iter_0.GetValue(), 46UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 11));
                    VerifyOrReturn(CheckValue("serverList[11]", iter_0.GetValue(), 48UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 12));
                    VerifyOrReturn(CheckValue("serverList[12]", iter_0.GetValue(), 49UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 13));
                    VerifyOrReturn(CheckValue("serverList[13]", iter_0.GetValue(), 50UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 14));
                    VerifyOrReturn(CheckValue("serverList[14]", iter_0.GetValue(), 51UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 15));
                    VerifyOrReturn(CheckValue("serverList[15]", iter_0.GetValue(), 52UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 16));
                    VerifyOrReturn(CheckValue("serverList[16]", iter_0.GetValue(), 53UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 17));
                    VerifyOrReturn(CheckValue("serverList[17]", iter_0.GetValue(), 54UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 18));
                    VerifyOrReturn(CheckValue("serverList[18]", iter_0.GetValue(), 55UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 19));
                    VerifyOrReturn(CheckValue("serverList[19]", iter_0.GetValue(), 60UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 20));
                    VerifyOrReturn(CheckValue("serverList[20]", iter_0.GetValue(), 62UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 21));
                    VerifyOrReturn(CheckValue("serverList[21]", iter_0.GetValue(), 63UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 22));
                    VerifyOrReturn(CheckValue("serverList[22]", iter_0.GetValue(), 64UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 23));
                    VerifyOrReturn(CheckValue("serverList[23]", iter_0.GetValue(), 65UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("serverList", iter_0, 24));
                    VerifyOrReturn(CheckValue("serverList[24]", iter_0.GetValue(), 1029UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("serverList", iter_0, 25));
                }
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::ClusterId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("clientList", iter_0, 0));
                    VerifyOrReturn(CheckValue("clientList[0]", iter_0.GetValue(), 41UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("clientList", iter_0, 1));
                }
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::EndpointId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("partsList", iter_0, 0));
                    VerifyOrReturn(CheckValue("partsList[0]", iter_0.GetValue(), 1U));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("partsList", iter_0, 1));
                    VerifyOrReturn(CheckValue("partsList[1]", iter_0.GetValue(), 2U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("partsList", iter_0, 2));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read attribute Device list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Descriptor::Id, Descriptor::Attributes::DeviceList::Id);
        }
        case 2: {
            LogStep(2, "Read attribute Server list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Descriptor::Id, Descriptor::Attributes::ServerList::Id);
        }
        case 3: {
            LogStep(3, "Read attribute Client list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Descriptor::Id, Descriptor::Attributes::ClientList::Id);
        }
        case 4: {
            LogStep(4, "Read attribute Parts list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Descriptor::Id, Descriptor::Attributes::PartsList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestBasicInformationSuite : public TestCommand
{
public:
    TestBasicInformationSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestBasicInformation", 18, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestBasicInformationSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("location", value, chip::CharSpan("XX", 2)));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("location", value, chip::CharSpan("US", 2)));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::AttributeId> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 0));
                    VerifyOrReturn(CheckValue("attributeList[0]", iter_0.GetValue(), 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 1));
                    VerifyOrReturn(CheckValue("attributeList[1]", iter_0.GetValue(), 1UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 2));
                    VerifyOrReturn(CheckValue("attributeList[2]", iter_0.GetValue(), 2UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 3));
                    VerifyOrReturn(CheckValue("attributeList[3]", iter_0.GetValue(), 3UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 4));
                    VerifyOrReturn(CheckValue("attributeList[4]", iter_0.GetValue(), 4UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 5));
                    VerifyOrReturn(CheckValue("attributeList[5]", iter_0.GetValue(), 5UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 6));
                    VerifyOrReturn(CheckValue("attributeList[6]", iter_0.GetValue(), 6UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 7));
                    VerifyOrReturn(CheckValue("attributeList[7]", iter_0.GetValue(), 7UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 8));
                    VerifyOrReturn(CheckValue("attributeList[8]", iter_0.GetValue(), 8UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 9));
                    VerifyOrReturn(CheckValue("attributeList[9]", iter_0.GetValue(), 9UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 10));
                    VerifyOrReturn(CheckValue("attributeList[10]", iter_0.GetValue(), 10UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 11));
                    VerifyOrReturn(CheckValue("attributeList[11]", iter_0.GetValue(), 11UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 12));
                    VerifyOrReturn(CheckValue("attributeList[12]", iter_0.GetValue(), 12UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 13));
                    VerifyOrReturn(CheckValue("attributeList[13]", iter_0.GetValue(), 13UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 14));
                    VerifyOrReturn(CheckValue("attributeList[14]", iter_0.GetValue(), 14UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 15));
                    VerifyOrReturn(CheckValue("attributeList[15]", iter_0.GetValue(), 15UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 16));
                    VerifyOrReturn(CheckValue("attributeList[16]", iter_0.GetValue(), 16UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 17));
                    VerifyOrReturn(CheckValue("attributeList[17]", iter_0.GetValue(), 17UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 18));
                    VerifyOrReturn(CheckValue("attributeList[18]", iter_0.GetValue(), 18UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 19));
                    VerifyOrReturn(CheckValue("attributeList[19]", iter_0.GetValue(), 19UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 20));
                    VerifyOrReturn(CheckValue("attributeList[20]", iter_0.GetValue(), 65528UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 21));
                    VerifyOrReturn(CheckValue("attributeList[21]", iter_0.GetValue(), 65529UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 22));
                    VerifyOrReturn(CheckValue("attributeList[22]", iter_0.GetValue(), 65531UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("attributeList", iter_0, 23));
                    VerifyOrReturn(CheckValue("attributeList[23]", iter_0.GetValue(), 65533UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("attributeList", iter_0, 24));
                }
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("", 0)));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("My node", 7)));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("localConfigDisabled", value, false));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("localConfigDisabled", value, true));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("My node", 7)));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("localConfigDisabled", value, true));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read location");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id);
        }
        case 2: {
            LogStep(2, "Write location");
            chip::CharSpan value;
            value = chip::Span<const char>("USgarbage: not in length on purpose", 2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id, value);
        }
        case 3: {
            LogStep(3, "Read back location");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id);
        }
        case 4: {
            LogStep(4, "Restore initial location value");
            chip::CharSpan value;
            value = chip::Span<const char>("XXgarbage: not in length on purpose", 2);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::Location::Id, value);
        }
        case 5: {
            LogStep(5, "Read AttributeList value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::AttributeList::Id);
        }
        case 6: {
            LogStep(6, "Read NodeLabel");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 7: {
            LogStep(7, "Write NodeLabel");
            chip::CharSpan value;
            value = chip::Span<const char>("My nodegarbage: not in length on purpose", 7);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 8: {
            LogStep(8, "Read back NodeLabel");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 9: {
            LogStep(9, "Read LocalConfigDisabled");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::LocalConfigDisabled::Id);
        }
        case 10: {
            LogStep(10, "Write LocalConfigDisabled");
            bool value;
            value = true;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::LocalConfigDisabled::Id, value);
        }
        case 11: {
            LogStep(11, "Read back LocalConfigDisabled");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::LocalConfigDisabled::Id);
        }
        case 12: {
            LogStep(12, "Reboot the device");
            SetIdentity(kIdentityAlpha);
            return Reboot();
        }
        case 13: {
            LogStep(13, "Connect to the device again");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 14: {
            LogStep(14, "Read back NodeLabel after reboot");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 15: {
            LogStep(15, "Restore initial NodeLabel value");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 16: {
            LogStep(16, "Read back LocalConfigDisabled after reboot");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::LocalConfigDisabled::Id);
        }
        case 17: {
            LogStep(17, "Restore initial LocalConfigDisabled value");
            bool value;
            value = false;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::LocalConfigDisabled::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestGeneralCommissioningSuite : public TestCommand
{
public:
    TestGeneralCommissioningSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGeneralCommissioning", 31, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("payload", &mPayload);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestGeneralCommissioningSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<chip::CharSpan> mPayload;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 137438953472ULL));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 81ULL));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 0ULL));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 1ULL));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 3));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 1ULL));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 4));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 1ULL));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 0));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 2ULL));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 4));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 2ULL));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 2));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 2ULL));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 0));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 0ULL));
            }
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 0));
            }
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 3ULL));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 0));
            }
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("breadcrumb", value, 0ULL));
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "bool"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Write Breadcrumb (1/2)");
            uint64_t value;
            value = 137438953472ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                  GeneralCommissioning::Attributes::Breadcrumb::Id, value);
        }
        case 2: {
            LogStep(2, "Read back Breadcrumb (1/2)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 3: {
            LogStep(3, "Write Breadcrumb (2/2)");
            uint64_t value;
            value = 81ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                  GeneralCommissioning::Attributes::Breadcrumb::Id, value);
        }
        case 4: {
            LogStep(4, "Read back Breadcrumb (2/2)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 5: {
            LogStep(5, "Reboot to reset Breadcrumb");
            SetIdentity(kIdentityAlpha);
            return Reboot();
        }
        case 6: {
            LogStep(6, "Connect to the device again");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 7: {
            LogStep(7, "Read back Breadcrumb after reboot and ensure it was not persisted");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 8: {
            LogStep(8, "Set Breadcrumb to nonzero value");
            uint64_t value;
            value = 1ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                  GeneralCommissioning::Attributes::Breadcrumb::Id, value);
        }
        case 9: {
            LogStep(9, "Check Breadcrumb set worked");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 10: {
            LogStep(10, "Send CommissioningComplete without armed fail-safe");
            chip::app::Clusters::GeneralCommissioning::Commands::CommissioningComplete::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::CommissioningComplete::Id, value);
        }
        case 11: {
            LogStep(11, "Check Breadcrumb was not touched by invalid CommissioningComplete");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 12: {
            LogStep(12, "Open Commissioning Window from alpha");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 13: {
            LogStep(13, "Try to arm fail-safe");
            chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type value;
            value.expiryLengthSeconds = 10U;
            value.breadcrumb          = 5000ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::ArmFailSafe::Id, value);
        }
        case 14: {
            LogStep(14, "Check Breadcrumb was not touched by ArmFailSafe with commissioning window open");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 15: {
            LogStep(15, "Reset Breadcrumb to 0 so we can commission");
            uint64_t value;
            value = 0ULL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                  GeneralCommissioning::Attributes::Breadcrumb::Id, value);
        }
        case 16: {
            LogStep(16, "Commission from beta");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(
                74565, mPayload.HasValue() ? mPayload.Value() : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 17: {
            LogStep(17, "Wait for the commissioned device to be retrieved for beta");
            SetIdentity(kIdentityBeta);
            return WaitForCommissionee(74565);
        }
        case 18: {
            LogStep(18, "Arm fail-safe");
            chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type value;
            value.expiryLengthSeconds = 500U;
            value.breadcrumb          = 2ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::ArmFailSafe::Id, value);
        }
        case 19: {
            LogStep(19, "Check Breadcrumb was properly set by ArmFailSafe");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 20: {
            LogStep(20, "Try to arm fail-safe from wrong fabric");
            chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type value;
            value.expiryLengthSeconds = 10U;
            value.breadcrumb          = 5000ULL;
            return SendCommand(kIdentityBeta, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::ArmFailSafe::Id, value);
        }
        case 21: {
            LogStep(21, "Check Breadcrumb was not touched by ArmFailSafe with existing fail-safe armed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 22: {
            LogStep(22, "Send CommissioningComplete from wrong fabric");
            chip::app::Clusters::GeneralCommissioning::Commands::CommissioningComplete::Type value;
            return SendCommand(kIdentityBeta, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::CommissioningComplete::Id, value);
        }
        case 23: {
            LogStep(23, "Check Breadcrumb was not touched by CommissioningComplete from wrong fabric");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 24: {
            LogStep(24, "Close out the fail-safe gracefully");
            chip::app::Clusters::GeneralCommissioning::Commands::CommissioningComplete::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::CommissioningComplete::Id, value);
        }
        case 25: {
            LogStep(25, "Check Breadcrumb was reset to 0 by CommissioningComplete");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 26: {
            LogStep(26, "Arm fail-safe again");
            chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type value;
            value.expiryLengthSeconds = 500U;
            value.breadcrumb          = 3ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::ArmFailSafe::Id, value);
        }
        case 27: {
            LogStep(27, "Check Breadcrumb was set by arming fail-safe again");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 28: {
            LogStep(28, "Force-expire the fail-safe");
            chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type value;
            value.expiryLengthSeconds = 0U;
            value.breadcrumb          = 4ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::ArmFailSafe::Id, value);
        }
        case 29: {
            LogStep(29, "Check Breadcrumb was reset by expiring the fail-safe");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::Breadcrumb::Id);
        }
        case 30: {
            LogStep(30, "Validate presence of SupportsConcurrentConnection");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                                 GeneralCommissioning::Attributes::SupportsConcurrentConnection::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestIdentifyClusterSuite : public TestCommand
{
public:
    TestIdentifyClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestIdentifyCluster", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestIdentifyClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Send Identify command and expect success response");
            chip::app::Clusters::Identify::Commands::Identify::Type value;
            value.identifyTime = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), Identify::Id, Identify::Commands::Identify::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestOperationalCredentialsClusterSuite : public TestCommand
{
public:
    TestOperationalCredentialsClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestOperationalCredentialsCluster", 8, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestOperationalCredentialsClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::FabricIndex ourFabricIndex;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 4));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::FabricIndex value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                ourFabricIndex = value;
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusCode", value.statusCode, 11));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckValue("fabrics[0].fabricIndex", iter_0.GetValue().fabricIndex, ourFabricIndex));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("statusCode", value.statusCode, 0));

                VerifyOrReturn(CheckValuePresent("fabricIndex", value.fabricIndex));
                VerifyOrReturn(CheckValue("fabricIndex.Value()", value.fabricIndex.Value(), ourFabricIndex));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("Batcave", 7)));
                    VerifyOrReturn(CheckValue("fabrics[0].fabricIndex", iter_0.GetValue().fabricIndex, ourFabricIndex));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read number of supported fabrics");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::SupportedFabrics::Id);
        }
        case 2: {
            LogStep(2, "Read number of commissioned fabrics");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::CommissionedFabrics::Id);
        }
        case 3: {
            LogStep(3, "Read current fabric index");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::CurrentFabricIndex::Id);
        }
        case 4: {
            LogStep(4, "Remove nonexistent fabric");
            chip::app::Clusters::OperationalCredentials::Commands::RemoveFabric::Type value;
            value.fabricIndex = 243;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                               OperationalCredentials::Commands::RemoveFabric::Id, value);
        }
        case 5: {
            LogStep(5, "Read fabric list before setting label");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        case 6: {
            LogStep(6, "Set the fabric label");
            chip::app::Clusters::OperationalCredentials::Commands::UpdateFabricLabel::Type value;
            value.label = chip::Span<const char>("Batcavegarbage: not in length on purpose", 7);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                               OperationalCredentials::Commands::UpdateFabricLabel::Id, value);
        }
        case 7: {
            LogStep(7, "Read fabric list after setting label");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestModeSelectClusterSuite : public TestCommand
{
public:
    TestModeSelectClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestModeSelectCluster", 32, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestModeSelectClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<uint16_t> mTimeout;

    uint8_t currentModeBeforeToggle;
    chip::app::DataModel::Nullable<uint8_t> OnModeValue;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("description", value, chip::CharSpan("Coffee", 6)));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint16_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("standardNamespace", value));
                VerifyOrReturn(CheckValue("standardNamespace.Value()", value.Value(), 0U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("supportedModes", iter_0, 0));
                    VerifyOrReturn(
                        CheckValueAsString("supportedModes[0].label", iter_0.GetValue().label, chip::CharSpan("Black", 5)));
                    VerifyOrReturn(CheckValue("supportedModes[0].mode", iter_0.GetValue().mode, 0));
                    VerifyOrReturn(CheckValue("supportedModes[0].semanticTag", iter_0.GetValue().semanticTag, 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("supportedModes", iter_0, 1));
                    VerifyOrReturn(
                        CheckValueAsString("supportedModes[1].label", iter_0.GetValue().label, chip::CharSpan("Cappuccino", 10)));
                    VerifyOrReturn(CheckValue("supportedModes[1].mode", iter_0.GetValue().mode, 4));
                    VerifyOrReturn(CheckValue("supportedModes[1].semanticTag", iter_0.GetValue().semanticTag, 0UL));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("supportedModes", iter_0, 2));
                    VerifyOrReturn(
                        CheckValueAsString("supportedModes[2].label", iter_0.GetValue().label, chip::CharSpan("Espresso", 8)));
                    VerifyOrReturn(CheckValue("supportedModes[2].mode", iter_0.GetValue().mode, 7));
                    VerifyOrReturn(CheckValue("supportedModes[2].semanticTag", iter_0.GetValue().semanticTag, 0UL));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("supportedModes", iter_0, 3));
                }
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentMode", value, 0));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("startUpMode", value));
                VerifyOrReturn(CheckValue("startUpMode.Value()", value.Value(), 0));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("onMode", value));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentMode", value, 4));

                currentModeBeforeToggle = value;
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentMode", value, currentModeBeforeToggle));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("onMode", value));
                VerifyOrReturn(CheckValue("onMode.Value()", value.Value(), 7));

                OnModeValue = value;
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentMode", value, OnModeValue));
            }
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<uint8_t> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("startUpMode", value));
                VerifyOrReturn(CheckValue("startUpMode.Value()", value.Value(), 7));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentMode", value, 4));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("currentMode", value, 7));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read Description");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::Description::Id);
        }
        case 2: {
            LogStep(2, "Read StandardNamespace");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::StandardNamespace::Id);
        }
        case 3: {
            LogStep(3, "Read SupportedModes");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::SupportedModes::Id);
        }
        case 4: {
            LogStep(4, "Read CurrentMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::CurrentMode::Id);
        }
        case 5: {
            LogStep(5, "Read StartUpMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::StartUpMode::Id);
        }
        case 6: {
            LogStep(6, "Read OnMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::OnMode::Id);
        }
        case 7: {
            LogStep(7, "Change to Supported Mode");
            chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type value;
            value.newMode = 4;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Commands::ChangeToMode::Id, value);
        }
        case 8: {
            LogStep(8, "Verify Current Mode Change");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::CurrentMode::Id);
        }
        case 9: {
            LogStep(9, "Change to Unsupported Mode");
            chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type value;
            value.newMode = 2;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Commands::ChangeToMode::Id, value);
        }
        case 10: {
            LogStep(10, "Toggle OnOff");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 11: {
            LogStep(11, "Toggle OnOff");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 12: {
            LogStep(12, "Verify Current Mode does not change when OnMode is null");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::CurrentMode::Id);
        }
        case 13: {
            LogStep(13, "Change to Unsupported OnMode");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::OnMode::Id, value);
        }
        case 14: {
            LogStep(14, "Change OnMode");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 7;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::OnMode::Id, value);
        }
        case 15: {
            LogStep(15, "Verify OnMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::OnMode::Id);
        }
        case 16: {
            LogStep(16, "Toggle OnOff");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 17: {
            LogStep(17, "Toggle OnOff");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 18: {
            LogStep(18, "Verify Current Mode Changes if OnMode is not null");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::CurrentMode::Id);
        }
        case 19: {
            LogStep(19, "Change to Unsupported StartUp Mode");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 2;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::StartUpMode::Id, value);
        }
        case 20: {
            LogStep(20, "Change to Supported StartUp Mode");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 7;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::StartUpMode::Id, value);
        }
        case 21: {
            LogStep(21, "Verify StartUp Mode Change");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::StartUpMode::Id);
        }
        case 22: {
            LogStep(22, "Change CurrentMode to another value");
            chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type value;
            value.newMode = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Commands::ChangeToMode::Id, value);
        }
        case 23: {
            LogStep(23, "Change On Mode");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNonNull();
            value.Value() = 4;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::OnMode::Id, value);
        }
        case 24: {
            LogStep(24, "Set StartUpOnOff");
            chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffStartUpOnOff> value;
            value.SetNonNull();
            value.Value() = static_cast<chip::app::Clusters::OnOff::OnOffStartUpOnOff>(1);
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::StartUpOnOff::Id, value);
        }
        case 25: {
            LogStep(25, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 26: {
            LogStep(26, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 27: {
            LogStep(27, "Verify Current Mode Change based on OnMode, as it overwrites StartUpMode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::CurrentMode::Id);
        }
        case 28: {
            LogStep(28, "Change On Mode to Null");
            chip::app::DataModel::Nullable<uint8_t> value;
            value.SetNull();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::OnMode::Id, value);
        }
        case 29: {
            LogStep(29, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 30: {
            LogStep(30, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 31: {
            LogStep(31, "Verify Current Mode Change based on new StartUp Mode");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), ModeSelect::Id, ModeSelect::Attributes::CurrentMode::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestSelfFabricRemovalSuite : public TestCommand
{
public:
    TestSelfFabricRemovalSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestSelfFabricRemoval", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestSelfFabricRemovalSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::FabricIndex ourFabricIndex;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("commissionedFabrics", value, 1));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::FabricIndex value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint8"));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 1));
                ourFabricIndex = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read number of commissioned fabrics");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::CommissionedFabrics::Id);
        }
        case 2: {
            LogStep(2, "Read current fabric index");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::CurrentFabricIndex::Id);
        }
        case 3: {
            LogStep(3, "Remove single own fabric");
            chip::app::Clusters::OperationalCredentials::Commands::RemoveFabric::Type value;
            value.fabricIndex = ourFabricIndex;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                               OperationalCredentials::Commands::RemoveFabric::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestSystemCommandsSuite : public TestCommand
{
public:
    TestSystemCommandsSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestSystemCommands", 14, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestSystemCommandsSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Stop the accessory");
            SetIdentity(kIdentityAlpha);
            return Stop();
        }
        case 2: {
            LogStep(2, "Start the accessory with no command line options");
            SetIdentity(kIdentityAlpha);
            return Start();
        }
        case 3: {
            LogStep(3, "Stop the accessory");
            SetIdentity(kIdentityAlpha);
            return Stop();
        }
        case 4: {
            LogStep(4, "Start the accessory with only discriminator command line option");
            SetIdentity(kIdentityAlpha);
            return Start(1111);
        }
        case 5: {
            LogStep(5, "Stop the accessory");
            SetIdentity(kIdentityAlpha);
            return Stop();
        }
        case 6: {
            LogStep(6, "Start the accessory with discriminator and port command line option");
            SetIdentity(kIdentityAlpha);
            return Start(1111, 5560);
        }
        case 7: {
            LogStep(7, "Stop the accessory");
            SetIdentity(kIdentityAlpha);
            return Stop();
        }
        case 8: {
            LogStep(8, "Start the accessory with all command line options");
            SetIdentity(kIdentityAlpha);
            return Start(1111, 5560, "/tmp/chip_kvs_test");
        }
        case 9: {
            LogStep(9, "Reboot the accessory with no command line options");
            SetIdentity(kIdentityAlpha);
            return Reboot();
        }
        case 10: {
            LogStep(10, "Reboot the accessory with only discriminator command line option");
            SetIdentity(kIdentityAlpha);
            return Reboot(2222);
        }
        case 11: {
            LogStep(11, "Reboot the accessory with discriminator and port command line option");
            SetIdentity(kIdentityAlpha);
            return Reboot(2222, 5565);
        }
        case 12: {
            LogStep(12, "Reboot the accessory with all command line options");
            SetIdentity(kIdentityAlpha);
            return Reboot(2222, 5565, "/tmp/chip_kvs_test");
        }
        case 13: {
            LogStep(13, "Factory Reset the accessory");
            SetIdentity(kIdentityAlpha);
            return FactoryReset();
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestBindingSuite : public TestCommand
{
public:
    TestBindingSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestBinding", 9, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestBindingSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("binding", iter_0, 0));
                }
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("binding", iter_0, 0));
                    VerifyOrReturn(CheckValuePresent("binding[0].group", iter_0.GetValue().group));
                    VerifyOrReturn(CheckValue("binding[0].group.Value()", iter_0.GetValue().group.Value(), 1U));
                    VerifyOrReturn(CheckValue("binding[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("binding", iter_0, 1));
                    VerifyOrReturn(CheckValuePresent("binding[1].node", iter_0.GetValue().node));
                    VerifyOrReturn(CheckValue("binding[1].node.Value()", iter_0.GetValue().node.Value(), 1ULL));
                    VerifyOrReturn(CheckValuePresent("binding[1].endpoint", iter_0.GetValue().endpoint));
                    VerifyOrReturn(CheckValue("binding[1].endpoint.Value()", iter_0.GetValue().endpoint.Value(), 1U));
                    VerifyOrReturn(CheckValuePresent("binding[1].cluster", iter_0.GetValue().cluster));
                    VerifyOrReturn(CheckValue("binding[1].cluster.Value()", iter_0.GetValue().cluster.Value(), 6UL));
                    VerifyOrReturn(CheckValue("binding[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("binding", iter_0, 2));
                    VerifyOrReturn(CheckValuePresent("binding[2].node", iter_0.GetValue().node));
                    VerifyOrReturn(CheckValue("binding[2].node.Value()", iter_0.GetValue().node.Value(), 2ULL));
                    VerifyOrReturn(CheckValuePresent("binding[2].endpoint", iter_0.GetValue().endpoint));
                    VerifyOrReturn(CheckValue("binding[2].endpoint.Value()", iter_0.GetValue().endpoint.Value(), 1U));
                    VerifyOrReturn(CheckValue("binding[2].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("binding", iter_0, 3));
                }
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("binding", iter_0, 0));
                    VerifyOrReturn(CheckValuePresent("binding[0].node", iter_0.GetValue().node));
                    VerifyOrReturn(CheckValue("binding[0].node.Value()", iter_0.GetValue().node.Value(), 3ULL));
                    VerifyOrReturn(CheckValuePresent("binding[0].endpoint", iter_0.GetValue().endpoint));
                    VerifyOrReturn(CheckValue("binding[0].endpoint.Value()", iter_0.GetValue().endpoint.Value(), 1U));
                    VerifyOrReturn(CheckValue("binding[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("binding", iter_0, 1));
                }
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("binding", iter_0, 0));
                    VerifyOrReturn(CheckValuePresent("binding[0].group", iter_0.GetValue().group));
                    VerifyOrReturn(CheckValue("binding[0].group.Value()", iter_0.GetValue().group.Value(), 1U));
                    VerifyOrReturn(CheckValue("binding[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("binding", iter_0, 1));
                    VerifyOrReturn(CheckValuePresent("binding[1].node", iter_0.GetValue().node));
                    VerifyOrReturn(CheckValue("binding[1].node.Value()", iter_0.GetValue().node.Value(), 1ULL));
                    VerifyOrReturn(CheckValuePresent("binding[1].endpoint", iter_0.GetValue().endpoint));
                    VerifyOrReturn(CheckValue("binding[1].endpoint.Value()", iter_0.GetValue().endpoint.Value(), 1U));
                    VerifyOrReturn(CheckValuePresent("binding[1].cluster", iter_0.GetValue().cluster));
                    VerifyOrReturn(CheckValue("binding[1].cluster.Value()", iter_0.GetValue().cluster.Value(), 6UL));
                    VerifyOrReturn(CheckValue("binding[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("binding", iter_0, 2));
                    VerifyOrReturn(CheckValuePresent("binding[2].node", iter_0.GetValue().node));
                    VerifyOrReturn(CheckValue("binding[2].node.Value()", iter_0.GetValue().node.Value(), 2ULL));
                    VerifyOrReturn(CheckValuePresent("binding[2].endpoint", iter_0.GetValue().endpoint));
                    VerifyOrReturn(CheckValue("binding[2].endpoint.Value()", iter_0.GetValue().endpoint.Value(), 1U));
                    VerifyOrReturn(CheckValue("binding[2].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("binding", iter_0, 3));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Write empty binding table");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type> value;

            value = chip::app::DataModel::List<chip::app::Clusters::Binding::Structs::TargetStruct::Type>();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Binding::Id, Binding::Attributes::Binding::Id, value);
        }
        case 2: {
            LogStep(2, "Read empty binding table");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Binding::Id, Binding::Attributes::Binding::Id);
        }
        case 3: {
            LogStep(3, "Write invalid binding table");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].node.Emplace();
                listHolder_0->mList[1].node.Value() = 1ULL;
                listHolder_0->mList[1].group.Emplace();
                listHolder_0->mList[1].group.Value() = 1U;
                listHolder_0->mList[1].endpoint.Emplace();
                listHolder_0->mList[1].endpoint.Value() = 1U;
                listHolder_0->mList[1].cluster.Emplace();
                listHolder_0->mList[1].cluster.Value() = 6UL;
                listHolder_0->mList[1].fabricIndex     = 0;

                value =
                    chip::app::DataModel::List<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Binding::Id, Binding::Attributes::Binding::Id, value);
        }
        case 4: {
            LogStep(4, "Write binding table (endpoint 1)");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(3);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].group.Emplace();
                listHolder_0->mList[0].group.Value() = 1U;
                listHolder_0->mList[0].fabricIndex   = 0;

                listHolder_0->mList[1].node.Emplace();
                listHolder_0->mList[1].node.Value() = 1ULL;
                listHolder_0->mList[1].endpoint.Emplace();
                listHolder_0->mList[1].endpoint.Value() = 1U;
                listHolder_0->mList[1].cluster.Emplace();
                listHolder_0->mList[1].cluster.Value() = 6UL;
                listHolder_0->mList[1].fabricIndex     = 0;

                listHolder_0->mList[2].node.Emplace();
                listHolder_0->mList[2].node.Value() = 2ULL;
                listHolder_0->mList[2].endpoint.Emplace();
                listHolder_0->mList[2].endpoint.Value() = 1U;
                listHolder_0->mList[2].fabricIndex      = 0;

                value =
                    chip::app::DataModel::List<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(listHolder_0->mList, 3);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), Binding::Id, Binding::Attributes::Binding::Id, value);
        }
        case 5: {
            LogStep(5, "Read binding table (endpoint 1)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Binding::Id, Binding::Attributes::Binding::Id);
        }
        case 6: {
            LogStep(6, "Write binding table (endpoint 0)");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].node.Emplace();
                listHolder_0->mList[0].node.Value() = 3ULL;
                listHolder_0->mList[0].endpoint.Emplace();
                listHolder_0->mList[0].endpoint.Value() = 1U;
                listHolder_0->mList[0].fabricIndex      = 0;

                value =
                    chip::app::DataModel::List<chip::app::Clusters::Binding::Structs::TargetStruct::Type>(listHolder_0->mList, 1);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Binding::Id, Binding::Attributes::Binding::Id, value);
        }
        case 7: {
            LogStep(7, "Read binding table (endpoint 0)");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Binding::Id, Binding::Attributes::Binding::Id);
        }
        case 8: {
            LogStep(8, "Verify endpoint 1 not changed");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), Binding::Id, Binding::Attributes::Binding::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestUserLabelClusterSuite : public TestCommand
{
public:
    TestUserLabelClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestUserLabelCluster", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestUserLabelClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("labelList", iter_0, 0));
                }
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("labelList", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("labelList[0].label", iter_0.GetValue().label, chip::CharSpan("room", 4)));
                    VerifyOrReturn(
                        CheckValueAsString("labelList[0].value", iter_0.GetValue().value, chip::CharSpan("bedroom 2", 9)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("labelList", iter_0, 1));
                    VerifyOrReturn(
                        CheckValueAsString("labelList[1].label", iter_0.GetValue().label, chip::CharSpan("orientation", 11)));
                    VerifyOrReturn(CheckValueAsString("labelList[1].value", iter_0.GetValue().value, chip::CharSpan("North", 5)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("labelList", iter_0, 2));
                    VerifyOrReturn(CheckValueAsString("labelList[2].label", iter_0.GetValue().label, chip::CharSpan("floor", 5)));
                    VerifyOrReturn(CheckValueAsString("labelList[2].value", iter_0.GetValue().value, chip::CharSpan("5", 1)));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("labelList", iter_0, 3));
                    VerifyOrReturn(
                        CheckValueAsString("labelList[3].label", iter_0.GetValue().label, chip::CharSpan("direction", 9)));
                    VerifyOrReturn(CheckValueAsString("labelList[3].value", iter_0.GetValue().value, chip::CharSpan("up", 2)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("labelList", iter_0, 4));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Clear User Label List");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::UserLabel::Structs::LabelStruct::Type> value;

            value = chip::app::DataModel::List<chip::app::Clusters::UserLabel::Structs::LabelStruct::Type>();
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), UserLabel::Id, UserLabel::Attributes::LabelList::Id, value);
        }
        case 2: {
            LogStep(2, "Read User Label List");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), UserLabel::Id, UserLabel::Attributes::LabelList::Id);
        }
        case 3: {
            LogStep(3, "Write User Label List");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::UserLabel::Structs::LabelStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::UserLabel::Structs::LabelStruct::Type>(4);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].label = chip::Span<const char>("roomgarbage: not in length on purpose", 4);
                listHolder_0->mList[0].value = chip::Span<const char>("bedroom 2garbage: not in length on purpose", 9);

                listHolder_0->mList[1].label = chip::Span<const char>("orientationgarbage: not in length on purpose", 11);
                listHolder_0->mList[1].value = chip::Span<const char>("Northgarbage: not in length on purpose", 5);

                listHolder_0->mList[2].label = chip::Span<const char>("floorgarbage: not in length on purpose", 5);
                listHolder_0->mList[2].value = chip::Span<const char>("5garbage: not in length on purpose", 1);

                listHolder_0->mList[3].label = chip::Span<const char>("directiongarbage: not in length on purpose", 9);
                listHolder_0->mList[3].value = chip::Span<const char>("upgarbage: not in length on purpose", 2);

                value =
                    chip::app::DataModel::List<chip::app::Clusters::UserLabel::Structs::LabelStruct::Type>(listHolder_0->mList, 4);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), UserLabel::Id, UserLabel::Attributes::LabelList::Id, value);
        }
        case 4: {
            LogStep(4, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 5: {
            LogStep(5, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 6: {
            LogStep(6, "Verify");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), UserLabel::Id, UserLabel::Attributes::LabelList::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestArmFailSafeSuite : public TestCommand
{
public:
    TestArmFailSafeSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestArmFailSafe", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("payload", &mPayload);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestArmFailSafeSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<chip::CharSpan> mPayload;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckValueAsString("fabrics[0].label", iter_0.GetValue().label, chip::CharSpan("", 0)));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("errorCode", value.errorCode, 0));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("", 0)));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "Wait for the alpha device to be retrieved ");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2, "Query fabrics list");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id);
        }
        case 3: {
            LogStep(3, "ArmFailSafe on target device with timeout 0");
            chip::app::Clusters::GeneralCommissioning::Commands::ArmFailSafe::Type value;
            value.expiryLengthSeconds = 0U;
            value.breadcrumb          = 0ULL;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GeneralCommissioning::Id,
                               GeneralCommissioning::Commands::ArmFailSafe::Id, value);
        }
        case 4: {
            LogStep(4, "Reads NodeLabel mandatory attribute of target device");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestMultiAdminSuite : public TestCommand
{
public:
    TestMultiAdminSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestMultiAdmin", 17, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("nodeIdForDuplicateCommissioning", 0, UINT64_MAX, &mNodeIdForDuplicateCommissioning);
        AddArgument("nodeId2", 0, UINT64_MAX, &mNodeId2);
        AddArgument("nodeId3", 0, UINT64_MAX, &mNodeId3);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("payload", &mPayload);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestMultiAdminSuite()
    {
        if (readFromAlphaBuffer != nullptr)
        {
            chip::Platform::MemoryFree(readFromAlphaBuffer);
            readFromAlphaBuffer = nullptr;
        }
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::NodeId> mNodeIdForDuplicateCommissioning;
    chip::Optional<chip::NodeId> mNodeId2;
    chip::Optional<chip::NodeId> mNodeId3;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mDiscriminator;
    chip::Optional<chip::CharSpan> mPayload;
    chip::Optional<uint16_t> mTimeout;

    char * readFromAlphaBuffer = nullptr;
    chip::CharSpan readFromAlpha;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            VerifyOrReturn(CheckValue("clusterStatus", status.mClusterStatus.HasValue(), true));
            VerifyOrReturn(CheckValue("clusterStatus", status.mClusterStatus.Value(), 9));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("fabrics", iter_0, 0));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("fabrics", iter_0, 1));
                }
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("", 0)));

                if (readFromAlphaBuffer != nullptr)
                {
                    chip::Platform::MemoryFree(readFromAlphaBuffer);
                }
                readFromAlphaBuffer = static_cast<char *>(chip::Platform::MemoryAlloc(value.size()));
                memcpy(readFromAlphaBuffer, value.data(), value.size());
                readFromAlpha = chip::CharSpan(readFromAlphaBuffer, value.size());
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintNotValue("value", value, readFromAlpha));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Reboot target device");
            SetIdentity(kIdentityAlpha);
            return Reboot(mDiscriminator.HasValue() ? mDiscriminator.Value() : 3840U);
        }
        case 1: {
            LogStep(1, "Wait for the commissioned device to be retrieved for alpha");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 2: {
            LogStep(2, "Commission from alpha when the commissioning window is not opened");
            SetIdentity(kIdentityAlpha);
            return PairWithQRCode(mNodeIdForDuplicateCommissioning.HasValue() ? mNodeIdForDuplicateCommissioning.Value() : 17ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 3: {
            LogStep(3, "Open Commissioning Window from alpha");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 4: {
            LogStep(4, "Commission from alpha again");
            SetIdentity(kIdentityAlpha);
            return PairWithQRCode(mNodeIdForDuplicateCommissioning.HasValue() ? mNodeIdForDuplicateCommissioning.Value() : 17ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 5: {
            LogStep(5, "Check that we just have the one fabric and did not add a new one");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), OperationalCredentials::Id,
                                 OperationalCredentials::Attributes::Fabrics::Id, false);
        }
        case 6: {
            LogStep(6, "Close Commissioning Window after failed commissioning");
            chip::app::Clusters::AdministratorCommissioning::Commands::RevokeCommissioning::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::RevokeCommissioning::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 7: {
            LogStep(7, "Open Commissioning Window from alpha again");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 8: {
            LogStep(8, "Commission from beta");
            SetIdentity(kIdentityBeta);
            return PairWithQRCode(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 9: {
            LogStep(9, "Wait for the commissioned device to be retrieved for beta");
            SetIdentity(kIdentityBeta);
            return WaitForCommissionee(mNodeId2.HasValue() ? mNodeId2.Value() : 51966ULL);
        }
        case 10: {
            LogStep(10, "Open Commissioning Window from beta");
            chip::app::Clusters::AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Type value;
            value.commissioningTimeout = 180U;
            return SendCommand(kIdentityBeta, GetEndpoint(0), AdministratorCommissioning::Id,
                               AdministratorCommissioning::Commands::OpenBasicCommissioningWindow::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 11: {
            LogStep(11, "Commission from gamma");
            SetIdentity(kIdentityGamma);
            return PairWithQRCode(mNodeId3.HasValue() ? mNodeId3.Value() : 12586990ULL,
                                  mPayload.HasValue() ? mPayload.Value()
                                                      : chip::CharSpan::fromCharString("MT:-24J0AFN00KA0648G00"));
        }
        case 12: {
            LogStep(12, "Wait for the commissioned device to be retrieved for gamma");
            SetIdentity(kIdentityGamma);
            return WaitForCommissionee(mNodeId3.HasValue() ? mNodeId3.Value() : 12586990ULL);
        }
        case 13: {
            LogStep(13, "read the mandatory attribute: NodeLabel from alpha");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 14: {
            LogStep(14, "write the mandatory attribute NodeLabel from beta");
            chip::CharSpan value;
            value = chip::Span<const char>("written from betagarbage: not in length on purpose", 17);
            return WriteAttribute(kIdentityBeta, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 15: {
            LogStep(15, "read the mandatory attribute: NodeLabel from gamma");
            return ReadAttribute(kIdentityGamma, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 16: {
            LogStep(16, "write the mandatory attribute NodeLabel back to default");
            chip::CharSpan value;
            value = readFromAlpha;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWDIAG_1_1", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWDIAG_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "list"));
            }
            break;
        case 2:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 3:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 4:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Reads a list of ThreadMetrics struct non-global attribute from DUT.");
            VerifyOrdo(!ShouldSkip("A_THREADMETRICS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::ThreadMetrics::Id);
        }
        case 2: {
            LogStep(2, "Reads CurrentHeapFree non-global attribute value from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapFree::Id);
        }
        case 3: {
            LogStep(3, "Reads CurrentHeapUsed non-global attribute value from DUT");
            VerifyOrdo(!ShouldSkip("A_CURRENTHEAPUSED"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapUsed::Id);
        }
        case 4: {
            LogStep(4, "Reads CurrentHeapHighWaterMark non-global attribute value from DUT");
            VerifyOrdo(!ShouldSkip("A_CURRENTHEAPHIGHWATERMARK"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWDIAG_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWDIAG_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWDIAG_3_1Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWDIAG_3_1", 4, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWDIAG_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        case 3:
            if (IsUnsupported(status.mStatus))
            {
                return;
            }
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint64_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintType("value", "", "uint64"));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Sends ResetWatermarks to DUT");
            VerifyOrdo(!ShouldSkip("CR_RESETWATERMARKS"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            chip::app::Clusters::SoftwareDiagnostics::Commands::ResetWatermarks::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                               SoftwareDiagnostics::Commands::ResetWatermarks::Id, value);
        }
        case 2: {
            LogStep(2, "Reads CurrentHeapUsed attribute value from DUT");
            VerifyOrdo(!ShouldSkip("A_CURRENTHEAPUSED"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapUsed::Id);
        }
        case 3: {
            LogStep(3, "Reads CurrentHeapHighWaterMark attribute value from DUT");
            VerifyOrdo(!ShouldSkip("A_CURRENTHEAPHIGHWATERMARK"), return ContinueOnChipMainThread(CHIP_NO_ERROR));
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), SoftwareDiagnostics::Id,
                                 SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::Id);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestSubscribe_OnOffSuite : public TestCommand
{
public:
    TestSubscribe_OnOffSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestSubscribe_OnOff", 7, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestSubscribe_OnOffSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, false));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, true));
            }
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, false));
            }
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Set OnOff Attribute to false");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 2: {
            LogStep(2, "Subscribe OnOff Attribute");
            return SubscribeAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id, 2, 5);
        }
        case 3: {
            LogStep(3, "Turn On the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 4: {
            LogStep(4, "Check for attribute report");
            return WaitForReport();
        }
        case 5: {
            LogStep(5, "Turn Off the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 6: {
            LogStep(6, "Check for attribute report");
            return WaitForReport();
        }
        }
        return CHIP_NO_ERROR;
    }
};

class DL_UsersAndCredentialsSuite : public TestCommand
{
public:
    DL_UsersAndCredentialsSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("DL_UsersAndCredentials", 102, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~DL_UsersAndCredentialsSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint16_t NumberOfTotalUsersSupported;
    uint16_t NumberOfPINUsersSupported;
    uint16_t NumberOfRFIDUsersSupported;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfTotalUsersSupported", value, 10U));

                NumberOfTotalUsersSupported = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 1));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));

                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 305441741UL));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));

                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 305441741UL));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 3));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));

                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 305441741UL));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 3));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 6));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("new_user", 8)));

                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 305441741UL));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 3));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 6));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 2));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("test_user", 9)));

                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 466460832UL));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 1));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("test_user2", 10)));

                VerifyOrReturn(CheckValueNonNull("userUniqueId", value.userUniqueId));
                VerifyOrReturn(CheckValue("userUniqueId.Value()", value.userUniqueId.Value(), 12648430UL));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 2));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, NumberOfTotalUsersSupported));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("last_user", 9)));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNull("nextUserIndex", value.nextUserIndex));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, NumberOfTotalUsersSupported));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNull("nextUserIndex", value.nextUserIndex));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfPINUsersSupported", value, 10U));

                NumberOfPINUsersSupported = value;
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentials", value.credentials));
                {
                    auto iter_1 = value.credentials.Value().begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 1));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 1U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 1));
                }

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, true));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfRFIDUsersSupported", value, 10U));

                NumberOfRFIDUsersSupported = value;
            }
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentials", value.credentials));
                {
                    auto iter_1 = value.credentials.Value().begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 1));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 1U));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 1));
                    VerifyOrReturn(CheckValue("credentials.Value()[1].credentialType", iter_1.GetValue().credentialType, 2));
                    VerifyOrReturn(CheckValue("credentials.Value()[1].credentialIndex", iter_1.GetValue().credentialIndex, 2U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 2));
                }

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, true));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 3));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 2));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 5U));
            }
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 2));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 5U));
            }
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 2U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 2));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 5U));
            }
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentials", value.credentials));
                {
                    auto iter_1 = value.credentials.Value().begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 2));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 2U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 1));
                }

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 4U));
            }
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 2U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 2U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 3U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 7U));
            }
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 3U));
            }
            break;
        case 84:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 7U));
            }
            break;
        case 85:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 86:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 3U));
            }
            break;
        case 87:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 3U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 4U));
            }
            break;
        case 88:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 133));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 89:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 90:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNonNull("userName", value.userName));
                VerifyOrReturn(CheckValueAsString("userName.Value()", value.userName.Value(), chip::CharSpan("", 0)));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNonNull("userStatus", value.userStatus));
                VerifyOrReturn(CheckValue("userStatus.Value()", value.userStatus.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("userType", value.userType));
                VerifyOrReturn(CheckValue("userType.Value()", value.userType.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentialRule", value.credentialRule));
                VerifyOrReturn(CheckValue("credentialRule.Value()", value.credentialRule.Value(), 0));

                VerifyOrReturn(CheckValueNonNull("credentials", value.credentials));
                {
                    auto iter_1 = value.credentials.Value().begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialType", iter_1.GetValue().credentialType, 0));
                    VerifyOrReturn(CheckValue("credentials.Value()[0].credentialIndex", iter_1.GetValue().credentialIndex, 0U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.credentials.Value())>("credentials.Value()", iter_1, 1));
                }

                VerifyOrReturn(CheckValueNonNull("creatorFabricIndex", value.creatorFabricIndex));
                VerifyOrReturn(CheckValue("creatorFabricIndex.Value()", value.creatorFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));
                VerifyOrReturn(CheckValue("lastModifiedFabricIndex.Value()", value.lastModifiedFabricIndex.Value(), 1));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 91:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, true));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 92:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        case 93:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 94:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 95:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 96:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 97:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 98:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_COMMAND));
            break;
        case 99:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 100:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetUserResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValueNull("userName", value.userName));

                VerifyOrReturn(CheckValueNull("userUniqueId", value.userUniqueId));

                VerifyOrReturn(CheckValueNull("userStatus", value.userStatus));

                VerifyOrReturn(CheckValueNull("userType", value.userType));

                VerifyOrReturn(CheckValueNull("credentialRule", value.credentialRule));

                VerifyOrReturn(CheckValueNull("credentials", value.credentials));

                VerifyOrReturn(CheckValueNull("creatorFabricIndex", value.creatorFabricIndex));

                VerifyOrReturn(CheckValueNull("lastModifiedFabricIndex", value.lastModifiedFabricIndex));

                VerifyOrReturn(CheckValueNonNull("nextUserIndex", value.nextUserIndex));
                VerifyOrReturn(CheckValue("nextUserIndex.Value()", value.nextUserIndex.Value(), 2U));
            }
            break;
        case 101:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("credentialExists", value.credentialExists, false));

                VerifyOrReturn(CheckValueNull("userIndex", value.userIndex));

                VerifyOrReturn(CheckValueNull("nextCredentialIndex", value.nextCredentialIndex));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read available user slot and verify response fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 2: {
            LogStep(2, "Get number of supported users and verify default value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfTotalUsersSupported::Id);
        }
        case 3: {
            LogStep(3, "Read fails for user with index 0");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 4: {
            LogStep(4, "Read fails for user with index greater than Number Of Users Supported");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 5: {
            LogStep(5, "Create new user with default parameters");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 6: {
            LogStep(6, "Read the user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 7: {
            LogStep(7, "Set user at the occupied index fails with appropriate response");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 8: {
            LogStep(8, "Modify userName for existing user");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNonNull();
            value.userName.Value() = chip::Span<const char>("new_usergarbage: not in length on purpose", 8);
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 9: {
            LogStep(9, "Read the modified user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 10: {
            LogStep(10, "Modify userUniqueId for existing user");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNonNull();
            value.userUniqueId.Value() = 305441741UL;
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 11: {
            LogStep(11, "Read the modified user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 12: {
            LogStep(12, "Modify userStatus for existing user");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNonNull();
            value.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(3);
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 13: {
            LogStep(13, "Read the modified user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 14: {
            LogStep(14, "Modify userType for existing user");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNonNull();
            value.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(6);
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 15: {
            LogStep(15, "Read the modified user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 16: {
            LogStep(16, "Modify credentialRule for existing user");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNonNull();
            value.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(2);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 17: {
            LogStep(17, "Read the modified user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 18: {
            LogStep(18, "Modify all fields for existing user");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);
            value.userIndex     = 1U;
            value.userName.SetNonNull();
            value.userName.Value() = chip::Span<const char>("test_usergarbage: not in length on purpose", 9);
            value.userUniqueId.SetNonNull();
            value.userUniqueId.Value() = 466460832UL;
            value.userStatus.SetNonNull();
            value.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(1);
            value.userType.SetNonNull();
            value.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(0);
            value.credentialRule.SetNonNull();
            value.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 19: {
            LogStep(19, "Read the modified user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 20: {
            LogStep(20, "Add another user with non-default fields");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 2U;
            value.userName.SetNonNull();
            value.userName.Value() = chip::Span<const char>("test_user2garbage: not in length on purpose", 10);
            value.userUniqueId.SetNonNull();
            value.userUniqueId.Value() = 12648430UL;
            value.userStatus.SetNonNull();
            value.userStatus.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserStatus>(1);
            value.userType.SetNonNull();
            value.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(1);
            value.credentialRule.SetNonNull();
            value.credentialRule.Value() = static_cast<chip::app::Clusters::DoorLock::DlCredentialRule>(2);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 21: {
            LogStep(21, "Read the new user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 22: {
            LogStep(22, "Create user in the last slot");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = NumberOfTotalUsersSupported;
            value.userName.SetNonNull();
            value.userName.Value() = chip::Span<const char>("last_usergarbage: not in length on purpose", 9);
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 23: {
            LogStep(23, "Read the last user back and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = NumberOfTotalUsersSupported;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 24: {
            LogStep(24, "User creation in the 0 slot fails");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 0U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 25: {
            LogStep(25, "User creation in the out-of-bounds slot fails");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 26: {
            LogStep(26, "Clear first user");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 27: {
            LogStep(27, "Read cleared user and verify it is available");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 28: {
            LogStep(28, "Create new user in the cleared slot");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 1U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 29: {
            LogStep(29, "Read the user in the previously cleared slot and verify its fields");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 30: {
            LogStep(30, "Clear user with index 0 fails");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 31: {
            LogStep(31, "Clear user with out-of-bounds index fails");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 32: {
            LogStep(32, "Clear all users");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 65534U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 33: {
            LogStep(33, "Read first cleared user and verify it is available");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 34: {
            LogStep(34, "Read last cleared user and verify it is available");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = NumberOfTotalUsersSupported;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 35: {
            LogStep(35, "Get number of supported PIN credentials and verify default value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::NumberOfPINUsersSupported::Id);
        }
        case 36: {
            LogStep(36, "Check that PIN credential does not exist");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 37: {
            LogStep(37, "Reading PIN credential with index 0 fails");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 38: {
            LogStep(38, "Reading PIN credential with out-of-bounds index fails");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 39: {
            LogStep(39, "Create new PIN credential and user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 40: {
            LogStep(40, "Verify created user");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 41: {
            LogStep(41, "Verify created PIN credential");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 42: {
            LogStep(42, "Create new PIN credential and user with index 0 fails");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 0U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 43: {
            LogStep(43, "Create new PIN credential and user with out-of-bounds index fails");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 44: {
            LogStep(44, "Get number of supported RFID credentials and verify default value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfRFIDUsersSupported::Id);
        }
        case 45: {
            LogStep(45, "Reading RFID credential with index 0 fails");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 46: {
            LogStep(46, "Reading RFID credential with out-of-bounds index fails");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 47: {
            LogStep(47, "Check that RFID credential does not exist");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 48: {
            LogStep(48, "Create new RFID credential and add it to existing user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_123456garbage: not in length on purpose"), 16);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 1U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 49: {
            LogStep(49, "Verify modified user");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 50: {
            LogStep(50, "Verify created credential");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 51: {
            LogStep(51, "Create new RFID credential and user with index 0 fails");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 0U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("new_rfid_data_fieldgarbage: not in length on purpose"), 19);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 52: {
            LogStep(52, "Create new RFID credential and user with out-of-bounds index fails");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("new_rfid_data_fieldgarbage: not in length on purpose"), 19);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 53: {
            LogStep(53, "Create new PIN credential and try to add it to existing user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 1U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 54: {
            LogStep(54, "Create new credential and try to add it to 0 user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 55: {
            LogStep(55, "Create new credential and try to add it to out-of-bounds user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123465garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = static_cast<uint16_t>(NumberOfTotalUsersSupported + 1);
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 56: {
            LogStep(56, "Create new PIN with too short data");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("12345garbage: not in length on purpose"), 5);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 57: {
            LogStep(57, "Create new PIN with too long data");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456789garbage: not in length on purpose"), 9);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 58: {
            LogStep(58, "Create new RFID with too short data");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("rfid_datagarbage: not in length on purpose"), 9);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 59: {
            LogStep(59, "Create new PIN with Programming user type fails");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNonNull();
            value.userType.Value() = static_cast<chip::app::Clusters::DoorLock::DlUserType>(3);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 60: {
            LogStep(60, "Create new RFID with too short data");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(
                chip::Uint8::from_const_char("very_long_rfid_data_to_test_boundariesgarbage: not in length on purpose"), 38);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 0U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 61: {
            LogStep(61, "Create new PIN credential with data the would cause duplicate");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 4U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 62: {
            LogStep(62, "Create new RFID credential with data the would cause duplicate");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 4U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_123456garbage: not in length on purpose"), 16);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 63: {
            LogStep(63, "Modify credentialData of existing PIN credential");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNonNull();
            value.userIndex.Value() = 1U;
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 64: {
            LogStep(64, "Verify that credential was changed by creating new credential with old data");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 65: {
            LogStep(65, "Verify that credential was changed by creating new credential with new data");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 4U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 66: {
            LogStep(66, "Clear first PIN credential");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 67: {
            LogStep(67, "Read back the credential and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 68: {
            LogStep(68, "Read the user back and make sure PIN credential is deleted");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 69: {
            LogStep(69, "Clear the second PIN credential");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 3U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 70: {
            LogStep(70, "Read back the credential and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 3U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 71: {
            LogStep(71, "Read the user back and make sure related user is deleted");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 72: {
            LogStep(72, "Create new RFID credential with user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 1U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_12345garbage: not in length on purpose"), 15);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 73: {
            LogStep(73, "Clear all the RFID credentials");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.Value().credentialIndex = 65534U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 74: {
            LogStep(74, "Read back the fist RFID credential and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 75: {
            LogStep(75, "Read back the second RFID credential and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 76: {
            LogStep(76, "Read the user related with first RFID back and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 77: {
            LogStep(77, "Read the user related with second RFID back and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 78: {
            LogStep(78, "Create new PIN credential with user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 79: {
            LogStep(79, "Create new RFID credential with user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_1234garbage: not in length on purpose"), 14);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 80: {
            LogStep(80, "Create another RFID credential with user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 6U;

            value.credentialData =
                chip::ByteSpan(chip::Uint8::from_const_char("rfid_data_9876garbage: not in length on purpose"), 14);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 81: {
            LogStep(81, "Clear all the credentials");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 82: {
            LogStep(82, "Read back the first PIN credential and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 83: {
            LogStep(83, "Read back the first RFID credential and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.credentialIndex = 2U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 84: {
            LogStep(84, "Read back the second PIN credential and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 6U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 85: {
            LogStep(85, "Read the user related with first PIN back and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 86: {
            LogStep(86, "Read the user related with first RFID back and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 87: {
            LogStep(87, "Read the user related with second PIN back and make sure it is deleted");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 3U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 88: {
            LogStep(88, "Create new Programming PIN credential with invalid index");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 89: {
            LogStep(89, "Create new Programming PIN credential with valid index");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 0U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 90: {
            LogStep(90, "Verify created user");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 91: {
            LogStep(91, "Verify created programming PIN credential");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        case 92: {
            LogStep(92, "Modify the Programming PIN credential");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(2);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 0U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("654321garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 93: {
            LogStep(93, "Clearing Programming PIN fails");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.Value().credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 94: {
            LogStep(94, "Clearing Programming PIN with invalid index fails");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.Value().credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 95: {
            LogStep(95, "Clearing PIN credential with zero index fails");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 96: {
            LogStep(96, "Clearing PIN credential with out-of-bound index fails");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = static_cast<uint16_t>(NumberOfPINUsersSupported + 1);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 97: {
            LogStep(97, "Clearing RFID credential with zero index fails");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.Value().credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 98: {
            LogStep(98, "Clearing RFID credential with out-of-bound index fails");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(2);
            value.credential.Value().credentialIndex = static_cast<uint16_t>(NumberOfRFIDUsersSupported + 1);

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 99: {
            LogStep(99, "Clear the Programming PIN user");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 100: {
            LogStep(100, "Make sure Programming PIN user is deleted");
            chip::app::Clusters::DoorLock::Commands::GetUser::Type value;
            value.userIndex = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetUser::Id, value);
        }
        case 101: {
            LogStep(101, "Make sure programming PIN credential is deleted");
            chip::app::Clusters::DoorLock::Commands::GetCredentialStatus::Type value;

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(0);
            value.credential.credentialIndex = 0U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetCredentialStatus::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class DL_LockUnlockSuite : public TestCommand
{
public:
    DL_LockUnlockSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("DL_LockUnlock", 11, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~DL_LockUnlockSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 1));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 2));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_FAILURE));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 2));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 1));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Create new PIN credential and lock/unlock user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 2: {
            LogStep(2, "Try to unlock the door with invalid PIN");
            chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::UnlockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "Verify that lock state attribute value is set to Locked");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 4: {
            LogStep(4, "Try to unlock the door with valid PIN");
            chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::UnlockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 5: {
            LogStep(5, "Verify that lock state attribute value is set to Unlocked");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 6: {
            LogStep(6, "Try to lock the door with invalid PIN");
            chip::app::Clusters::DoorLock::Commands::LockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("000000garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::LockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 7: {
            LogStep(7, "Verify that lock state attribute value is set to Unlocked");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 8: {
            LogStep(8, "Try to unlock the door with valid PIN");
            chip::app::Clusters::DoorLock::Commands::LockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::LockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 9: {
            LogStep(9, "Verify that lock state attribute value is set to Locked");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 10: {
            LogStep(10, "Clean the created credential");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        }
        return CHIP_NO_ERROR;
    }
};

class DL_SchedulesSuite : public TestCommand
{
public:
    DL_SchedulesSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("DL_Schedules", 84, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~DL_SchedulesSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    uint16_t NumberOfTotalUsersSupported;
    uint8_t NumberOfWeekDaySchedulesSupportedPerUser;
    uint8_t NumberOfYearDaySchedulesSupportedPerUser;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfTotalUsersSupported", value, 10U));

                NumberOfTotalUsersSupported = value;
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfWeekDaySchedulesSupportedPerUser", value, 10));

                NumberOfWeekDaySchedulesSupportedPerUser = value;
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint8_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("numberOfYearDaySchedulesSupportedPerUser", value, 10));

                NumberOfYearDaySchedulesSupportedPerUser = value;
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 0));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 21:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex,
                                          static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1)));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 22:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 0U));

                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 23:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, static_cast<uint8_t>(NumberOfTotalUsersSupported + 1)));

                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 24:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 25:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 26:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 27:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 28:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 29:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 30:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 31:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 32:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 0));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 33:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex,
                                          static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1)));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 34:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 0U));

                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 35:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, static_cast<uint8_t>(NumberOfTotalUsersSupported + 1)));

                VerifyOrReturn(CheckValue("status", value.status, 133));
            }
            break;
        case 36:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 37:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 38:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 1));

                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 15));

                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 16));

                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 18));

                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 0));
            }
            break;
        case 39:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 40:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 12345UL));

                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 12345689UL));
            }
            break;
        case 41:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 42:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 43:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 44:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 45:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 46:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 47:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 48:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 49:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_INVALID_FIELD));
            break;
        case 50:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 51:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 1));

                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 15));

                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 16));

                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 18));

                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 0));
            }
            break;
        case 52:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 12345UL));

                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 12345689UL));
            }
            break;
        case 53:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 54:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 2));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 2));

                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 0));

                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 0));

                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 23));

                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 59));
            }
            break;
        case 55:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 56:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 2));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 9000UL));

                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 888888888UL));
            }
            break;
        case 57:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 58:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 59:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 60:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 2));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 61:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 12345UL));

                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 12345689UL));
            }
            break;
        case 62:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 2));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 9000UL));

                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 888888888UL));
            }
            break;
        case 63:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 64:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 65:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 66:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 67:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 2));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 68:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 2));

                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 0));

                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 0));

                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 23));

                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 59));
            }
            break;
        case 69:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 70:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 71:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 72:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 1));

                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 0));

                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 0));

                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 23));

                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 59));
            }
            break;
        case 73:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 74:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 4));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 9000UL));

                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 888888888UL));
            }
            break;
        case 75:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 76:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 4));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("daysMask", value.daysMask));
                VerifyOrReturn(CheckValue("daysMask.Value()", value.daysMask.Value(), 64));

                VerifyOrReturn(CheckValuePresent("startHour", value.startHour));
                VerifyOrReturn(CheckValue("startHour.Value()", value.startHour.Value(), 23));

                VerifyOrReturn(CheckValuePresent("startMinute", value.startMinute));
                VerifyOrReturn(CheckValue("startMinute.Value()", value.startMinute.Value(), 0));

                VerifyOrReturn(CheckValuePresent("endHour", value.endHour));
                VerifyOrReturn(CheckValue("endHour.Value()", value.endHour.Value(), 23));

                VerifyOrReturn(CheckValuePresent("endMinute", value.endMinute));
                VerifyOrReturn(CheckValue("endMinute.Value()", value.endMinute.Value(), 59));
            }
            break;
        case 77:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 78:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValuePresent("localStartTime", value.localStartTime));
                VerifyOrReturn(CheckValue("localStartTime.Value()", value.localStartTime.Value(), 55555UL));

                VerifyOrReturn(CheckValuePresent("localEndTime", value.localEndTime));
                VerifyOrReturn(CheckValue("localEndTime.Value()", value.localEndTime.Value(), 7777777UL));
            }
            break;
        case 79:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 80:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 81:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 4));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 1U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 82:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("weekDayIndex", value.weekDayIndex, 4));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        case 83:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("yearDayIndex", value.yearDayIndex, 1));

                VerifyOrReturn(CheckValue("userIndex", value.userIndex, 2U));

                VerifyOrReturn(CheckValue("status", value.status, 139));
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Create new PIN credential and schedule user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 2: {
            LogStep(2, "Get number of supported users");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfTotalUsersSupported::Id);
        }
        case 3: {
            LogStep(3, "Get Max number of Week Day schedules for user and verify default value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfWeekDaySchedulesSupportedPerUser::Id);
        }
        case 4: {
            LogStep(4, "Get Max number of Year Day schedules for user and verify default value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id,
                                 DoorLock::Attributes::NumberOfYearDaySchedulesSupportedPerUser::Id);
        }
        case 5: {
            LogStep(5, "Create Week Day schedule with 0 index");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 0;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 6: {
            LogStep(6, "Create Week Day schedule with out-of-bounds index");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 7: {
            LogStep(7, "Create Week Day schedule with 0 user index");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 0U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 8: {
            LogStep(8, "Create Week Day schedule with out-of-bounds user index");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 9: {
            LogStep(9, "Create Week Day schedule for non-existing user");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 2U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 10: {
            LogStep(10, "Create Week Day schedule with 0 days mask");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(0);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 11: {
            LogStep(11, "Create Week Day schedule for Sunday and Monday");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(3);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 12: {
            LogStep(12, "Create Week Day schedule for Sunday Wednesday and Saturday");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(73);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 13: {
            LogStep(13, "Create Week Day schedule with invalid start hour");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 24;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 14: {
            LogStep(14, "Create Week Day schedule with invalid start minute");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 60;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 15: {
            LogStep(15, "Create Week Day schedule with invalid end hour");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 24;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 16: {
            LogStep(16, "Create Week Day schedule with invalid end minute");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 60;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 17: {
            LogStep(17, "Create Week Day schedule with start hour later that end hour");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 19;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 18: {
            LogStep(18, "Create Week Day schedule with start minute later that end minute when hours are equal");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 50;
            value.endHour      = 15;
            value.endMinute    = 49;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 19: {
            LogStep(19, "Make sure that previous operations did not create a schedule");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 20: {
            LogStep(20, "Get Week Day schedule with 0 index");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 0;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 21: {
            LogStep(21, "Get Week Day schedule with out-of-bounds index");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 22: {
            LogStep(22, "Get Week Day schedule with 0 user index");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 23: {
            LogStep(23, "Get Week Day schedule with out-of-bounds user index");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 24: {
            LogStep(24, "Get Week Day schedule with non-existing user index");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 25: {
            LogStep(25, "Create Year Day schedule with 0 index");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 0;
            value.userIndex      = 1U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 26: {
            LogStep(26, "Create Year Day schedule with out-of-bounds index");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
            value.userIndex      = 1U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 27: {
            LogStep(27, "Create Year Day schedule with 0 user index");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 0U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 28: {
            LogStep(28, "Create Year Day schedule with out-of-bounds user index");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 29: {
            LogStep(29, "Create Year Day schedule for non-existing user");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 2U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 30: {
            LogStep(30, "Create Year Day schedule with start hour later that end hour");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 1U;
            value.localStartTime = 12345689UL;
            value.localEndTime   = 12345688UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 31: {
            LogStep(31, "Make sure that previous operations did not create a schedule");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 32: {
            LogStep(32, "Get Year Day schedule with 0 index");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 0;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 33: {
            LogStep(33, "Get Year Day schedule with out-of-bounds index");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 34: {
            LogStep(34, "Get Year Day schedule with 0 user index");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 35: {
            LogStep(35, "Get Year Day schedule with out-of-bounds user index");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 36: {
            LogStep(36, "Get Year Day schedule with non-existing user index");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 37: {
            LogStep(37, "Create Week Day schedule with valid parameters");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 15;
            value.startMinute  = 16;
            value.endHour      = 18;
            value.endMinute    = 0;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 38: {
            LogStep(38, "Verify created schedule");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 39: {
            LogStep(39, "Create Year Day schedule with valid parameters");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 1U;
            value.localStartTime = 12345UL;
            value.localEndTime   = 12345689UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 40: {
            LogStep(40, "Verify created schedule");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 41: {
            LogStep(41, "Clear Week Day schedule with 0 index");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 0;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 42: {
            LogStep(42, "Clear Week Day schedule with out-of-bounds index");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = static_cast<uint8_t>(NumberOfWeekDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 43: {
            LogStep(43, "Clear Week Day schedule with 0 user index");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 44: {
            LogStep(44, "Clear Week Day schedule with out-of-bounds user index");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 45: {
            LogStep(45, "Clear Week Day schedule with non-existing user");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 46: {
            LogStep(46, "Clear Year Day schedule with 0 index");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 0;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 47: {
            LogStep(47, "Clear Year Day schedule with out-of-bounds index");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = static_cast<uint8_t>(NumberOfYearDaySchedulesSupportedPerUser + 1);
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 48: {
            LogStep(48, "Clear Year Day schedule with 0 user index");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 49: {
            LogStep(49, "Clear Year Day schedule with out-of-bounds user index");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = static_cast<uint8_t>(NumberOfTotalUsersSupported + 1);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 50: {
            LogStep(50, "Clear Year Day schedule with non-existing user");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 51: {
            LogStep(51, "Make sure that week day schedule was not deleted");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 52: {
            LogStep(52, "Make sure that year day schedule was not deleted");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 53: {
            LogStep(53, "Create another Week Day schedule with valid parameters");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 2;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(2);
            value.startHour    = 0;
            value.startMinute  = 0;
            value.endHour      = 23;
            value.endMinute    = 59;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 54: {
            LogStep(54, "Verify created week day schedule");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 55: {
            LogStep(55, "Create another Year Day schedule with valid parameters");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 2;
            value.userIndex      = 1U;
            value.localStartTime = 9000UL;
            value.localEndTime   = 888888888UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 56: {
            LogStep(56, "Verify created year day schedule");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 57: {
            LogStep(57, "Clear a single week day schedule for the first user");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 58: {
            LogStep(58, "Verify cleared week day schedule");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 59: {
            LogStep(59, "Clear all remaining week day schedules for the first user");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 254;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 60: {
            LogStep(60, "Verify cleared week schedule");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 61: {
            LogStep(61, "Make sure that first year day schedule was not deleted");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 62: {
            LogStep(62, "Make sure that second year day schedule was not deleted");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 63: {
            LogStep(63, "Create another Week Day schedule with valid parameters");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(2);
            value.startHour    = 0;
            value.startMinute  = 0;
            value.endHour      = 23;
            value.endMinute    = 59;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 64: {
            LogStep(64, "Clear a single year day schedule for the first user");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 65: {
            LogStep(65, "Verify cleared year day schedule");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 66: {
            LogStep(66, "Clear all remaining year schedules for the first user");
            chip::app::Clusters::DoorLock::Commands::ClearYearDaySchedule::Type value;
            value.yearDayIndex = 254;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearYearDaySchedule::Id, value);
        }
        case 67: {
            LogStep(67, "Verify that second year day schedule was cleared");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 2;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 68: {
            LogStep(68, "Verify created week day schedule");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 69: {
            LogStep(69, "Clear all remaining week day schedules for the first user");
            chip::app::Clusters::DoorLock::Commands::ClearWeekDaySchedule::Type value;
            value.weekDayIndex = 254;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearWeekDaySchedule::Id, value);
        }
        case 70: {
            LogStep(70, "Create new user without credential so we can add more schedules to it");
            chip::app::Clusters::DoorLock::Commands::SetUser::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);
            value.userIndex     = 2U;
            value.userName.SetNull();
            value.userUniqueId.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            value.credentialRule.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 71: {
            LogStep(71, "Create Week Day schedule with valid parameters for first user");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(1);
            value.startHour    = 0;
            value.startMinute  = 0;
            value.endHour      = 23;
            value.endMinute    = 59;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 72: {
            LogStep(72, "Verify created week day schedule for first user");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 73: {
            LogStep(73, "Create Year Day schedule for first user");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 4;
            value.userIndex      = 1U;
            value.localStartTime = 9000UL;
            value.localEndTime   = 888888888UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 74: {
            LogStep(74, "Verify created year day schedule for first");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 4;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 75: {
            LogStep(75, "Create Week Day schedule with valid parameters for second user");
            chip::app::Clusters::DoorLock::Commands::SetWeekDaySchedule::Type value;
            value.weekDayIndex = 4;
            value.userIndex    = 2U;
            value.daysMask     = static_cast<chip::BitFlags<chip::app::Clusters::DoorLock::DlDaysMaskMap>>(64);
            value.startHour    = 23;
            value.startMinute  = 0;
            value.endHour      = 23;
            value.endMinute    = 59;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetWeekDaySchedule::Id, value);
        }
        case 76: {
            LogStep(76, "Verify created week day schedule for first user");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 4;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 77: {
            LogStep(77, "Create Year Day schedule for second user");
            chip::app::Clusters::DoorLock::Commands::SetYearDaySchedule::Type value;
            value.yearDayIndex   = 1;
            value.userIndex      = 1U;
            value.localStartTime = 55555UL;
            value.localEndTime   = 7777777UL;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetYearDaySchedule::Id, value);
        }
        case 78: {
            LogStep(78, "Verify created year day schedule for first");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 79: {
            LogStep(79, "Cleanup");
            chip::app::Clusters::DoorLock::Commands::ClearUser::Type value;
            value.userIndex = 65534U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearUser::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 80: {
            LogStep(80, "Make sure clearing first user also cleared week day schedules");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 1;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 81: {
            LogStep(81, "Make sure clearing first user also cleared year day schedules");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 4;
            value.userIndex    = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        case 82: {
            LogStep(82, "Make sure clearing second user also cleared week day schedules");
            chip::app::Clusters::DoorLock::Commands::GetWeekDaySchedule::Type value;
            value.weekDayIndex = 4;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetWeekDaySchedule::Id, value);
        }
        case 83: {
            LogStep(83, "Make sure clearing second user also cleared year day schedules");
            chip::app::Clusters::DoorLock::Commands::GetYearDaySchedule::Type value;
            value.yearDayIndex = 1;
            value.userIndex    = 2U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::GetYearDaySchedule::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DL_1_3Suite : public TestCommand
{
public:
    Test_TC_DL_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DL_1_3", 9, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DL_1_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValueNonNull("userIndex", value.userIndex));
                VerifyOrReturn(CheckValue("userIndex.Value()", value.userIndex.Value(), 1U));

                VerifyOrReturn(CheckValueNonNull("nextCredentialIndex", value.nextCredentialIndex));
                VerifyOrReturn(CheckValue("nextCredentialIndex.Value()", value.nextCredentialIndex.Value(), 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint32_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("autoRelockTime", value, 10UL));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNonNull("lockState", value));
                VerifyOrReturn(CheckValue("lockState.Value()", value.Value(), 1));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Create new PIN credential and lock/unlock user");
            chip::app::Clusters::DoorLock::Commands::SetCredential::Type value;
            value.operationType = static_cast<chip::app::Clusters::DoorLock::DlDataOperationType>(0);

            value.credential.credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.credentialIndex = 1U;

            value.credentialData = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            value.userIndex.SetNull();
            value.userStatus.SetNull();
            value.userType.SetNull();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::SetCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 2: {
            LogStep(2, "Precondition: Door is in locked state");
            chip::app::Clusters::DoorLock::Commands::LockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::LockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 3: {
            LogStep(3, "TH writes AutoRelockTime attribute value as 10 seconds on the DUT");
            uint32_t value;
            value = 10UL;
            return WriteAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::AutoRelockTime::Id, value);
        }
        case 4: {
            LogStep(4, "TH sends the unlock Door command to the DUT with valid PINCode");
            chip::app::Clusters::DoorLock::Commands::UnlockDoor::Type value;
            value.pinCode.Emplace();
            value.pinCode.Value() = chip::ByteSpan(chip::Uint8::from_const_char("123456garbage: not in length on purpose"), 6);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::UnlockDoor::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        case 5: {
            LogStep(5, "TH reads AutoRelockTime attribute from DUT");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::AutoRelockTime::Id);
        }
        case 6: {
            LogStep(6, "Wait 10000ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(10000);
        }
        case 7: {
            LogStep(7, "TH reads LockState attriute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Attributes::LockState::Id);
        }
        case 8: {
            LogStep(8, "Clean the created credential");
            chip::app::Clusters::DoorLock::Commands::ClearCredential::Type value;
            value.credential.SetNonNull();

            value.credential.Value().credentialType  = static_cast<chip::app::Clusters::DoorLock::DlCredentialType>(1);
            value.credential.Value().credentialIndex = 1U;

            return SendCommand(kIdentityAlpha, GetEndpoint(1), DoorLock::Id, DoorLock::Commands::ClearCredential::Id, value,
                               chip::Optional<uint16_t>(10000));
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestGroupMessagingSuite : public TestCommand
{
public:
    TestGroupMessagingSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestGroupMessaging", 15, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestGroupMessagingSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 257U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 258U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("", 0)));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("xyzzy", 5)));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::CharSpan value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueAsString("nodeLabel", value, chip::CharSpan("", 0)));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                bool value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("onOff", value, 1));
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Add Group 1 (endpoint 1)");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 257U;
            value.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 2: {
            LogStep(2, "Add Group 2 (endpoint 0)");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 258U;
            value.groupName = chip::Span<const char>("Group #2garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(0), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 3: {
            LogStep(3, "KeySet Write 1");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 417U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(0);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 1110000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 1110001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 1110002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 4: {
            LogStep(4, "KeySet Write 2");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 418U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(0);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 2220000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 2220001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 2220002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 5: {
            LogStep(5, "Write Group Keys");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].groupId       = 257U;
                listHolder_0->mList[0].groupKeySetID = 417U;
                listHolder_0->mList[0].fabricIndex   = 1;

                listHolder_0->mList[1].groupId       = 258U;
                listHolder_0->mList[1].groupKeySetID = 418U;
                listHolder_0->mList[1].fabricIndex   = 1;

                value = chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                  GroupKeyManagement::Attributes::GroupKeyMap::Id, value);
        }
        case 6: {
            LogStep(6, "Install ACLs");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(4);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(3);
                listHolder_0->mList[1].subjects.SetNull();
                listHolder_0->mList[1].targets.SetNull();
                listHolder_0->mList[1].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        case 7: {
            LogStep(7, "Read initial Attribute value");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 8: {
            LogStep(8, "Group Write Attribute");
            chip::CharSpan value;
            value = chip::Span<const char>("xyzzygarbage: not in length on purpose", 5);
            return WriteGroupAttribute(kIdentityAlpha, 258, Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 9: {
            LogStep(9, "Read back Attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 10: {
            LogStep(10, "Restore initial Attribute value");
            chip::CharSpan value;
            value = chip::Span<const char>("garbage: not in length on purpose", 0);
            return WriteGroupAttribute(kIdentityAlpha, 258, Basic::Id, Basic::Attributes::NodeLabel::Id, value);
        }
        case 11: {
            LogStep(11, "Read back Attribute");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), Basic::Id, Basic::Attributes::NodeLabel::Id);
        }
        case 12: {
            LogStep(12, "Turn On the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 13: {
            LogStep(13, "Check on/off attribute value is true after on command for endpoint 1");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(1), OnOff::Id, OnOff::Attributes::OnOff::Id);
        }
        case 14: {
            LogStep(14, "Cleanup ACLs");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 0;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 1);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestGroupsClusterSuite : public TestCommand
{
public:
    TestGroupsClusterSuite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("TestGroupsCluster", 19, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestGroupsClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 135));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 0U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));

                VerifyOrReturn(CheckValueAsString("groupName", value.groupName, chip::CharSpan("Group #1", 8)));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 4369U));
            }
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("capacity", value.capacity));

                {
                    auto iter_0 = value.groupList.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.groupList)>("groupList", iter_0, 0));
                    VerifyOrReturn(CheckValue("groupList[0]", iter_0.GetValue(), 1U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.groupList)>("groupList", iter_0, 1));
                }
            }
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 32767U));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));

                VerifyOrReturn(CheckValueAsString("groupName", value.groupName, chip::CharSpan("Group #1", 8)));
            }
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::RemoveGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 135));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 0U));
            }
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::RemoveGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 4U));
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));

                VerifyOrReturn(CheckValueAsString("groupName", value.groupName, chip::CharSpan("Group #1", 8)));
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 4369U));
            }
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("capacity", value.capacity));

                {
                    auto iter_0 = value.groupList.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value.groupList)>("groupList", iter_0, 0));
                    VerifyOrReturn(CheckValue("groupList[0]", iter_0.GetValue(), 1U));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.groupList)>("groupList", iter_0, 1));
                }
            }
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 1U));
            }
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 4369U));
            }
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::ViewGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 139));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 32767U));
            }
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValueNull("capacity", value.capacity));

                {
                    auto iter_0 = value.groupList.begin();
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value.groupList)>("groupList", iter_0, 0));
                }
            }
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "View Group 0 (invalid)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 2: {
            LogStep(2, "View Group 1 (not found)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 3: {
            LogStep(3, "Add Group 1 (new)");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 1U;
            value.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 4: {
            LogStep(4, "View Group 1 (new)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 5: {
            LogStep(5, "View Group 2 (not found)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 4369U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 6: {
            LogStep(6, "Get Group Membership 1 (all)");
            ListFreer listFreer;
            chip::app::Clusters::Groups::Commands::GetGroupMembership::Type value;

            value.groupList = chip::app::DataModel::List<chip::GroupId>();
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::GetGroupMembership::Id, value);
        }
        case 7: {
            LogStep(7, "View Group 3 (not found)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 32767U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 8: {
            LogStep(8, "View Group 1 (existing)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 9: {
            LogStep(9, "Remove Group 0 (invalid)");
            chip::app::Clusters::Groups::Commands::RemoveGroup::Type value;
            value.groupId = 0U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::RemoveGroup::Id, value);
        }
        case 10: {
            LogStep(10, "Remove Group 4 (not found)");
            chip::app::Clusters::Groups::Commands::RemoveGroup::Type value;
            value.groupId = 4U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::RemoveGroup::Id, value);
        }
        case 11: {
            LogStep(11, "View Group 1 (not removed)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 12: {
            LogStep(12, "View Group 2 (removed)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 4369U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 13: {
            LogStep(13, "Get Group Membership 3");
            ListFreer listFreer;
            chip::app::Clusters::Groups::Commands::GetGroupMembership::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::GroupId>(4);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1U;
                listHolder_0->mList[1] = 2U;
                listHolder_0->mList[2] = 4369U;
                listHolder_0->mList[3] = 3U;
                value.groupList        = chip::app::DataModel::List<chip::GroupId>(listHolder_0->mList, 4);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::GetGroupMembership::Id, value);
        }
        case 14: {
            LogStep(14, "Remove All");
            chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::RemoveAllGroups::Id, value);
        }
        case 15: {
            LogStep(15, "View Group 1 (removed)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 1U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 16: {
            LogStep(16, "View Group 2 (still removed)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 4369U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 17: {
            LogStep(17, "View Group 3 (removed)");
            chip::app::Clusters::Groups::Commands::ViewGroup::Type value;
            value.groupId = 32767U;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::ViewGroup::Id, value);
        }
        case 18: {
            LogStep(18, "Get Group Membership 4");
            ListFreer listFreer;
            chip::app::Clusters::Groups::Commands::GetGroupMembership::Type value;

            {
                auto * listHolder_0 = new ListHolder<chip::GroupId>(5);
                listFreer.add(listHolder_0);
                listHolder_0->mList[0] = 1U;
                listHolder_0->mList[1] = 2U;
                listHolder_0->mList[2] = 4369U;
                listHolder_0->mList[3] = 3U;
                listHolder_0->mList[4] = 32767U;
                value.groupList        = chip::app::DataModel::List<chip::GroupId>(listHolder_0->mList, 5);
            }
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::GetGroupMembership::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestGroupKeyManagementClusterSuite : public TestCommand
{
public:
    TestGroupKeyManagementClusterSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupKeyManagementCluster", 18, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestGroupKeyManagementClusterSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckConstraintMinValue("value", value, 2U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                uint16_t value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("maxGroupKeysPerFabric", value, 2U));
            }
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 257U));
            }
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 258U));
            }
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("groupKeySet.groupKeySetID", value.groupKeySet.groupKeySetID, 417U));
                VerifyOrReturn(CheckValue("groupKeySet.groupKeySecurityPolicy", value.groupKeySet.groupKeySecurityPolicy, 0));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey0", value.groupKeySet.epochKey0));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime0", value.groupKeySet.epochStartTime0));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime0.Value()", value.groupKeySet.epochStartTime0.Value(), 1110000ULL));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey1", value.groupKeySet.epochKey1));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime1", value.groupKeySet.epochStartTime1));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime1.Value()", value.groupKeySet.epochStartTime1.Value(), 1110001ULL));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey2", value.groupKeySet.epochKey2));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime2", value.groupKeySet.epochStartTime2));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime2.Value()", value.groupKeySet.epochStartTime2.Value(), 1110002ULL));
            }
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_CONSTRAINT_ERROR));
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("groupKeyMap", iter_0, 0));
                    VerifyOrReturn(CheckValue("groupKeyMap[0].groupId", iter_0.GetValue().groupId, 257U));
                    VerifyOrReturn(CheckValue("groupKeyMap[0].groupKeySetID", iter_0.GetValue().groupKeySetID, 417U));
                    VerifyOrReturn(CheckValue("groupKeyMap[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("groupKeyMap", iter_0, 1));
                    VerifyOrReturn(CheckValue("groupKeyMap[1].groupId", iter_0.GetValue().groupId, 258U));
                    VerifyOrReturn(CheckValue("groupKeyMap[1].groupKeySetID", iter_0.GetValue().groupKeySetID, 418U));
                    VerifyOrReturn(CheckValue("groupKeyMap[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("groupKeyMap", iter_0, 2));
                }
            }
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::DataModel::DecodableList<
                    chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType>
                    value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                {
                    auto iter_0 = value.begin();
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("groupTable", iter_0, 0));
                    VerifyOrReturn(CheckValue("groupTable[0].groupId", iter_0.GetValue().groupId, 257U));
                    VerifyOrReturn(CheckValuePresent("groupTable[0].groupName", iter_0.GetValue().groupName));
                    VerifyOrReturn(CheckValueAsString("groupTable[0].groupName.Value()", iter_0.GetValue().groupName.Value(),
                                                      chip::CharSpan("Group #1", 8)));
                    VerifyOrReturn(CheckValue("groupTable[0].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNextListItemDecodes<decltype(value)>("groupTable", iter_0, 1));
                    VerifyOrReturn(CheckValue("groupTable[1].groupId", iter_0.GetValue().groupId, 258U));
                    VerifyOrReturn(CheckValuePresent("groupTable[1].groupName", iter_0.GetValue().groupName));
                    VerifyOrReturn(CheckValueAsString("groupTable[1].groupName.Value()", iter_0.GetValue().groupName.Value(),
                                                      chip::CharSpan("Group #2", 8)));
                    VerifyOrReturn(CheckValue("groupTable[1].fabricIndex", iter_0.GetValue().fabricIndex, 1));
                    VerifyOrReturn(CheckNoMoreListItems<decltype(value)>("groupTable", iter_0, 2));
                }
            }
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("groupKeySet.groupKeySetID", value.groupKeySet.groupKeySetID, 418U));
                VerifyOrReturn(CheckValue("groupKeySet.groupKeySecurityPolicy", value.groupKeySet.groupKeySecurityPolicy, 1));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey0", value.groupKeySet.epochKey0));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime0", value.groupKeySet.epochStartTime0));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime0.Value()", value.groupKeySet.epochStartTime0.Value(), 2110000ULL));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey1", value.groupKeySet.epochKey1));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime1", value.groupKeySet.epochStartTime1));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime1.Value()", value.groupKeySet.epochStartTime1.Value(), 2110001ULL));
                VerifyOrReturn(CheckValueNull("groupKeySet.epochKey2", value.groupKeySet.epochKey2));
                VerifyOrReturn(CheckValueNonNull("groupKeySet.epochStartTime2", value.groupKeySet.epochStartTime2));
                VerifyOrReturn(
                    CheckValue("groupKeySet.epochStartTime2.Value()", value.groupKeySet.epochStartTime2.Value(), 2110002ULL));
            }
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), EMBER_ZCL_STATUS_NOT_FOUND));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Read maxGroupsPerFabric");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                 GroupKeyManagement::Attributes::MaxGroupsPerFabric::Id);
        }
        case 2: {
            LogStep(2, "Read maxGroupKeysPerFabric");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                 GroupKeyManagement::Attributes::MaxGroupKeysPerFabric::Id);
        }
        case 3: {
            LogStep(3, "Add Group 1");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 257U;
            value.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 4: {
            LogStep(4, "Add Group 2");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 258U;
            value.groupName = chip::Span<const char>("Group #2garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 5: {
            LogStep(5, "KeySet Write 1");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 417U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(0);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 1110000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 1110001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 1110002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 6: {
            LogStep(6, "KeySet Write 2");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 418U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(1);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 2110000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 2110001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 2110002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 7: {
            LogStep(7, "KeySet Read");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type value;
            value.groupKeySetID = 417U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id, GroupKeyManagement::Commands::KeySetRead::Id,
                               value);
        }
        case 8: {
            LogStep(8, "Write Group Keys (invalid)");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].groupId       = 258U;
                listHolder_0->mList[0].groupKeySetID = 0U;
                listHolder_0->mList[0].fabricIndex   = 1;

                value = chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 1);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                  GroupKeyManagement::Attributes::GroupKeyMap::Id, value);
        }
        case 9: {
            LogStep(9, "Write Group Keys");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].groupId       = 257U;
                listHolder_0->mList[0].groupKeySetID = 417U;
                listHolder_0->mList[0].fabricIndex   = 1;

                listHolder_0->mList[1].groupId       = 258U;
                listHolder_0->mList[1].groupKeySetID = 418U;
                listHolder_0->mList[1].fabricIndex   = 1;

                value = chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                  GroupKeyManagement::Attributes::GroupKeyMap::Id, value);
        }
        case 10: {
            LogStep(10, "Read Group Keys");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                 GroupKeyManagement::Attributes::GroupKeyMap::Id);
        }
        case 11: {
            LogStep(11, "Read GroupTable");
            return ReadAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                 GroupKeyManagement::Attributes::GroupTable::Id);
        }
        case 12: {
            LogStep(12, "KeySet Remove 1");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRemove::Type value;
            value.groupKeySetID = 417U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetRemove::Id, value);
        }
        case 13: {
            LogStep(13, "KeySet Read (removed)");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type value;
            value.groupKeySetID = 417U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id, GroupKeyManagement::Commands::KeySetRead::Id,
                               value);
        }
        case 14: {
            LogStep(14, "KeySet Read (not removed)");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type value;
            value.groupKeySetID = 418U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id, GroupKeyManagement::Commands::KeySetRead::Id,
                               value);
        }
        case 15: {
            LogStep(15, "Remove All");
            chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type value;
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::RemoveAllGroups::Id, value);
        }
        case 16: {
            LogStep(16, "KeySet Remove 2");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRemove::Type value;
            value.groupKeySetID = 418U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetRemove::Id, value);
        }
        case 17: {
            LogStep(17, "KeySet Read (also removed)");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetRead::Type value;
            value.groupKeySetID = 418U;
            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id, GroupKeyManagement::Commands::KeySetRead::Id,
                               value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_5Suite : public TestCommand
{
public:
    Test_TC_DD_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_5", 1, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Step 1");
            SetIdentity(kIdentityAlpha);
            return Log("Verify that the onboarding payload for NFC tags SHALL use NDEF URI Record Type Definition as defined by "
                       "NFC Forum in URI Record Type Definition RTD URI");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_6Suite : public TestCommand
{
public:
    Test_TC_DD_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_6", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Step 1");
            SetIdentity(kIdentityAlpha);
            return Log("Scan the DUTs QR code using a QR code reader");
        }
        case 1: {
            LogStep(1, "Step 1 verification");
            SetIdentity(kIdentityAlpha);
            return Log(
                "Verify the QR code gets scanned successfully and the QR code must be of sufficient size and contrast respective "
                "to surface material as to be readable with standard readers such as smartphones in normal lighting conditions");
        }
        case 2: {
            LogStep(2, "Step 2 verificaiton");
            SetIdentity(kIdentityAlpha);
            return Log("Verify QR code version is 1 or higher");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_7Suite : public TestCommand
{
public:
    Test_TC_DD_1_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_7", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_7Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Precondition");
            SetIdentity(kIdentityAlpha);
            return Log("Verify manual pairing code is printed on the device or in additional provided materials");
        }
        case 1: {
            LogStep(1, "Step 1");
            SetIdentity(kIdentityAlpha);
            return Log("Verify that the Manual Pairing Code should be printed using a minimum font size of 6 points typically "
                       "producing a typeface height of 2.1 mm");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_8Suite : public TestCommand
{
public:
    Test_TC_DD_1_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_8", 2, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_8Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Step 1");
            SetIdentity(kIdentityAlpha);
            return Log("Scan the device QR code using DUT");
        }
        case 1: {
            LogStep(1, "Step 1 verification");
            SetIdentity(kIdentityAlpha);
            return Log(
                "Verify the DUT is able to scan and parse the QR code successfully to onboard the device onto the CHIP network");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_9Suite : public TestCommand
{
public:
    Test_TC_DD_1_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_9", 3, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_9Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Precondition");
            SetIdentity(kIdentityAlpha);
            return Log("Verify that the manual pairing code is printed on the device or in additional provided materials");
        }
        case 1: {
            LogStep(1, "Step 1");
            SetIdentity(kIdentityAlpha);
            return Log(
                "Provide the 11 digit or 21 digit pairing code from the Device in text speech or any format supported by DUT");
        }
        case 2: {
            LogStep(2, "Step 1 verification");
            SetIdentity(kIdentityAlpha);
            return Log("Verify that the manual pairing code can be provided to DUT and parsed to onboard the device onto the CHIP "
                       "network");
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_1_10Suite : public TestCommand
{
public:
    Test_TC_DD_1_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_1_10", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_1_10Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_2_1Suite : public TestCommand
{
public:
    Test_TC_DD_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_2_2Suite : public TestCommand
{
public:
    Test_TC_DD_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_1Suite : public TestCommand
{
public:
    Test_TC_DD_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_2Suite : public TestCommand
{
public:
    Test_TC_DD_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_5Suite : public TestCommand
{
public:
    Test_TC_DD_3_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_5", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_6Suite : public TestCommand
{
public:
    Test_TC_DD_3_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_6", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_9Suite : public TestCommand
{
public:
    Test_TC_DD_3_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_9", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_9Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_10Suite : public TestCommand
{
public:
    Test_TC_DD_3_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_10", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_10Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_11Suite : public TestCommand
{
public:
    Test_TC_DD_3_11Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_11", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_11Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_12Suite : public TestCommand
{
public:
    Test_TC_DD_3_12Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_12", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_12Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_13Suite : public TestCommand
{
public:
    Test_TC_DD_3_13Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_13", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_13Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_3_14Suite : public TestCommand
{
public:
    Test_TC_DD_3_14Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_3_14", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_3_14Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DD_4_1Suite : public TestCommand
{
public:
    Test_TC_DD_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DD_4_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DD_4_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class TestGroupDemoCommandSuite : public TestCommand
{
public:
    TestGroupDemoCommandSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupDemoCommand", 21, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestGroupDemoCommandSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 5:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 6:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 7:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 8:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 9:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 10:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 11:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 12:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 13:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 14:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 15:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 16:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 17:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 18:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 19:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 20:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Turn On the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 2: {
            LogStep(2, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 3: {
            LogStep(3, "Turn Off the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 4: {
            LogStep(4, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 5: {
            LogStep(5, "Turn On the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 6: {
            LogStep(6, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 7: {
            LogStep(7, "Turn Off the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 8: {
            LogStep(8, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 9: {
            LogStep(9, "Turn On the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 10: {
            LogStep(10, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 11: {
            LogStep(11, "Turn Off the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 12: {
            LogStep(12, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 13: {
            LogStep(13, "Turn On the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 14: {
            LogStep(14, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 15: {
            LogStep(15, "Turn Off the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 16: {
            LogStep(16, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 17: {
            LogStep(17, "Turn On the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::On::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::On::Id, value);
        }
        case 18: {
            LogStep(18, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        case 19: {
            LogStep(19, "Turn Off the light to see attribute change");
            chip::app::Clusters::OnOff::Commands::Off::Type value;
            return SendGroupCommand(kIdentityAlpha, 257, OnOff::Id, OnOff::Commands::Off::Id, value);
        }
        case 20: {
            LogStep(20, "Wait 100ms");
            SetIdentity(kIdentityAlpha);
            return WaitForMs(1000);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class TestGroupDemoConfigSuite : public TestCommand
{
public:
    TestGroupDemoConfigSuite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("TestGroupDemoConfig", 5, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~TestGroupDemoConfigSuite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        case 0:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            shouldContinue = true;
            break;
        case 1:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            {
                chip::app::Clusters::Groups::Commands::AddGroupResponse::DecodableType value;
                VerifyOrReturn(CheckDecodeValue(chip::app::DataModel::Decode(*data, value)));
                VerifyOrReturn(CheckValue("status", value.status, 0));

                VerifyOrReturn(CheckValue("groupId", value.groupId, 257U));
            }
            break;
        case 2:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 3:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        case 4:
            VerifyOrReturn(CheckValue("status", chip::to_underlying(status.mStatus), 0));
            break;
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        case 0: {
            LogStep(0, "Wait for the commissioned device to be retrieved");
            SetIdentity(kIdentityAlpha);
            return WaitForCommissionee(mNodeId.HasValue() ? mNodeId.Value() : 305414945ULL);
        }
        case 1: {
            LogStep(1, "Add Group 1 - endpoint 1");
            chip::app::Clusters::Groups::Commands::AddGroup::Type value;
            value.groupId   = 257U;
            value.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);
            return SendCommand(kIdentityAlpha, GetEndpoint(1), Groups::Id, Groups::Commands::AddGroup::Id, value);
        }
        case 2: {
            LogStep(2, "KeySet Write 1");
            chip::app::Clusters::GroupKeyManagement::Commands::KeySetWrite::Type value;

            value.groupKeySet.groupKeySetID = 417U;
            value.groupKeySet.groupKeySecurityPolicy =
                static_cast<chip::app::Clusters::GroupKeyManagement::GroupKeySecurityPolicy>(0);
            value.groupKeySet.epochKey0.SetNonNull();
            value.groupKeySet.epochKey0.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime0.SetNonNull();
            value.groupKeySet.epochStartTime0.Value() = 1110000ULL;
            value.groupKeySet.epochKey1.SetNonNull();
            value.groupKeySet.epochKey1.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime1.SetNonNull();
            value.groupKeySet.epochStartTime1.Value() = 1110001ULL;
            value.groupKeySet.epochKey2.SetNonNull();
            value.groupKeySet.epochKey2.Value() = chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317garbage: not in length on purpose"),
                16);
            value.groupKeySet.epochStartTime2.SetNonNull();
            value.groupKeySet.epochStartTime2.Value() = 1110002ULL;

            return SendCommand(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                               GroupKeyManagement::Commands::KeySetWrite::Id, value);
        }
        case 3: {
            LogStep(3, "Map Group Key Set to group ID on a given fabric");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(1);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].groupId       = 257U;
                listHolder_0->mList[0].groupKeySetID = 417U;
                listHolder_0->mList[0].fabricIndex   = 1;

                value = chip::app::DataModel::List<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>(
                    listHolder_0->mList, 1);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), GroupKeyManagement::Id,
                                  GroupKeyManagement::Attributes::GroupKeyMap::Id, value);
        }
        case 4: {
            LogStep(4, "Install ACLs for test");
            ListFreer listFreer;
            chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type> value;

            {
                auto * listHolder_0 = new ListHolder<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(2);
                listFreer.add(listHolder_0);

                listHolder_0->mList[0].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(5);
                listHolder_0->mList[0].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(2);
                listHolder_0->mList[0].subjects.SetNull();
                listHolder_0->mList[0].targets.SetNull();
                listHolder_0->mList[0].fabricIndex = 1;

                listHolder_0->mList[1].privilege = static_cast<chip::app::Clusters::AccessControl::Privilege>(3);
                listHolder_0->mList[1].authMode  = static_cast<chip::app::Clusters::AccessControl::AuthMode>(3);
                listHolder_0->mList[1].subjects.SetNonNull();

                {
                    auto * listHolder_3 = new ListHolder<uint64_t>(1);
                    listFreer.add(listHolder_3);
                    listHolder_3->mList[0]                  = 257ULL;
                    listHolder_0->mList[1].subjects.Value() = chip::app::DataModel::List<uint64_t>(listHolder_3->mList, 1);
                }
                listHolder_0->mList[1].targets.SetNull();
                listHolder_0->mList[1].fabricIndex = 1;

                value = chip::app::DataModel::List<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>(
                    listHolder_0->mList, 2);
            }
            return WriteAttribute(kIdentityAlpha, GetEndpoint(0), AccessControl::Id, AccessControl::Attributes::Acl::Id, value);
        }
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_1_1Suite : public TestCommand
{
public:
    Test_TC_BDX_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_1_2Suite : public TestCommand
{
public:
    Test_TC_BDX_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_1_3Suite : public TestCommand
{
public:
    Test_TC_BDX_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_1_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_1_5Suite : public TestCommand
{
public:
    Test_TC_BDX_1_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_5", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_1_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_1_6Suite : public TestCommand
{
public:
    Test_TC_BDX_1_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_1_6", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_1_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_2_1Suite : public TestCommand
{
public:
    Test_TC_BDX_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_2_2Suite : public TestCommand
{
public:
    Test_TC_BDX_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_2_3Suite : public TestCommand
{
public:
    Test_TC_BDX_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_2_4Suite : public TestCommand
{
public:
    Test_TC_BDX_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_2_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BDX_2_5Suite : public TestCommand
{
public:
    Test_TC_BDX_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BDX_2_5", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BDX_2_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BR_1Suite : public TestCommand
{
public:
    Test_TC_BR_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BR_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BR_2Suite : public TestCommand
{
public:
    Test_TC_BR_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BR_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BR_3Suite : public TestCommand
{
public:
    Test_TC_BR_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BR_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BR_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BRAC_2_1Suite : public TestCommand
{
public:
    Test_TC_BRAC_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BRAC_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BRAC_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_BRAC_2_2Suite : public TestCommand
{
public:
    Test_TC_BRAC_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_BRAC_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_BRAC_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_1_2Suite : public TestCommand
{
public:
    Test_TC_DM_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_1_4Suite : public TestCommand
{
public:
    Test_TC_DM_1_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_1_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_1_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_2_3Suite : public TestCommand
{
public:
    Test_TC_DM_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_2_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_2_4Suite : public TestCommand
{
public:
    Test_TC_DM_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_2_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_2_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_3_2Suite : public TestCommand
{
public:
    Test_TC_DM_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_3_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_3_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DM_3_4Suite : public TestCommand
{
public:
    Test_TC_DM_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DM_3_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DM_3_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DIAG_LOG_1_1Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_LOG_1_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DIAG_LOG_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DIAG_LOG_1_2Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_LOG_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DIAG_LOG_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DIAG_LOG_1_3Suite : public TestCommand
{
public:
    Test_TC_DIAG_LOG_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_DIAG_LOG_1_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DIAG_LOG_1_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_DESC_1_1Suite : public TestCommand
{
public:
    Test_TC_DESC_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_DESC_1_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_DESC_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_ETHDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_ETHDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_ETHDIAG_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ETHDIAG_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_GC_1_2Suite : public TestCommand
{
public:
    Test_TC_GC_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_GC_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_GC_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_GC_1_3Suite : public TestCommand
{
public:
    Test_TC_GC_1_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_GC_1_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_GC_1_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_GENDIAG_1_1Suite : public TestCommand
{
public:
    Test_TC_GENDIAG_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_GENDIAG_1_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_GENDIAG_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_GENDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_GENDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_GENDIAG_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_GENDIAG_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_GENDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_GENDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_GENDIAG_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_GENDIAG_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_I_2_2Suite : public TestCommand
{
public:
    Test_TC_I_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_I_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_I_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_ILL_2_2Suite : public TestCommand
{
public:
    Test_TC_ILL_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_ILL_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_ILL_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_1_1Suite : public TestCommand
{
public:
    Test_TC_IDM_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_1_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_1_2Suite : public TestCommand
{
public:
    Test_TC_IDM_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_2_1Suite : public TestCommand
{
public:
    Test_TC_IDM_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_2_2Suite : public TestCommand
{
public:
    Test_TC_IDM_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_3_1Suite : public TestCommand
{
public:
    Test_TC_IDM_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_3_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_3_2Suite : public TestCommand
{
public:
    Test_TC_IDM_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_3_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_3_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_4_1Suite : public TestCommand
{
public:
    Test_TC_IDM_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_4_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_4_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_4_2Suite : public TestCommand
{
public:
    Test_TC_IDM_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_4_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_4_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_5_1Suite : public TestCommand
{
public:
    Test_TC_IDM_5_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_5_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_5_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_5_2Suite : public TestCommand
{
public:
    Test_TC_IDM_5_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_5_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_5_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_6_1Suite : public TestCommand
{
public:
    Test_TC_IDM_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_6_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_6_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_6_2Suite : public TestCommand
{
public:
    Test_TC_IDM_6_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_6_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_6_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_6_3Suite : public TestCommand
{
public:
    Test_TC_IDM_6_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_6_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_6_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_IDM_6_4Suite : public TestCommand
{
public:
    Test_TC_IDM_6_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_IDM_6_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_IDM_6_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_12Suite : public TestCommand
{
public:
    Test_TC_MC_3_12Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_12", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_12Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_3_13Suite : public TestCommand
{
public:
    Test_TC_MC_3_13Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_3_13", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_3_13Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_4_1Suite : public TestCommand
{
public:
    Test_TC_MC_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_4_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_4_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_8_2Suite : public TestCommand
{
public:
    Test_TC_MC_8_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_8_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_8_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_9_2Suite : public TestCommand
{
public:
    Test_TC_MC_9_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_9_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_9_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_10_2Suite : public TestCommand
{
public:
    Test_TC_MC_10_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_10_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_10_3Suite : public TestCommand
{
public:
    Test_TC_MC_10_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_10_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_10_4Suite : public TestCommand
{
public:
    Test_TC_MC_10_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_10_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_10_5Suite : public TestCommand
{
public:
    Test_TC_MC_10_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_5", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_10_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MC_10_6Suite : public TestCommand
{
public:
    Test_TC_MC_10_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MC_10_6", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MC_10_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_1Suite : public TestCommand
{
public:
    Test_TC_MF_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_2Suite : public TestCommand
{
public:
    Test_TC_MF_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_7Suite : public TestCommand
{
public:
    Test_TC_MF_1_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_7", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_7Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_8Suite : public TestCommand
{
public:
    Test_TC_MF_1_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_8", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_8Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_9Suite : public TestCommand
{
public:
    Test_TC_MF_1_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_9", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_9Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_10Suite : public TestCommand
{
public:
    Test_TC_MF_1_10Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_10", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_10Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_11Suite : public TestCommand
{
public:
    Test_TC_MF_1_11Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_11", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_11Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_12Suite : public TestCommand
{
public:
    Test_TC_MF_1_12Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_12", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_12Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_13Suite : public TestCommand
{
public:
    Test_TC_MF_1_13Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_13", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_13Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_14Suite : public TestCommand
{
public:
    Test_TC_MF_1_14Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_14", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_14Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_16Suite : public TestCommand
{
public:
    Test_TC_MF_1_16Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_16", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_16Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_17Suite : public TestCommand
{
public:
    Test_TC_MF_1_17Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_17", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_17Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_18Suite : public TestCommand
{
public:
    Test_TC_MF_1_18Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_18", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_18Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_19Suite : public TestCommand
{
public:
    Test_TC_MF_1_19Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_19", 0, credsIssuerConfig)
    {
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_19Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_20Suite : public TestCommand
{
public:
    Test_TC_MF_1_20Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_20", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_20Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_21Suite : public TestCommand
{
public:
    Test_TC_MF_1_21Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_21", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_21Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_22Suite : public TestCommand
{
public:
    Test_TC_MF_1_22Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_22", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_22Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_23Suite : public TestCommand
{
public:
    Test_TC_MF_1_23Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_23", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_23Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_24Suite : public TestCommand
{
public:
    Test_TC_MF_1_24Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_24", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_24Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_25Suite : public TestCommand
{
public:
    Test_TC_MF_1_25Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_25", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_25Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_26Suite : public TestCommand
{
public:
    Test_TC_MF_1_26Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_26", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_26Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_27Suite : public TestCommand
{
public:
    Test_TC_MF_1_27Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_27", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_27Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MF_1_28Suite : public TestCommand
{
public:
    Test_TC_MF_1_28Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MF_1_28", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MF_1_28Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MOD_1_2Suite : public TestCommand
{
public:
    Test_TC_MOD_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MOD_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MOD_2_1Suite : public TestCommand
{
public:
    Test_TC_MOD_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MOD_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MOD_2_2Suite : public TestCommand
{
public:
    Test_TC_MOD_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MOD_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MOD_3_1Suite : public TestCommand
{
public:
    Test_TC_MOD_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_3_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MOD_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MOD_3_2Suite : public TestCommand
{
public:
    Test_TC_MOD_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_3_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MOD_3_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_MOD_3_3Suite : public TestCommand
{
public:
    Test_TC_MOD_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_MOD_3_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_MOD_3_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_1_1Suite : public TestCommand
{
public:
    Test_TC_SU_1_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_1_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_1_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_2_1Suite : public TestCommand
{
public:
    Test_TC_SU_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_2_2Suite : public TestCommand
{
public:
    Test_TC_SU_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_2_3Suite : public TestCommand
{
public:
    Test_TC_SU_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_2_4Suite : public TestCommand
{
public:
    Test_TC_SU_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_2_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_2_5Suite : public TestCommand
{
public:
    Test_TC_SU_2_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_5", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_2_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_2_6Suite : public TestCommand
{
public:
    Test_TC_SU_2_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_6", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_2_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_2_7Suite : public TestCommand
{
public:
    Test_TC_SU_2_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_2_7", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_2_7Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_3_1Suite : public TestCommand
{
public:
    Test_TC_SU_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_3_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_3_2Suite : public TestCommand
{
public:
    Test_TC_SU_3_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_3_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_3_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_3_3Suite : public TestCommand
{
public:
    Test_TC_SU_3_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_3_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_3_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_3_4Suite : public TestCommand
{
public:
    Test_TC_SU_3_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_3_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_3_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_4_1Suite : public TestCommand
{
public:
    Test_TC_SU_4_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_4_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_4_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SU_4_2Suite : public TestCommand
{
public:
    Test_TC_SU_4_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SU_4_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SU_4_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PSCFG_2_1Suite : public TestCommand
{
public:
    Test_TC_PSCFG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PSCFG_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PSCFG_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PSCFG_3_1Suite : public TestCommand
{
public:
    Test_TC_PSCFG_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PSCFG_3_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PSCFG_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SC_4_5Suite : public TestCommand
{
public:
    Test_TC_SC_4_5Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_5", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SC_4_5Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SC_4_6Suite : public TestCommand
{
public:
    Test_TC_SC_4_6Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_6", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SC_4_6Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SC_4_7Suite : public TestCommand
{
public:
    Test_TC_SC_4_7Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_7", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SC_4_7Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SC_4_8Suite : public TestCommand
{
public:
    Test_TC_SC_4_8Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_8", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SC_4_8Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SC_4_9Suite : public TestCommand
{
public:
    Test_TC_SC_4_9Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SC_4_9", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SC_4_9Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_SWDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_SWDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_SWDIAG_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_SWDIAG_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WIFIDIAG_1_2Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_1_2Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WIFIDIAG_1_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WIFIDIAG_1_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WIFIDIAG_2_1Suite : public TestCommand
{
public:
    Test_TC_WIFIDIAG_2_1Suite(CredentialIssuerCommands * credsIssuerConfig) :
        TestCommand("Test_TC_WIFIDIAG_2_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WIFIDIAG_2_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_WNCV_6_1Suite : public TestCommand
{
public:
    Test_TC_WNCV_6_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_WNCV_6_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_WNCV_6_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_FLW_3_1Suite : public TestCommand
{
public:
    Test_TC_FLW_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_FLW_3_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_FLW_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_2_3Suite : public TestCommand
{
public:
    Test_TC_OCC_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_2_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_2_4Suite : public TestCommand
{
public:
    Test_TC_OCC_2_4Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_2_4", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_2_4Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_OCC_3_1Suite : public TestCommand
{
public:
    Test_TC_OCC_3_1Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_OCC_3_1", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_OCC_3_1Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PRS_2_2Suite : public TestCommand
{
public:
    Test_TC_PRS_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PRS_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PRS_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PRS_2_3Suite : public TestCommand
{
public:
    Test_TC_PRS_2_3Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PRS_2_3", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PRS_2_3Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

class Test_TC_PS_2_2Suite : public TestCommand
{
public:
    Test_TC_PS_2_2Suite(CredentialIssuerCommands * credsIssuerConfig) : TestCommand("Test_TC_PS_2_2", 0, credsIssuerConfig)
    {
        AddArgument("nodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("cluster", &mCluster);
        AddArgument("endpoint", 0, UINT16_MAX, &mEndpoint);
        AddArgument("timeout", 0, UINT16_MAX, &mTimeout);
    }

    ~Test_TC_PS_2_2Suite() {}

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mTimeout.ValueOr(kTimeoutInSeconds));
    }

private:
    chip::Optional<chip::NodeId> mNodeId;
    chip::Optional<chip::CharSpan> mCluster;
    chip::Optional<chip::EndpointId> mEndpoint;
    chip::Optional<uint16_t> mTimeout;

    chip::EndpointId GetEndpoint(chip::EndpointId endpoint) { return mEndpoint.HasValue() ? mEndpoint.Value() : endpoint; }

    //
    // Tests methods
    //

    void OnResponse(const chip::app::StatusIB & status, chip::TLV::TLVReader * data) override
    {
        bool shouldContinue = false;

        switch (mTestIndex - 1)
        {
        default:
            LogErrorOnFailure(ContinueOnChipMainThread(CHIP_ERROR_INVALID_ARGUMENT));
        }

        if (shouldContinue)
        {
            ContinueOnChipMainThread(CHIP_NO_ERROR);
        }
    }

    CHIP_ERROR DoTestStep(uint16_t testIndex) override
    {
        using namespace chip::app::Clusters;
        switch (testIndex)
        {
        }
        return CHIP_NO_ERROR;
    }
};

#endif // CONFIG_ENABLE_YAML_TESTS

void registerCommandsTests(Commands & commands, CredentialIssuerCommands * credsIssuerConfig)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
#if CONFIG_ENABLE_YAML_TESTS
        make_unique<TestList>(),
        make_unique<ManualTestList>(),
        make_unique<TestAccessControlClusterSuite>(credsIssuerConfig),
        make_unique<Test_TC_BI_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BI_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BI_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BOOL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BOOL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_4_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_5_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_6_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_7_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_8_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_CC_9_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_EMR_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_ILL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ILL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_LVL_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_11Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_1_12Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_11Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_5_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_6_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_7_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_7_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_8_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_9_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_15Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_OO_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_PS_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PS_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PRS_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PRS_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_PCC_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_PSCFG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_RH_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWTCH_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWTCH_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSTAT_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_TSUIC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_TH_NW_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_TH_NW_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_LC_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_4_5Suite>(credsIssuerConfig),
        make_unique<TV_TargetNavigatorClusterSuite>(credsIssuerConfig),
        make_unique<TV_AudioOutputClusterSuite>(credsIssuerConfig),
        make_unique<TV_ApplicationLauncherClusterSuite>(credsIssuerConfig),
        make_unique<TV_KeypadInputClusterSuite>(credsIssuerConfig),
        make_unique<TV_AccountLoginClusterSuite>(credsIssuerConfig),
        make_unique<TV_WakeOnLanClusterSuite>(credsIssuerConfig),
        make_unique<TV_ApplicationBasicClusterSuite>(credsIssuerConfig),
        make_unique<TV_MediaPlaybackClusterSuite>(credsIssuerConfig),
        make_unique<TV_ChannelClusterSuite>(credsIssuerConfig),
        make_unique<TV_LowPowerClusterSuite>(credsIssuerConfig),
        make_unique<TV_ContentLauncherClusterSuite>(credsIssuerConfig),
        make_unique<TV_MediaInputClusterSuite>(credsIssuerConfig),
        make_unique<TestClusterSuite>(credsIssuerConfig),
        make_unique<TestClusterComplexTypesSuite>(credsIssuerConfig),
        make_unique<TestConstraintsSuite>(credsIssuerConfig),
        make_unique<TestDelayCommandsSuite>(credsIssuerConfig),
        make_unique<TestEventsSuite>(credsIssuerConfig),
        make_unique<TestDiscoverySuite>(credsIssuerConfig),
        make_unique<TestLogCommandsSuite>(credsIssuerConfig),
        make_unique<TestSaveAsSuite>(credsIssuerConfig),
        make_unique<TestConfigVariablesSuite>(credsIssuerConfig),
        make_unique<TestDescriptorClusterSuite>(credsIssuerConfig),
        make_unique<TestBasicInformationSuite>(credsIssuerConfig),
        make_unique<TestGeneralCommissioningSuite>(credsIssuerConfig),
        make_unique<TestIdentifyClusterSuite>(credsIssuerConfig),
        make_unique<TestOperationalCredentialsClusterSuite>(credsIssuerConfig),
        make_unique<TestModeSelectClusterSuite>(credsIssuerConfig),
        make_unique<TestSelfFabricRemovalSuite>(credsIssuerConfig),
        make_unique<TestSystemCommandsSuite>(credsIssuerConfig),
        make_unique<TestBindingSuite>(credsIssuerConfig),
        make_unique<TestUserLabelClusterSuite>(credsIssuerConfig),
        make_unique<TestArmFailSafeSuite>(credsIssuerConfig),
        make_unique<TestMultiAdminSuite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_3_1Suite>(credsIssuerConfig),
        make_unique<TestSubscribe_OnOffSuite>(credsIssuerConfig),
        make_unique<DL_UsersAndCredentialsSuite>(credsIssuerConfig),
        make_unique<DL_LockUnlockSuite>(credsIssuerConfig),
        make_unique<DL_SchedulesSuite>(credsIssuerConfig),
        make_unique<Test_TC_DL_1_3Suite>(credsIssuerConfig),
        make_unique<TestGroupMessagingSuite>(credsIssuerConfig),
        make_unique<TestGroupsClusterSuite>(credsIssuerConfig),
        make_unique<TestGroupKeyManagementClusterSuite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_1_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_11Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_12Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_13Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_3_14Suite>(credsIssuerConfig),
        make_unique<Test_TC_DD_4_1Suite>(credsIssuerConfig),
        make_unique<TestGroupDemoCommandSuite>(credsIssuerConfig),
        make_unique<TestGroupDemoConfigSuite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_1_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_BDX_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_BR_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_BRAC_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_1_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DM_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_DIAG_LOG_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_DESC_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_ETHDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_GC_1_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_GENDIAG_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_GENDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_GENDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_I_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_ILL_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_5_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_5_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_6_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_6_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_IDM_6_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_12Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_3_13Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_8_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_9_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_MC_10_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_10Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_11Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_12Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_13Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_14Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_16Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_17Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_18Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_19Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_20Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_21Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_22Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_23Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_24Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_25Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_26Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_27Suite>(credsIssuerConfig),
        make_unique<Test_TC_MF_1_28Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_MOD_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_1_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_2_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_3_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_4_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SU_4_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_PSCFG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PSCFG_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_5Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_6Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_7Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_8Suite>(credsIssuerConfig),
        make_unique<Test_TC_SC_4_9Suite>(credsIssuerConfig),
        make_unique<Test_TC_SWDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_1_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_WIFIDIAG_2_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_WNCV_6_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_FLW_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_2_4Suite>(credsIssuerConfig),
        make_unique<Test_TC_OCC_3_1Suite>(credsIssuerConfig),
        make_unique<Test_TC_PRS_2_2Suite>(credsIssuerConfig),
        make_unique<Test_TC_PRS_2_3Suite>(credsIssuerConfig),
        make_unique<Test_TC_PS_2_2Suite>(credsIssuerConfig),
#endif // CONFIG_ENABLE_YAML_TESTS
    };

    commands.Register(clusterName, clusterCommands);
}
