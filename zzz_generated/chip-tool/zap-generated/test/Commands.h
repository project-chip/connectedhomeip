/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <commands/common/CommandInvoker.h>
#include <commands/tests/TestCommand.h>

class Test_TC_BI_1_1 : public TestCommand
{
public:
    Test_TC_BI_1_1() : TestCommand("Test_TC_BI_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BI_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }
};

class Test_TC_BI_2_1 : public TestCommand
{
public:
    Test_TC_BI_2_1() : TestCommand("Test_TC_BI_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read mandatory non-global attribute: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeOutOfService_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute constraints: OutOfService\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default values to mandatory non-global attribute: OutOfService\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back the mandatory non-global attribute: OutOfService\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read mandatory non-global attribute constraints: PresentValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Write the default values to mandatory non-global attribute: PresentValue\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads back the mandatory non-global attribute: PresentValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributePresentValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read mandatory non-global attribute: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeStatusFlags_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read mandatory non-global attribute constraints: StatusFlags\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Write the default values to mandatory non-global attribute: StatusFlags\n");
            err = TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads back the mandatory non-global attribute: StatusFlags\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_0(outOfService);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_1(outOfService);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_3(outOfService);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_4(presentValue);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_6(presentValue);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_7(statusFlags);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_8(statusFlags);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_1 *>(context))->OnSuccessResponse_10(statusFlags);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeOutOfService_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool outOfService)
    {
        VerifyOrReturn(CheckValue<bool>("outOfService", outOfService, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsOutOfService_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool outOfService)
    {
        VerifyOrReturn(CheckConstraintType("outOfService", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeOutOfService_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        bool outOfServiceArgument;
        outOfServiceArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            outOfServiceArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeOutOfService_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool outOfService)
    {
        VerifyOrReturn(CheckValue<bool>("outOfService", outOfService, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsPresentValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool presentValue)
    {
        VerifyOrReturn(CheckConstraintType("presentValue", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributePresentValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        bool presentValueArgument;
        presentValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            presentValueArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributePresentValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool presentValue)
    {
        VerifyOrReturn(CheckValue<bool>("presentValue", presentValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStatusFlags_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue<uint8_t>("statusFlags", statusFlags, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStatusFlags_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckConstraintType("statusFlags", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("statusFlags", statusFlags, 15));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryNonGlobalAttributeStatusFlags_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t statusFlagsArgument;
        statusFlagsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            statusFlagsArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { NextTest(); }

    void OnSuccessResponse_9() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStatusFlags_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue<uint8_t>("statusFlags", statusFlags, 0));
        NextTest();
    }
};

class Test_TC_BI_2_2 : public TestCommand
{
public:
    Test_TC_BI_2_2() : TestCommand("Test_TC_BI_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BI_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BI_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads PresentValue attribute from DUT\n");
            err = TestReadsPresentValueAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads OutOfService attribute from DUT\n");
            err = TestReadsOutOfServiceAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads StatusFlags attribute from DUT\n");
            err = TestReadsStatusFlagsAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads PresentValue attribute from DUT\n");
            err = TestReadsPresentValueAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads OutOfService attribute from DUT\n");
            err = TestReadsOutOfServiceAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads StatusFlags attribute from DUT\n");
            err = TestReadsStatusFlagsAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads StatusFlags attribute from DUT\n");
            err = TestReadsStatusFlagsAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads StatusFlags attribute from DUT\n");
            err = TestReadsStatusFlagsAttributeFromDut_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_0(presentValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_1(outOfService);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_2(statusFlags);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, bool presentValue)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_3(presentValue);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool outOfService)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_4(outOfService);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_5(statusFlags);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_6(statusFlags);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t statusFlags)
    {
        (static_cast<Test_TC_BI_2_2 *>(context))->OnSuccessResponse_7(statusFlags);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsPresentValueAttributeFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool presentValue)
    {
        VerifyOrReturn(CheckValue<bool>("presentValue", presentValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOutOfServiceAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool outOfService)
    {
        VerifyOrReturn(CheckValue<bool>("outOfService", outOfService, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue<uint8_t>("statusFlags", statusFlags, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsPresentValueAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool presentValue)
    {
        VerifyOrReturn(CheckValue<bool>("presentValue", presentValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOutOfServiceAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool outOfService)
    {
        VerifyOrReturn(CheckValue<bool>("outOfService", outOfService, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue<uint8_t>("statusFlags", statusFlags, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue<uint8_t>("statusFlags", statusFlags, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsStatusFlagsAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BinaryInputBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t statusFlags)
    {
        VerifyOrReturn(CheckValue<uint8_t>("statusFlags", statusFlags, 0));
        NextTest();
    }
};

class Test_TC_BOOL_1_1 : public TestCommand
{
public:
    Test_TC_BOOL_1_1() : TestCommand("Test_TC_BOOL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_BOOL_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }
};

class Test_TC_BOOL_2_1 : public TestCommand
{
public:
    Test_TC_BOOL_2_1() : TestCommand("Test_TC_BOOL_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_BOOL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_BOOL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read mandatory non-global attribute: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeStateValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read mandatory non-global attribute constraints: StateValue\n");
            err = TestReadMandatoryNonGlobalAttributeConstraintsStateValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default value to mandatory non-global attribute: StateValue\n");
            err = TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back the mandatory non-global attribute: StateValue\n");
            err = TestReadsBackTheMandatoryNonGlobalAttributeStateValue_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_0(stateValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_1(stateValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, bool stateValue)
    {
        (static_cast<Test_TC_BOOL_2_1 *>(context))->OnSuccessResponse_3(stateValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeStateValue_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                          OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool stateValue)
    {
        VerifyOrReturn(CheckValue<bool>("stateValue", stateValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadMandatoryNonGlobalAttributeConstraintsStateValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                          OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool stateValue)
    {
        VerifyOrReturn(CheckConstraintType("stateValue", "", "bool"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryNonGlobalAttributeStateValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        bool stateValueArgument;
        stateValueArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(
            stateValueArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { NextTest(); }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackTheMandatoryNonGlobalAttributeStateValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::BooleanStateClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::BooleanState::Attributes::StateValue::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                          OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool stateValue)
    {
        VerifyOrReturn(CheckValue<bool>("stateValue", stateValue, 0));
        NextTest();
    }
};

class Test_TC_CC_1_1 : public TestCommand
{
public:
    Test_TC_CC_1_1() : TestCommand("Test_TC_CC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_CC_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_CC_2_1 : public TestCommand
{
public:
    Test_TC_CC_2_1() : TestCommand("Test_TC_CC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads mandatory attribute: CurrentHue\n");
            err = TestReadsMandatoryAttributeCurrentHue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Validate constraints of attribute: current hue\n");
            err = TestValidateConstraintsOfAttributeCurrentHue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write the default value to mandatory attribute: CurrentHue\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back mandatory attribute: CurrentHue\n");
            err = TestReadsBackMandatoryAttributeCurrentHue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Reads mandatory attribute: CurrentSaturation\n");
            err = TestReadsMandatoryAttributeCurrentSaturation_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Validate constraints of attribute: CurrentSaturation\n");
            err = TestValidateConstraintsOfAttributeCurrentSaturation_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write the default value to mandatory attribute: CurrentSaturation\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads back mandatory attribute: CurrentSaturation\n");
            err = TestReadsBackMandatoryAttributeCurrentSaturation_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read the mandatory attribute: CurrentX\n");
            err = TestReadTheMandatoryAttributeCurrentX_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Validate constraints of attribute: CurrentX\n");
            err = TestValidateConstraintsOfAttributeCurrentX_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Write the default value to mandatory attribute: CurrentX\n");
            err = TestWriteTheDefaultValueToMandatoryAttributeCurrentX_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads back mandatory attribute: CurrentX\n");
            err = TestReadsBackMandatoryAttributeCurrentX_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read the mandatory attribute: CurrentY\n");
            err = TestReadTheMandatoryAttributeCurrentY_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Validate constraints of attribute: CurrentY\n");
            err = TestValidateConstraintsOfAttributeCurrentY_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Write the default values to mandatory attribute: CurrentY\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reads back mandatory attribute: CurrentY\n");
            err = TestReadsBackMandatoryAttributeCurrentY_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Validate constraints of attribute: ColorTemperatureMireds\n");
            err = TestValidateConstraintsOfAttributeColorTemperatureMireds_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Validate constraints of attribute: ColorMode\n");
            err = TestValidateConstraintsOfAttributeColorMode_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read the mandatory attribute: Options\n");
            err = TestReadTheMandatoryAttributeOptions_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Validate constraints of attribute: Options\n");
            err = TestValidateConstraintsOfAttributeOptions_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Write the default values to mandatory attribute: Options\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeOptions_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads back mandatory attribute: Options\n");
            err = TestReadsBackMandatoryAttributeOptions_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read the mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadTheMandatoryAttributeEnhancedCurrentHue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Validate constraints of attribute: EnhancedCurrentHue\n");
            err = TestValidateConstraintsOfAttributeEnhancedCurrentHue_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : Write the default values to mandatory attribute: EnhancedCurrentHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Reads back mandatory attribute: EnhancedCurrentHue\n");
            err = TestReadsBackMandatoryAttributeEnhancedCurrentHue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Validate constraints of attribute: EnhancedColorMode\n");
            err = TestValidateConstraintsOfAttributeEnhancedColorMode_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read the mandatory attribute: ColorLoopActive\n");
            err = TestReadTheMandatoryAttributeColorLoopActive_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Validate constraints of attribute: ColorLoopActive\n");
            err = TestValidateConstraintsOfAttributeColorLoopActive_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Write the default values to mandatory attribute: ColorLoopActive\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads back mandatory attribute: ColorLoopActive\n");
            err = TestReadsBackMandatoryAttributeColorLoopActive_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Read the mandatory attribute: ColorLoopDirection\n");
            err = TestReadTheMandatoryAttributeColorLoopDirection_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Validate constraints of attribute: ColorLoopDirection\n");
            err = TestValidateConstraintsOfAttributeColorLoopDirection_32();
            break;
        case 33:
            ChipLogProgress(chipTool,
                            " ***** Test Step 33 : Write the default values to mandatory attribute: ColorLoopDirection\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads back mandatory attribute: ColorLoopDirection\n");
            err = TestReadsBackMandatoryAttributeColorLoopDirection_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read the mandatory attribute: ColorLoopTime\n");
            err = TestReadTheMandatoryAttributeColorLoopTime_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Validate constraints of attribute: ColorLoopTime\n");
            err = TestValidateConstraintsOfAttributeColorLoopTime_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write the default values to mandatory attribute: ColorLoopTime\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads back mandatory attribute: ColorLoopTime\n");
            err = TestReadsBackMandatoryAttributeColorLoopTime_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read the mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadTheMandatoryAttributeColorLoopStartEnhancedHue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Validate constraints of attribute: ColorLoopStartEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_40();
            break;
        case 41:
            ChipLogProgress(chipTool,
                            " ***** Test Step 41 : Write the default values to mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads back mandatory attribute: ColorLoopStartEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Read the mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadTheMandatoryAttributeColorLoopStoredEnhancedHue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Validate constraints of attribute: ColorLoopStoredEnhancedHue\n");
            err = TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_44();
            break;
        case 45:
            ChipLogProgress(chipTool,
                            " ***** Test Step 45 : Write the default values to mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reads back mandatory attribute: ColorLoopStoredEnhancedHue\n");
            err = TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Read the mandatory attribute: ColorCapabilities\n");
            err = TestReadTheMandatoryAttributeColorCapabilities_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Validate constraints of attribute: ColorCapabilities\n");
            err = TestValidateConstraintsOfAttributeColorCapabilities_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Write the default values to mandatory attribute: ColorCapabilities\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Reads back mandatory attribute: ColorCapabilities\n");
            err = TestReadsBackMandatoryAttributeColorCapabilities_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Read the mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadTheMandatoryAttributeColorTempPhysicalMinMireds_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Validate constraints of attribute: ColorTempPhysicalMinMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_52();
            break;
        case 53:
            ChipLogProgress(chipTool,
                            " ***** Test Step 53 : Write the default values to mandatory  attribute: ColorTempPhysicalMinMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Reads back mandatory attribute: ColorTempPhysicalMinMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Read the mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadTheMandatoryAttributeColorTempPhysicalMaxMireds_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Validate constraints of attribute: ColorTempPhysicalMaxMireds\n");
            err = TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_56();
            break;
        case 57:
            ChipLogProgress(chipTool,
                            " ***** Test Step 57 : Write the default values to mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Reads back mandatory attribute: ColorTempPhysicalMaxMireds\n");
            err = TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read the optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_59();
            break;
        case 60:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 60 : Write the default values to optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Reads back optional attribute: CoupleColorTempToLevelMinMireds\n");
            err = TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Read the optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadTheOptionalAttributeStartUpColorTemperatureMireds_62();
            break;
        case 63:
            ChipLogProgress(
                chipTool, " ***** Test Step 63 : Write the default values to optional attribute: StartUpColorTemperatureMireds\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Reads back optional attribute: StartUpColorTemperatureMireds\n");
            err = TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Read the Optional attribute: RemainingTime\n");
            err = TestReadTheOptionalAttributeRemainingTime_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Validate constraints of attribute: RemainingTime\n");
            err = TestValidateConstraintsOfAttributeRemainingTime_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write the default values to optional attribute: RemainingTime\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Reads back optional attribute: RemainingTime\n");
            err = TestReadsBackOptionalAttributeRemainingTime_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Read the optional attribute: DriftCompensation\n");
            err = TestReadTheOptionalAttributeDriftCompensation_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Write the default values to optional attribute: DriftCompensation\n");
            err = TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Reads back optional attribute: DriftCompensation\n");
            err = TestReadsBackOptionalAttributeDriftCompensation_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Read the optional attribute: CompensationText\n");
            err = TestReadTheOptionalAttributeCompensationText_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadTheMandatoryAttributeNumberOfPrimaries_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Write the default mandatory attribute: NumberOfPrimaries\n");
            err = TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Read back the mandatory attribute: NumberOfPrimaries\n");
            err = TestReadBackTheMandatoryAttributeNumberOfPrimaries_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read the mandatory attribute: Primary1X\n");
            err = TestReadTheMandatoryAttributePrimary1X_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write the default mandatory attribute: Primary1X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1X_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read back the mandatory attribute: Primary1X\n");
            err = TestReadBackTheMandatoryAttributePrimary1X_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Read the mandatory attribute: Primary1Y\n");
            err = TestReadTheMandatoryAttributePrimary1Y_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Write the default mandatory attribute: Primary1Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary1Y_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Read back the mandatory attribute: Primary1Y\n");
            err = TestReadBackTheMandatoryAttributePrimary1Y_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read the mandatory attribute: Primary1Intensity\n");
            err = TestReadTheMandatoryAttributePrimary1Intensity_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read the mandatory attribute: Primary2X\n");
            err = TestReadTheMandatoryAttributePrimary2X_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write the default mandatory attribute: Primary2X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2X_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read back the mandatory attribute: Primary2X\n");
            err = TestReadBackTheMandatoryAttributePrimary2X_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read the mandatory attribute: Primary2Y\n");
            err = TestReadTheMandatoryAttributePrimary2Y_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write the default mandatory attribute: Primary2Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary2Y_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read back the mandatory attribute: Primary2Y\n");
            err = TestReadBackTheMandatoryAttributePrimary2Y_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Validate constraints of attribute: Primary2Intensity\n");
            err = TestValidateConstraintsOfAttributePrimary2Intensity_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read the mandatory attribute: Primary3X\n");
            err = TestReadTheMandatoryAttributePrimary3X_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write the default mandatory attribute: Primary3X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3X_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read back the mandatory attribute: Primary3X\n");
            err = TestReadBackTheMandatoryAttributePrimary3X_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Read the mandatory attribute: Primary3Y\n");
            err = TestReadTheMandatoryAttributePrimary3Y_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Write the default mandatory attribute: Primary3Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary3Y_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Read back the mandatory attribute: Primary3Y\n");
            err = TestReadBackTheMandatoryAttributePrimary3Y_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read the mandatory attribute: Primary3Intensity\n");
            err = TestReadTheMandatoryAttributePrimary3Intensity_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read the mandatory attribute: Primary4X\n");
            err = TestReadTheMandatoryAttributePrimary4X_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Write the default mandatory attribute: Primary4X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4X_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read back the mandatory attribute: Primary4X\n");
            err = TestReadBackTheMandatoryAttributePrimary4X_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Read the mandatory attribute: Primary4Y\n");
            err = TestReadTheMandatoryAttributePrimary4Y_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write the default mandatory attribute: Primary4Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary4Y_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read back the mandatory attribute: Primary4Y\n");
            err = TestReadBackTheMandatoryAttributePrimary4Y_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Read the mandatory attribute: Primary4Intensity\n");
            err = TestReadTheMandatoryAttributePrimary4Intensity_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read the mandatory attribute: Primary5X\n");
            err = TestReadTheMandatoryAttributePrimary5X_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write the default mandatory attribute: Primary5X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5X_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read back the mandatory attribute: Primary5X\n");
            err = TestReadBackTheMandatoryAttributePrimary5X_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read the mandatory attribute: Primary5Y\n");
            err = TestReadTheMandatoryAttributePrimary5Y_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Write the default mandatory attribute: Primary5Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary5Y_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Read back the mandatory attribute: Primary5Y\n");
            err = TestReadBackTheMandatoryAttributePrimary5Y_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Read the mandatory attribute: Primary5Intensity\n");
            err = TestReadTheMandatoryAttributePrimary5Intensity_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Read the mandatory attribute: Primary6X\n");
            err = TestReadTheMandatoryAttributePrimary6X_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Write the default mandatory attribute: Primary6X\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6X_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read back the mandatory attribute: Primary6X\n");
            err = TestReadBackTheMandatoryAttributePrimary6X_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Read the mandatory attribute: Primary6Y\n");
            err = TestReadTheMandatoryAttributePrimary6Y_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Write the default mandatory attribute: Primary6Y\n");
            err = TestWriteTheDefaultMandatoryAttributePrimary6Y_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Read back the mandatory attribute: Primary6Y\n");
            err = TestReadBackTheMandatoryAttributePrimary6Y_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read the mandatory attribute: Primary6Intensity\n");
            err = TestReadTheMandatoryAttributePrimary6Intensity_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Read the optional attribute: WhitePointX\n");
            err = TestReadTheOptionalAttributeWhitePointX_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Write the default optional attribute: WhitePointX\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointX_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Read back the optional attribute: WhitePointX\n");
            err = TestReadBackTheOptionalAttributeWhitePointX_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read the optional attribute: WhitePointY\n");
            err = TestReadTheOptionalAttributeWhitePointY_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write the default optional attribute: WhitePointY\n");
            err = TestWriteTheDefaultOptionalAttributeWhitePointY_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read back the optional attribute: WhitePointY\n");
            err = TestReadBackTheOptionalAttributeWhitePointY_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Read the optional attribute: ColorPointRX\n");
            err = TestReadTheOptionalAttributeColorPointRX_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Write the default optional attribute: ColorPointRX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRX_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Read back the optional attribute: ColorPointRX\n");
            err = TestReadBackTheOptionalAttributeColorPointRX_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Read the optional attribute: ColorPointRY\n");
            err = TestReadTheOptionalAttributeColorPointRY_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Write the default optional attribute: ColorPointRY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointRY_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Read back the optional attribute: ColorPointRY\n");
            err = TestReadBackTheOptionalAttributeColorPointRY_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Read the optional attribute: ColorPointRIntensity\n");
            err = TestReadTheOptionalAttributeColorPointRIntensity_130();
            break;
        case 131:
            ChipLogProgress(chipTool, " ***** Test Step 131 : Read the optional attribute: ColorPointGX\n");
            err = TestReadTheOptionalAttributeColorPointGX_131();
            break;
        case 132:
            ChipLogProgress(chipTool, " ***** Test Step 132 : Write the default optional attribute: ColorPointGX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGX_132();
            break;
        case 133:
            ChipLogProgress(chipTool, " ***** Test Step 133 : Read back the optional attribute: ColorPointGX\n");
            err = TestReadBackTheOptionalAttributeColorPointGX_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Read the optional attribute: ColorPointGY\n");
            err = TestReadTheOptionalAttributeColorPointGY_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Write the default optional attribute: ColorPointGY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointGY_135();
            break;
        case 136:
            ChipLogProgress(chipTool, " ***** Test Step 136 : Read back the optional attribute: ColorPointGY\n");
            err = TestReadBackTheOptionalAttributeColorPointGY_136();
            break;
        case 137:
            ChipLogProgress(chipTool, " ***** Test Step 137 : Read the optional attribute: ColorPointGIntensity\n");
            err = TestReadTheOptionalAttributeColorPointGIntensity_137();
            break;
        case 138:
            ChipLogProgress(chipTool, " ***** Test Step 138 : Read the optional attribute: ColorPointBX\n");
            err = TestReadTheOptionalAttributeColorPointBX_138();
            break;
        case 139:
            ChipLogProgress(chipTool, " ***** Test Step 139 : Write the default optional attribute: ColorPointBX\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBX_139();
            break;
        case 140:
            ChipLogProgress(chipTool, " ***** Test Step 140 : Read back the optional attribute: ColorPointBX\n");
            err = TestReadBackTheOptionalAttributeColorPointBX_140();
            break;
        case 141:
            ChipLogProgress(chipTool, " ***** Test Step 141 : Read the optional attribute: ColorPointBY\n");
            err = TestReadTheOptionalAttributeColorPointBY_141();
            break;
        case 142:
            ChipLogProgress(chipTool, " ***** Test Step 142 : Write the default optional attribute: ColorPointBY\n");
            err = TestWriteTheDefaultOptionalAttributeColorPointBY_142();
            break;
        case 143:
            ChipLogProgress(chipTool, " ***** Test Step 143 : Read back the optional attribute: ColorPointBY\n");
            err = TestReadBackTheOptionalAttributeColorPointBY_143();
            break;
        case 144:
            ChipLogProgress(chipTool, " ***** Test Step 144 : Read the optional attribute: ColorPointBIntensity\n");
            err = TestReadTheOptionalAttributeColorPointBIntensity_144();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 145;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_0(currentHue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_1(currentHue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_3(currentHue);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_4(currentSaturation);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_5(currentSaturation);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t currentSaturation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_7(currentSaturation);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_8(currentX);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_9(currentX);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_10(); }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint16_t currentX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_11(currentX);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_12(currentY);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_13(currentY);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, uint16_t currentY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_15(currentY);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, uint16_t colorTemperature)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_16(colorTemperature);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, uint8_t colorMode)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_17(colorMode);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_18(colorControlOptions);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_19(colorControlOptions);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_20(); }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, uint8_t colorControlOptions)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_21(colorControlOptions);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_22(enhancedCurrentHue);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_23(enhancedCurrentHue);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_25(enhancedCurrentHue);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, uint8_t enhancedColorMode)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_26(enhancedColorMode);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_27(colorLoopActive);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_28(colorLoopActive);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_30(colorLoopActive);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_31(colorLoopDirection);
    }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_32(colorLoopDirection);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_33(); }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_34(colorLoopDirection);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_35(colorLoopTime);
    }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_36(colorLoopTime);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_38(colorLoopTime);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_39(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_40(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_41(); }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_42(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_43(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_44(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_45(); }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context, uint16_t colorLoopStoredEnhancedHue)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_46(colorLoopStoredEnhancedHue);
    }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_47(colorCapabilities);
    }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_48(colorCapabilities);
    }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_49(); }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context, uint16_t colorCapabilities)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_50(colorCapabilities);
    }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_51(colorTempPhysicalMin);
    }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_52(colorTempPhysicalMin);
    }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_53(); }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context, uint16_t colorTempPhysicalMin)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_54(colorTempPhysicalMin);
    }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_55(colorTempPhysicalMax);
    }

    static void OnFailureCallback_56(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_56(chip::to_underlying(status));
    }

    static void OnSuccessCallback_56(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_56(colorTempPhysicalMax);
    }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_57(); }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context, uint16_t colorTempPhysicalMax)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_58(colorTempPhysicalMax);
    }

    static void OnFailureCallback_59(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_59(chip::to_underlying(status));
    }

    static void OnSuccessCallback_59(void * context, uint16_t coupleColorTempToLevelMinMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_59(coupleColorTempToLevelMinMireds);
    }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_60(); }

    static void OnFailureCallback_61(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_61(chip::to_underlying(status));
    }

    static void OnSuccessCallback_61(void * context, uint16_t coupleColorTempToLevelMinMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_61(coupleColorTempToLevelMinMireds);
    }

    static void OnFailureCallback_62(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_62(chip::to_underlying(status));
    }

    static void OnSuccessCallback_62(void * context, uint16_t startUpColorTemperatureMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_62(startUpColorTemperatureMireds);
    }

    static void OnFailureCallback_63(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_63(chip::to_underlying(status));
    }

    static void OnSuccessCallback_63(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_63(); }

    static void OnFailureCallback_64(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_64(chip::to_underlying(status));
    }

    static void OnSuccessCallback_64(void * context, uint16_t startUpColorTemperatureMireds)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_64(startUpColorTemperatureMireds);
    }

    static void OnFailureCallback_65(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_65(chip::to_underlying(status));
    }

    static void OnSuccessCallback_65(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_65(remainingTime);
    }

    static void OnFailureCallback_66(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_66(chip::to_underlying(status));
    }

    static void OnSuccessCallback_66(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_66(remainingTime);
    }

    static void OnFailureCallback_67(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_67(chip::to_underlying(status));
    }

    static void OnSuccessCallback_67(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_67(); }

    static void OnFailureCallback_68(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_68(chip::to_underlying(status));
    }

    static void OnSuccessCallback_68(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_68(remainingTime);
    }

    static void OnFailureCallback_69(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_69(chip::to_underlying(status));
    }

    static void OnSuccessCallback_69(void * context, uint8_t driftCompensation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_69(driftCompensation);
    }

    static void OnFailureCallback_70(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_70(chip::to_underlying(status));
    }

    static void OnSuccessCallback_70(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_70(); }

    static void OnFailureCallback_71(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_71(chip::to_underlying(status));
    }

    static void OnSuccessCallback_71(void * context, uint8_t driftCompensation)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_71(driftCompensation);
    }

    static void OnFailureCallback_72(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_72(chip::to_underlying(status));
    }

    static void OnSuccessCallback_72(void * context, chip::CharSpan compensationText)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_72(compensationText);
    }

    static void OnFailureCallback_73(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_73(chip::to_underlying(status));
    }

    static void OnSuccessCallback_73(void * context, uint8_t numberOfPrimaries)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_73(numberOfPrimaries);
    }

    static void OnFailureCallback_74(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_74(chip::to_underlying(status));
    }

    static void OnSuccessCallback_74(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_74(); }

    static void OnFailureCallback_75(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_75(chip::to_underlying(status));
    }

    static void OnSuccessCallback_75(void * context, uint8_t numberOfPrimaries)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_75(numberOfPrimaries);
    }

    static void OnFailureCallback_76(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_76(chip::to_underlying(status));
    }

    static void OnSuccessCallback_76(void * context, uint16_t primary1X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_76(primary1X);
    }

    static void OnFailureCallback_77(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_77(chip::to_underlying(status));
    }

    static void OnSuccessCallback_77(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_77(); }

    static void OnFailureCallback_78(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_78(chip::to_underlying(status));
    }

    static void OnSuccessCallback_78(void * context, uint16_t primary1X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_78(primary1X);
    }

    static void OnFailureCallback_79(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_79(chip::to_underlying(status));
    }

    static void OnSuccessCallback_79(void * context, uint16_t primary1Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_79(primary1Y);
    }

    static void OnFailureCallback_80(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_80(chip::to_underlying(status));
    }

    static void OnSuccessCallback_80(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_80(); }

    static void OnFailureCallback_81(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_81(chip::to_underlying(status));
    }

    static void OnSuccessCallback_81(void * context, uint16_t primary1Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_81(primary1Y);
    }

    static void OnFailureCallback_82(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_82(chip::to_underlying(status));
    }

    static void OnSuccessCallback_82(void * context, uint8_t primary1Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_82(primary1Intensity);
    }

    static void OnFailureCallback_83(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_83(chip::to_underlying(status));
    }

    static void OnSuccessCallback_83(void * context, uint16_t primary2X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_83(primary2X);
    }

    static void OnFailureCallback_84(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_84(chip::to_underlying(status));
    }

    static void OnSuccessCallback_84(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_84(); }

    static void OnFailureCallback_85(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_85(chip::to_underlying(status));
    }

    static void OnSuccessCallback_85(void * context, uint16_t primary2X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_85(primary2X);
    }

    static void OnFailureCallback_86(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_86(chip::to_underlying(status));
    }

    static void OnSuccessCallback_86(void * context, uint16_t primary2Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_86(primary2Y);
    }

    static void OnFailureCallback_87(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_87(chip::to_underlying(status));
    }

    static void OnSuccessCallback_87(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_87(); }

    static void OnFailureCallback_88(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_88(chip::to_underlying(status));
    }

    static void OnSuccessCallback_88(void * context, uint16_t primary2Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_88(primary2Y);
    }

    static void OnFailureCallback_89(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_89(chip::to_underlying(status));
    }

    static void OnSuccessCallback_89(void * context, uint8_t primary2Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_89(primary2Intensity);
    }

    static void OnFailureCallback_90(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_90(chip::to_underlying(status));
    }

    static void OnSuccessCallback_90(void * context, uint16_t primary3X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_90(primary3X);
    }

    static void OnFailureCallback_91(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_91(chip::to_underlying(status));
    }

    static void OnSuccessCallback_91(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_91(); }

    static void OnFailureCallback_92(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_92(chip::to_underlying(status));
    }

    static void OnSuccessCallback_92(void * context, uint16_t primary3X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_92(primary3X);
    }

    static void OnFailureCallback_93(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_93(chip::to_underlying(status));
    }

    static void OnSuccessCallback_93(void * context, uint16_t primary3Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_93(primary3Y);
    }

    static void OnFailureCallback_94(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_94(chip::to_underlying(status));
    }

    static void OnSuccessCallback_94(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_94(); }

    static void OnFailureCallback_95(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_95(chip::to_underlying(status));
    }

    static void OnSuccessCallback_95(void * context, uint16_t primary3Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_95(primary3Y);
    }

    static void OnFailureCallback_96(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_96(chip::to_underlying(status));
    }

    static void OnSuccessCallback_96(void * context, uint8_t primary3Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_96(primary3Intensity);
    }

    static void OnFailureCallback_97(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_97(chip::to_underlying(status));
    }

    static void OnSuccessCallback_97(void * context, uint16_t primary4X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_97(primary4X);
    }

    static void OnFailureCallback_98(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_98(chip::to_underlying(status));
    }

    static void OnSuccessCallback_98(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_98(); }

    static void OnFailureCallback_99(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_99(chip::to_underlying(status));
    }

    static void OnSuccessCallback_99(void * context, uint16_t primary4X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_99(primary4X);
    }

    static void OnFailureCallback_100(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_100(chip::to_underlying(status));
    }

    static void OnSuccessCallback_100(void * context, uint16_t primary4Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_100(primary4Y);
    }

    static void OnFailureCallback_101(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_101(chip::to_underlying(status));
    }

    static void OnSuccessCallback_101(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_101(); }

    static void OnFailureCallback_102(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_102(chip::to_underlying(status));
    }

    static void OnSuccessCallback_102(void * context, uint16_t primary4Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_102(primary4Y);
    }

    static void OnFailureCallback_103(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_103(chip::to_underlying(status));
    }

    static void OnSuccessCallback_103(void * context, uint8_t primary4Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_103(primary4Intensity);
    }

    static void OnFailureCallback_104(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_104(chip::to_underlying(status));
    }

    static void OnSuccessCallback_104(void * context, uint16_t primary5X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_104(primary5X);
    }

    static void OnFailureCallback_105(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_105(chip::to_underlying(status));
    }

    static void OnSuccessCallback_105(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_105(); }

    static void OnFailureCallback_106(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_106(chip::to_underlying(status));
    }

    static void OnSuccessCallback_106(void * context, uint16_t primary5X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_106(primary5X);
    }

    static void OnFailureCallback_107(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_107(chip::to_underlying(status));
    }

    static void OnSuccessCallback_107(void * context, uint16_t primary5Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_107(primary5Y);
    }

    static void OnFailureCallback_108(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_108(chip::to_underlying(status));
    }

    static void OnSuccessCallback_108(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_108(); }

    static void OnFailureCallback_109(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_109(chip::to_underlying(status));
    }

    static void OnSuccessCallback_109(void * context, uint16_t primary5Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_109(primary5Y);
    }

    static void OnFailureCallback_110(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_110(chip::to_underlying(status));
    }

    static void OnSuccessCallback_110(void * context, uint8_t primary5Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_110(primary5Intensity);
    }

    static void OnFailureCallback_111(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_111(chip::to_underlying(status));
    }

    static void OnSuccessCallback_111(void * context, uint16_t primary6X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_111(primary6X);
    }

    static void OnFailureCallback_112(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_112(chip::to_underlying(status));
    }

    static void OnSuccessCallback_112(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_112(); }

    static void OnFailureCallback_113(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_113(chip::to_underlying(status));
    }

    static void OnSuccessCallback_113(void * context, uint16_t primary6X)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_113(primary6X);
    }

    static void OnFailureCallback_114(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_114(chip::to_underlying(status));
    }

    static void OnSuccessCallback_114(void * context, uint16_t primary6Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_114(primary6Y);
    }

    static void OnFailureCallback_115(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_115(chip::to_underlying(status));
    }

    static void OnSuccessCallback_115(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_115(); }

    static void OnFailureCallback_116(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_116(chip::to_underlying(status));
    }

    static void OnSuccessCallback_116(void * context, uint16_t primary6Y)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_116(primary6Y);
    }

    static void OnFailureCallback_117(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_117(chip::to_underlying(status));
    }

    static void OnSuccessCallback_117(void * context, uint8_t primary6Intensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_117(primary6Intensity);
    }

    static void OnFailureCallback_118(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_118(chip::to_underlying(status));
    }

    static void OnSuccessCallback_118(void * context, uint16_t whitePointX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_118(whitePointX);
    }

    static void OnFailureCallback_119(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_119(chip::to_underlying(status));
    }

    static void OnSuccessCallback_119(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_119(); }

    static void OnFailureCallback_120(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_120(chip::to_underlying(status));
    }

    static void OnSuccessCallback_120(void * context, uint16_t whitePointX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_120(whitePointX);
    }

    static void OnFailureCallback_121(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_121(chip::to_underlying(status));
    }

    static void OnSuccessCallback_121(void * context, uint16_t whitePointY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_121(whitePointY);
    }

    static void OnFailureCallback_122(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_122(chip::to_underlying(status));
    }

    static void OnSuccessCallback_122(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_122(); }

    static void OnFailureCallback_123(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_123(chip::to_underlying(status));
    }

    static void OnSuccessCallback_123(void * context, uint16_t whitePointY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_123(whitePointY);
    }

    static void OnFailureCallback_124(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_124(chip::to_underlying(status));
    }

    static void OnSuccessCallback_124(void * context, uint16_t colorPointRX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_124(colorPointRX);
    }

    static void OnFailureCallback_125(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_125(chip::to_underlying(status));
    }

    static void OnSuccessCallback_125(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_125(); }

    static void OnFailureCallback_126(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_126(chip::to_underlying(status));
    }

    static void OnSuccessCallback_126(void * context, uint16_t colorPointRX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_126(colorPointRX);
    }

    static void OnFailureCallback_127(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_127(chip::to_underlying(status));
    }

    static void OnSuccessCallback_127(void * context, uint16_t colorPointRY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_127(colorPointRY);
    }

    static void OnFailureCallback_128(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_128(chip::to_underlying(status));
    }

    static void OnSuccessCallback_128(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_128(); }

    static void OnFailureCallback_129(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_129(chip::to_underlying(status));
    }

    static void OnSuccessCallback_129(void * context, uint16_t colorPointRY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_129(colorPointRY);
    }

    static void OnFailureCallback_130(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_130(chip::to_underlying(status));
    }

    static void OnSuccessCallback_130(void * context, uint8_t colorPointRIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_130(colorPointRIntensity);
    }

    static void OnFailureCallback_131(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_131(chip::to_underlying(status));
    }

    static void OnSuccessCallback_131(void * context, uint16_t colorPointGX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_131(colorPointGX);
    }

    static void OnFailureCallback_132(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_132(chip::to_underlying(status));
    }

    static void OnSuccessCallback_132(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_132(); }

    static void OnFailureCallback_133(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_133(chip::to_underlying(status));
    }

    static void OnSuccessCallback_133(void * context, uint16_t colorPointGX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_133(colorPointGX);
    }

    static void OnFailureCallback_134(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_134(chip::to_underlying(status));
    }

    static void OnSuccessCallback_134(void * context, uint16_t colorPointGY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_134(colorPointGY);
    }

    static void OnFailureCallback_135(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_135(chip::to_underlying(status));
    }

    static void OnSuccessCallback_135(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_135(); }

    static void OnFailureCallback_136(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_136(chip::to_underlying(status));
    }

    static void OnSuccessCallback_136(void * context, uint16_t colorPointGY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_136(colorPointGY);
    }

    static void OnFailureCallback_137(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_137(chip::to_underlying(status));
    }

    static void OnSuccessCallback_137(void * context, uint8_t colorPointGIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_137(colorPointGIntensity);
    }

    static void OnFailureCallback_138(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_138(chip::to_underlying(status));
    }

    static void OnSuccessCallback_138(void * context, uint16_t colorPointBX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_138(colorPointBX);
    }

    static void OnFailureCallback_139(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_139(chip::to_underlying(status));
    }

    static void OnSuccessCallback_139(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_139(); }

    static void OnFailureCallback_140(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_140(chip::to_underlying(status));
    }

    static void OnSuccessCallback_140(void * context, uint16_t colorPointBX)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_140(colorPointBX);
    }

    static void OnFailureCallback_141(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_141(chip::to_underlying(status));
    }

    static void OnSuccessCallback_141(void * context, uint16_t colorPointBY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_141(colorPointBY);
    }

    static void OnFailureCallback_142(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_142(chip::to_underlying(status));
    }

    static void OnSuccessCallback_142(void * context) { (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_142(); }

    static void OnFailureCallback_143(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_143(chip::to_underlying(status));
    }

    static void OnSuccessCallback_143(void * context, uint16_t colorPointBY)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_143(colorPointBY);
    }

    static void OnFailureCallback_144(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnFailureResponse_144(chip::to_underlying(status));
    }

    static void OnSuccessCallback_144(void * context, uint8_t colorPointBIntensity)
    {
        (static_cast<Test_TC_CC_2_1 *>(context))->OnSuccessResponse_144(colorPointBIntensity);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsMandatoryAttributeCurrentHue_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                          OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentHue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentHue", currentHue, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentHue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                          OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t currentHue)
    {
        VerifyOrReturn(CheckConstraintType("currentHue", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentHue", currentHue, 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentHue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t currentHueArgument;
        currentHueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(
            currentHueArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { NextTest(); }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentHue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentHue::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                          OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t currentHue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentHue", currentHue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeCurrentSaturation_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentSaturation", currentSaturation, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentSaturation_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckConstraintType("currentSaturation", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("currentSaturation", currentSaturation, 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentSaturation_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t currentSaturationArgument;
        currentSaturationArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            currentSaturationArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { NextTest(); }

    void OnSuccessResponse_6() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentSaturation_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t currentSaturation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentSaturation", currentSaturation, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCurrentX_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(this, OnSuccessCallback_8,
                                                                                                        OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint16_t currentX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("currentX", currentX, 24939U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentX_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(this, OnSuccessCallback_9,
                                                                                                        OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint16_t currentX)
    {
        VerifyOrReturn(CheckConstraintType("currentX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentX", currentX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryAttributeCurrentX_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t currentXArgument;
        currentXArgument = 24939U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(
            currentXArgument, this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { NextTest(); }

    void OnSuccessResponse_10() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentX_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentX::TypeInfo>(this, OnSuccessCallback_11,
                                                                                                        OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint16_t currentX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("currentX", currentX, 24939U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCurrentY_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(this, OnSuccessCallback_12,
                                                                                                        OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint16_t currentY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("currentY", currentY, 24701U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeCurrentY_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(this, OnSuccessCallback_13,
                                                                                                        OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint16_t currentY)
    {
        VerifyOrReturn(CheckConstraintType("currentY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("currentY", currentY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeCurrentY_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t currentYArgument;
        currentYArgument = 24701U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(
            currentYArgument, this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { NextTest(); }

    void OnSuccessResponse_14() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeCurrentY_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CurrentY::TypeInfo>(this, OnSuccessCallback_15,
                                                                                                        OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint16_t currentY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("currentY", currentY, 24701U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTemperatureMireds_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTemperature::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t colorTemperature)
    {
        VerifyOrReturn(CheckConstraintType("colorTemperature", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTemperature", colorTemperature, 65279));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorMode_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorMode::TypeInfo>(this, OnSuccessCallback_17,
                                                                                                         OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint8_t colorMode)
    {
        VerifyOrReturn(CheckConstraintType("colorMode", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("colorMode", colorMode, 2));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeOptions_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorControlOptions", colorControlOptions, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeOptions_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckConstraintType("colorControlOptions", "", "map8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeOptions_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t colorControlOptionsArgument;
        colorControlOptionsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            colorControlOptionsArgument, this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOptions_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorControlOptions::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(uint8_t colorControlOptions)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorControlOptions", colorControlOptions, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEnhancedCurrentHue_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enhancedCurrentHue", enhancedCurrentHue, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedCurrentHue_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckConstraintType("enhancedCurrentHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeEnhancedCurrentHue_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t enhancedCurrentHueArgument;
        enhancedCurrentHueArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            enhancedCurrentHueArgument, this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { NextTest(); }

    void OnSuccessResponse_24() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeEnhancedCurrentHue_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enhancedCurrentHue", enhancedCurrentHue, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeEnhancedColorMode_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedColorMode::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint8_t enhancedColorMode)
    {
        VerifyOrReturn(CheckConstraintType("enhancedColorMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopActive_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopActive_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopActive", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopActive_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t colorLoopActiveArgument;
        colorLoopActiveArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            colorLoopActiveArgument, this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { NextTest(); }

    void OnSuccessResponse_29() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopActive_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopDirection_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopDirection_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopDirection", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopDirection_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t colorLoopDirectionArgument;
        colorLoopDirectionArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            colorLoopDirectionArgument, this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { NextTest(); }

    void OnSuccessResponse_33() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopDirection_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopTime_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 25U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopTime_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopTime", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopTime_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorLoopTimeArgument;
        colorLoopTimeArgument = 25U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            colorLoopTimeArgument, this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { NextTest(); }

    void OnSuccessResponse_37() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopTime_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 25U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopStartEnhancedHue_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 8960U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStartEnhancedHue_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStartEnhancedHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStartEnhancedHue_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorLoopStartEnhancedHueArgument;
        colorLoopStartEnhancedHueArgument = 8960U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            colorLoopStartEnhancedHueArgument, this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { NextTest(); }

    void OnSuccessResponse_41() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStartEnhancedHue_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 8960U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorLoopStoredEnhancedHue_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorLoopStoredEnhancedHue_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckConstraintType("colorLoopStoredEnhancedHue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorLoopStoredEnhancedHue_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorLoopStoredEnhancedHueArgument;
        colorLoopStoredEnhancedHueArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            colorLoopStoredEnhancedHueArgument, this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { NextTest(); }

    void OnSuccessResponse_45() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorLoopStoredEnhancedHue_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_46, OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(uint16_t colorLoopStoredEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStoredEnhancedHue", colorLoopStoredEnhancedHue, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorCapabilities_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorCapabilities", colorCapabilities, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorCapabilities_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckConstraintType("colorCapabilities", "", "map16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorCapabilities", colorCapabilities, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorCapabilities_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorCapabilitiesArgument;
        colorCapabilitiesArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            colorCapabilitiesArgument, this, OnSuccessCallback_49, OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { NextTest(); }

    void OnSuccessResponse_49() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorCapabilities_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::TypeInfo>(
            this, OnSuccessCallback_50, OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(uint16_t colorCapabilities)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorCapabilities", colorCapabilities, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorTempPhysicalMinMireds_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_51, OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMinMireds_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_52, OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckConstraintType("colorTempPhysicalMin", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMinMireds_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorTempPhysicalMinArgument;
        colorTempPhysicalMinArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            colorTempPhysicalMinArgument, this, OnSuccessCallback_53, OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { NextTest(); }

    void OnSuccessResponse_53() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMinMireds_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMin::TypeInfo>(
            this, OnSuccessCallback_54, OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(uint16_t colorTempPhysicalMin)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorTempPhysicalMin", colorTempPhysicalMin, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeColorTempPhysicalMaxMireds_55()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_55, OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeColorTempPhysicalMaxMireds_56()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_56, OnFailureCallback_56);
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckConstraintType("colorTempPhysicalMax", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeColorTempPhysicalMaxMireds_57()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorTempPhysicalMaxArgument;
        colorTempPhysicalMaxArgument = 65279U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            colorTempPhysicalMaxArgument, this, OnSuccessCallback_57, OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { NextTest(); }

    void OnSuccessResponse_57() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeColorTempPhysicalMaxMireds_58()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMax::TypeInfo>(
            this, OnSuccessCallback_58, OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58(uint16_t colorTempPhysicalMax)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorTempPhysicalMax", colorTempPhysicalMax, 65279U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeCoupleColorTempToLevelMinMireds_59()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
            this, OnSuccessCallback_59, OnFailureCallback_59);
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59(uint16_t coupleColorTempToLevelMinMireds)
    {
        VerifyOrReturn(CheckConstraintType("coupleColorTempToLevelMinMireds", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeCoupleColorTempToLevelMinMireds_60()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t coupleColorTempToLevelMinMiredsArgument;
        coupleColorTempToLevelMinMiredsArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
            coupleColorTempToLevelMinMiredsArgument, this, OnSuccessCallback_60, OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status) { NextTest(); }

    void OnSuccessResponse_60() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeCoupleColorTempToLevelMinMireds_61()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::TypeInfo>(
            this, OnSuccessCallback_61, OnFailureCallback_61);
    }

    void OnFailureResponse_61(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_61(uint16_t coupleColorTempToLevelMinMireds)
    {
        VerifyOrReturn(CheckValue<uint16_t>("coupleColorTempToLevelMinMireds", coupleColorTempToLevelMinMireds, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeStartUpColorTemperatureMireds_62()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
            this, OnSuccessCallback_62, OnFailureCallback_62);
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62(uint16_t startUpColorTemperatureMireds)
    {
        VerifyOrReturn(CheckConstraintType("startUpColorTemperatureMireds", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeStartUpColorTemperatureMireds_63()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t startUpColorTemperatureMiredsArgument;
        startUpColorTemperatureMiredsArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
            startUpColorTemperatureMiredsArgument, this, OnSuccessCallback_63, OnFailureCallback_63);
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63() { NextTest(); }

    CHIP_ERROR TestReadsBackOptionalAttributeStartUpColorTemperatureMireds_64()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::TypeInfo>(
            this, OnSuccessCallback_64, OnFailureCallback_64);
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64(uint16_t startUpColorTemperatureMireds)
    {
        VerifyOrReturn(CheckValue<uint16_t>("startUpColorTemperatureMireds", startUpColorTemperatureMireds, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeRemainingTime_65()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_65, OnFailureCallback_65);
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("remainingTime", remainingTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributeRemainingTime_66()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_66, OnFailureCallback_66);
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckConstraintType("remainingTime", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("remainingTime", remainingTime, 254));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeRemainingTime_67()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t remainingTimeArgument;
        remainingTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            remainingTimeArgument, this, OnSuccessCallback_67, OnFailureCallback_67);
    }

    void OnFailureResponse_67(uint8_t status) { NextTest(); }

    void OnSuccessResponse_67() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeRemainingTime_68()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_68, OnFailureCallback_68);
    }

    void OnFailureResponse_68(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_68(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("remainingTime", remainingTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeDriftCompensation_69()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            this, OnSuccessCallback_69, OnFailureCallback_69);
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69(uint8_t driftCompensation)
    {
        VerifyOrReturn(CheckConstraintType("driftCompensation", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("driftCompensation", driftCompensation, 4));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalAttributeDriftCompensation_70()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t driftCompensationArgument;
        driftCompensationArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            driftCompensationArgument, this, OnSuccessCallback_70, OnFailureCallback_70);
    }

    void OnFailureResponse_70(uint8_t status) { NextTest(); }

    void OnSuccessResponse_70() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalAttributeDriftCompensation_71()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::DriftCompensation::TypeInfo>(
            this, OnSuccessCallback_71, OnFailureCallback_71);
    }

    void OnFailureResponse_71(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_71(uint8_t driftCompensation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("driftCompensation", driftCompensation, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeCompensationText_72()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::CompensationText::TypeInfo>(
            this, OnSuccessCallback_72, OnFailureCallback_72);
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72(chip::CharSpan compensationText)
    {
        VerifyOrReturn(CheckConstraintType("compensationText", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("compensationText", compensationText.size(), 254));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeNumberOfPrimaries_73()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            this, OnSuccessCallback_73, OnFailureCallback_73);
    }

    void OnFailureResponse_73(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_73(uint8_t numberOfPrimaries)
    {
        VerifyOrReturn(CheckConstraintType("numberOfPrimaries", "", "uint8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("numberOfPrimaries", numberOfPrimaries, 6));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributeNumberOfPrimaries_74()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t numberOfPrimariesArgument;
        numberOfPrimariesArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            numberOfPrimariesArgument, this, OnSuccessCallback_74, OnFailureCallback_74);
    }

    void OnFailureResponse_74(uint8_t status) { NextTest(); }

    void OnSuccessResponse_74() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributeNumberOfPrimaries_75()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::TypeInfo>(
            this, OnSuccessCallback_75, OnFailureCallback_75);
    }

    void OnFailureResponse_75(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_75(uint8_t numberOfPrimaries)
    {
        VerifyOrReturn(CheckValue<uint8_t>("numberOfPrimaries", numberOfPrimaries, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1X_76()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(this, OnSuccessCallback_76,
                                                                                                         OnFailureCallback_76);
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76(uint16_t primary1X)
    {
        VerifyOrReturn(CheckConstraintType("primary1X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1X", primary1X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1X_77()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary1XArgument;
        primary1XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(
            primary1XArgument, this, OnSuccessCallback_77, OnFailureCallback_77);
    }

    void OnFailureResponse_77(uint8_t status) { NextTest(); }

    void OnSuccessResponse_77() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1X_78()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1X::TypeInfo>(this, OnSuccessCallback_78,
                                                                                                         OnFailureCallback_78);
    }

    void OnFailureResponse_78(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_78(uint16_t primary1X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary1X", primary1X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Y_79()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(this, OnSuccessCallback_79,
                                                                                                         OnFailureCallback_79);
    }

    void OnFailureResponse_79(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_79(uint16_t primary1Y)
    {
        VerifyOrReturn(CheckConstraintType("primary1Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary1Y", primary1Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary1Y_80()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary1YArgument;
        primary1YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(
            primary1YArgument, this, OnSuccessCallback_80, OnFailureCallback_80);
    }

    void OnFailureResponse_80(uint8_t status) { NextTest(); }

    void OnSuccessResponse_80() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary1Y_81()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Y::TypeInfo>(this, OnSuccessCallback_81,
                                                                                                         OnFailureCallback_81);
    }

    void OnFailureResponse_81(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_81(uint16_t primary1Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary1Y", primary1Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary1Intensity_82()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary1Intensity::TypeInfo>(
            this, OnSuccessCallback_82, OnFailureCallback_82);
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82(uint8_t primary1Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary1Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2X_83()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(this, OnSuccessCallback_83,
                                                                                                         OnFailureCallback_83);
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83(uint16_t primary2X)
    {
        VerifyOrReturn(CheckConstraintType("primary2X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2X", primary2X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2X_84()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary2XArgument;
        primary2XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(
            primary2XArgument, this, OnSuccessCallback_84, OnFailureCallback_84);
    }

    void OnFailureResponse_84(uint8_t status) { NextTest(); }

    void OnSuccessResponse_84() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2X_85()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2X::TypeInfo>(this, OnSuccessCallback_85,
                                                                                                         OnFailureCallback_85);
    }

    void OnFailureResponse_85(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_85(uint16_t primary2X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary2X", primary2X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary2Y_86()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(this, OnSuccessCallback_86,
                                                                                                         OnFailureCallback_86);
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86(uint16_t primary2Y)
    {
        VerifyOrReturn(CheckConstraintType("primary2Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary2Y", primary2Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary2Y_87()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary2YArgument;
        primary2YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(
            primary2YArgument, this, OnSuccessCallback_87, OnFailureCallback_87);
    }

    void OnFailureResponse_87(uint8_t status) { NextTest(); }

    void OnSuccessResponse_87() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary2Y_88()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Y::TypeInfo>(this, OnSuccessCallback_88,
                                                                                                         OnFailureCallback_88);
    }

    void OnFailureResponse_88(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_88(uint16_t primary2Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary2Y", primary2Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestValidateConstraintsOfAttributePrimary2Intensity_89()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary2Intensity::TypeInfo>(
            this, OnSuccessCallback_89, OnFailureCallback_89);
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89(uint8_t primary2Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary2Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3X_90()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(this, OnSuccessCallback_90,
                                                                                                         OnFailureCallback_90);
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90(uint16_t primary3X)
    {
        VerifyOrReturn(CheckConstraintType("primary3X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3X", primary3X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3X_91()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary3XArgument;
        primary3XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(
            primary3XArgument, this, OnSuccessCallback_91, OnFailureCallback_91);
    }

    void OnFailureResponse_91(uint8_t status) { NextTest(); }

    void OnSuccessResponse_91() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3X_92()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3X::TypeInfo>(this, OnSuccessCallback_92,
                                                                                                         OnFailureCallback_92);
    }

    void OnFailureResponse_92(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_92(uint16_t primary3X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary3X", primary3X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Y_93()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(this, OnSuccessCallback_93,
                                                                                                         OnFailureCallback_93);
    }

    void OnFailureResponse_93(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_93(uint16_t primary3Y)
    {
        VerifyOrReturn(CheckConstraintType("primary3Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary3Y", primary3Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary3Y_94()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary3YArgument;
        primary3YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(
            primary3YArgument, this, OnSuccessCallback_94, OnFailureCallback_94);
    }

    void OnFailureResponse_94(uint8_t status) { NextTest(); }

    void OnSuccessResponse_94() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary3Y_95()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Y::TypeInfo>(this, OnSuccessCallback_95,
                                                                                                         OnFailureCallback_95);
    }

    void OnFailureResponse_95(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_95(uint16_t primary3Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary3Y", primary3Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary3Intensity_96()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary3Intensity::TypeInfo>(
            this, OnSuccessCallback_96, OnFailureCallback_96);
    }

    void OnFailureResponse_96(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_96(uint8_t primary3Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary3Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4X_97()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(this, OnSuccessCallback_97,
                                                                                                         OnFailureCallback_97);
    }

    void OnFailureResponse_97(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_97(uint16_t primary4X)
    {
        VerifyOrReturn(CheckConstraintType("primary4X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4X", primary4X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4X_98()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary4XArgument;
        primary4XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(
            primary4XArgument, this, OnSuccessCallback_98, OnFailureCallback_98);
    }

    void OnFailureResponse_98(uint8_t status) { NextTest(); }

    void OnSuccessResponse_98() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4X_99()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4X::TypeInfo>(this, OnSuccessCallback_99,
                                                                                                         OnFailureCallback_99);
    }

    void OnFailureResponse_99(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_99(uint16_t primary4X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary4X", primary4X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Y_100()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            this, OnSuccessCallback_100, OnFailureCallback_100);
    }

    void OnFailureResponse_100(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_100(uint16_t primary4Y)
    {
        VerifyOrReturn(CheckConstraintType("primary4Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary4Y", primary4Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary4Y_101()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary4YArgument;
        primary4YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            primary4YArgument, this, OnSuccessCallback_101, OnFailureCallback_101);
    }

    void OnFailureResponse_101(uint8_t status) { NextTest(); }

    void OnSuccessResponse_101() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary4Y_102()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Y::TypeInfo>(
            this, OnSuccessCallback_102, OnFailureCallback_102);
    }

    void OnFailureResponse_102(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_102(uint16_t primary4Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary4Y", primary4Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary4Intensity_103()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary4Intensity::TypeInfo>(
            this, OnSuccessCallback_103, OnFailureCallback_103);
    }

    void OnFailureResponse_103(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_103(uint8_t primary4Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary4Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5X_104()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            this, OnSuccessCallback_104, OnFailureCallback_104);
    }

    void OnFailureResponse_104(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_104(uint16_t primary5X)
    {
        VerifyOrReturn(CheckConstraintType("primary5X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5X", primary5X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5X_105()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary5XArgument;
        primary5XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            primary5XArgument, this, OnSuccessCallback_105, OnFailureCallback_105);
    }

    void OnFailureResponse_105(uint8_t status) { NextTest(); }

    void OnSuccessResponse_105() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5X_106()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5X::TypeInfo>(
            this, OnSuccessCallback_106, OnFailureCallback_106);
    }

    void OnFailureResponse_106(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_106(uint16_t primary5X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary5X", primary5X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Y_107()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            this, OnSuccessCallback_107, OnFailureCallback_107);
    }

    void OnFailureResponse_107(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_107(uint16_t primary5Y)
    {
        VerifyOrReturn(CheckConstraintType("primary5Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary5Y", primary5Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary5Y_108()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary5YArgument;
        primary5YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            primary5YArgument, this, OnSuccessCallback_108, OnFailureCallback_108);
    }

    void OnFailureResponse_108(uint8_t status) { NextTest(); }

    void OnSuccessResponse_108() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary5Y_109()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Y::TypeInfo>(
            this, OnSuccessCallback_109, OnFailureCallback_109);
    }

    void OnFailureResponse_109(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_109(uint16_t primary5Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary5Y", primary5Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary5Intensity_110()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary5Intensity::TypeInfo>(
            this, OnSuccessCallback_110, OnFailureCallback_110);
    }

    void OnFailureResponse_110(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_110(uint8_t primary5Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary5Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6X_111()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            this, OnSuccessCallback_111, OnFailureCallback_111);
    }

    void OnFailureResponse_111(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_111(uint16_t primary6X)
    {
        VerifyOrReturn(CheckConstraintType("primary6X", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6X", primary6X, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6X_112()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary6XArgument;
        primary6XArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            primary6XArgument, this, OnSuccessCallback_112, OnFailureCallback_112);
    }

    void OnFailureResponse_112(uint8_t status) { NextTest(); }

    void OnSuccessResponse_112() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6X_113()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6X::TypeInfo>(
            this, OnSuccessCallback_113, OnFailureCallback_113);
    }

    void OnFailureResponse_113(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_113(uint16_t primary6X)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary6X", primary6X, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Y_114()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            this, OnSuccessCallback_114, OnFailureCallback_114);
    }

    void OnFailureResponse_114(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_114(uint16_t primary6Y)
    {
        VerifyOrReturn(CheckConstraintType("primary6Y", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("primary6Y", primary6Y, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultMandatoryAttributePrimary6Y_115()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t primary6YArgument;
        primary6YArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            primary6YArgument, this, OnSuccessCallback_115, OnFailureCallback_115);
    }

    void OnFailureResponse_115(uint8_t status) { NextTest(); }

    void OnSuccessResponse_115() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackTheMandatoryAttributePrimary6Y_116()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Y::TypeInfo>(
            this, OnSuccessCallback_116, OnFailureCallback_116);
    }

    void OnFailureResponse_116(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_116(uint16_t primary6Y)
    {
        VerifyOrReturn(CheckValue<uint16_t>("primary6Y", primary6Y, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributePrimary6Intensity_117()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::Primary6Intensity::TypeInfo>(
            this, OnSuccessCallback_117, OnFailureCallback_117);
    }

    void OnFailureResponse_117(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_117(uint8_t primary6Intensity)
    {
        VerifyOrReturn(CheckConstraintType("primary6Intensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointX_118()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            this, OnSuccessCallback_118, OnFailureCallback_118);
    }

    void OnFailureResponse_118(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_118(uint16_t whitePointX)
    {
        VerifyOrReturn(CheckConstraintType("whitePointX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointX", whitePointX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointX_119()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t whitePointXArgument;
        whitePointXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            whitePointXArgument, this, OnSuccessCallback_119, OnFailureCallback_119);
    }

    void OnFailureResponse_119(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_119() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointX_120()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointX::TypeInfo>(
            this, OnSuccessCallback_120, OnFailureCallback_120);
    }

    void OnFailureResponse_120(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_120(uint16_t whitePointX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("whitePointX", whitePointX, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeWhitePointY_121()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            this, OnSuccessCallback_121, OnFailureCallback_121);
    }

    void OnFailureResponse_121(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_121(uint16_t whitePointY)
    {
        VerifyOrReturn(CheckConstraintType("whitePointY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("whitePointY", whitePointY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeWhitePointY_122()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t whitePointYArgument;
        whitePointYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            whitePointYArgument, this, OnSuccessCallback_122, OnFailureCallback_122);
    }

    void OnFailureResponse_122(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_122() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeWhitePointY_123()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::WhitePointY::TypeInfo>(
            this, OnSuccessCallback_123, OnFailureCallback_123);
    }

    void OnFailureResponse_123(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_123(uint16_t whitePointY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("whitePointY", whitePointY, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRX_124()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            this, OnSuccessCallback_124, OnFailureCallback_124);
    }

    void OnFailureResponse_124(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_124(uint16_t colorPointRX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRX", colorPointRX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRX_125()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorPointRXArgument;
        colorPointRXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            colorPointRXArgument, this, OnSuccessCallback_125, OnFailureCallback_125);
    }

    void OnFailureResponse_125(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_125() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRX_126()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRX::TypeInfo>(
            this, OnSuccessCallback_126, OnFailureCallback_126);
    }

    void OnFailureResponse_126(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_126(uint16_t colorPointRX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointRX", colorPointRX, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRY_127()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            this, OnSuccessCallback_127, OnFailureCallback_127);
    }

    void OnFailureResponse_127(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_127(uint16_t colorPointRY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointRY", colorPointRY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointRY_128()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorPointRYArgument;
        colorPointRYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            colorPointRYArgument, this, OnSuccessCallback_128, OnFailureCallback_128);
    }

    void OnFailureResponse_128(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_128() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointRY_129()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRY::TypeInfo>(
            this, OnSuccessCallback_129, OnFailureCallback_129);
    }

    void OnFailureResponse_129(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_129(uint16_t colorPointRY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointRY", colorPointRY, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointRIntensity_130()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointRIntensity::TypeInfo>(
            this, OnSuccessCallback_130, OnFailureCallback_130);
    }

    void OnFailureResponse_130(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_130(uint8_t colorPointRIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointRIntensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGX_131()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            this, OnSuccessCallback_131, OnFailureCallback_131);
    }

    void OnFailureResponse_131(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_131(uint16_t colorPointGX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGX", colorPointGX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGX_132()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorPointGXArgument;
        colorPointGXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            colorPointGXArgument, this, OnSuccessCallback_132, OnFailureCallback_132);
    }

    void OnFailureResponse_132(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_132() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGX_133()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGX::TypeInfo>(
            this, OnSuccessCallback_133, OnFailureCallback_133);
    }

    void OnFailureResponse_133(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_133(uint16_t colorPointGX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointGX", colorPointGX, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGY_134()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            this, OnSuccessCallback_134, OnFailureCallback_134);
    }

    void OnFailureResponse_134(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_134(uint16_t colorPointGY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointGY", colorPointGY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointGY_135()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorPointGYArgument;
        colorPointGYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            colorPointGYArgument, this, OnSuccessCallback_135, OnFailureCallback_135);
    }

    void OnFailureResponse_135(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_135() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointGY_136()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGY::TypeInfo>(
            this, OnSuccessCallback_136, OnFailureCallback_136);
    }

    void OnFailureResponse_136(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_136(uint16_t colorPointGY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointGY", colorPointGY, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointGIntensity_137()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointGIntensity::TypeInfo>(
            this, OnSuccessCallback_137, OnFailureCallback_137);
    }

    void OnFailureResponse_137(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_137(uint8_t colorPointGIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointGIntensity", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBX_138()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            this, OnSuccessCallback_138, OnFailureCallback_138);
    }

    void OnFailureResponse_138(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_138(uint16_t colorPointBX)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBX", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBX", colorPointBX, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBX_139()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorPointBXArgument;
        colorPointBXArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            colorPointBXArgument, this, OnSuccessCallback_139, OnFailureCallback_139);
    }

    void OnFailureResponse_139(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_139() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBX_140()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBX::TypeInfo>(
            this, OnSuccessCallback_140, OnFailureCallback_140);
    }

    void OnFailureResponse_140(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_140(uint16_t colorPointBX)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointBX", colorPointBX, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBY_141()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            this, OnSuccessCallback_141, OnFailureCallback_141);
    }

    void OnFailureResponse_141(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_141(uint16_t colorPointBY)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBY", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("colorPointBY", colorPointBY, 65279));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultOptionalAttributeColorPointBY_142()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t colorPointBYArgument;
        colorPointBYArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            colorPointBYArgument, this, OnSuccessCallback_142, OnFailureCallback_142);
    }

    void OnFailureResponse_142(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_142() { NextTest(); }

    CHIP_ERROR TestReadBackTheOptionalAttributeColorPointBY_143()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBY::TypeInfo>(
            this, OnSuccessCallback_143, OnFailureCallback_143);
    }

    void OnFailureResponse_143(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_143(uint16_t colorPointBY)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorPointBY", colorPointBY, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeColorPointBIntensity_144()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorPointBIntensity::TypeInfo>(
            this, OnSuccessCallback_144, OnFailureCallback_144);
    }

    void OnFailureResponse_144(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_144(uint8_t colorPointBIntensity)
    {
        VerifyOrReturn(CheckConstraintType("colorPointBIntensity", "", "uint8"));
        NextTest();
    }
};

class Test_TC_CC_3_1 : public TestCommand
{
public:
    Test_TC_CC_3_1() : TestCommand("Test_TC_CC_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to hue shortest distance command\n");
            err = TestMoveToHueShortestDistanceCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move to hue longest distance command\n");
            err = TestMoveToHueLongestDistanceCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move to hue up command\n");
            err = TestMoveToHueUpCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move to hue down command\n");
            err = TestMoveToHueDownCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToHueShortestDistanceCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 150;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveToHueLongestDistanceCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 200;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(1);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveToHueUpCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 250;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(2);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveToHueDownCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHue::Type;

        RequestType request;
        request.hue             = 225;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(3);
        request.transitionTime  = 100U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_1 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_7,
                                                                                              OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_3_2 : public TestCommand
{
public:
    Test_TC_CC_3_2() : TestCommand("Test_TC_CC_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move hue up command\n");
            err = TestMoveHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move hue stop command\n");
            err = TestMoveHueStopCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move hue down command\n");
            err = TestMoveHueDownCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Move hue stop command\n");
            err = TestMoveHueStopCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveHueUpCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveHueDownCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestMoveHueStopCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 50;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_2 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_7,
                                                                                              OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_3_3 : public TestCommand
{
public:
    Test_TC_CC_3_3() : TestCommand("Test_TC_CC_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step hue up command\n");
            err = TestStepHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step hue down command\n");
            err = TestStepHueDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepHueUpCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepHueDownCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize        = 5;
        request.transitionTime  = 25;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_3_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_1 : public TestCommand
{
public:
    Test_TC_CC_4_1() : TestCommand("Test_TC_CC_4_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to saturation command\n");
            err = TestMoveToSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToSaturationCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToSaturation::Type;

        RequestType request;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_4,
                                                                                              OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_2 : public TestCommand
{
public:
    Test_TC_CC_4_2() : TestCommand("Test_TC_CC_4_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move saturation up command\n");
            err = TestMoveSaturationUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Move saturation down command\n");
            err = TestMoveSaturationDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveSaturationUpCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(1);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestMoveSaturationDownCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveSaturation::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::SaturationMoveMode>(3);
        request.rate            = 5;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_3 : public TestCommand
{
public:
    Test_TC_CC_4_3() : TestCommand("Test_TC_CC_4_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step saturation up command\n");
            err = TestStepSaturationUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step saturation down command\n");
            err = TestStepSaturationDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepSaturationUpCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(1);
        request.stepSize        = 15;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepSaturationDownCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepSaturation::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::SaturationStepMode>(3);
        request.stepSize        = 20;
        request.transitionTime  = 10;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_4_4 : public TestCommand
{
public:
    Test_TC_CC_4_4() : TestCommand("Test_TC_CC_4_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_4_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_4_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move To current hue and saturation command\n");
            err = TestMoveToCurrentHueAndSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToCurrentHueAndSaturationCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToHueAndSaturation::Type;

        RequestType request;
        request.hue             = 40;
        request.saturation      = 160;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_4_4 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_4,
                                                                                              OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_1 : public TestCommand
{
public:
    Test_TC_CC_5_1() : TestCommand("Test_TC_CC_5_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move to Color command\n");
            err = TestMoveToColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToColorCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToColor::Type;

        RequestType request;
        request.colorX          = 200U;
        request.colorY          = 300U;
        request.transitionTime  = 20U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_4,
                                                                                              OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_2 : public TestCommand
{
public:
    Test_TC_CC_5_2() : TestCommand("Test_TC_CC_5_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move Color command\n");
            err = TestMoveColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Stop Move Step command\n");
            err = TestStopMoveStepCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveColorCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColor::Type;

        RequestType request;
        request.rateX           = 15;
        request.rateY           = 20;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStopMoveStepCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StopMoveStep::Type;

        RequestType request;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_5_3 : public TestCommand
{
public:
    Test_TC_CC_5_3() : TestCommand("Test_TC_CC_5_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_5_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_5_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step Color command\n");
            err = TestStepColorCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepColorCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColor::Type;

        RequestType request;
        request.stepX           = 15;
        request.stepY           = 20;
        request.transitionTime  = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_5_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_4,
                                                                                              OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_1 : public TestCommand
{
public:
    Test_TC_CC_6_1() : TestCommand("Test_TC_CC_6_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move To Color Temperature command\n");
            err = TestMoveToColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveToColorTemperatureCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveToColorTemperature::Type;

        RequestType request;
        request.colorTemperature = 100U;
        request.transitionTime   = 10U;
        request.optionsMask      = 0;
        request.optionsOverride  = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_4,
                                                                                              OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_2 : public TestCommand
{
public:
    Test_TC_CC_6_2() : TestCommand("Test_TC_CC_6_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Move up color temperature command\n");
            err = TestMoveUpColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Stop Color Temperature command\n");
            err = TestStopColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Move down color temperature command\n");
            err = TestMoveDownColorTemperatureCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_6(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestMoveUpColorTemperatureCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStopColorTemperatureCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate                    = 10U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestMoveDownColorTemperatureCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::MoveColorTemperature::Type;

        RequestType request;
        request.moveMode                = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate                    = 20U;
        request.colorTemperatureMinimum = 1U;
        request.colorTemperatureMaximum = 255U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_6_3 : public TestCommand
{
public:
    Test_TC_CC_6_3() : TestCommand("Test_TC_CC_6_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_6_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_6_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Step up color temperature command\n");
            err = TestStepUpColorTemperatureCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Step down color temperature command\n");
            err = TestStepDownColorTemperatureCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestStepUpColorTemperatureCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;

        RequestType request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestStepDownColorTemperatureCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::StepColorTemperature::Type;

        RequestType request;
        request.stepMode                = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(3);
        request.stepSize                = 5U;
        request.transitionTime          = 50U;
        request.colorTemperatureMinimum = 5U;
        request.colorTemperatureMaximum = 100U;
        request.optionsMask             = 0;
        request.optionsOverride         = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_6_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_1 : public TestCommand
{
public:
    Test_TC_CC_7_1() : TestCommand("Test_TC_CC_7_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Move To Hue command\n");
            err = TestEnhancedMoveToHueCommand_2();
            break;
        case 3:
            ChipLogProgress(
                chipTool, " ***** Test Step 3 : Check Remaining time attribute value matched the value sent by the last command\n");
            err = TestCheckRemainingTimeAttributeValueMatchedTheValueSentByTheLastCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint16_t remainingTime)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_3(remainingTime);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 1025U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckRemainingTimeAttributeValueMatchedTheValueSentByTheLastCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::RemainingTime::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t remainingTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("remainingTime", remainingTime, 1U));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_2 : public TestCommand
{
public:
    Test_TC_CC_7_2() : TestCommand("Test_TC_CC_7_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Move Hue Down command \n");
            err = TestEnhancedMoveHueDownCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Enhanced Move Hue Up command\n");
            err = TestEnhancedMoveHueUpCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Enhanced Move Hue Stop command\n");
            err = TestEnhancedMoveHueStopCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveHueDownCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(3);
        request.rate            = 5U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueUpCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(1);
        request.rate            = 50U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestEnhancedMoveHueStopCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveHue::Type;

        RequestType request;
        request.moveMode        = static_cast<chip::app::Clusters::ColorControl::HueMoveMode>(0);
        request.rate            = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_2 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_7,
                                                                                              OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_3 : public TestCommand
{
public:
    Test_TC_CC_7_3() : TestCommand("Test_TC_CC_7_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced Step Hue Up command\n");
            err = TestEnhancedStepHueUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Enhanced Step Hue Down command\n");
            err = TestEnhancedStepHueDownCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_5(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedStepHueUpCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(0);
        request.stepSize        = 50U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestEnhancedStepHueDownCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedStepHue::Type;

        RequestType request;
        request.stepMode        = static_cast<chip::app::Clusters::ColorControl::HueStepMode>(1);
        request.stepSize        = 75U;
        request.transitionTime  = 1U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_7_4 : public TestCommand
{
public:
    Test_TC_CC_7_4() : TestCommand("Test_TC_CC_7_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_7_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_7_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Enhanced move to hue and saturation command\n");
            err = TestEnhancedMoveToHueAndSaturationCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_4(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueAndSaturationCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHueAndSaturation::Type;

        RequestType request;
        request.enhancedHue     = 1200U;
        request.saturation      = 90;
        request.transitionTime  = 10U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_7_4 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_4,
                                                                                              OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_8_1 : public TestCommand
{
public:
    Test_TC_CC_8_1() : TestCommand("Test_TC_CC_8_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_8_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_8_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Turn on light for color control tests\n");
            err = TestTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Color Loop Set Command - Set all Attributs\n");
            err = TestColorLoopSetCommandSetAllAttributs_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check ColorLoopStartEnhancedHue Value\n");
            err = TestCheckColorLoopStartEnhancedHueValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Check ColorLoopActive Value\n");
            err = TestCheckColorLoopActiveValue_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Color Loop Set Command - Set direction and time while running\n");
            err = TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check ColorLoopTime Value\n");
            err = TestCheckColorLoopTimeValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Color Loop Set Command - Set direction while running\n");
            err = TestColorLoopSetCommandSetDirectionWhileRunning_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Check ColorLoopDirection Value\n");
            err = TestCheckColorLoopDirectionValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Turn off light that we turned on\n");
            err = TestTurnOffLightThatWeTurnedOn_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_15();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 16;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_3(colorLoopDirection);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_4(colorLoopTime);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_5(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_6(colorLoopActive);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_8(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_10(colorLoopDirection);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_11(colorLoopTime);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_13(colorLoopDirection);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_15(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributs_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(14);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 100U;
        request.startHue        = 500U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 100U));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopStartEnhancedHueValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 500U));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopActiveValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopActiveValue_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionAndTimeWhileRunning_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(6);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 3500U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestCheckColorLoopTimeValue_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 3500U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetDirectionWhileRunning_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestCheckColorLoopDirectionValue_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightThatWeTurnedOn_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_8_1 *>(context))->OnFailureResponse_14(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_15,
                                                                                              OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_CC_9_1 : public TestCommand
{
public:
    Test_TC_CC_9_1() : TestCommand("Test_TC_CC_9_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition : Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read ColorLoopTime attribute from DUT\n");
            err = TestReadColorLoopTimeAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read ColorLoopStartEnhancedHue attribute from DUT\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Enhanced Move To Hue command 10\n");
            err = TestEnhancedMoveToHueCommand10_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Wait 2000ms\n");
            err = TestWait2000ms_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read EnhancedCurrentHue attribute from DUT\n");
            err = TestReadEnhancedCurrentHueAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read ColorLoopDirection attribute from DUT\n");
            err = TestReadColorLoopDirectionAttributeFromDut_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Turn Off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_35();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 36;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_3(colorLoopActive);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_5(colorLoopDirection);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_7(colorLoopTime);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_9(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_11(colorLoopActive);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_13(colorLoopActive);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_15(colorLoopDirection);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_17(colorLoopActive);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_19(colorLoopActive);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, uint16_t enhancedCurrentHue)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_22(enhancedCurrentHue);
    }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_24(colorLoopDirection);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_26(colorLoopActive);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_28(colorLoopActive);
    }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_30(colorLoopDirection);
    }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_32(colorLoopActive);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_34(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 30U));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(8);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_14(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_16();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_16(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_18();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_18(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestEnhancedMoveToHueCommand10_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::EnhancedMoveToHue::Type;

        RequestType request;
        request.enhancedHue     = 40960U;
        request.direction       = static_cast<chip::app::Clusters::ColorControl::HueDirection>(0);
        request.transitionTime  = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_20();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_20(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20() { NextTest(); }

    CHIP_ERROR TestWait2000ms_21() { return WaitForMs(2000); }

    CHIP_ERROR TestReadEnhancedCurrentHueAttributeFromDut_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint16_t enhancedCurrentHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enhancedCurrentHue", enhancedCurrentHue, 40960U));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_23();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_23(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_25();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_25(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_27();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_27(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_29();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_29(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(2);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_31();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_31(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_33();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_33(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnSuccessResponse_35();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_1 *>(context))->OnFailureResponse_35(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35() { NextTest(); }
};

class Test_TC_CC_9_2 : public TestCommand
{
public:
    Test_TC_CC_9_2() : TestCommand("Test_TC_CC_9_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Color Loop Set Command - Set all Attributes\n");
            err = TestColorLoopSetCommandSetAllAttributes_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read ColorLoopActive attribute from DUT.\n");
            err = TestReadColorLoopActiveAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_3(colorLoopActive);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_4(colorLoopDirection);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_5(colorLoopTime);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_6(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_8(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_10(colorLoopDirection);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_12(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 30U));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(2);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(1);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_2 *>(context))->OnFailureResponse_13(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }
};

class Test_TC_CC_9_3 : public TestCommand
{
public:
    Test_TC_CC_9_3() : TestCommand("Test_TC_CC_9_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_CC_9_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_CC_9_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Precondition: Turn on light for color control tests\n");
            err = TestPreconditionTurnOnLightForColorControlTests_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: Check on/off attribute value is true after on command\n");
            err = TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Sends ColorLoopSet Command - Set all Attributes\n");
            err = TestSendsColorLoopSetCommandSetAllAttributes_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read ColorLoopDirection attribute from DUT.\n");
            err = TestReadColorLoopDirectionAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read ColorLoopStartEnhancedHue attribute from DUT.\n");
            err = TestReadColorLoopStartEnhancedHueAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Color Loop Set Command - Set all Attributes\n");
            err = TestColorLoopSetCommandSetAllAttributes_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read ColorLoopActive attribute from DUT.\n");
            err = TestReadColorLoopActiveAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read ColorLoopTime attribute from DUT.\n");
            err = TestReadColorLoopTimeAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Color Loop Set Command - Start Color Loop\n");
            err = TestColorLoopSetCommandStartColorLoop_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read ColorLoopActive attribute from DUT\n");
            err = TestReadColorLoopActiveAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Turn off light for color control tests\n");
            err = TestTurnOffLightForColorControlTests_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_3(colorLoopActive);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t colorLoopDirection)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_4(colorLoopDirection);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_5(colorLoopTime);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint16_t colorLoopStartEnhancedHue)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_6(colorLoopStartEnhancedHue);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_8(colorLoopActive);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint16_t colorLoopTime)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_10(colorLoopTime);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint8_t colorLoopActive)
    {
        (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_12(colorLoopActive);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestPreconditionTurnOnLightForColorControlTests_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestPreconditionCheckOnOffAttributeValueIsTrueAfterOnCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendsColorLoopSetCommandSetAllAttributes_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(15);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 30U;
        request.startHue        = 160U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopDirectionAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t colorLoopDirection)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopDirection", colorLoopDirection, 0));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 30U));
        NextTest();
    }

    CHIP_ERROR TestReadColorLoopStartEnhancedHueAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint16_t colorLoopStartEnhancedHue)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopStartEnhancedHue", colorLoopStartEnhancedHue, 160U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandSetAllAttributes_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(1);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 1));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(4);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 60U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_9();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadColorLoopTimeAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint16_t colorLoopTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("colorLoopTime", colorLoopTime, 60U));
        NextTest();
    }

    CHIP_ERROR TestColorLoopSetCommandStartColorLoop_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ColorControl::Commands::ColorLoopSet::Type;

        RequestType request;
        request.updateFlags     = static_cast<chip::BitFlags<chip::app::Clusters::ColorControl::ColorLoopUpdateFlags>>(1);
        request.action          = static_cast<chip::app::Clusters::ColorControl::ColorLoopAction>(0);
        request.direction       = static_cast<chip::app::Clusters::ColorControl::ColorLoopDirection>(0);
        request.time            = 0U;
        request.startHue        = 0U;
        request.optionsMask     = 0;
        request.optionsOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadColorLoopActiveAttributeFromDut_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ColorControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t colorLoopActive)
    {
        VerifyOrReturn(CheckValue<uint8_t>("colorLoopActive", colorLoopActive, 0));
        NextTest();
    }

    CHIP_ERROR TestTurnOffLightForColorControlTests_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnSuccessResponse_13();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_CC_9_3 *>(context))->OnFailureResponse_13(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }
};

class Test_TC_DM_1_1 : public TestCommand
{
public:
    Test_TC_DM_1_1() : TestCommand("Test_TC_DM_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Query Interaction Model Version\n");
            err = TestQueryInteractionModelVersion_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Vendor Name\n");
            err = TestQueryVendorName_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query VendorID\n");
            err = TestQueryVendorID_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query Product Name\n");
            err = TestQueryProductName_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Query ProductID\n");
            err = TestQueryProductID_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Query User Label\n");
            err = TestQueryUserLabel_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Query User Location\n");
            err = TestQueryUserLocation_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Query HardwareVersion\n");
            err = TestQueryHardwareVersion_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Query HardwareVersionString\n");
            err = TestQueryHardwareVersionString_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Query SoftwareVersion\n");
            err = TestQuerySoftwareVersion_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Query SoftwareVersionString\n");
            err = TestQuerySoftwareVersionString_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Query ManufacturingDate\n");
            err = ShouldSkip("MANF_DATE") ? CHIP_NO_ERROR : TestQueryManufacturingDate_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Query PartNumber\n");
            err = ShouldSkip("PART_NUM") ? CHIP_NO_ERROR : TestQueryPartNumber_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Query ProductURL\n");
            err = TestQueryProductURL_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Query ProductLabel\n");
            err = TestQueryProductLabel_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Query SerialNumber\n");
            err = TestQuerySerialNumber_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Query LocalConfigDisabled\n");
            err = TestQueryLocalConfigDisabled_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Query Reachable\n");
            err = TestQueryReachable_17();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 18;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t interactionModelVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_0(interactionModelVersion);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan vendorName)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_1(vendorName);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t vendorID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_2(vendorID);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan productName)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_3(productName);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t productID)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_4(productID);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, chip::CharSpan userLabel)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_5(userLabel);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, chip::CharSpan location)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_6(location);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint16_t hardwareVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_7(hardwareVersion);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, chip::CharSpan hardwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_8(hardwareVersionString);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint32_t softwareVersion)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_9(softwareVersion);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, chip::CharSpan softwareVersionString)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_10(softwareVersionString);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, chip::CharSpan manufacturingDate)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_11(manufacturingDate);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, chip::CharSpan partNumber)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_12(partNumber);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, chip::CharSpan productURL)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_13(productURL);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, chip::CharSpan productLabel)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_14(productLabel);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, chip::CharSpan serialNumber)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_15(serialNumber);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, bool localConfigDisabled)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_16(localConfigDisabled);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, bool reachable)
    {
        (static_cast<Test_TC_DM_1_1 *>(context))->OnSuccessResponse_17(reachable);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestQueryInteractionModelVersion_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::InteractionModelVersion::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t interactionModelVersion)
    {
        VerifyOrReturn(CheckConstraintType("interactionModelVersion", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryVendorName_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::VendorName::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                   OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::CharSpan vendorName)
    {
        VerifyOrReturn(CheckConstraintType("vendorName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("vendorName", vendorName.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryVendorID_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::VendorID::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                 OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t vendorID)
    {
        VerifyOrReturn(CheckConstraintType("vendorID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryProductName_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductName::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                    OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::CharSpan productName)
    {
        VerifyOrReturn(CheckConstraintType("productName", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productName", productName.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryProductID_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductID::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                  OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t productID)
    {
        VerifyOrReturn(CheckConstraintType("productID", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryUserLabel_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::UserLabel::TypeInfo>(this, OnSuccessCallback_5,
                                                                                                  OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(chip::CharSpan userLabel)
    {
        VerifyOrReturn(CheckConstraintType("userLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("userLabel", userLabel.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryUserLocation_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_6,
                                                                                                 OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(chip::CharSpan location)
    {
        VerifyOrReturn(CheckConstraintType("location", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("location", "", "ISO 3166-1 alpha-2"));
        VerifyOrReturn(CheckConstraintMaxLength("location", location.size(), 2));
        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersion_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::HardwareVersion::TypeInfo>(this, OnSuccessCallback_7,
                                                                                                        OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t hardwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersion", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestQueryHardwareVersionString_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::HardwareVersionString::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(chip::CharSpan hardwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("hardwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintMinLength("hardwareVersionString", hardwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("hardwareVersionString", hardwareVersionString.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersion_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SoftwareVersion::TypeInfo>(this, OnSuccessCallback_9,
                                                                                                        OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint32_t softwareVersion)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersion", "", "uint32"));
        NextTest();
    }

    CHIP_ERROR TestQuerySoftwareVersionString_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SoftwareVersionString::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(chip::CharSpan softwareVersionString)
    {
        VerifyOrReturn(CheckConstraintType("softwareVersionString", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("softwareVersionString", "", "ASCII"));
        VerifyOrReturn(CheckConstraintMinLength("softwareVersionString", softwareVersionString.size(), 1));
        VerifyOrReturn(CheckConstraintMaxLength("softwareVersionString", softwareVersionString.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQueryManufacturingDate_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ManufacturingDate::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_11(chip::CharSpan manufacturingDate)
    {
        VerifyOrReturn(CheckConstraintType("manufacturingDate", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("manufacturingDate", "", "ISO 8601"));
        VerifyOrReturn(CheckConstraintMinLength("manufacturingDate", manufacturingDate.size(), 8));
        VerifyOrReturn(CheckConstraintMaxLength("manufacturingDate", manufacturingDate.size(), 16));
        NextTest();
    }

    CHIP_ERROR TestQueryPartNumber_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::PartNumber::TypeInfo>(this, OnSuccessCallback_12,
                                                                                                   OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_12(chip::CharSpan partNumber)
    {
        VerifyOrReturn(CheckConstraintType("partNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("partNumber", partNumber.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryProductURL_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductURL::TypeInfo>(this, OnSuccessCallback_13,
                                                                                                   OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_13(chip::CharSpan productURL)
    {
        VerifyOrReturn(CheckConstraintType("productURL", "", "string"));
        VerifyOrReturn(CheckConstraintFormat("productURL", "", "RFC3986"));
        VerifyOrReturn(CheckConstraintMaxLength("productURL", productURL.size(), 256));
        NextTest();
    }

    CHIP_ERROR TestQueryProductLabel_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::ProductLabel::TypeInfo>(this, OnSuccessCallback_14,
                                                                                                     OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_14(chip::CharSpan productLabel)
    {
        VerifyOrReturn(CheckConstraintType("productLabel", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("productLabel", productLabel.size(), 64));
        NextTest();
    }

    CHIP_ERROR TestQuerySerialNumber_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::SerialNumber::TypeInfo>(this, OnSuccessCallback_15,
                                                                                                     OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_15(chip::CharSpan serialNumber)
    {
        VerifyOrReturn(CheckConstraintType("serialNumber", "", "string"));
        VerifyOrReturn(CheckConstraintMaxLength("serialNumber", serialNumber.size(), 32));
        NextTest();
    }

    CHIP_ERROR TestQueryLocalConfigDisabled_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::LocalConfigDisabled::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_16(bool localConfigDisabled)
    {
        VerifyOrReturn(CheckConstraintType("localConfigDisabled", "", "boolean"));
        NextTest();
    }

    CHIP_ERROR TestQueryReachable_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Reachable::TypeInfo>(this, OnSuccessCallback_17,
                                                                                                  OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_17(bool reachable)
    {
        VerifyOrReturn(CheckConstraintType("reachable", "", "boolean"));
        NextTest();
    }
};

class Test_TC_DM_3_1 : public TestCommand
{
public:
    Test_TC_DM_3_1() : TestCommand("Test_TC_DM_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_DM_2_2 : public TestCommand
{
public:
    Test_TC_DM_2_2() : TestCommand("Test_TC_DM_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Query fabrics list\n");
            err = TestQueryFabricsList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Query Supported Fabrics\n");
            err = TestQuerySupportedFabrics_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Query Commissioned Fabrics\n");
            err = TestQueryCommissionedFabrics_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Query User Trusted Root Certificates\n");
            err = TestQueryUserTrustedRootCertificates_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void
    OnSuccessCallback_0(void * context,
                        const chip::app::DataModel::DecodableList<
                            chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabricsList)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_0(fabricsList);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t supportedFabrics)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_1(supportedFabrics);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_2(commissionedFabrics);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context,
                                    const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)
    {
        (static_cast<Test_TC_DM_2_2 *>(context))->OnSuccessResponse_3(trustedRootCertificates);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestQueryFabricsList_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::FabricsList::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(const chip::app::DataModel::DecodableList<
                             chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> & fabricsList)
    {
        auto iter = fabricsList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(fabricsList)>("fabricsList", iter, 0));
        VerifyOrReturn(CheckNoMoreListItems<decltype(fabricsList)>("fabricsList", iter, 1));
        NextTest();
    }

    CHIP_ERROR TestQuerySupportedFabrics_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::SupportedFabrics::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckValue<uint8_t>("supportedFabrics", supportedFabrics, 16));
        NextTest();
    }

    CHIP_ERROR TestQueryCommissionedFabrics_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckValue<uint8_t>("commissionedFabrics", commissionedFabrics, 1));
        NextTest();
    }

    CHIP_ERROR TestQueryUserTrustedRootCertificates_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::TrustedRootCertificates::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::ByteSpan> & trustedRootCertificates)
    {
        VerifyOrReturn(CheckConstraintType("trustedRootCertificates", "", "list"));
        NextTest();
    }
};

class Test_TC_EMR_1_1 : public TestCommand
{
public:
    Test_TC_EMR_1_1() : TestCommand("Test_TC_EMR_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_EMR_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_EMR_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_EMR_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ElectricalMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }
};

class Test_TC_FLW_1_1 : public TestCommand
{
public:
    Test_TC_FLW_1_1() : TestCommand("Test_TC_FLW_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_FLW_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_FLW_2_1 : public TestCommand
{
public:
    Test_TC_FLW_2_1() : TestCommand("Test_TC_FLW_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : write the default value to optional attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default value to optional attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMinMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeMaxMeasuredValue_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_1(minMeasuredValue);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_2(maxMeasuredValue);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_5(measuredValue);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_6(minMeasuredValue);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_FLW_2_1 *>(context))->OnSuccessResponse_7(maxMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMinMeasuredValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minMeasuredValueArgument;
        minMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            minMeasuredValueArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { NextTest(); }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteTheDefaultValueToOptionalAttributeMaxMeasuredValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxMeasuredValueArgument;
        maxMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            maxMeasuredValueArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMinMeasuredValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxMeasuredValue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_FLW_2_2 : public TestCommand
{
public:
    Test_TC_FLW_2_2() : TestCommand("Test_TC_FLW_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_FLW_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_FLW_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_FLW_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::FlowMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_ILL_1_1 : public TestCommand
{
public:
    Test_TC_ILL_1_1() : TestCommand("Test_TC_ILL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_ILL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_ILL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_ILL_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_ILL_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::IlluminanceMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }
};

class Test_TC_LVL_1_1 : public TestCommand
{
public:
    Test_TC_LVL_1_1() : TestCommand("Test_TC_LVL_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_LVL_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 4U;

        return cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_LVL_2_1 : public TestCommand
{
public:
    Test_TC_LVL_2_1() : TestCommand("Test_TC_LVL_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 100ms\n");
            err = TestWait100ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 200ms\n");
            err = TestWait200ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : reads On Off Transition Time attribute from DUT\n");
            err = TestReadsOnOffTransitionTimeAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : sends a Move to level command\n");
            err = TestSendsAMoveToLevelCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 10ms\n");
            err = TestWait10ms_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads current Level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reset level to 0\n");
            err = TestResetLevelTo0_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            err = TestWait100ms_12();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 13;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_0(currentLevel);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_3(currentLevel);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_6(currentLevel);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint16_t onOffTransitionTime)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_7(onOffTransitionTime);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_10(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 64;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait100ms_2() { return WaitForMs(100); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 64));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 128;
        request.transitionTime = 1U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait200ms_5() { return WaitForMs(200); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 128));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffTransitionTimeAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint16_t onOffTransitionTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onOffTransitionTime", onOffTransitionTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveToLevelCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 254;
        request.transitionTime = 65535U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWait10ms_9() { return WaitForMs(10); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 254));
        NextTest();
    }

    CHIP_ERROR TestResetLevelTo0_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::MoveToLevel::Type;

        RequestType request;
        request.level          = 0;
        request.transitionTime = 0U;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_2_1 *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestWait100ms_12() { return WaitForMs(100); }
};

class Test_TC_LVL_3_1 : public TestCommand
{
public:
    Test_TC_LVL_3_1() : TestCommand("Test_TC_LVL_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads max level attribute from DUT\n");
            err = TestReadsMaxLevelAttributeFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : sends a Move up command\n");
            err = TestSendsAMoveUpCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Wait 3000ms\n");
            err = TestWait3000ms_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads min level attribute from DUT\n");
            err = TestReadsMinLevelAttributeFromDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : sends a Move down command\n");
            err = TestSendsAMoveDownCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Wait 3000ms\n");
            err = TestWait3000ms_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write default move rate attribute from DUT\n");
            err = TestWriteDefaultMoveRateAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads default move rate attribute from DUT\n");
            err = TestReadsDefaultMoveRateAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : sends a Move up command at default move rate\n");
            err = TestSendsAMoveUpCommandAtDefaultMoveRate_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Wait 100ms\n");
            err = TestWait100ms_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_0(currentLevel);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t maxLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_1(maxLevel);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_4(currentLevel);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t minLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_5(minLevel);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_8(currentLevel);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t defaultMoveRate)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_10(defaultMoveRate);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_13(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMaxLevelAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MaxLevel::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                        OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t maxLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("maxLevel", maxLevel, 255));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 200;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWait3000ms_3() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 255));
        NextTest();
    }

    CHIP_ERROR TestReadsMinLevelAttributeFromDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::MinLevel::TypeInfo>(this, OnSuccessCallback_5,
                                                                                                        OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t minLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("minLevel", minLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveDownCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 250;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWait3000ms_7() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteDefaultMoveRateAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t defaultMoveRateArgument;
        defaultMoveRateArgument = 20;

        return cluster.WriteAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            defaultMoveRateArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadsDefaultMoveRateAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t defaultMoveRate)
    {
        VerifyOrReturn(CheckValue<uint8_t>("defaultMoveRate", defaultMoveRate, 20));
        NextTest();
    }

    CHIP_ERROR TestSendsAMoveUpCommandAtDefaultMoveRate_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(1);
        request.rate           = 255;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_3_1 *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestWait100ms_12() { return WaitForMs(100); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckConstraintNotValue<uint8_t>("currentLevel", currentLevel, 255));
        NextTest();
    }
};

class Test_TC_LVL_4_1 : public TestCommand
{
public:
    Test_TC_LVL_4_1() : TestCommand("Test_TC_LVL_4_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_4_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_4_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Sending on command\n");
            err = TestSendingOnCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: DUT level is set to 0x80\n");
            err = TestPreconditionDutLevelIsSetTo0x80_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 3000ms\n");
            err = TestWait3000ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Sends step down command to DUT\n");
            err = TestSendsStepDownCommandToDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 3000ms\n");
            err = TestWait3000ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Sends a Step up command\n");
            err = TestSendsAStepUpCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Wait 3000ms\n");
            err = TestWait3000ms_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads current level attribute from DUT\n");
            err = TestReadsCurrentLevelAttributeFromDut_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Sending off command\n");
            err = TestSendingOffCommand_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_3(currentLevel);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_6(currentLevel);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t currentLevel)
    {
        (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_9(currentLevel);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendingOnCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestPreconditionDutLevelIsSetTo0x80_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 128;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait3000ms_2() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 128));
        NextTest();
    }

    CHIP_ERROR TestSendsStepDownCommandToDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(1);
        request.stepSize       = 64;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait3000ms_5() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 64));
        NextTest();
    }

    CHIP_ERROR TestSendsAStepUpCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 64;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWait3000ms_8() { return WaitForMs(3000); }

    CHIP_ERROR TestReadsCurrentLevelAttributeFromDut_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::LevelControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::LevelControl::Attributes::CurrentLevel::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t currentLevel)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentLevel", currentLevel, 128));
        NextTest();
    }

    CHIP_ERROR TestSendingOffCommand_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_4_1 *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }
};

class Test_TC_LVL_5_1 : public TestCommand
{
public:
    Test_TC_LVL_5_1() : TestCommand("Test_TC_LVL_5_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_LVL_5_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_LVL_5_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Sending on command\n");
            err = TestSendingOnCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Precondition: DUT level is set to 0x80\n");
            err = TestPreconditionDutLevelIsSetTo0x80_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Wait 3000ms\n");
            err = TestWait3000ms_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Sends a move up command to DUT\n");
            err = TestSendsAMoveUpCommandToDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Wait 3000ms\n");
            err = TestWait3000ms_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Sends stop command to DUT\n");
            err = TestSendsStopCommandToDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Sending off command\n");
            err = TestSendingOffCommand_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendingOnCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestPreconditionDutLevelIsSetTo0x80_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Step::Type;

        RequestType request;
        request.stepMode       = static_cast<chip::app::Clusters::LevelControl::StepMode>(0);
        request.stepSize       = 128;
        request.transitionTime = 20U;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWait3000ms_2() { return WaitForMs(3000); }

    CHIP_ERROR TestSendsAMoveUpCommandToDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Move::Type;

        RequestType request;
        request.moveMode       = static_cast<chip::app::Clusters::LevelControl::MoveMode>(0);
        request.rate           = 1;
        request.optionMask     = 1;
        request.optionOverride = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWait3000ms_4() { return WaitForMs(3000); }

    CHIP_ERROR TestSendsStopCommandToDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LevelControl::Commands::Stop::Type;

        RequestType request;
        request.optionMask     = 0;
        request.optionOverride = 0;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestSendingOffCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_LVL_5_1 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }
};

class Test_TC_MC_1_1 : public TestCommand
{
public:
    Test_TC_MC_1_1() : TestCommand("Test_TC_MC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_MC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_MC_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_MC_2_1 : public TestCommand
{
public:
    Test_TC_MC_2_1() : TestCommand("Test_TC_MC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Put the device into low power mode\n");
            err = TestPutTheDeviceIntoLowPowerMode_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestPutTheDeviceIntoLowPowerMode_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LowPower::Commands::Sleep::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_MC_2_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_MC_2_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }
};

class Test_TC_MC_3_1 : public TestCommand
{
public:
    Test_TC_MC_3_1() : TestCommand("Test_TC_MC_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_2 : public TestCommand
{
public:
    Test_TC_MC_3_2() : TestCommand("Test_TC_MC_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_3 : public TestCommand
{
public:
    Test_TC_MC_3_3() : TestCommand("Test_TC_MC_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_4 : public TestCommand
{
public:
    Test_TC_MC_3_4() : TestCommand("Test_TC_MC_3_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_5 : public TestCommand
{
public:
    Test_TC_MC_3_5() : TestCommand("Test_TC_MC_3_5"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_6 : public TestCommand
{
public:
    Test_TC_MC_3_6() : TestCommand("Test_TC_MC_3_6"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_6\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_6\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_7 : public TestCommand
{
public:
    Test_TC_MC_3_7() : TestCommand("Test_TC_MC_3_7"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_7\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_7\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_8 : public TestCommand
{
public:
    Test_TC_MC_3_8() : TestCommand("Test_TC_MC_3_8"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_8\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_8\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_9 : public TestCommand
{
public:
    Test_TC_MC_3_9() : TestCommand("Test_TC_MC_3_9"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_9\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_9\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_10 : public TestCommand
{
public:
    Test_TC_MC_3_10() : TestCommand("Test_TC_MC_3_10"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_10\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_10\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_MC_3_11 : public TestCommand
{
public:
    Test_TC_MC_3_11() : TestCommand("Test_TC_MC_3_11"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_MC_3_11\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_MC_3_11\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_OCC_1_1 : public TestCommand
{
public:
    Test_TC_OCC_1_1() : TestCommand("Test_TC_OCC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_OCC_1_1 *>(context))->OnSuccessResponse_1(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }
};

class Test_TC_OCC_2_1 : public TestCommand
{
public:
    Test_TC_OCC_2_1() : TestCommand("Test_TC_OCC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads mandatory attribute constrains: Occupancy\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancy_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Writes the respective default value to mandatory attribute: Occupancy\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads back mandatory attribute: Occupancy\n");
            err = TestReadsBackMandatoryAttributeOccupancy_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads mandatory attribute constrains: OccupancySensorType\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorType_3();
            break;
        case 4:
            ChipLogProgress(
                chipTool, " ***** Test Step 4 : Writes the respective default value to mandatory attribute: OccupancySensorType\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads back mandatory attribute: OccupancySensorType\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorType_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads mandatory attribute constrains: OccupancySensorTypeBitmap\n");
            err = TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 7 : Writes the respective default value to mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads back mandatory attribute: OccupancySensorTypeBitmap\n");
            err = TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_0(occupancy);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_2(occupancy);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t occupancySensorType)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_3(occupancySensorType);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t occupancySensorType)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_5(occupancySensorType);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t occupancySensorTypeBitmap)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_6(occupancySensorTypeBitmap);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t occupancySensorTypeBitmap)
    {
        (static_cast<Test_TC_OCC_2_1 *>(context))->OnSuccessResponse_8(occupancySensorTypeBitmap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancy_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancy", occupancy, 1));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancy_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t occupancyArgument;
        occupancyArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            occupancyArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancy_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t occupancy)
    {
        VerifyOrReturn(CheckValue<uint8_t>("occupancy", occupancy, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorType_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t occupancySensorType)
    {
        VerifyOrReturn(CheckConstraintType("occupancySensorType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorType", occupancySensorType, 3));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorType_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t occupancySensorTypeArgument;
        occupancySensorTypeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
            occupancySensorTypeArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorType_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t occupancySensorType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("occupancySensorType", occupancySensorType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributeConstrainsOccupancySensorTypeBitmap_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t occupancySensorTypeBitmap)
    {
        VerifyOrReturn(CheckConstraintType("occupancySensorTypeBitmap", "", "map8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 1));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 7));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributeOccupancySensorTypeBitmap_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t occupancySensorTypeBitmapArgument;
        occupancySensorTypeBitmapArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
            occupancySensorTypeBitmapArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { NextTest(); }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeOccupancySensorTypeBitmap_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t occupancySensorTypeBitmap)
    {
        VerifyOrReturn(CheckValue<uint8_t>("occupancySensorTypeBitmap", occupancySensorTypeBitmap, 1));
        NextTest();
    }
};

class Test_TC_OCC_2_2 : public TestCommand
{
public:
    Test_TC_OCC_2_2() : TestCommand("Test_TC_OCC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads Occupancy attribute from DUT\n");
            err = TestReadsOccupancyAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Occupancy attribute from DUT\n");
            err = TestReadsOccupancyAttributeFromDut_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnSuccessResponse_0(occupancy);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t occupancy)
    {
        (static_cast<Test_TC_OCC_2_2 *>(context))->OnSuccessResponse_1(occupancy);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        NextTest();
    }

    CHIP_ERROR TestReadsOccupancyAttributeFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OccupancySensingClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OccupancySensing::Attributes::Occupancy::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t occupancy)
    {
        VerifyOrReturn(CheckConstraintType("occupancy", "", "map8"));
        NextTest();
    }
};

class Test_TC_OO_1_1 : public TestCommand
{
public:
    Test_TC_OO_1_1() : TestCommand("Test_TC_OO_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the optional global attribute: FeatureMap\n");
            err = TestReadTheOptionalGlobalAttributeFeatureMap_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : write the default values to optional global attribute: FeatureMap\n");
            err = TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads back optional global attribute: FeatureMap\n");
            err = TestReadsBackOptionalGlobalAttributeFeatureMap_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_3(featureMap);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_OO_1_1 *>(context))->OnSuccessResponse_5(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                        OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 4U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::ClusterRevision::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                        OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 4U));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalGlobalAttributeFeatureMap_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                   OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToOptionalGlobalAttributeFeatureMap_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint32_t featureMapArgument;
        featureMapArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(
            featureMapArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackOptionalGlobalAttributeFeatureMap_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::FeatureMap::TypeInfo>(this, OnSuccessCallback_5,
                                                                                                   OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }
};

class Test_TC_OO_2_1 : public TestCommand
{
public:
    Test_TC_OO_2_1() : TestCommand("Test_TC_OO_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: OnOff\n");
            err = TestReadTheMandatoryAttributeOnOff_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads back mandatory attribute: OnOff\n");
            err = TestReadsBackMandatoryAttributeOnOff_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read LT attribute: GlobalSceneControl\n");
            err = TestReadLtAttributeGlobalSceneControl_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read LT attribute: OnTime\n");
            err = TestReadLtAttributeOnTime_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read LT attribute: OffWaitTime\n");
            err = TestReadLtAttributeOffWaitTime_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read LT attribute: StartUpOnOff\n");
            err = TestReadLtAttributeStartUpOnOff_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : write the default value to LT attribute: OnTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOnTime_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write the default value to LT attribute: OffWaitTime\n");
            err = TestWriteTheDefaultValueToLtAttributeOffWaitTime_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : write the default value to LT attribute: StartUpOnOff\n");
            err = TestWriteTheDefaultValueToLtAttributeStartUpOnOff_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : reads back LT attribute: OnTime\n");
            err = TestReadsBackLtAttributeOnTime_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads back LT attribute: OffWaitTime\n");
            err = TestReadsBackLtAttributeOffWaitTime_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : reads back LT attribute: StartUpOnOff\n");
            err = TestReadsBackLtAttributeStartUpOnOff_11();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 12;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_0(onOff);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_2(globalSceneControl);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_3(onTime);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_4(offWaitTime);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_5(startUpOnOff);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_9(onTime);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_10(offWaitTime);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t startUpOnOff)
    {
        (static_cast<Test_TC_OO_2_1 *>(context))->OnSuccessResponse_11(startUpOnOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeOnOff_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_0,
                                                                                              OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackMandatoryAttributeOnOff_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeGlobalSceneControl_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOnTime_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_3,
                                                                                               OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeOffWaitTime_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_4,
                                                                                                    OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadLtAttributeStartUpOnOff_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                                     OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startUpOnOff", startUpOnOff, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOnTime_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t onTimeArgument;
        onTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(
            onTimeArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeOffWaitTime_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t offWaitTimeArgument;
        offWaitTimeArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(
            offWaitTimeArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWriteTheDefaultValueToLtAttributeStartUpOnOff_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t startUpOnOffArgument;
        startUpOnOffArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(
            startUpOnOffArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadsBackLtAttributeOnTime_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_9,
                                                                                               OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeOffWaitTime_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_10,
                                                                                                    OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsBackLtAttributeStartUpOnOff_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::StartUpOnOff::TypeInfo>(this, OnSuccessCallback_11,
                                                                                                     OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t startUpOnOff)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startUpOnOff", startUpOnOff, 0));
        NextTest();
    }
};

class Test_TC_OO_2_2 : public TestCommand
{
public:
    Test_TC_OO_2_2() : TestCommand("Test_TC_OO_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Off Command\n");
            err = TestSendOffCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send On Command\n");
            err = TestSendOnCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send Off Command\n");
            err = TestSendOffCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Send Toggle Command\n");
            err = TestSendToggleCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Check on/off attribute value is true after toggle command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Send Toggle Command\n");
            err = TestSendToggleCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Check on/off attribute value is false after toggle command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Send On Command\n");
            err = TestSendOnCommand_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Check on/off attribute value is true after on command\n");
            err = TestCheckOnOffAttributeValueIsTrueAfterOnCommand_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Send Off Command\n");
            err = TestSendOffCommand_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Check on/off attribute value is false after off command\n");
            err = TestCheckOnOffAttributeValueIsFalseAfterOffCommand_13();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 14;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_1(onOff);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_3(onOff);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_5(onOff);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_7(onOff);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_9(onOff);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_11(onOff);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_13(onOff);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendOffCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_1,
                                                                                              OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_3,
                                                                                              OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_5,
                                                                                              OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Toggle::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_6();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterToggleCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_7,
                                                                                              OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendToggleCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Toggle::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterToggleCommand_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_9,
                                                                                              OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_10();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsTrueAfterOnCommand_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_11,
                                                                                              OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnSuccessResponse_12();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_2 *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestCheckOnOffAttributeValueIsFalseAfterOffCommand_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_13,
                                                                                              OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }
};

class Test_TC_OO_2_3 : public TestCommand
{
public:
    Test_TC_OO_2_3() : TestCommand("Test_TC_OO_2_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_OO_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_OO_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send On Command\n");
            err = TestSendOnCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Wait 1000ms\n");
            err = TestWait1000ms_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send On Command\n");
            err = TestSendOnCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Wait 1000ms\n");
            err = TestWait1000ms_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Send On Command\n");
            err = TestSendOnCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Wait 1000ms\n");
            err = TestWait1000ms_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Reads GlobalSceneControl attribute from DUT\n");
            err = TestReadsGlobalSceneControlAttributeFromDut_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Send On Command\n");
            err = TestSendOnCommand_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Send Off Command\n");
            err = TestSendOffCommand_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Send On Command\n");
            err = TestSendOnCommand_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Send Off Command\n");
            err = TestSendOffCommand_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Send On Command\n");
            err = TestSendOnCommand_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Send Off Command\n");
            err = TestSendOffCommand_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Reads OnOff attribute from DUT\n");
            err = TestReadsOnOffAttributeFromDut_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Reads OnTime attribute from DUT\n");
            err = TestReadsOnTimeAttributeFromDut_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Reads OffWaitTime attribute from DUT\n");
            err = TestReadsOffWaitTimeAttributeFromDut_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Send Off Command\n");
            err = TestSendOffCommand_45();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 46;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_3(globalSceneControl);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_6(onOff);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_7(globalSceneControl);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_10(onOff);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, bool globalSceneControl)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_11(globalSceneControl);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_12(onTime);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_13(offWaitTime);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_15(onOff);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_16(onTime);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_17(offWaitTime);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_19(onOff);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_20(onTime);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_21(onOff);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_22(onTime);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_23(offWaitTime);
    }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_25(onTime);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_26(offWaitTime);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_28(onOff);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_29(onTime);
    }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_30(onOff);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_31(onTime);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_33(onOff);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_34(onTime);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_35(offWaitTime);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_37(onOff);
    }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_38(onTime);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_39(onOff);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_40(onTime);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_41(offWaitTime);
    }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context, bool onOff)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_42(onOff);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context, uint16_t onTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_43(onTime);
    }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context, uint16_t offWaitTime)
    {
        (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_44(offWaitTime);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendOnCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestWait1000ms_1() { return WaitForMs(1000); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_2,
                                                                                              OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWait1000ms_5() { return WaitForMs(1000); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_6,
                                                                                              OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_8();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWait1000ms_9() { return WaitForMs(1000); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_10,
                                                                                              OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsGlobalSceneControlAttributeFromDut_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(bool globalSceneControl)
    {
        VerifyOrReturn(CheckValue<bool>("globalSceneControl", globalSceneControl, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_12,
                                                                                               OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_13,
                                                                                                    OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_14();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_14(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_15,
                                                                                              OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_16,
                                                                                               OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_17,
                                                                                                    OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_18();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_18(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_19,
                                                                                              OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_20,
                                                                                               OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_21,
                                                                                              OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_22,
                                                                                               OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_23,
                                                                                                    OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_24();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_24(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_25,
                                                                                               OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_26,
                                                                                                    OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_27();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_27(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_28,
                                                                                              OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_29,
                                                                                               OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_30,
                                                                                              OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_31,
                                                                                               OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOnCommand_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_32();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_32(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_33,
                                                                                              OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_34,
                                                                                               OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_35,
                                                                                                    OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_36();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_36(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_37,
                                                                                              OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_38,
                                                                                               OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_39,
                                                                                              OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_40,
                                                                                               OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_41,
                                                                                                    OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOnOffAttributeFromDut_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnOff::TypeInfo>(this, OnSuccessCallback_42,
                                                                                              OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(bool onOff)
    {
        VerifyOrReturn(CheckValue<bool>("onOff", onOff, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsOnTimeAttributeFromDut_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OnTime::TypeInfo>(this, OnSuccessCallback_43,
                                                                                               OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43(uint16_t onTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("onTime", onTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadsOffWaitTimeAttributeFromDut_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OnOff::Attributes::OffWaitTime::TypeInfo>(this, OnSuccessCallback_44,
                                                                                                    OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint16_t offWaitTime)
    {
        VerifyOrReturn(CheckValue<uint16_t>("offWaitTime", offWaitTime, 0U));
        NextTest();
    }

    CHIP_ERROR TestSendOffCommand_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnSuccessResponse_45();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_OO_2_3 *>(context))->OnFailureResponse_45(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45() { NextTest(); }
};

class Test_TC_PRS_1_1 : public TestCommand
{
public:
    Test_TC_PRS_1_1() : TestCommand("Test_TC_PRS_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the global attribute constraints: ClusterRevision\n");
            err = TestReadTheGlobalAttributeConstraintsClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_1(clusterRevision);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_PRS_1_1 *>(context))->OnSuccessResponse_3(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeConstraintsClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckConstraintType("clusterRevision", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { NextTest(); }

    void OnSuccessResponse_2() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 2U));
        NextTest();
    }
};

class Test_TC_PRS_2_1 : public TestCommand
{
public:
    Test_TC_PRS_2_1() : TestCommand("Test_TC_PRS_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PRS_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PRS_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read the mandatory attribute constraints: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMeasuredValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write the default values to mandatory attribute: MeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads back mandatory attribute: MeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMeasuredValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read the mandatory attribute constraints: MinMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Write the default values to mandatory attribute: MinMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads back mandatory attribute: MinMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMinMeasuredValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read the mandatory attribute constraints: MaxMeasuredValue\n");
            err = TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write the default values to mandatory attribute: MaxMeasuredValue\n");
            err = TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Reads back mandatory attribute: MaxMeasuredValue\n");
            err = TestReadsBackMandatoryAttributeMaxMeasuredValue_8();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 9;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_2(measuredValue);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_3(minMeasuredValue);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, int16_t minMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_5(minMeasuredValue);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_6(maxMeasuredValue);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, int16_t maxMeasuredValue)
    {
        (static_cast<Test_TC_PRS_2_1 *>(context))->OnSuccessResponse_8(maxMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMeasuredValue_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t measuredValueArgument;
        measuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            measuredValueArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMeasuredValue_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t measuredValue)
    {
        VerifyOrReturn(CheckValue<int16_t>("measuredValue", measuredValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMinMeasuredValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMinMeasuredValue_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minMeasuredValueArgument;
        minMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            minMeasuredValueArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMinMeasuredValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(int16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckValue<int16_t>("minMeasuredValue", minMeasuredValue, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeConstraintsMaxMeasuredValue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("maxMeasuredValue", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryAttributeMaxMeasuredValue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxMeasuredValueArgument;
        maxMeasuredValueArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            maxMeasuredValueArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { NextTest(); }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackMandatoryAttributeMaxMeasuredValue_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PressureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(int16_t maxMeasuredValue)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxMeasuredValue", maxMeasuredValue, 0));
        NextTest();
    }
};

class Test_TC_PCC_1_1 : public TestCommand
{
public:
    Test_TC_PCC_1_1() : TestCommand("Test_TC_PCC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_PCC_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_PCC_2_1 : public TestCommand
{
public:
    Test_TC_PCC_2_1() : TestCommand("Test_TC_PCC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: MaxPressure\n");
            err = TestReadTheMandatoryAttributeMaxPressure_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: EffectiveOperationMode\n");
            err = TestReadTheMandatoryAttributeEffectiveOperationMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: EffectiveControlMode\n");
            err = TestReadTheMandatoryAttributeEffectiveControlMode_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : read the mandatory attribute: Capacity\n");
            err = TestReadTheMandatoryAttributeCapacity_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_0(maxPressure);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_1(effectiveOperationMode);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_2(effectiveControlMode);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_3(capacity);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, int16_t maxPressure)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_4(maxPressure);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_5(effectiveOperationMode);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t effectiveControlMode)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_6(effectiveControlMode);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, int16_t capacity)
    {
        (static_cast<Test_TC_PCC_2_1 *>(context))->OnSuccessResponse_7(capacity);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Capacity::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMaxPressure_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxPressure::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(int16_t maxPressure)
    {
        VerifyOrReturn(CheckConstraintType("maxPressure", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveOperationMode_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveOperationMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeEffectiveControlMode_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveControlMode::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t effectiveControlMode)
    {
        VerifyOrReturn(CheckConstraintType("effectiveControlMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeCapacity_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::Capacity::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t capacity)
    {
        VerifyOrReturn(CheckConstraintType("capacity", "", "int16"));
        NextTest();
    }
};

class Test_TC_PCC_2_2 : public TestCommand
{
public:
    Test_TC_PCC_2_2() : TestCommand("Test_TC_PCC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Write 1 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite1ToTheOperationModeAttributeToDutOperationMode_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write 2 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite2ToTheOperationModeAttributeToDutOperationMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Write 3 to the OperationMode attribute to DUT: OperationMode\n");
            err = TestWrite3ToTheOperationModeAttributeToDutOperationMode_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_PCC_2_2 *>(context))->OnSuccessResponse_2(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWrite1ToTheOperationModeAttributeToDutOperationMode_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestWrite2ToTheOperationModeAttributeToDutOperationMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(2);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWrite3ToTheOperationModeAttributeToDutOperationMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(3);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class Test_TC_PCC_2_3 : public TestCommand
{
public:
    Test_TC_PCC_2_3() : TestCommand("Test_TC_PCC_2_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_PCC_2_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_PCC_2_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Write 0 to the OperationMode attribute to DUT\n");
            err = TestWrite0ToTheOperationModeAttributeToDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads the attribute: EffectiveOperationMode\n");
            err = TestReadsTheAttributeEffectiveOperationMode_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_PCC_2_3 *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t effectiveOperationMode)
    {
        (static_cast<Test_TC_PCC_2_3 *>(context))->OnSuccessResponse_1(effectiveOperationMode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWrite0ToTheOperationModeAttributeToDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t operationModeArgument;
        operationModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::TypeInfo>(
            operationModeArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReadsTheAttributeEffectiveOperationMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::PumpConfigurationAndControlClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t effectiveOperationMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("effectiveOperationMode", effectiveOperationMode, 0));
        NextTest();
    }
};

class Test_TC_RH_1_1 : public TestCommand
{
public:
    Test_TC_RH_1_1() : TestCommand("Test_TC_RH_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_RH_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_RH_2_1 : public TestCommand
{
public:
    Test_TC_RH_2_1() : TestCommand("Test_TC_RH_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads constraints of attribute: MeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMeasuredValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads constraints of attribute: MinMeasuredValue\n");
            err = TestReadsConstraintsOfAttributeMinMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t minMeasuredValue)
    {
        (static_cast<Test_TC_RH_2_1 *>(context))->OnSuccessResponse_1(minMeasuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsConstraintsOfAttributeMeasuredValue_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfAttributeMinMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MinMeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t minMeasuredValue)
    {
        VerifyOrReturn(CheckConstraintType("minMeasuredValue", "", "uint16"));
        VerifyOrReturn(CheckConstraintMaxValue<uint16_t>("minMeasuredValue", minMeasuredValue, 9999));
        NextTest();
    }
};

class Test_TC_RH_2_2 : public TestCommand
{
public:
    Test_TC_RH_2_2() : TestCommand("Test_TC_RH_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_RH_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_RH_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads MeasuredValue attribute from DUT\n");
            err = TestReadsMeasuredValueAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t measuredValue)
    {
        (static_cast<Test_TC_RH_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::RelativeHumidityMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_TM_1_1 : public TestCommand
{
public:
    Test_TC_TM_1_1() : TestCommand("Test_TC_TM_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_TM_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 3U;

        return cluster.WriteAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 3U));
        NextTest();
    }
};

class Test_TC_TM_2_1 : public TestCommand
{
public:
    Test_TC_TM_2_1() : TestCommand("Test_TC_TM_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_1 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "int16"));
        NextTest();
    }
};

class Test_TC_TM_2_2 : public TestCommand
{
public:
    Test_TC_TM_2_2() : TestCommand("Test_TC_TM_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TM_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TM_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads MeasuredValue attribute from DUT\n");
            err = TestReadsMeasuredValueAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read the mandatory attribute: MeasuredValue\n");
            err = TestReadTheMandatoryAttributeMeasuredValue_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnSuccessResponse_0(measuredValue);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t measuredValue)
    {
        (static_cast<Test_TC_TM_2_2 *>(context))->OnSuccessResponse_1(measuredValue);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsMeasuredValueAttributeFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeMeasuredValue_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TemperatureMeasurementClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t measuredValue)
    {
        VerifyOrReturn(CheckConstraintType("measuredValue", "", "uint16"));
        NextTest();
    }
};

class Test_TC_TSTAT_1_1 : public TestCommand
{
public:
    Test_TC_TSTAT_1_1() : TestCommand("Test_TC_TSTAT_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_TSTAT_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 5U;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_TSTAT_2_1 : public TestCommand
{
public:
    Test_TC_TSTAT_2_1() : TestCommand("Test_TC_TSTAT_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : Reads constraints of mandatory attributes from DUT: LocalTemperature\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutLocalTemperature_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMinHeatSetpointLimit_1();
            break;
        case 2:
            ChipLogProgress(chipTool,
                            " ***** Test Step 2 : Reads constraints of mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinHeatSetpointLimit_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMinHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinHeatSetpointLimit_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read back mandatory attributes from DUT: AbsMinHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMinHeatSetpointLimit_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Reads mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_5();
            break;
        case 6:
            ChipLogProgress(chipTool,
                            " ***** Test Step 6 : Reads constraints of mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_6();
            break;
        case 7:
            ChipLogProgress(chipTool,
                            " ***** Test Step 7 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMaxHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxHeatSetpointLimit_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read back mandatory attributes from DUT: AbsMaxHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Reads mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMinCoolSetpointLimit_9();
            break;
        case 10:
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Reads constraints of mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinCoolSetpointLimit_10();
            break;
        case 11:
            ChipLogProgress(chipTool,
                            " ***** Test Step 11 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMinCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinCoolSetpointLimit_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read back mandatory attributes from DUT: AbsMinCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMinCoolSetpointLimit_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Reads mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_13();
            break;
        case 14:
            ChipLogProgress(chipTool,
                            " ***** Test Step 14 : Reads constraints of mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_14();
            break;
        case 15:
            ChipLogProgress(chipTool,
                            " ***** Test Step 15 : Writes the respective default value to mandatory attributes to DUT: "
                            "AbsMaxCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxCoolSetpointLimit_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read back mandatory attributes from DUT: AbsMaxCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Reads mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadsMandatoryAttributesFromDutOccupiedCoolingSetpoint_17();
            break;
        case 18:
            ChipLogProgress(chipTool,
                            " ***** Test Step 18 : Reads constraints of mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedCoolingSetpoint_18();
            break;
        case 19:
            ChipLogProgress(chipTool,
                            " ***** Test Step 19 : Writes the respective default value to mandatory attributes to DUT: "
                            "OccupiedCoolingSetpoint\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedCoolingSetpoint_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read back mandatory attributes from DUT: OccupiedCoolingSetpoint\n");
            err = TestReadBackMandatoryAttributesFromDutOccupiedCoolingSetpoint_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Reads mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadsMandatoryAttributesFromDutOccupiedHeatingSetpoint_21();
            break;
        case 22:
            ChipLogProgress(chipTool,
                            " ***** Test Step 22 : Reads constraints of mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedHeatingSetpoint_22();
            break;
        case 23:
            ChipLogProgress(chipTool,
                            " ***** Test Step 23 : Writes the respective default value to mandatory attributes to DUT: "
                            "OccupiedHeatingSetpoint\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedHeatingSetpoint_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read back mandatory attributes from DUT: OccupiedHeatingSetpoint\n");
            err = TestReadBackMandatoryAttributesFromDutOccupiedHeatingSetpoint_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Reads mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMinHeatSetpointLimit_25();
            break;
        case 26:
            ChipLogProgress(chipTool,
                            " ***** Test Step 26 : Reads constraints of mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMinHeatSetpointLimit_26();
            break;
        case 27:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 27 : Writes the respective default value to mandatory attributes to DUT: MinHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinHeatSetpointLimit_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read back mandatory attributes from DUT: MinHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMinHeatSetpointLimit_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Reads mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMaxHeatSetpointLimit_29();
            break;
        case 30:
            ChipLogProgress(chipTool,
                            " ***** Test Step 30 : Reads constraints of mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMaxHeatSetpointLimit_30();
            break;
        case 31:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 31 : Writes the respective default value to mandatory attributes to DUT: MaxHeatSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxHeatSetpointLimit_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read back mandatory attributes from DUT: MaxHeatSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMaxHeatSetpointLimit_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Reads mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMinCoolSetpointLimit_33();
            break;
        case 34:
            ChipLogProgress(chipTool,
                            " ***** Test Step 34 : Reads constraints of mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMinCoolSetpointLimit_34();
            break;
        case 35:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 35 : Writes the respective default value to mandatory attributes to DUT: MinCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinCoolSetpointLimit_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read back mandatory attributes from DUT: MinCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMinCoolSetpointLimit_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Reads mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadsMandatoryAttributesFromDutMaxCoolSetpointLimit_37();
            break;
        case 38:
            ChipLogProgress(chipTool,
                            " ***** Test Step 38 : Reads constraints of mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutMaxCoolSetpointLimit_38();
            break;
        case 39:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 39 : Writes the respective default value to mandatory attributes to DUT: MaxCoolSetpointLimit\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxCoolSetpointLimit_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read back mandatory attributes from DUT: MaxCoolSetpointLimit\n");
            err = TestReadBackMandatoryAttributesFromDutMaxCoolSetpointLimit_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Reads mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadsMandatoryAttributesFromDutControlSequenceOfOperation_41();
            break;
        case 42:
            ChipLogProgress(
                chipTool, " ***** Test Step 42 : Reads constraints of mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutControlSequenceOfOperation_42();
            break;
        case 43:
            ChipLogProgress(chipTool,
                            " ***** Test Step 43 : Writes the respective default value to mandatory attributes to DUT: "
                            "ControlSequenceOfOperation\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutControlSequenceOfOperation_43();
            break;
        case 44:
            ChipLogProgress(chipTool,
                            " ***** Test Step 44 : Read back mandatory attributes from DUT: ControlSequenceOfOperation\n");
            err = TestReadBackMandatoryAttributesFromDutControlSequenceOfOperation_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Reads mandatory attributes from DUT: SystemMode\n");
            err = TestReadsMandatoryAttributesFromDutSystemMode_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Reads constraints of mandatory attributes from DUT: SystemMode\n");
            err = TestReadsConstraintsOfMandatoryAttributesFromDutSystemMode_46();
            break;
        case 47:
            ChipLogProgress(
                chipTool, " ***** Test Step 47 : Writes the respective default value to mandatory attributes to DUT: SystemMode\n");
            err = TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutSystemMode_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read back mandatory attributes from DUT: SystemMode\n");
            err = TestReadBackMandatoryAttributesFromDutSystemMode_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Reads optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadsOptionalAttributesFromDutMinSetpointDeadBand_49();
            break;
        case 50:
            ChipLogProgress(chipTool,
                            " ***** Test Step 50 : Reads constraints of optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutMinSetpointDeadBand_50();
            break;
        case 51:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 51 : Writes the respective default value to optional attributes to DUT: MinSetpointDeadBand\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutMinSetpointDeadBand_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Read back optional attributes from DUT: MinSetpointDeadBand\n");
            err = TestReadBackOptionalAttributesFromDutMinSetpointDeadBand_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Reads constraints of optional attributes from DUT: StartOfWeek\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutStartOfWeek_53();
            break;
        case 54:
            ChipLogProgress(
                chipTool, " ***** Test Step 54 : Writes the respective default value to optional attributes to DUT: StartOfWeek\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutStartOfWeek_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Read back optional attributes from DUT: StartOfWeek\n");
            err = TestReadBackOptionalAttributesFromDutStartOfWeek_55();
            break;
        case 56:
            ChipLogProgress(chipTool,
                            " ***** Test Step 56 : Reads constraints of optional attributes from DUT: NumberOfWeeklyTransitions\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutNumberOfWeeklyTransitions_56();
            break;
        case 57:
            ChipLogProgress(chipTool,
                            " ***** Test Step 57 : Writes the respective default value to optional attributes to DUT: "
                            "NumberOfWeeklyTransitions\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfWeeklyTransitions_57();
            break;
        case 58:
            ChipLogProgress(chipTool,
                            " ***** Test Step 58 : Reads constraints of optional attributes from DUT: NumberOfDailyTransitions\n");
            err = TestReadsConstraintsOfOptionalAttributesFromDutNumberOfDailyTransitions_58();
            break;
        case 59:
            ChipLogProgress(chipTool,
                            " ***** Test Step 59 : Writes the respective default value to optional attributes to DUT: "
                            "NumberOfDailyTransitions\n");
            err = TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfDailyTransitions_59();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 60;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, int16_t localTemperature)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_0(localTemperature);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_1(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_2(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, int16_t absMinHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_4(absMinHeatSetpointLimit);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_5(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_6(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, int16_t absMaxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_8(absMaxHeatSetpointLimit);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_9(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_10(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, int16_t absMinCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_12(absMinCoolSetpointLimit);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_13(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_14(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, int16_t absMaxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_16(absMaxCoolSetpointLimit);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_17(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_18(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_19(); }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_20(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_21(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_22(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_23(); }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_24(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_25(minHeatSetpointLimit);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_26(minHeatSetpointLimit);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_27(); }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_28(minHeatSetpointLimit);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_29(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_30(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_31(); }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_32(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_33(minCoolSetpointLimit);
    }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_34(minCoolSetpointLimit);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_36(minCoolSetpointLimit);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_37(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_38(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_39(); }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_40(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_41(controlSequenceOfOperation);
    }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_42(controlSequenceOfOperation);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_43(); }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_44(controlSequenceOfOperation);
    }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_45(systemMode);
    }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_46(systemMode);
    }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context, uint8_t systemMode)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_48(systemMode);
    }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_49(minSetpointDeadBand);
    }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_50(minSetpointDeadBand);
    }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_51(); }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context, int8_t minSetpointDeadBand)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_52(minSetpointDeadBand);
    }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context, uint8_t startOfWeek)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_53(startOfWeek);
    }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_54(); }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context, uint8_t startOfWeek)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_55(startOfWeek);
    }

    static void OnFailureCallback_56(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_56(chip::to_underlying(status));
    }

    static void OnSuccessCallback_56(void * context, uint8_t numberOfWeeklyTransitions)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_56(numberOfWeeklyTransitions);
    }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_57(); }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context, uint8_t numberOfDailyTransitions)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_58(numberOfDailyTransitions);
    }

    static void OnFailureCallback_59(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnFailureResponse_59(chip::to_underlying(status));
    }

    static void OnSuccessCallback_59(void * context) { (static_cast<Test_TC_TSTAT_2_1 *>(context))->OnSuccessResponse_59(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutLocalTemperature_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::LocalTemperature::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t localTemperature)
    {
        VerifyOrReturn(CheckConstraintType("localTemperature", "", "int16"));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMinHeatSetpointLimit_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinHeatSetpointLimit_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMinHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinHeatSetpointLimit_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t absMinHeatSetpointLimitArgument;
        absMinHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            absMinHeatSetpointLimitArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { NextTest(); }

    void OnSuccessResponse_3() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMinHeatSetpointLimit_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(int16_t absMinHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("absMinHeatSetpointLimit", absMinHeatSetpointLimit, 700));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMaxHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxHeatSetpointLimit_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t absMaxHeatSetpointLimitArgument;
        absMaxHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            absMaxHeatSetpointLimitArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { NextTest(); }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMaxHeatSetpointLimit_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(int16_t absMaxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("absMaxHeatSetpointLimit", absMaxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMinCoolSetpointLimit_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMinCoolSetpointLimit_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMinCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMinCoolSetpointLimit_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t absMinCoolSetpointLimitArgument;
        absMinCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            absMinCoolSetpointLimitArgument, this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { NextTest(); }

    void OnSuccessResponse_11() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMinCoolSetpointLimit_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(int16_t absMinCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("absMinCoolSetpointLimit", absMinCoolSetpointLimit, 1600));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("absMaxCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutAbsMaxCoolSetpointLimit_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t absMaxCoolSetpointLimitArgument;
        absMaxCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            absMaxCoolSetpointLimitArgument, this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { NextTest(); }

    void OnSuccessResponse_15() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutAbsMaxCoolSetpointLimit_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(int16_t absMaxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("absMaxCoolSetpointLimit", absMaxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutOccupiedCoolingSetpoint_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedCoolingSetpoint_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckConstraintType("occupiedCoolingSetpoint", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedCoolingSetpoint_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutOccupiedCoolingSetpoint_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutOccupiedHeatingSetpoint_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutOccupiedHeatingSetpoint_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckConstraintType("occupiedHeatingSetpoint", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2600));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutOccupiedHeatingSetpoint_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutOccupiedHeatingSetpoint_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMinHeatSetpointLimit_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 700));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMinHeatSetpointLimit_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("minHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinHeatSetpointLimit_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMinHeatSetpointLimit_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 700));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMaxHeatSetpointLimit_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMaxHeatSetpointLimit_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("maxHeatSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 700));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxHeatSetpointLimit_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMaxHeatSetpointLimit_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMinCoolSetpointLimit_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 1600));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMinCoolSetpointLimit_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("minCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMinCoolSetpointLimit_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMinCoolSetpointLimit_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 1600));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutMaxCoolSetpointLimit_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutMaxCoolSetpointLimit_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckConstraintType("maxCoolSetpointLimit", "", "int16"));
        VerifyOrReturn(CheckConstraintMinValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 1600));
        VerifyOrReturn(CheckConstraintMaxValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutMaxCoolSetpointLimit_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutMaxCoolSetpointLimit_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutControlSequenceOfOperation_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 4));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutControlSequenceOfOperation_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckConstraintType("controlSequenceOfOperation", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 5));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutControlSequenceOfOperation_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t controlSequenceOfOperationArgument;
        controlSequenceOfOperationArgument = static_cast<uint8_t>(4);

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            controlSequenceOfOperationArgument, this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutControlSequenceOfOperation_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 4));
        NextTest();
    }

    CHIP_ERROR TestReadsMandatoryAttributesFromDutSystemMode_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(this, OnSuccessCallback_45,
                                                                                                        OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint8_t systemMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("systemMode", systemMode, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfMandatoryAttributesFromDutSystemMode_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(this, OnSuccessCallback_46,
                                                                                                        OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(uint8_t systemMode)
    {
        VerifyOrReturn(CheckConstraintType("systemMode", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("systemMode", systemMode, 9));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToMandatoryAttributesToDutSystemMode_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t systemModeArgument;
        systemModeArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(
            systemModeArgument, this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestReadBackMandatoryAttributesFromDutSystemMode_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::SystemMode::TypeInfo>(this, OnSuccessCallback_48,
                                                                                                        OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(uint8_t systemMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("systemMode", systemMode, 1));
        NextTest();
    }

    CHIP_ERROR TestReadsOptionalAttributesFromDutMinSetpointDeadBand_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_49, OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckValue<int8_t>("minSetpointDeadBand", minSetpointDeadBand, 25));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutMinSetpointDeadBand_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_50, OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckConstraintType("minSetpointDeadBand", "", "int8"));
        VerifyOrReturn(CheckConstraintMaxValue<int8_t>("minSetpointDeadBand", minSetpointDeadBand, 25));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutMinSetpointDeadBand_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int8_t minSetpointDeadBandArgument;
        minSetpointDeadBandArgument = 25;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            minSetpointDeadBandArgument, this, OnSuccessCallback_51, OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51() { NextTest(); }

    CHIP_ERROR TestReadBackOptionalAttributesFromDutMinSetpointDeadBand_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::TypeInfo>(
            this, OnSuccessCallback_52, OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(int8_t minSetpointDeadBand)
    {
        VerifyOrReturn(CheckValue<int8_t>("minSetpointDeadBand", minSetpointDeadBand, 25));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutStartOfWeek_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(this, OnSuccessCallback_53,
                                                                                                         OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53(uint8_t startOfWeek)
    {
        VerifyOrReturn(CheckConstraintType("startOfWeek", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("startOfWeek", startOfWeek, 6));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutStartOfWeek_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t startOfWeekArgument;
        startOfWeekArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(
            startOfWeekArgument, this, OnSuccessCallback_54, OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status) { NextTest(); }

    void OnSuccessResponse_54() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadBackOptionalAttributesFromDutStartOfWeek_55()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::StartOfWeek::TypeInfo>(this, OnSuccessCallback_55,
                                                                                                         OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55(uint8_t startOfWeek)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startOfWeek", startOfWeek, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutNumberOfWeeklyTransitions_56()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo>(
            this, OnSuccessCallback_56, OnFailureCallback_56);
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(uint8_t numberOfWeeklyTransitions)
    {
        VerifyOrReturn(CheckConstraintType("numberOfWeeklyTransitions", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfWeeklyTransitions_57()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t numberOfWeeklyTransitionsArgument;
        numberOfWeeklyTransitionsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfWeeklyTransitions::TypeInfo>(
            numberOfWeeklyTransitionsArgument, this, OnSuccessCallback_57, OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { NextTest(); }

    void OnSuccessResponse_57() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsConstraintsOfOptionalAttributesFromDutNumberOfDailyTransitions_58()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo>(
            this, OnSuccessCallback_58, OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58(uint8_t numberOfDailyTransitions)
    {
        VerifyOrReturn(CheckConstraintType("numberOfDailyTransitions", "", "uint8"));
        NextTest();
    }

    CHIP_ERROR TestWritesTheRespectiveDefaultValueToOptionalAttributesToDutNumberOfDailyTransitions_59()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t numberOfDailyTransitionsArgument;
        numberOfDailyTransitionsArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::NumberOfDailyTransitions::TypeInfo>(
            numberOfDailyTransitionsArgument, this, OnSuccessCallback_59, OnFailureCallback_59);
    }

    void OnFailureResponse_59(uint8_t status) { NextTest(); }

    void OnSuccessResponse_59() { ThrowSuccessResponse(); }
};

class Test_TC_TSTAT_2_2 : public TestCommand
{
public:
    Test_TC_TSTAT_2_2() : TestCommand("Test_TC_TSTAT_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSTAT_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSTAT_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : Reads OccupiedCoolingSetpoint attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsOccupiedCoolingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_0();
            break;
        case 1:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 1 : Writes a value back that is different but valid for OccupiedCoolingSetpoint attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForOccupiedCoolingSetpointAttribute_1();
            break;
        case 2:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 2 : Reads it back again to confirm the successful write of OccupiedCoolingSetpoint attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedCoolingSetpointAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool,
                            " ***** Test Step 3 : Writes the limit of MinCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            err = TestWritesTheLimitOfMinCoolSetpointLimitToOccupiedCoolingSetpointAttribute_3();
            break;
        case 4:
            ChipLogProgress(chipTool,
                            " ***** Test Step 4 : Writes the limit of MaxCoolSetpointLimit to OccupiedCoolingSetpoint attribute\n");
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToOccupiedCoolingSetpointAttribute_4();
            break;
        case 5:
            ChipLogProgress(chipTool,
                            " ***** Test Step 5 : Reads OccupiedHeatingSetpoint attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsOccupiedHeatingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_5();
            break;
        case 6:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 6 : Writes a value back that is different but valid for OccupiedHeatingSetpoint attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForOccupiedHeatingSetpointAttribute_6();
            break;
        case 7:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 7 : Reads it back again to confirm the successful write of OccupiedHeatingSetpoint attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedHeatingSetpointAttribute_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : Writes the limit of MinHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            err = TestWritesTheLimitOfMinHeatSetpointLimitToOccupiedHeatingSetpointAttribute_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes the limit of MaxHeatSetpointLimit to OccupiedHeatingSetpoint attribute\n");
            err = TestWritesTheLimitOfMaxHeatSetpointLimitToOccupiedHeatingSetpointAttribute_9();
            break;
        case 10:
            ChipLogProgress(chipTool,
                            " ***** Test Step 10 : Reads MinHeatSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsMinHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_10();
            break;
        case 11:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 11 : Writes a value back that is different but valid for MinHeatSetpointLimit attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForMinHeatSetpointLimitAttribute_11();
            break;
        case 12:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 12 : Reads it back again to confirm the successful write of MinHeatSetpointLimit attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinHeatSetpointLimitAttribute_12();
            break;
        case 13:
            ChipLogProgress(
                chipTool, " ***** Test Step 13 : Writes the limit of AbsMinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_13();
            break;
        case 14:
            ChipLogProgress(
                chipTool, " ***** Test Step 14 : Writes the limit of AbsMaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_14();
            break;
        case 15:
            ChipLogProgress(chipTool,
                            " ***** Test Step 15 : Reads MaxHeatSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsMaxHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_15();
            break;
        case 16:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 16 : Writes a value back that is different but valid for MaxHeatSetpointLimit attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForMaxHeatSetpointLimitAttribute_16();
            break;
        case 17:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 17 : Reads it back again to confirm the successful write of MaxHeatSetpointLimit attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxHeatSetpointLimitAttribute_17();
            break;
        case 18:
            ChipLogProgress(
                chipTool, " ***** Test Step 18 : Writes the limit of AbsMinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_18();
            break;
        case 19:
            ChipLogProgress(
                chipTool, " ***** Test Step 19 : Writes the limit of AbsMaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_19();
            break;
        case 20:
            ChipLogProgress(chipTool,
                            " ***** Test Step 20 : Reads MinCoolSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsMinCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_20();
            break;
        case 21:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 21 : Writes a value back that is different but valid for MinCoolSetpointLimit attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForMinCoolSetpointLimitAttribute_21();
            break;
        case 22:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 22 : Reads it back again to confirm the successful write of MinCoolSetpointLimit attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinCoolSetpointLimitAttribute_22();
            break;
        case 23:
            ChipLogProgress(
                chipTool, " ***** Test Step 23 : Writes the limit of AbsMinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_23();
            break;
        case 24:
            ChipLogProgress(chipTool,
                            " ***** Test Step 24 : Writes the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_24();
            break;
        case 25:
            ChipLogProgress(chipTool,
                            " ***** Test Step 25 : Reads MaxCoolSetpointLimit attribute from Server DUT and verifies that the "
                            "value is within range\n");
            err = TestReadsMaxCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_25();
            break;
        case 26:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 26 : Writes a value back that is different but valid for MaxCoolSetpointLimit attribute\n");
            err = TestWritesAValueBackThatIsDifferentButValidForMaxCoolSetpointLimitAttribute_26();
            break;
        case 27:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 27 : Reads it back again to confirm the successful write of MaxCoolSetpointLimit attribute\n");
            err = TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxCoolSetpointLimitAttribute_27();
            break;
        case 28:
            ChipLogProgress(
                chipTool, " ***** Test Step 28 : Writes the limit of AbsMinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            err = TestWritesTheLimitOfAbsMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_28();
            break;
        case 29:
            ChipLogProgress(chipTool,
                            " ***** Test Step 29 : Writes the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            err = TestWritesTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_29();
            break;
        case 30:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 30 : Writes (sets back) the limit of MinHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_30();
            break;
        case 31:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 31 : Writes (sets back) the limit of MaxHeatSetpointLimit to MinHeatSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_31();
            break;
        case 32:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 32 : Writes (sets back) the limit of MinHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_32();
            break;
        case 33:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 33 : Writes (sets back) the limit of MaxHeatSetpointLimit to MaxHeatSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_33();
            break;
        case 34:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 34 : Writes (sets back) the limit of MinCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_34();
            break;
        case 35:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 35 : Writes (sets back) the limit of MaxCoolSetpointLimit to MinCoolSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_35();
            break;
        case 36:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 36 : Writes (sets back) the limit of MinCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_36();
            break;
        case 37:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 37 : Writes (sets back) the limit of MaxCoolSetpointLimit to MaxCoolSetpointLimit attribute\n");
            err = TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_37();
            break;
        case 38:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 38 : Reads ControlSequenceOfOperation from Server DUT and verifies that the value is valid\n");
            err = TestReadsControlSequenceOfOperationFromServerDutAndVerifiesThatTheValueIsValid_38();
            break;
        case 39:
            ChipLogProgress(
                chipTool, " ***** Test Step 39 : Write Attribute command for ControlSequenceOfOperation with a new valid value\n");
            err = TestWriteAttributeCommandForControlSequenceOfOperationWithANewValidValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read it back again to confirm the successful write\n");
            err = TestReadItBackAgainToConfirmTheSuccessfulWrite_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Sets OccupiedHeatingSetpoint to default value\n");
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Sets OccupiedHeatingSetpoint to default value\n");
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Sets OccupiedCoolingSetpoint to default value\n");
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Sets OccupiedCoolingSetpoint to default value\n");
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Sets OccupiedCoolingSetpoint to default value\n");
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Sets OccupiedHeatingSetpoint to default value\n");
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Sets OccupiedCoolingSetpoint to default value\n");
            err = TestSetsOccupiedCoolingSetpointToDefaultValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Sets OccupiedHeatingSetpoint to default value\n");
            err = TestSetsOccupiedHeatingSetpointToDefaultValue_48();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 49;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_0(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, int16_t occupiedCoolingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_2(occupiedCoolingSetpoint);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_5(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, int16_t occupiedHeatingSetpoint)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_7(occupiedHeatingSetpoint);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_10(minHeatSetpointLimit);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, int16_t minHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_12(minHeatSetpointLimit);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_13(); }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_14(); }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_15(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_16(); }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, int16_t maxHeatSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_17(maxHeatSetpointLimit);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_18(); }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_19(); }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_20(minCoolSetpointLimit);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_21(); }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, int16_t minCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_22(minCoolSetpointLimit);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_23(); }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_24(); }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_25(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_26(); }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context, int16_t maxCoolSetpointLimit)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_27(maxCoolSetpointLimit);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_28(); }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_30(); }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_31(); }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_32(); }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_33(); }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_34(); }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_36(); }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_38(controlSequenceOfOperation);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_39(); }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, uint8_t controlSequenceOfOperation)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_40(controlSequenceOfOperation);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_41(); }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_42(); }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_43(); }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_44(); }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_45(); }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_46(); }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context) { (static_cast<Test_TC_TSTAT_2_2 *>(context))->OnSuccessResponse_48(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsOccupiedCoolingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2600));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForOccupiedCoolingSetpointAttribute_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedCoolingSetpointAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(int16_t occupiedCoolingSetpoint)
    {
        VerifyOrReturn(CheckValue<int16_t>("occupiedCoolingSetpoint", occupiedCoolingSetpoint, 2000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfMinCoolSetpointLimitToOccupiedCoolingSetpointAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToOccupiedCoolingSetpointAttribute_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestReadsOccupiedHeatingSetpointAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2000));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForOccupiedHeatingSetpointAttribute_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2100;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfOccupiedHeatingSetpointAttribute_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(int16_t occupiedHeatingSetpoint)
    {
        VerifyOrReturn(CheckValue<int16_t>("occupiedHeatingSetpoint", occupiedHeatingSetpoint, 2100));
        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfMinHeatSetpointLimitToOccupiedHeatingSetpointAttribute_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxHeatSetpointLimitToOccupiedHeatingSetpointAttribute_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadsMinHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 700));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMinHeatSetpointLimitAttribute_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinHeatSetpointLimitAttribute_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(int16_t minHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("minHeatSetpointLimit", minHeatSetpointLimit, 2000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14() { NextTest(); }

    CHIP_ERROR TestReadsMaxHeatSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 3000));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMaxHeatSetpointLimitAttribute_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxHeatSetpointLimitAttribute_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(int16_t maxHeatSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxHeatSetpointLimit", maxHeatSetpointLimit, 2000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfAbsMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19() { NextTest(); }

    CHIP_ERROR TestReadsMinCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 1600));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMinCoolSetpointLimitAttribute_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMinCoolSetpointLimitAttribute_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(int16_t minCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("minCoolSetpointLimit", minCoolSetpointLimit, 2000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24() { NextTest(); }

    CHIP_ERROR TestReadsMaxCoolSetpointLimitAttributeFromServerDutAndVerifiesThatTheValueIsWithinRange_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 3200));
        NextTest();
    }

    CHIP_ERROR TestWritesAValueBackThatIsDifferentButValidForMaxCoolSetpointLimitAttribute_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26() { NextTest(); }

    CHIP_ERROR TestReadsItBackAgainToConfirmTheSuccessfulWriteOfMaxCoolSetpointLimitAttribute_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(int16_t maxCoolSetpointLimit)
    {
        VerifyOrReturn(CheckValue<int16_t>("maxCoolSetpointLimit", maxCoolSetpointLimit, 2000));
        NextTest();
    }

    CHIP_ERROR TestWritesTheLimitOfAbsMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestWritesTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMinHeatSetpointLimitAttribute_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMinHeatSetpointLimitAttribute_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minHeatSetpointLimitArgument;
        minHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::TypeInfo>(
            minHeatSetpointLimitArgument, this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinHeatSetpointLimitToMaxHeatSetpointLimitAttribute_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 700;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxHeatSetpointLimitToMaxHeatSetpointLimitAttribute_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxHeatSetpointLimitArgument;
        maxHeatSetpointLimitArgument = 3000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::TypeInfo>(
            maxHeatSetpointLimitArgument, this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMinCoolSetpointLimitAttribute_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMinCoolSetpointLimitAttribute_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t minCoolSetpointLimitArgument;
        minCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::TypeInfo>(
            minCoolSetpointLimitArgument, this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMinCoolSetpointLimitToMaxCoolSetpointLimitAttribute_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 1600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestWritesSetsBackTheLimitOfMaxCoolSetpointLimitToMaxCoolSetpointLimitAttribute_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t maxCoolSetpointLimitArgument;
        maxCoolSetpointLimitArgument = 3200;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::TypeInfo>(
            maxCoolSetpointLimitArgument, this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37() { NextTest(); }

    CHIP_ERROR TestReadsControlSequenceOfOperationFromServerDutAndVerifiesThatTheValueIsValid_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 4));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCommandForControlSequenceOfOperationWithANewValidValue_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t controlSequenceOfOperationArgument;
        controlSequenceOfOperationArgument = static_cast<uint8_t>(2);

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            controlSequenceOfOperationArgument, this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39() { NextTest(); }

    CHIP_ERROR TestReadItBackAgainToConfirmTheSuccessfulWrite_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint8_t controlSequenceOfOperation)
    {
        VerifyOrReturn(CheckValue<uint8_t>("controlSequenceOfOperation", controlSequenceOfOperation, 2));
        NextTest();
    }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_46, OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedCoolingSetpointToDefaultValue_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedCoolingSetpointArgument;
        occupiedCoolingSetpointArgument = 2600;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::TypeInfo>(
            occupiedCoolingSetpointArgument, this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestSetsOccupiedHeatingSetpointToDefaultValue_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t occupiedHeatingSetpointArgument;
        occupiedHeatingSetpointArgument = 2000;

        return cluster.WriteAttribute<chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::TypeInfo>(
            occupiedHeatingSetpointArgument, this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48() { NextTest(); }
};

class Test_TC_TSUIC_1_1 : public TestCommand
{
public:
    Test_TC_TSUIC_1_1() : TestCommand("Test_TC_TSUIC_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool,
                            " ***** Test Step 0 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_TSUIC_1_1 *>(context))->OnSuccessResponse_0(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 2U;

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::TypeInfo>(
                clusterRevisionArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { NextTest(); }

    void OnSuccessResponse_0() { ThrowSuccessResponse(); }
};

class Test_TC_TSUIC_2_1 : public TestCommand
{
public:
    Test_TC_TSUIC_2_1() : TestCommand("Test_TC_TSUIC_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : write to the mandatory attribute: TemperatureDisplayMode\n");
            err = TestWriteToTheMandatoryAttributeTemperatureDisplayMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the mandatory attribute: TemperatureDisplayMode\n");
            err = TestReadTheMandatoryAttributeTemperatureDisplayMode_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : write to the mandatory attribute: KeypadLockout\n");
            err = TestWriteToTheMandatoryAttributeKeypadLockout_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : read the mandatory attribute: KeypadLockout\n");
            err = TestReadTheMandatoryAttributeKeypadLockout_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : write to the mandatory attribute: ScheduleProgrammingVisibility\n");
            err = TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : read the optional attribute: ScheduleProgrammingVisibility\n");
            err = TestReadTheOptionalAttributeScheduleProgrammingVisibility_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_0(temperatureDisplayMode);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_1(temperatureDisplayMode);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_3(temperatureDisplayMode);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t temperatureDisplayMode)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_4(temperatureDisplayMode);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_5(keypadLockout);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_6(keypadLockout);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_8(keypadLockout);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, uint8_t keypadLockout)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_9(keypadLockout);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_10(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_11(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context) { (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_12(); }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_13(scheduleProgrammingVisibility);
    }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint8_t scheduleProgrammingVisibility)
    {
        (static_cast<Test_TC_TSUIC_2_1 *>(context))->OnSuccessResponse_14(scheduleProgrammingVisibility);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("temperatureDisplayMode", temperatureDisplayMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeTemperatureDisplayMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("temperatureDisplayMode", temperatureDisplayMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeTemperatureDisplayMode_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
                this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t temperatureDisplayMode)
    {
        VerifyOrReturn(CheckConstraintType("temperatureDisplayMode", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue<uint8_t>("keypadLockout", keypadLockout, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeKeypadLockout_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(0);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckValue<uint8_t>("keypadLockout", keypadLockout, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheMandatoryAttributeKeypadLockout_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster
            .ReadAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t keypadLockout)
    {
        VerifyOrReturn(CheckConstraintType("keypadLockout", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue<uint8_t>("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
        NextTest();
    }

    CHIP_ERROR TestWriteToTheMandatoryAttributeScheduleProgrammingVisibility_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12() { NextTest(); }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckValue<uint8_t>("scheduleProgrammingVisibility", scheduleProgrammingVisibility, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheOptionalAttributeScheduleProgrammingVisibility_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t scheduleProgrammingVisibility)
    {
        VerifyOrReturn(CheckConstraintType("scheduleProgrammingVisibility", "", "enum8"));
        NextTest();
    }
};

class Test_TC_TSUIC_2_2 : public TestCommand
{
public:
    Test_TC_TSUIC_2_2() : TestCommand("Test_TC_TSUIC_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_TSUIC_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_TSUIC_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Writes a value of 0 to TemperatureDisplayMode attribute of DUT\n");
            err = TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Writes a value of 1 to TemperatureDisplayMode attribute of DUT\n");
            err = TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Writes a value of 0 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Writes a value of 1 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Writes a value of 2 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Writes a value of 3 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Writes a value of 4 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Writes a value of 5 to KeypadLockout attribute of DUT\n");
            err = TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_7();
            break;
        case 8:
            ChipLogProgress(chipTool,
                            " ***** Test Step 8 : Writes a value of 0 to ScheduleProgrammingVisibility attribute of DUT\n");
            err = TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_8();
            break;
        case 9:
            ChipLogProgress(chipTool,
                            " ***** Test Step 9 : Writes a value of 1 to ScheduleProgrammingVisibility attribute of DUT\n");
            err = TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_9();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 10;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_4(); }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_TSUIC_2_2 *>(context))->OnSuccessResponse_9(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestWritesAValueOf0ToTemperatureDisplayModeAttributeOfDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToTemperatureDisplayModeAttributeOfDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t temperatureDisplayModeArgument;
        temperatureDisplayModeArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::TypeInfo>(
            temperatureDisplayModeArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf0ToKeypadLockoutAttributeOfDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(0);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToKeypadLockoutAttributeOfDut_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(1);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf2ToKeypadLockoutAttributeOfDut_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(2);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf3ToKeypadLockoutAttributeOfDut_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(3);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf4ToKeypadLockoutAttributeOfDut_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(4);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf5ToKeypadLockoutAttributeOfDut_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t keypadLockoutArgument;
        keypadLockoutArgument = static_cast<uint8_t>(5);

        return cluster
            .WriteAttribute<chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::TypeInfo>(
                keypadLockoutArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf0ToScheduleProgrammingVisibilityAttributeOfDut_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestWritesAValueOf1ToScheduleProgrammingVisibilityAttributeOfDut_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ThermostatUserInterfaceConfigurationClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t scheduleProgrammingVisibilityArgument;
        scheduleProgrammingVisibilityArgument = static_cast<uint8_t>(1);

        return cluster.WriteAttribute<
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::TypeInfo>(
            scheduleProgrammingVisibilityArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }
};

class Test_TC_DIAGTH_1_1 : public TestCommand
{
public:
    Test_TC_DIAGTH_1_1() : TestCommand("Test_TC_DIAGTH_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGTH_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGTH_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default values to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_DIAGTH_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValuesToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 1U;

        return cluster.WriteAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::ThreadNetworkDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 1U));
        NextTest();
    }
};

class Test_TC_WNCV_1_1 : public TestCommand
{
public:
    Test_TC_WNCV_1_1() : TestCommand("Test_TC_WNCV_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the global attribute: ClusterRevision\n");
            err = TestReadTheGlobalAttributeClusterRevision_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : write the default value to mandatory global attribute: ClusterRevision\n");
            err = TestWriteTheDefaultValueToMandatoryGlobalAttributeClusterRevision_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : reads back global attribute: ClusterRevision\n");
            err = TestReadsBackGlobalAttributeClusterRevision_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : read the global attribute: FeatureMap\n");
            err = TestReadTheGlobalAttributeFeatureMap_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : reads back global attribute: FeatureMap\n");
            err = TestReadsBackGlobalAttributeFeatureMap_4();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 5;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_0(clusterRevision);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t clusterRevision)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_2(clusterRevision);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_3(featureMap);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint32_t featureMap)
    {
        (static_cast<Test_TC_WNCV_1_1 *>(context))->OnSuccessResponse_4(featureMap);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheGlobalAttributeClusterRevision_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 5U));
        NextTest();
    }

    CHIP_ERROR TestWriteTheDefaultValueToMandatoryGlobalAttributeClusterRevision_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t clusterRevisionArgument;
        clusterRevisionArgument = 5U;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            clusterRevisionArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadsBackGlobalAttributeClusterRevision_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t clusterRevision)
    {
        VerifyOrReturn(CheckValue<uint16_t>("clusterRevision", clusterRevision, 5U));
        NextTest();
    }

    CHIP_ERROR TestReadTheGlobalAttributeFeatureMap_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadsBackGlobalAttributeFeatureMap_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::FeatureMap::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint32_t featureMap)
    {
        VerifyOrReturn(CheckValue<uint32_t>("featureMap", featureMap, 0UL));
        NextTest();
    }
};

class Test_TC_WNCV_2_1 : public TestCommand
{
public:
    Test_TC_WNCV_2_1() : TestCommand("Test_TC_WNCV_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : read the RO mandatory attribute default: Type\n");
            err = TestReadTheRoMandatoryAttributeDefaultType_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : reads back the RO mandatory attribute: Type\n");
            err = TestReadsBackTheRoMandatoryAttributeType_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : read the RO mandatory attribute default: ConfigStatus\n");
            err = TestReadTheRoMandatoryAttributeDefaultConfigStatus_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : reads back the RO mandatory attribute: ConfigStatus\n");
            err = TestReadsBackTheRoMandatoryAttributeConfigStatus_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : read the RO mandatory attribute default: OperationalStatus\n");
            err = TestReadTheRoMandatoryAttributeDefaultOperationalStatus_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : reads back the RO mandatory attribute: OperationalStatus\n");
            err = TestReadsBackTheRoMandatoryAttributeOperationalStatus_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : read the RO mandatory attribute default: EndProductType\n");
            err = TestReadTheRoMandatoryAttributeDefaultEndProductType_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : reads back the RO mandatory attribute: EndProductType\n");
            err = TestReadsBackTheRoMandatoryAttributeEndProductType_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : read the RW mandatory attribute default: Mode\n");
            err = TestReadTheRwMandatoryAttributeDefaultMode_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : write a value into the RW mandatory attribute:: Mode\n");
            err = TestWriteAValueIntoTheRwMandatoryAttributeMode_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : reads back the RW mandatory attribute: Mode\n");
            err = TestReadsBackTheRwMandatoryAttributeMode_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_0(type);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_1(type);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_2(configStatus);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t configStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_3(configStatus);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_4(operationalStatus);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_5(operationalStatus);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_6(endProductType);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_7(endProductType);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_8(mode);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t mode)
    {
        (static_cast<Test_TC_WNCV_2_1 *>(context))->OnSuccessResponse_10(mode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultType_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                      OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t type)
    {
        VerifyOrReturn(CheckValue<uint8_t>("type", type, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeType_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                      OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t type)
    {
        VerifyOrReturn(CheckValue<uint8_t>("type", type, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultConfigStatus_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t configStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("configStatus", configStatus, 3));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeConfigStatus_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t configStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("configStatus", configStatus, 3));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultOperationalStatus_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeOperationalStatus_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRoMandatoryAttributeDefaultEndProductType_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("endProductType", endProductType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsBackTheRoMandatoryAttributeEndProductType_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("endProductType", endProductType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadTheRwMandatoryAttributeDefaultMode_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(this, OnSuccessCallback_8,
                                                                                                      OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t mode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mode", mode, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAValueIntoTheRwMandatoryAttributeMode_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t modeArgument;
        modeArgument = 7;

        return cluster.WriteAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(
            modeArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadsBackTheRwMandatoryAttributeMode_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Mode::TypeInfo>(this, OnSuccessCallback_10,
                                                                                                      OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t mode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mode", mode, 7));
        NextTest();
    }
};

class Test_TC_WNCV_2_2 : public TestCommand
{
public:
    Test_TC_WNCV_2_2() : TestCommand("Test_TC_WNCV_2_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_WNCV_2_4 : public TestCommand
{
public:
    Test_TC_WNCV_2_4() : TestCommand("Test_TC_WNCV_2_4"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_4\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_4\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads Type attribute from DUT\n");
            err = TestReadsTypeAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads Type attribute constraints\n");
            err = TestReadsTypeAttributeConstraints_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_4 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_4 *>(context))->OnSuccessResponse_0(type);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_4 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t type)
    {
        (static_cast<Test_TC_WNCV_2_4 *>(context))->OnSuccessResponse_1(type);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsTypeAttributeFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                      OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t type)
    {
        VerifyOrReturn(CheckValue<uint8_t>("type", type, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsTypeAttributeConstraints_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::Type::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                      OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t type)
    {
        VerifyOrReturn(CheckConstraintType("type", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("type", type, 9));
        NextTest();
    }
};

class Test_TC_WNCV_2_5 : public TestCommand
{
public:
    Test_TC_WNCV_2_5() : TestCommand("Test_TC_WNCV_2_5"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_2_5\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_2_5\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads EndProductType attribute from DUT\n");
            err = TestReadsEndProductTypeAttributeFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads EndProductType attribute constraints from DUT\n");
            err = TestReadsEndProductTypeAttributeConstraintsFromDut_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnSuccessResponse_0(endProductType);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t endProductType)
    {
        (static_cast<Test_TC_WNCV_2_5 *>(context))->OnSuccessResponse_1(endProductType);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsEndProductTypeAttributeFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t endProductType)
    {
        VerifyOrReturn(CheckValue<uint8_t>("endProductType", endProductType, 0));
        NextTest();
    }

    CHIP_ERROR TestReadsEndProductTypeAttributeConstraintsFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::EndProductType::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t endProductType)
    {
        VerifyOrReturn(CheckConstraintType("endProductType", "", "enum8"));
        VerifyOrReturn(CheckConstraintMaxValue<uint8_t>("endProductType", endProductType, 23));
        NextTest();
    }
};

class Test_TC_WNCV_3_1 : public TestCommand
{
public:
    Test_TC_WNCV_3_1() : TestCommand("Test_TC_WNCV_3_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-open position\n");
            err = Test1aThAdjustsTheTheDutToANonOpenPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends UpOrOpen command to DUT\n");
            err = Test2aThSendsUpOrOpenCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: TH reads OperationalStatus attribute from DUT\n");
            err = Test3aThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonOpenPosition_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsUpOrOpenCommandToDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_1 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test3aThReadsOperationalStatusAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class Test_TC_WNCV_3_2 : public TestCommand
{
public:
    Test_TC_WNCV_3_2() : TestCommand("Test_TC_WNCV_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-closed position\n");
            err = Test1aThAdjustsTheTheDutToANonClosedPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends DownOrClose command to DUT\n");
            err = Test2aThSendsDownOrCloseCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 3a: TH reads OperationalStatus attribute from DUT\n");
            err = Test3aThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonClosedPosition_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsDownOrCloseCommandToDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::DownOrClose::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_2 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test3aThReadsOperationalStatusAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class Test_TC_WNCV_3_3 : public TestCommand
{
public:
    Test_TC_WNCV_3_3() : TestCommand("Test_TC_WNCV_3_3"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_WNCV_3_3\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_WNCV_3_3\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : 1a: TH adjusts the the DUT to a non-open position\n");
            err = Test1aThAdjustsTheTheDutToANonOpenPosition_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : 2a: TH sends StopMotion command to DUT\n");
            err = Test2aThSendsStopMotionCommandToDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : 2b: TH reads OperationalStatus attribute from DUT\n");
            err = Test2bThReadsOperationalStatusAttributeFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t operationalStatus)
    {
        (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_2(operationalStatus);
    }

    //
    // Tests methods
    //

    CHIP_ERROR Test1aThAdjustsTheTheDutToANonOpenPosition_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::UpOrOpen::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR Test2aThSendsStopMotionCommandToDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::WindowCovering::Commands::StopMotion::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<Test_TC_WNCV_3_3 *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR Test2bThReadsOperationalStatusAttributeFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WindowCoveringClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t operationalStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("operationalStatus", operationalStatus, 0));
        NextTest();
    }
};

class TV_TargetNavigatorCluster : public TestCommand
{
public:
    TV_TargetNavigatorCluster() : TestCommand("TV_TargetNavigatorCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TargetNavigatorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TargetNavigatorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Target Navigator list\n");
            err = TestReadAttributeTargetNavigatorList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Navigate Target Command\n");
            err = TestNavigateTargetCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TV_TargetNavigatorCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)
    {
        (static_cast<TV_TargetNavigatorCluster *>(context))->OnSuccessResponse_0(targetNavigatorList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeTargetNavigatorList_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TargetNavigatorClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TargetNavigator::Attributes::TargetNavigatorList::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<
            chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> & targetNavigatorList)
    {
        auto iter = targetNavigatorList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(targetNavigatorList)>("targetNavigatorList", iter, 0));
        VerifyOrReturn(CheckValue<>("targetNavigatorList[0].identifier", iter.GetValue().identifier, 1));
        VerifyOrReturn(CheckValueAsString("targetNavigatorList[0].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(targetNavigatorList)>("targetNavigatorList", iter, 1));
        VerifyOrReturn(CheckValue<>("targetNavigatorList[1].identifier", iter.GetValue().identifier, 2));
        VerifyOrReturn(CheckValueAsString("targetNavigatorList[1].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(targetNavigatorList)>("targetNavigatorList", iter, 2));
        NextTest();
    }

    CHIP_ERROR TestNavigateTargetCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TargetNavigator::Commands::NavigateTarget::Type;

        RequestType request;
        request.target = 1;
        request.data   = chip::Span<const char>("1garbage: not in length on purpose", 1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_TargetNavigatorCluster *>(context))->OnSuccessResponse_1(data.status, data.data);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TargetNavigatorCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::TargetNavigator::NavigateTargetStatus status, chip::CharSpan data) { NextTest(); }
};

class TV_AudioOutputCluster : public TestCommand
{
public:
    TV_AudioOutputCluster() : TestCommand("TV_AudioOutputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AudioOutputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AudioOutputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Audio Output list\n");
            err = TestReadAttributeAudioOutputList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Select Output Command\n");
            err = TestSelectOutputCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Rename Output Command\n");
            err = TestRenameOutputCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)
    {
        (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_0(audioOutputList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeAudioOutputList_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 2;
        chip::Controller::AudioOutputClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::AudioOutput::Attributes::AudioOutputList::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &
            audioOutputList)
    {
        auto iter = audioOutputList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 0));
        VerifyOrReturn(CheckValue<>("audioOutputList[0].index", iter.GetValue().index, 1));
        VerifyOrReturn(CheckValue<>("audioOutputList[0].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[0].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 1));
        VerifyOrReturn(CheckValue<>("audioOutputList[1].index", iter.GetValue().index, 2));
        VerifyOrReturn(CheckValue<>("audioOutputList[1].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[1].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(audioOutputList)>("audioOutputList", iter, 2));
        VerifyOrReturn(CheckValue<>("audioOutputList[2].index", iter.GetValue().index, 3));
        VerifyOrReturn(CheckValue<>("audioOutputList[2].outputType", iter.GetValue().outputType, 0));
        VerifyOrReturn(CheckValueAsString("audioOutputList[2].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(audioOutputList)>("audioOutputList", iter, 3));
        NextTest();
    }

    CHIP_ERROR TestSelectOutputCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 2;
        using RequestType               = chip::app::Clusters::AudioOutput::Commands::SelectOutput::Type;

        RequestType request;
        request.index = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestRenameOutputCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 2;
        using RequestType               = chip::app::Clusters::AudioOutput::Commands::RenameOutput::Type;

        RequestType request;
        request.index = 1;
        request.name  = chip::Span<const char>("exampleNamegarbage: not in length on purpose", 11);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AudioOutputCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class TV_ApplicationLauncherCluster : public TestCommand
{
public:
    TV_ApplicationLauncherCluster() : TestCommand("TV_ApplicationLauncherCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationLauncherCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationLauncherCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Application Launcher list\n");
            err = TestReadAttributeApplicationLauncherList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Launch App Command\n");
            err = TestLaunchAppCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute catalog vendor id\n");
            err = TestReadAttributeCatalogVendorId_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute application id\n");
            err = TestReadAttributeApplicationId_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_0(applicationLauncherList);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t catalogVendorId)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_2(catalogVendorId);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint8_t applicationId)
    {
        (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_3(applicationId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeApplicationLauncherList_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationLauncher::Attributes::ApplicationLauncherList::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(const chip::app::DataModel::DecodableList<uint16_t> & applicationLauncherList)
    {
        auto iter = applicationLauncherList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(applicationLauncherList)>("applicationLauncherList", iter, 0));
        VerifyOrReturn(CheckValue<uint16_t>("applicationLauncherList[0]", iter.GetValue(), 123U));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(applicationLauncherList)>("applicationLauncherList", iter, 1));
        VerifyOrReturn(CheckValue<uint16_t>("applicationLauncherList[1]", iter.GetValue(), 456U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(applicationLauncherList)>("applicationLauncherList", iter, 2));
        NextTest();
    }

    CHIP_ERROR TestLaunchAppCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ApplicationLauncher::Commands::LaunchApp::Type;

        RequestType request;
        request.data            = chip::Span<const char>("exampleDatagarbage: not in length on purpose", 11);
        request.catalogVendorId = 1U;
        request.applicationId   = chip::Span<const char>("appIdgarbage: not in length on purpose", 5);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ApplicationLauncherCluster *>(context))->OnSuccessResponse_1(data.status, data.data);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_ApplicationLauncherCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::ApplicationLauncher::ApplicationLauncherStatus status, chip::CharSpan data)
    {

        NextTest();
    }

    CHIP_ERROR TestReadAttributeCatalogVendorId_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationLauncher::Attributes::CatalogVendorId::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t catalogVendorId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("catalogVendorId", catalogVendorId, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeApplicationId_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ApplicationLauncherClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationLauncher::Attributes::ApplicationId::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t applicationId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("applicationId", applicationId, 0));
        NextTest();
    }
};

class TV_KeypadInputCluster : public TestCommand
{
public:
    TV_KeypadInputCluster() : TestCommand("TV_KeypadInputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_KeypadInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_KeypadInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Key Command\n");
            err = TestSendKeyCommand_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendKeyCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::KeypadInput::Commands::SendKey::Type;

        RequestType request;
        request.keyCode = static_cast<chip::app::Clusters::KeypadInput::KeypadInputCecKeyCode>(3);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_KeypadInputCluster *>(context))->OnSuccessResponse_0(data.status);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_KeypadInputCluster *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::app::Clusters::KeypadInput::KeypadInputStatus status) { NextTest(); }
};

class TV_AccountLoginCluster : public TestCommand
{
public:
    TV_AccountLoginCluster() : TestCommand("TV_AccountLoginCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_AccountLoginCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_AccountLoginCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Get Setup PIN Command\n");
            err = TestGetSetupPinCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Login Command\n");
            err = TestLoginCommand_1();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 2;

    //
    // Tests methods
    //

    CHIP_ERROR TestGetSetupPinCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::AccountLogin::Commands::GetSetupPIN::Type;

        RequestType request;
        request.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnSuccessResponse_0(data.setupPIN);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::CharSpan setupPIN) { NextTest(); }

    CHIP_ERROR TestLoginCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::AccountLogin::Commands::Login::Type;

        RequestType request;
        request.tempAccountIdentifier = chip::Span<const char>("asdfgarbage: not in length on purpose", 4);
        request.setupPIN              = chip::Span<const char>("tempPin123garbage: not in length on purpose", 10);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_AccountLoginCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }
};

class TV_WakeOnLanCluster : public TestCommand
{
public:
    TV_WakeOnLanCluster() : TestCommand("TV_WakeOnLanCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_WakeOnLanCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_WakeOnLanCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read mac address\n");
            err = TestReadMacAddress_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TV_WakeOnLanCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, chip::CharSpan wakeOnLanMacAddress)
    {
        (static_cast<TV_WakeOnLanCluster *>(context))->OnSuccessResponse_0(wakeOnLanMacAddress);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadMacAddress_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::WakeOnLanClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::WakeOnLan::Attributes::WakeOnLanMacAddress::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::CharSpan wakeOnLanMacAddress)
    {
        VerifyOrReturn(CheckValueAsString("wakeOnLanMacAddress", wakeOnLanMacAddress, chip::CharSpan("00:00:00:00:00", 14)));
        NextTest();
    }
};

class TV_ApplicationBasicCluster : public TestCommand
{
public:
    TV_ApplicationBasicCluster() : TestCommand("TV_ApplicationBasicCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_ApplicationBasicCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_ApplicationBasicCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Change Status Command\n");
            err = TestChangeStatusCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute vendor id\n");
            err = TestReadAttributeVendorId_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute product id\n");
            err = TestReadAttributeProductId_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute catalog vendor id\n");
            err = TestReadAttributeCatalogVendorId_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint16_t vendorId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_1(vendorId);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint16_t productId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_2(productId);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint16_t catalogVendorId)
    {
        (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_3(catalogVendorId);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestChangeStatusCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::ApplicationBasic::Commands::ChangeStatus::Type;

        RequestType request;
        request.status = static_cast<chip::app::Clusters::ApplicationBasic::ApplicationBasicStatus>(1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_ApplicationBasicCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_ApplicationBasicCluster *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorId_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::VendorId::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint16_t vendorId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("vendorId", vendorId, 1U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeProductId_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::ProductId::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint16_t productId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("productId", productId, 1U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeCatalogVendorId_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        chip::Controller::ApplicationBasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ApplicationBasic::Attributes::CatalogVendorId::TypeInfo>(
            this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint16_t catalogVendorId)
    {
        VerifyOrReturn(CheckValue<uint16_t>("catalogVendorId", catalogVendorId, 1U));
        NextTest();
    }
};

class TV_MediaPlaybackCluster : public TestCommand
{
public:
    TV_MediaPlaybackCluster() : TestCommand("TV_MediaPlaybackCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaPlaybackCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaPlaybackCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Media Playback Play Command\n");
            err = TestMediaPlaybackPlayCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Media Playback Pause Command\n");
            err = TestMediaPlaybackPauseCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Media Playback Stop Command\n");
            err = TestMediaPlaybackStopCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Media Playback Start Over Command\n");
            err = TestMediaPlaybackStartOverCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Media Playback Previous Command\n");
            err = TestMediaPlaybackPreviousCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Media Playback Next Command\n");
            err = TestMediaPlaybackNextCommand_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Media Playback Rewind Command\n");
            err = TestMediaPlaybackRewindCommand_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Media Playback Fast Forward Command\n");
            err = TestMediaPlaybackFastForwardCommand_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Media Playback Skip Forward Command\n");
            err = TestMediaPlaybackSkipForwardCommand_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Media Playback Skip Backward Command\n");
            err = TestMediaPlaybackSkipBackwardCommand_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Media Playback Seek Command\n");
            err = TestMediaPlaybackSeekCommand_10();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 11;

    //
    // Tests methods
    //

    CHIP_ERROR TestMediaPlaybackPlayCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaPlay::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_0(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPauseCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaPause::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_1(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStopCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaStop::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_2(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackStartOverCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaStartOver::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_3(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackPreviousCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaPrevious::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_4(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackNextCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaNext::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_5(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackRewindCommand_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaRewind::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_6(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackFastForwardCommand_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaFastForward::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_7(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipForwardCommand_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaSkipForward::Type;

        RequestType request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_8(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSkipBackwardCommand_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaSkipBackward::Type;

        RequestType request;
        request.deltaPositionMilliseconds = 100ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_9(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }

    CHIP_ERROR TestMediaPlaybackSeekCommand_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 3;
        using RequestType               = chip::app::Clusters::MediaPlayback::Commands::MediaSeek::Type;

        RequestType request;
        request.position = 100ULL;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnSuccessResponse_10(data.mediaPlaybackStatus);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaPlaybackCluster *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(chip::app::Clusters::MediaPlayback::MediaPlaybackStatus mediaPlaybackStatus)
    {
        VerifyOrReturn(CheckValue<uint8_t>("mediaPlaybackStatus", mediaPlaybackStatus, 0));
        NextTest();
    }
};

class TV_TvChannelCluster : public TestCommand
{
public:
    TV_TvChannelCluster() : TestCommand("TV_TvChannelCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_TvChannelCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_TvChannelCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute TV Channel list\n");
            err = TestReadAttributeTvChannelList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Change Channel By Number Command\n");
            err = TestChangeChannelByNumberCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Skip Channel Command\n");
            err = TestSkipChannelCommand_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> &
            tvChannelList)
    {
        (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_0(tvChannelList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeTvChannelList_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TvChannelClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TvChannel::Attributes::TvChannelList::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                          OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TvChannel::Structs::TvChannelInfo::DecodableType> &
            tvChannelList)
    {
        auto iter = tvChannelList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(tvChannelList)>("tvChannelList", iter, 0));
        VerifyOrReturn(CheckValue<>("tvChannelList[0].majorNumber", iter.GetValue().majorNumber, 1U));
        VerifyOrReturn(CheckValue<>("tvChannelList[0].minorNumber", iter.GetValue().minorNumber, 2U));
        VerifyOrReturn(CheckValueAsString("tvChannelList[0].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(
            CheckValueAsString("tvChannelList[0].callSign", iter.GetValue().callSign, chip::CharSpan("exampleCSign", 12)));
        VerifyOrReturn(CheckValueAsString("tvChannelList[0].affiliateCallSign", iter.GetValue().affiliateCallSign,
                                          chip::CharSpan("exampleASign", 12)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(tvChannelList)>("tvChannelList", iter, 1));
        VerifyOrReturn(CheckValue<>("tvChannelList[1].majorNumber", iter.GetValue().majorNumber, 2U));
        VerifyOrReturn(CheckValue<>("tvChannelList[1].minorNumber", iter.GetValue().minorNumber, 3U));
        VerifyOrReturn(CheckValueAsString("tvChannelList[1].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(
            CheckValueAsString("tvChannelList[1].callSign", iter.GetValue().callSign, chip::CharSpan("exampleCSign", 12)));
        VerifyOrReturn(CheckValueAsString("tvChannelList[1].affiliateCallSign", iter.GetValue().affiliateCallSign,
                                          chip::CharSpan("exampleASign", 12)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(tvChannelList)>("tvChannelList", iter, 2));
        NextTest();
    }

    CHIP_ERROR TestChangeChannelByNumberCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TvChannel::Commands::ChangeChannelByNumber::Type;

        RequestType request;
        request.majorNumber = 1U;
        request.minorNumber = 2U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestSkipChannelCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TvChannel::Commands::SkipChannel::Type;

        RequestType request;
        request.count = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_TvChannelCluster *>(context))->OnSuccessResponse_2();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_TvChannelCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }
};

class TV_LowPowerCluster : public TestCommand
{
public:
    TV_LowPowerCluster() : TestCommand("TV_LowPowerCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_LowPowerCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_LowPowerCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Sleep Input Status Command\n");
            err = TestSleepInputStatusCommand_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestSleepInputStatusCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::LowPower::Commands::Sleep::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_LowPowerCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_LowPowerCluster *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }
};

class TV_MediaInputCluster : public TestCommand
{
public:
    TV_MediaInputCluster() : TestCommand("TV_MediaInputCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TV_MediaInputCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TV_MediaInputCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute media input list\n");
            err = TestReadAttributeMediaInputList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Select Input Command\n");
            err = TestSelectInputCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read current input list\n");
            err = TestReadCurrentInputList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Hide Input Status Command\n");
            err = TestHideInputStatusCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Show Input Status Command\n");
            err = TestShowInputStatusCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Rename Input Command\n");
            err = TestRenameInputCommand_5();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 6;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_0(mediaInputList);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t currentMediaInput)
    {
        (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_2(currentMediaInput);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeMediaInputList_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::MediaInputList::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &
            mediaInputList)
    {
        auto iter = mediaInputList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(mediaInputList)>("mediaInputList", iter, 0));
        VerifyOrReturn(CheckValue<>("mediaInputList[0].index", iter.GetValue().index, 1));
        VerifyOrReturn(CheckValue<>("mediaInputList[0].inputType", iter.GetValue().inputType, 4));
        VerifyOrReturn(CheckValueAsString("mediaInputList[0].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckValueAsString("mediaInputList[0].description", iter.GetValue().description,
                                          chip::CharSpan("exampleDescription", 18)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(mediaInputList)>("mediaInputList", iter, 1));
        VerifyOrReturn(CheckValue<>("mediaInputList[1].index", iter.GetValue().index, 2));
        VerifyOrReturn(CheckValue<>("mediaInputList[1].inputType", iter.GetValue().inputType, 4));
        VerifyOrReturn(CheckValueAsString("mediaInputList[1].name", iter.GetValue().name, chip::CharSpan("exampleName", 11)));
        VerifyOrReturn(CheckValueAsString("mediaInputList[1].description", iter.GetValue().description,
                                          chip::CharSpan("exampleDescription", 18)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(mediaInputList)>("mediaInputList", iter, 2));
        NextTest();
    }

    CHIP_ERROR TestSelectInputCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::SelectInput::Type;

        RequestType request;
        request.index = 1;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadCurrentInputList_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::MediaInputClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::MediaInput::Attributes::CurrentMediaInput::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t currentMediaInput)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentMediaInput", currentMediaInput, 1));
        NextTest();
    }

    CHIP_ERROR TestHideInputStatusCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::HideInputStatus::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestShowInputStatusCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::ShowInputStatus::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_4();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4() { NextTest(); }

    CHIP_ERROR TestRenameInputCommand_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::MediaInput::Commands::RenameInput::Type;

        RequestType request;
        request.index = 1;
        request.name  = chip::Span<const char>("newNamegarbage: not in length on purpose", 7);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TV_MediaInputCluster *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TV_MediaInputCluster *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }
};

class TestCluster : public TestCommand
{
public:
    TestCluster() : TestCommand("TestCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Test Command\n");
            err = TestSendTestCommand_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Send Test Not Handled Command\n");
            err = TestSendTestNotHandledCommand_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Send Test Specific Command\n");
            err = TestSendTestSpecificCommand_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Send Test Add Arguments Command\n");
            err = TestSendTestAddArgumentsCommand_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Send failing Test Add Arguments Command\n");
            err = TestSendFailingTestAddArgumentsCommand_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Read attribute BOOLEAN Default Value\n");
            err = TestReadAttributeBooleanDefaultValue_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Write attribute BOOLEAN True\n");
            err = TestWriteAttributeBooleanTrue_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Read attribute BOOLEAN True\n");
            err = TestReadAttributeBooleanTrue_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Write attribute BOOLEAN False\n");
            err = TestWriteAttributeBooleanFalse_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Read attribute BOOLEAN False\n");
            err = TestReadAttributeBooleanFalse_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute BITMAP8 Default Value\n");
            err = TestReadAttributeBitmap8DefaultValue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write attribute BITMAP8 Max Value\n");
            err = TestWriteAttributeBitmap8MaxValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read attribute BITMAP8 Max Value\n");
            err = TestReadAttributeBitmap8MaxValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Write attribute BITMAP8 Min Value\n");
            err = TestWriteAttributeBitmap8MinValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read attribute BITMAP8 Min Value\n");
            err = TestReadAttributeBitmap8MinValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Read attribute BITMAP16 Default Value\n");
            err = TestReadAttributeBitmap16DefaultValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Write attribute BITMAP16 Max Value\n");
            err = TestWriteAttributeBitmap16MaxValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Read attribute BITMAP16 Max Value\n");
            err = TestReadAttributeBitmap16MaxValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Write attribute BITMAP16 Min Value\n");
            err = TestWriteAttributeBitmap16MinValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Read attribute BITMAP16 Min Value\n");
            err = TestReadAttributeBitmap16MinValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute BITMAP32 Default Value\n");
            err = TestReadAttributeBitmap32DefaultValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write attribute BITMAP32 Max Value\n");
            err = TestWriteAttributeBitmap32MaxValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read attribute BITMAP32 Max Value\n");
            err = TestReadAttributeBitmap32MaxValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Write attribute BITMAP32 Min Value\n");
            err = TestWriteAttributeBitmap32MinValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read attribute BITMAP32 Min Value\n");
            err = TestReadAttributeBitmap32MinValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Read attribute BITMAP64 Default Value\n");
            err = TestReadAttributeBitmap64DefaultValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Write attribute BITMAP64 Max Value\n");
            err = TestWriteAttributeBitmap64MaxValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Read attribute BITMAP64 Max Value\n");
            err = TestReadAttributeBitmap64MaxValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Write attribute BITMAP64 Min Value\n");
            err = TestWriteAttributeBitmap64MinValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Read attribute BITMAP64 Min Value\n");
            err = TestReadAttributeBitmap64MinValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read attribute INT8U Default Value\n");
            err = TestReadAttributeInt8uDefaultValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Write attribute INT8U Max Value\n");
            err = TestWriteAttributeInt8uMaxValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read attribute INT8U Max Value\n");
            err = TestReadAttributeInt8uMaxValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Write attribute INT8U Min Value\n");
            err = TestWriteAttributeInt8uMinValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read attribute INT8U Min Value\n");
            err = TestReadAttributeInt8uMinValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Read attribute INT16U Default Value\n");
            err = TestReadAttributeInt16uDefaultValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Write attribute INT16U Max Value\n");
            err = TestWriteAttributeInt16uMaxValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Read attribute INT16U Max Value\n");
            err = TestReadAttributeInt16uMaxValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Write attribute INT16U Min Value\n");
            err = TestWriteAttributeInt16uMinValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Read attribute INT16U Min Value\n");
            err = TestReadAttributeInt16uMinValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read attribute INT32U Default Value\n");
            err = TestReadAttributeInt32uDefaultValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Write attribute INT32U Max Value\n");
            err = TestWriteAttributeInt32uMaxValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Read attribute INT32U Max Value\n");
            err = TestReadAttributeInt32uMaxValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Write attribute INT32U Min Value\n");
            err = TestWriteAttributeInt32uMinValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read attribute INT32U Min Value\n");
            err = TestReadAttributeInt32uMinValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Read attribute INT64U Default Value\n");
            err = TestReadAttributeInt64uDefaultValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Write attribute INT64U Max Value\n");
            err = TestWriteAttributeInt64uMaxValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Read attribute INT64U Max Value\n");
            err = TestReadAttributeInt64uMaxValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Write attribute INT64U Min Value\n");
            err = TestWriteAttributeInt64uMinValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Read attribute INT64U Min Value\n");
            err = TestReadAttributeInt64uMinValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Write attribute INT8S Max Value\n");
            err = TestWriteAttributeInt8sMaxValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Read attribute INT8S Max Value\n");
            err = TestReadAttributeInt8sMaxValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Write attribute INT8S Min Value\n");
            err = TestWriteAttributeInt8sMinValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Read attribute INT8S Min Value\n");
            err = TestReadAttributeInt8sMinValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Write attribute INT8S Default Value\n");
            err = TestWriteAttributeInt8sDefaultValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read attribute INT8S Default Value\n");
            err = TestReadAttributeInt8sDefaultValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Write attribute INT16S Max Value\n");
            err = TestWriteAttributeInt16sMaxValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Read attribute INT16S Max Value\n");
            err = TestReadAttributeInt16sMaxValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Write attribute INT16S Min Value\n");
            err = TestWriteAttributeInt16sMinValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Read attribute INT16S Min Value\n");
            err = TestReadAttributeInt16sMinValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Write attribute INT16S Default Value\n");
            err = TestWriteAttributeInt16sDefaultValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Read attribute INT16S Default Value\n");
            err = TestReadAttributeInt16sDefaultValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write attribute INT32S Max Value\n");
            err = TestWriteAttributeInt32sMaxValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read attribute INT32S Max Value\n");
            err = TestReadAttributeInt32sMaxValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write attribute INT32S Min Value\n");
            err = TestWriteAttributeInt32sMinValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read attribute INT32S Min Value\n");
            err = TestReadAttributeInt32sMinValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Write attribute INT32S Default Value\n");
            err = TestWriteAttributeInt32sDefaultValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read attribute INT32S Default Value\n");
            err = TestReadAttributeInt32sDefaultValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Write attribute INT64S Max Value\n");
            err = TestWriteAttributeInt64sMaxValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Read attribute INT64S Max Value\n");
            err = TestReadAttributeInt64sMaxValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Write attribute INT64S Min Value\n");
            err = TestWriteAttributeInt64sMinValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Read attribute INT64S Min Value\n");
            err = TestReadAttributeInt64sMinValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Write attribute INT64S Default Value\n");
            err = TestWriteAttributeInt64sDefaultValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Read attribute INT64S Default Value\n");
            err = TestReadAttributeInt64sDefaultValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute ENUM8 Default Value\n");
            err = TestReadAttributeEnum8DefaultValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Write attribute ENUM8 Max Value\n");
            err = TestWriteAttributeEnum8MaxValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Read attribute ENUM8 Max Value\n");
            err = TestReadAttributeEnum8MaxValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Write attribute ENUM8 Min Value\n");
            err = TestWriteAttributeEnum8MinValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read attribute ENUM8 Min Value\n");
            err = TestReadAttributeEnum8MinValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Read attribute ENUM16 Default Value\n");
            err = TestReadAttributeEnum16DefaultValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Write attribute ENUM16 Max Value\n");
            err = TestWriteAttributeEnum16MaxValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Read attribute ENUM16 Max Value\n");
            err = TestReadAttributeEnum16MaxValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Write attribute ENUM16 Min Value\n");
            err = TestWriteAttributeEnum16MinValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Read attribute ENUM16 Min Value\n");
            err = TestReadAttributeEnum16MinValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute OCTET_STRING Default Value\n");
            err = TestReadAttributeOctetStringDefaultValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write attribute OCTET_STRING with embedded null\n");
            err = TestWriteAttributeOctetStringWithEmbeddedNull_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read attribute OCTET_STRING with embedded null\n");
            err = TestReadAttributeOctetStringWithEmbeddedNull_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute OCTET_STRING\n");
            err = TestReadAttributeOctetString_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Write attribute OCTET_STRING\n");
            err = TestWriteAttributeOctetString_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Read attribute LONG_OCTET_STRING Default Value\n");
            err = TestReadAttributeLongOctetStringDefaultValue_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Read attribute LONG_OCTET_STRING\n");
            err = TestReadAttributeLongOctetString_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Write attribute LONG_OCTET_STRING\n");
            err = TestWriteAttributeLongOctetString_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Read attribute CHAR_STRING Default Value\n");
            err = TestReadAttributeCharStringDefaultValue_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Write attribute CHAR_STRING\n");
            err = TestWriteAttributeCharString_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Write attribute CHAR_STRING - Value too long\n");
            err = TestWriteAttributeCharStringValueTooLong_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write attribute CHAR_STRING - Empty\n");
            err = TestWriteAttributeCharStringEmpty_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Read attribute LONG_CHAR_STRING Default Value\n");
            err = TestReadAttributeLongCharStringDefaultValue_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Read attribute LONG_CHAR_STRING\n");
            err = TestReadAttributeLongCharString_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Write attribute LONG_CHAR_STRING\n");
            err = TestWriteAttributeLongCharString_107();
            break;
        case 108:
            ChipLogProgress(chipTool, " ***** Test Step 108 : Read attribute EPOCH_US Default Value\n");
            err = TestReadAttributeEpochUsDefaultValue_108();
            break;
        case 109:
            ChipLogProgress(chipTool, " ***** Test Step 109 : Write attribute EPOCH_US Max Value\n");
            err = TestWriteAttributeEpochUsMaxValue_109();
            break;
        case 110:
            ChipLogProgress(chipTool, " ***** Test Step 110 : Read attribute EPOCH_US Max Value\n");
            err = TestReadAttributeEpochUsMaxValue_110();
            break;
        case 111:
            ChipLogProgress(chipTool, " ***** Test Step 111 : Write attribute EPOCH_US Min Value\n");
            err = TestWriteAttributeEpochUsMinValue_111();
            break;
        case 112:
            ChipLogProgress(chipTool, " ***** Test Step 112 : Read attribute EPOCH_US Min Value\n");
            err = TestReadAttributeEpochUsMinValue_112();
            break;
        case 113:
            ChipLogProgress(chipTool, " ***** Test Step 113 : Read attribute EPOCH_S Default Value\n");
            err = TestReadAttributeEpochSDefaultValue_113();
            break;
        case 114:
            ChipLogProgress(chipTool, " ***** Test Step 114 : Write attribute EPOCH_S Max Value\n");
            err = TestWriteAttributeEpochSMaxValue_114();
            break;
        case 115:
            ChipLogProgress(chipTool, " ***** Test Step 115 : Read attribute EPOCH_S Max Value\n");
            err = TestReadAttributeEpochSMaxValue_115();
            break;
        case 116:
            ChipLogProgress(chipTool, " ***** Test Step 116 : Write attribute EPOCH_S Min Value\n");
            err = TestWriteAttributeEpochSMinValue_116();
            break;
        case 117:
            ChipLogProgress(chipTool, " ***** Test Step 117 : Read attribute EPOCH_S Min Value\n");
            err = TestReadAttributeEpochSMinValue_117();
            break;
        case 118:
            ChipLogProgress(chipTool, " ***** Test Step 118 : Read attribute UNSUPPORTED\n");
            err = TestReadAttributeUnsupported_118();
            break;
        case 119:
            ChipLogProgress(chipTool, " ***** Test Step 119 : Writeattribute UNSUPPORTED\n");
            err = TestWriteattributeUnsupported_119();
            break;
        case 120:
            ChipLogProgress(chipTool, " ***** Test Step 120 : Send Test Command to unsupported endpoint\n");
            err = TestSendTestCommandToUnsupportedEndpoint_120();
            break;
        case 121:
            ChipLogProgress(chipTool, " ***** Test Step 121 : Read attribute vendor_id Default Value\n");
            err = TestReadAttributeVendorIdDefaultValue_121();
            break;
        case 122:
            ChipLogProgress(chipTool, " ***** Test Step 122 : Write attribute vendor_id\n");
            err = TestWriteAttributeVendorId_122();
            break;
        case 123:
            ChipLogProgress(chipTool, " ***** Test Step 123 : Read attribute vendor_id\n");
            err = TestReadAttributeVendorId_123();
            break;
        case 124:
            ChipLogProgress(chipTool, " ***** Test Step 124 : Restore attribute vendor_id\n");
            err = TestRestoreAttributeVendorId_124();
            break;
        case 125:
            ChipLogProgress(chipTool, " ***** Test Step 125 : Send a command with a vendor_id and enum\n");
            err = TestSendACommandWithAVendorIdAndEnum_125();
            break;
        case 126:
            ChipLogProgress(chipTool, " ***** Test Step 126 : Send Test Command With Struct Argument and arg1.b is true\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsTrue_126();
            break;
        case 127:
            ChipLogProgress(chipTool, " ***** Test Step 127 : Send Test Command With Struct Argument and arg1.b is false\n");
            err = TestSendTestCommandWithStructArgumentAndArg1bIsFalse_127();
            break;
        case 128:
            ChipLogProgress(chipTool, " ***** Test Step 128 : Send Test Command With List of INT8U and none of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_128();
            break;
        case 129:
            ChipLogProgress(chipTool, " ***** Test Step 129 : Send Test Command With List of INT8U and one of them is set to 0\n");
            err = TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_129();
            break;
        case 130:
            ChipLogProgress(chipTool, " ***** Test Step 130 : Send Test Command With List of INT8U and get it reversed\n");
            err = TestSendTestCommandWithListOfInt8uAndGetItReversed_130();
            break;
        case 131:
            ChipLogProgress(chipTool,
                            " ***** Test Step 131 : Send Test Command With empty List of INT8U and get an empty list back\n");
            err = TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_131();
            break;
        case 132:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 132 : Send Test Command With List of Struct Argument and arg1.b of first item is true\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_132();
            break;
        case 133:
            ChipLogProgress(
                chipTool,
                " ***** Test Step 133 : Send Test Command With List of Struct Argument and arg1.b of first item is false\n");
            err = TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_133();
            break;
        case 134:
            ChipLogProgress(chipTool, " ***** Test Step 134 : Send Test Command with optional arg set.\n");
            err = TestSendTestCommandWithOptionalArgSet_134();
            break;
        case 135:
            ChipLogProgress(chipTool, " ***** Test Step 135 : Send Test Command without its optional arg.\n");
            err = TestSendTestCommandWithoutItsOptionalArg_135();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 136;

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_5(boolean);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_6(); }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_7(boolean);
    }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_8(); }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context, bool boolean)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_9(boolean);
    }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_10(bitmap8);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_12(bitmap8);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_13(); }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, uint8_t bitmap8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_14(bitmap8);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_15(bitmap16);
    }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_16(); }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_17(bitmap16);
    }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_18(); }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context, uint16_t bitmap16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_19(bitmap16);
    }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_20(bitmap32);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_21(); }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_22(bitmap32);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_23(); }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context, uint32_t bitmap32)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_24(bitmap32);
    }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_25(bitmap64);
    }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_26(); }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_27(bitmap64);
    }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_28(); }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context, uint64_t bitmap64)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_29(bitmap64);
    }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_30(int8u);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_31(); }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_32(int8u);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_33(); }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, uint8_t int8u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_34(int8u);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_35(int16u);
    }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_36(); }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_37(int16u);
    }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_38(); }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context, uint16_t int16u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_39(int16u);
    }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_40(int32u);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_41(); }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_42(int32u);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_43(); }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context, uint32_t int32u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_44(int32u);
    }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_45(int64u);
    }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_46(); }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_47(int64u);
    }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_48(); }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context, uint64_t int64u)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_49(int64u);
    }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_50(int8s);
    }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_51(); }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_52(int8s);
    }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_53(); }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_54(int8s);
    }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_55(); }

    static void OnFailureCallback_56(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_56(chip::to_underlying(status));
    }

    static void OnSuccessCallback_56(void * context, int8_t int8s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_56(int8s);
    }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_57(int16s);
    }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_58(); }

    static void OnFailureCallback_59(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_59(chip::to_underlying(status));
    }

    static void OnSuccessCallback_59(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_59(int16s);
    }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_60(); }

    static void OnFailureCallback_61(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_61(chip::to_underlying(status));
    }

    static void OnSuccessCallback_61(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_61(int16s);
    }

    static void OnFailureCallback_62(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_62(chip::to_underlying(status));
    }

    static void OnSuccessCallback_62(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_62(); }

    static void OnFailureCallback_63(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_63(chip::to_underlying(status));
    }

    static void OnSuccessCallback_63(void * context, int16_t int16s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_63(int16s);
    }

    static void OnFailureCallback_64(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_64(chip::to_underlying(status));
    }

    static void OnSuccessCallback_64(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_64(int32s);
    }

    static void OnFailureCallback_65(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_65(chip::to_underlying(status));
    }

    static void OnSuccessCallback_65(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_65(); }

    static void OnFailureCallback_66(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_66(chip::to_underlying(status));
    }

    static void OnSuccessCallback_66(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_66(int32s);
    }

    static void OnFailureCallback_67(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_67(chip::to_underlying(status));
    }

    static void OnSuccessCallback_67(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_67(); }

    static void OnFailureCallback_68(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_68(chip::to_underlying(status));
    }

    static void OnSuccessCallback_68(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_68(int32s);
    }

    static void OnFailureCallback_69(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_69(chip::to_underlying(status));
    }

    static void OnSuccessCallback_69(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_69(); }

    static void OnFailureCallback_70(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_70(chip::to_underlying(status));
    }

    static void OnSuccessCallback_70(void * context, int32_t int32s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_70(int32s);
    }

    static void OnFailureCallback_71(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_71(chip::to_underlying(status));
    }

    static void OnSuccessCallback_71(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_71(int64s);
    }

    static void OnFailureCallback_72(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_72(chip::to_underlying(status));
    }

    static void OnSuccessCallback_72(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_72(); }

    static void OnFailureCallback_73(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_73(chip::to_underlying(status));
    }

    static void OnSuccessCallback_73(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_73(int64s);
    }

    static void OnFailureCallback_74(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_74(chip::to_underlying(status));
    }

    static void OnSuccessCallback_74(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_74(); }

    static void OnFailureCallback_75(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_75(chip::to_underlying(status));
    }

    static void OnSuccessCallback_75(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_75(int64s);
    }

    static void OnFailureCallback_76(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_76(chip::to_underlying(status));
    }

    static void OnSuccessCallback_76(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_76(); }

    static void OnFailureCallback_77(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_77(chip::to_underlying(status));
    }

    static void OnSuccessCallback_77(void * context, int64_t int64s)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_77(int64s);
    }

    static void OnFailureCallback_78(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_78(chip::to_underlying(status));
    }

    static void OnSuccessCallback_78(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_78(enum8);
    }

    static void OnFailureCallback_79(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_79(chip::to_underlying(status));
    }

    static void OnSuccessCallback_79(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_79(); }

    static void OnFailureCallback_80(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_80(chip::to_underlying(status));
    }

    static void OnSuccessCallback_80(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_80(enum8);
    }

    static void OnFailureCallback_81(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_81(chip::to_underlying(status));
    }

    static void OnSuccessCallback_81(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_81(); }

    static void OnFailureCallback_82(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_82(chip::to_underlying(status));
    }

    static void OnSuccessCallback_82(void * context, uint8_t enum8)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_82(enum8);
    }

    static void OnFailureCallback_83(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_83(chip::to_underlying(status));
    }

    static void OnSuccessCallback_83(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_83(enum16);
    }

    static void OnFailureCallback_84(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_84(chip::to_underlying(status));
    }

    static void OnSuccessCallback_84(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_84(); }

    static void OnFailureCallback_85(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_85(chip::to_underlying(status));
    }

    static void OnSuccessCallback_85(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_85(enum16);
    }

    static void OnFailureCallback_86(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_86(chip::to_underlying(status));
    }

    static void OnSuccessCallback_86(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_86(); }

    static void OnFailureCallback_87(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_87(chip::to_underlying(status));
    }

    static void OnSuccessCallback_87(void * context, uint16_t enum16)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_87(enum16);
    }

    static void OnFailureCallback_88(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_88(chip::to_underlying(status));
    }

    static void OnSuccessCallback_88(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_88(octetString);
    }

    static void OnFailureCallback_89(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_89(chip::to_underlying(status));
    }

    static void OnSuccessCallback_89(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_89(); }

    static void OnFailureCallback_90(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_90(chip::to_underlying(status));
    }

    static void OnSuccessCallback_90(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_90(octetString);
    }

    static void OnFailureCallback_91(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_91(chip::to_underlying(status));
    }

    static void OnSuccessCallback_91(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_91(); }

    static void OnFailureCallback_92(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_92(chip::to_underlying(status));
    }

    static void OnSuccessCallback_92(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_92(octetString);
    }

    static void OnFailureCallback_93(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_93(chip::to_underlying(status));
    }

    static void OnSuccessCallback_93(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_93(); }

    static void OnFailureCallback_94(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_94(chip::to_underlying(status));
    }

    static void OnSuccessCallback_94(void * context, chip::ByteSpan octetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_94(octetString);
    }

    static void OnFailureCallback_95(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_95(chip::to_underlying(status));
    }

    static void OnSuccessCallback_95(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_95(); }

    static void OnFailureCallback_96(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_96(chip::to_underlying(status));
    }

    static void OnSuccessCallback_96(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_96(longOctetString);
    }

    static void OnFailureCallback_97(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_97(chip::to_underlying(status));
    }

    static void OnSuccessCallback_97(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_97(); }

    static void OnFailureCallback_98(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_98(chip::to_underlying(status));
    }

    static void OnSuccessCallback_98(void * context, chip::ByteSpan longOctetString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_98(longOctetString);
    }

    static void OnFailureCallback_99(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_99(chip::to_underlying(status));
    }

    static void OnSuccessCallback_99(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_99(); }

    static void OnFailureCallback_100(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_100(chip::to_underlying(status));
    }

    static void OnSuccessCallback_100(void * context, chip::CharSpan charString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_100(charString);
    }

    static void OnFailureCallback_101(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_101(chip::to_underlying(status));
    }

    static void OnSuccessCallback_101(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_101(); }

    static void OnFailureCallback_102(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_102(chip::to_underlying(status));
    }

    static void OnSuccessCallback_102(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_102(); }

    static void OnFailureCallback_103(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_103(chip::to_underlying(status));
    }

    static void OnSuccessCallback_103(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_103(); }

    static void OnFailureCallback_104(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_104(chip::to_underlying(status));
    }

    static void OnSuccessCallback_104(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_104(longCharString);
    }

    static void OnFailureCallback_105(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_105(chip::to_underlying(status));
    }

    static void OnSuccessCallback_105(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_105(); }

    static void OnFailureCallback_106(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_106(chip::to_underlying(status));
    }

    static void OnSuccessCallback_106(void * context, chip::CharSpan longCharString)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_106(longCharString);
    }

    static void OnFailureCallback_107(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_107(chip::to_underlying(status));
    }

    static void OnSuccessCallback_107(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_107(); }

    static void OnFailureCallback_108(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_108(chip::to_underlying(status));
    }

    static void OnSuccessCallback_108(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_108(epochUs);
    }

    static void OnFailureCallback_109(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_109(chip::to_underlying(status));
    }

    static void OnSuccessCallback_109(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_109(); }

    static void OnFailureCallback_110(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_110(chip::to_underlying(status));
    }

    static void OnSuccessCallback_110(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_110(epochUs);
    }

    static void OnFailureCallback_111(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_111(chip::to_underlying(status));
    }

    static void OnSuccessCallback_111(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_111(); }

    static void OnFailureCallback_112(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_112(chip::to_underlying(status));
    }

    static void OnSuccessCallback_112(void * context, uint64_t epochUs)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_112(epochUs);
    }

    static void OnFailureCallback_113(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_113(chip::to_underlying(status));
    }

    static void OnSuccessCallback_113(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_113(epochS);
    }

    static void OnFailureCallback_114(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_114(chip::to_underlying(status));
    }

    static void OnSuccessCallback_114(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_114(); }

    static void OnFailureCallback_115(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_115(chip::to_underlying(status));
    }

    static void OnSuccessCallback_115(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_115(epochS);
    }

    static void OnFailureCallback_116(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_116(chip::to_underlying(status));
    }

    static void OnSuccessCallback_116(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_116(); }

    static void OnFailureCallback_117(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_117(chip::to_underlying(status));
    }

    static void OnSuccessCallback_117(void * context, uint32_t epochS)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_117(epochS);
    }

    static void OnFailureCallback_118(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_118(chip::to_underlying(status));
    }

    static void OnSuccessCallback_118(void * context, bool unsupported)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_118(unsupported);
    }

    static void OnFailureCallback_119(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_119(chip::to_underlying(status));
    }

    static void OnSuccessCallback_119(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_119(); }

    static void OnFailureCallback_121(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_121(chip::to_underlying(status));
    }

    static void OnSuccessCallback_121(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_121(vendorId);
    }

    static void OnFailureCallback_122(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_122(chip::to_underlying(status));
    }

    static void OnSuccessCallback_122(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_122(); }

    static void OnFailureCallback_123(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_123(chip::to_underlying(status));
    }

    static void OnSuccessCallback_123(void * context, chip::VendorId vendorId)
    {
        (static_cast<TestCluster *>(context))->OnSuccessResponse_123(vendorId);
    }

    static void OnFailureCallback_124(void * context, EmberAfStatus status)
    {
        (static_cast<TestCluster *>(context))->OnFailureResponse_124(chip::to_underlying(status));
    }

    static void OnSuccessCallback_124(void * context) { (static_cast<TestCluster *>(context))->OnSuccessResponse_124(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendTestCommand_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestSendTestNotHandledCommand_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNotHandled::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_1();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { NextTest(); }

    void OnSuccessResponse_1() { ThrowSuccessResponse(); }

    CHIP_ERROR TestSendTestSpecificCommand_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestSpecific::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_2(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("returnValue", returnValue, 7));
        NextTest();
    }

    CHIP_ERROR TestSendTestAddArgumentsCommand_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 3;
        request.arg2 = 17;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_3(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t returnValue)
    {
        VerifyOrReturn(CheckValue<uint8_t>("returnValue", returnValue, 20));
        NextTest();
    }

    CHIP_ERROR TestSendFailingTestAddArgumentsCommand_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestAddArguments::Type;

        RequestType request;
        request.arg1 = 250;
        request.arg2 = 6;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_4(data.returnValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { NextTest(); }

    void OnSuccessResponse_4(uint8_t returnValue) { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeBooleanDefaultValue_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_5,
                                                                                                      OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanTrue_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        bool booleanArgument;
        booleanArgument = 1;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanTrue_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_7,
                                                                                                      OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 1));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBooleanFalse_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        bool booleanArgument;
        booleanArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(
            booleanArgument, this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8() { NextTest(); }

    CHIP_ERROR TestReadAttributeBooleanFalse_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Boolean::TypeInfo>(this, OnSuccessCallback_9,
                                                                                                      OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(bool boolean)
    {
        VerifyOrReturn(CheckValue<bool>("boolean", boolean, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap8DefaultValue_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_10,
                                                                                                      OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MaxValue_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MaxValue_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_12,
                                                                                                      OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap8MinValue_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t bitmap8Argument;
        bitmap8Argument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(
            bitmap8Argument, this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap8MinValue_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap8::TypeInfo>(this, OnSuccessCallback_14,
                                                                                                      OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t bitmap8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("bitmap8", bitmap8, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap16DefaultValue_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_15,
                                                                                                       OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MaxValue_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MaxValue_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_17,
                                                                                                       OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap16MinValue_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t bitmap16Argument;
        bitmap16Argument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(
            bitmap16Argument, this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap16MinValue_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap16::TypeInfo>(this, OnSuccessCallback_19,
                                                                                                       OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_19(uint16_t bitmap16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("bitmap16", bitmap16, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap32DefaultValue_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_20,
                                                                                                       OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MaxValue_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MaxValue_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_22,
                                                                                                       OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap32MinValue_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint32_t bitmap32Argument;
        bitmap32Argument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(
            bitmap32Argument, this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap32MinValue_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap32::TypeInfo>(this, OnSuccessCallback_24,
                                                                                                       OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(uint32_t bitmap32)
    {
        VerifyOrReturn(CheckValue<uint32_t>("bitmap32", bitmap32, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeBitmap64DefaultValue_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_25,
                                                                                                       OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_25(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MaxValue_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MaxValue_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_27,
                                                                                                       OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeBitmap64MinValue_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint64_t bitmap64Argument;
        bitmap64Argument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(
            bitmap64Argument, this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28() { NextTest(); }

    CHIP_ERROR TestReadAttributeBitmap64MinValue_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Bitmap64::TypeInfo>(this, OnSuccessCallback_29,
                                                                                                       OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29(uint64_t bitmap64)
    {
        VerifyOrReturn(CheckValue<uint64_t>("bitmap64", bitmap64, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8uDefaultValue_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_30,
                                                                                                    OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMaxValue_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t int8uArgument;
        int8uArgument = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_31() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMaxValue_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_32,
                                                                                                    OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8uMinValue_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t int8uArgument;
        int8uArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(
            int8uArgument, this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8uMinValue_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8u::TypeInfo>(this, OnSuccessCallback_34,
                                                                                                    OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(uint8_t int8u)
    {
        VerifyOrReturn(CheckValue<uint8_t>("int8u", int8u, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16uDefaultValue_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_35,
                                                                                                     OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMaxValue_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t int16uArgument;
        int16uArgument = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMaxValue_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_37,
                                                                                                     OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_37(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16uMinValue_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t int16uArgument;
        int16uArgument = 0U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(
            int16uArgument, this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16uMinValue_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16u::TypeInfo>(this, OnSuccessCallback_39,
                                                                                                     OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39(uint16_t int16u)
    {
        VerifyOrReturn(CheckValue<uint16_t>("int16u", int16u, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uDefaultValue_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_40,
                                                                                                     OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMaxValue_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint32_t int32uArgument;
        int32uArgument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMaxValue_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_42,
                                                                                                     OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32uMinValue_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint32_t int32uArgument;
        int32uArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_43() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uMinValue_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_44,
                                                                                                     OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(uint32_t int32u)
    {
        VerifyOrReturn(CheckValue<uint32_t>("int32u", int32u, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64uDefaultValue_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_45,
                                                                                                     OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMaxValue_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint64_t int64uArgument;
        int64uArgument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_46, OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMaxValue_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_47,
                                                                                                     OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64uMinValue_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint64_t int64uArgument;
        int64uArgument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(
            int64uArgument, this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64uMinValue_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64u::TypeInfo>(this, OnSuccessCallback_49,
                                                                                                     OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_49(uint64_t int64u)
    {
        VerifyOrReturn(CheckValue<uint64_t>("int64u", int64u, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_50,
                                                                                                    OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMaxValue_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int8_t int8sArgument;
        int8sArgument = 127;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_51, OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMaxValue_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_52,
                                                                                                    OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 127));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sMinValue_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int8_t int8sArgument;
        int8sArgument = -128;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_53, OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sMinValue_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_54,
                                                                                                    OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, -128));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt8sDefaultValue_55()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int8_t int8sArgument;
        int8sArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(
            int8sArgument, this, OnSuccessCallback_55, OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_55() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt8sDefaultValue_56()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int8s::TypeInfo>(this, OnSuccessCallback_56,
                                                                                                    OnFailureCallback_56);
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(int8_t int8s)
    {
        VerifyOrReturn(CheckValue<int8_t>("int8s", int8s, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_57()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_57,
                                                                                                     OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_57(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMaxValue_58()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t int16sArgument;
        int16sArgument = 32767;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_58, OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMaxValue_59()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_59,
                                                                                                     OnFailureCallback_59);
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 32767));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sMinValue_60()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t int16sArgument;
        int16sArgument = -32768;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_60, OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_60() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sMinValue_61()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_61,
                                                                                                     OnFailureCallback_61);
    }

    void OnFailureResponse_61(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_61(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, -32768));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt16sDefaultValue_62()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int16_t int16sArgument;
        int16sArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(
            int16sArgument, this, OnSuccessCallback_62, OnFailureCallback_62);
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt16sDefaultValue_63()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int16s::TypeInfo>(this, OnSuccessCallback_63,
                                                                                                     OnFailureCallback_63);
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63(int16_t int16s)
    {
        VerifyOrReturn(CheckValue<int16_t>("int16s", int16s, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_64()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_64,
                                                                                                     OnFailureCallback_64);
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 0L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMaxValue_65()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int32_t int32sArgument;
        int32sArgument = 2147483647L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_65, OnFailureCallback_65);
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMaxValue_66()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_66,
                                                                                                     OnFailureCallback_66);
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 2147483647L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sMinValue_67()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int32_t int32sArgument;
        int32sArgument = -2147483648L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_67, OnFailureCallback_67);
    }

    void OnFailureResponse_67(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_67() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sMinValue_68()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_68,
                                                                                                     OnFailureCallback_68);
    }

    void OnFailureResponse_68(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_68(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, -2147483648L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt32sDefaultValue_69()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int32_t int32sArgument;
        int32sArgument = 0L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(
            int32sArgument, this, OnSuccessCallback_69, OnFailureCallback_69);
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32sDefaultValue_70()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32s::TypeInfo>(this, OnSuccessCallback_70,
                                                                                                     OnFailureCallback_70);
    }

    void OnFailureResponse_70(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_70(int32_t int32s)
    {
        VerifyOrReturn(CheckValue<int32_t>("int32s", int32s, 0L));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_71()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_71,
                                                                                                     OnFailureCallback_71);
    }

    void OnFailureResponse_71(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_71(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 0LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMaxValue_72()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int64_t int64sArgument;
        int64sArgument = 9223372036854775807LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_72, OnFailureCallback_72);
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMaxValue_73()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_73,
                                                                                                     OnFailureCallback_73);
    }

    void OnFailureResponse_73(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_73(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sMinValue_74()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int64_t int64sArgument;
        int64sArgument = -9223372036854775807LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_74, OnFailureCallback_74);
    }

    void OnFailureResponse_74(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_74() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sMinValue_75()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_75,
                                                                                                     OnFailureCallback_75);
    }

    void OnFailureResponse_75(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_75(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, -9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeInt64sDefaultValue_76()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        int64_t int64sArgument;
        int64sArgument = 0LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(
            int64sArgument, this, OnSuccessCallback_76, OnFailureCallback_76);
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt64sDefaultValue_77()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int64s::TypeInfo>(this, OnSuccessCallback_77,
                                                                                                     OnFailureCallback_77);
    }

    void OnFailureResponse_77(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_77(int64_t int64s)
    {
        VerifyOrReturn(CheckValue<int64_t>("int64s", int64s, 0LL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum8DefaultValue_78()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_78,
                                                                                                    OnFailureCallback_78);
    }

    void OnFailureResponse_78(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_78(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MaxValue_79()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t enum8Argument;
        enum8Argument = static_cast<uint8_t>(255);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_79, OnFailureCallback_79);
    }

    void OnFailureResponse_79(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_79() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MaxValue_80()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_80,
                                                                                                    OnFailureCallback_80);
    }

    void OnFailureResponse_80(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_80(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 255));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum8MinValue_81()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint8_t enum8Argument;
        enum8Argument = static_cast<uint8_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(
            enum8Argument, this, OnSuccessCallback_81, OnFailureCallback_81);
    }

    void OnFailureResponse_81(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_81() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum8MinValue_82()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum8::TypeInfo>(this, OnSuccessCallback_82,
                                                                                                    OnFailureCallback_82);
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82(uint8_t enum8)
    {
        VerifyOrReturn(CheckValue<uint8_t>("enum8", enum8, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEnum16DefaultValue_83()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_83,
                                                                                                     OnFailureCallback_83);
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MaxValue_84()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t enum16Argument;
        enum16Argument = static_cast<uint16_t>(65535);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_84, OnFailureCallback_84);
    }

    void OnFailureResponse_84(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_84() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MaxValue_85()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_85,
                                                                                                     OnFailureCallback_85);
    }

    void OnFailureResponse_85(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_85(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 65535U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEnum16MinValue_86()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t enum16Argument;
        enum16Argument = static_cast<uint16_t>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(
            enum16Argument, this, OnSuccessCallback_86, OnFailureCallback_86);
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86() { NextTest(); }

    CHIP_ERROR TestReadAttributeEnum16MinValue_87()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Enum16::TypeInfo>(this, OnSuccessCallback_87,
                                                                                                     OnFailureCallback_87);
    }

    void OnFailureResponse_87(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_87(uint16_t enum16)
    {
        VerifyOrReturn(CheckValue<uint16_t>("enum16", enum16, 0U));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeOctetStringDefaultValue_88()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_88, OnFailureCallback_88);
    }

    void OnFailureResponse_88(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_88(chip::ByteSpan octetString)
    {
        VerifyOrReturn(CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetStringWithEmbeddedNull_89()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("Tes\x00ti\x00nggarbage: not in length on purpose"), 9);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_89, OnFailureCallback_89);
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetStringWithEmbeddedNull_90()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_90, OnFailureCallback_90);
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("Tes\x00ti\x00ng"), 9)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_91()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_91, OnFailureCallback_91);
    }

    void OnFailureResponse_91(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_91() { NextTest(); }

    CHIP_ERROR TestReadAttributeOctetString_92()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_92, OnFailureCallback_92);
    }

    void OnFailureResponse_92(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_92(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_93()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValueLongerThan10garbage: not in length on purpose"), 21);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_93, OnFailureCallback_93);
    }

    void OnFailureResponse_93(uint8_t status) { NextTest(); }

    void OnSuccessResponse_93() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeOctetString_94()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            this, OnSuccessCallback_94, OnFailureCallback_94);
    }

    void OnFailureResponse_94(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_94(chip::ByteSpan octetString)
    {
        VerifyOrReturn(
            CheckValueAsString("octetString", octetString, chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeOctetString_95()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::ByteSpan octetStringArgument;
        octetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::OctetString::TypeInfo>(
            octetStringArgument, this, OnSuccessCallback_95, OnFailureCallback_95);
    }

    void OnFailureResponse_95(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_95() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetStringDefaultValue_96()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            this, OnSuccessCallback_96, OnFailureCallback_96);
    }

    void OnFailureResponse_96(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_96(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString("longOctetString", longOctetString, chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_97()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::ByteSpan longOctetStringArgument;
        longOctetStringArgument = chip::ByteSpan(
            chip::Uint8::from_const_char(
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                "111111111111111111111111111111111111111111111111111111111111111111111111garbage: not in length on purpose"),
            300);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            longOctetStringArgument, this, OnSuccessCallback_97, OnFailureCallback_97);
    }

    void OnFailureResponse_97(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_97() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongOctetString_98()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            this, OnSuccessCallback_98, OnFailureCallback_98);
    }

    void OnFailureResponse_98(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_98(chip::ByteSpan longOctetString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longOctetString", longOctetString,
            chip::ByteSpan(
                chip::Uint8::from_const_char(
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
                    "11111111111111111111111111111111111111111111111111111111111111111111111111111111"),
                300)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongOctetString_99()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::ByteSpan longOctetStringArgument;
        longOctetStringArgument = chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongOctetString::TypeInfo>(
            longOctetStringArgument, this, OnSuccessCallback_99, OnFailureCallback_99);
    }

    void OnFailureResponse_99(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_99() { NextTest(); }

    CHIP_ERROR TestReadAttributeCharStringDefaultValue_100()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            this, OnSuccessCallback_100, OnFailureCallback_100);
    }

    void OnFailureResponse_100(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_100(chip::CharSpan charString)
    {
        VerifyOrReturn(CheckValueAsString("charString", charString, chip::CharSpan("", 0)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeCharString_101()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("Tgarbage: not in length on purpose", 3);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_101, OnFailureCallback_101);
    }

    void OnFailureResponse_101(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_101() { NextTest(); }

    CHIP_ERROR TestWriteAttributeCharStringValueTooLong_102()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("TestValueLongerThan10garbage: not in length on purpose", 23);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_102, OnFailureCallback_102);
    }

    void OnFailureResponse_102(uint8_t status) { NextTest(); }

    void OnSuccessResponse_102() { ThrowSuccessResponse(); }

    CHIP_ERROR TestWriteAttributeCharStringEmpty_103()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::CharSpan charStringArgument;
        charStringArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::CharString::TypeInfo>(
            charStringArgument, this, OnSuccessCallback_103, OnFailureCallback_103);
    }

    void OnFailureResponse_103(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_103() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharStringDefaultValue_104()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            this, OnSuccessCallback_104, OnFailureCallback_104);
    }

    void OnFailureResponse_104(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_104(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString("longCharString", longCharString, chip::CharSpan("", 0)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_105()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::CharSpan longCharStringArgument;
        longCharStringArgument = chip::Span<const char>(
            ""
            ""
            "garbage: not in length on purpose",
            300);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            longCharStringArgument, this, OnSuccessCallback_105, OnFailureCallback_105);
    }

    void OnFailureResponse_105(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_105() { NextTest(); }

    CHIP_ERROR TestReadAttributeLongCharString_106()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            this, OnSuccessCallback_106, OnFailureCallback_106);
    }

    void OnFailureResponse_106(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_106(chip::CharSpan longCharString)
    {
        VerifyOrReturn(CheckValueAsString(
            "longCharString", longCharString,
            chip::CharSpan(""
                           ""
                           "",
                           300)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeLongCharString_107()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::CharSpan longCharStringArgument;
        longCharStringArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::LongCharString::TypeInfo>(
            longCharStringArgument, this, OnSuccessCallback_107, OnFailureCallback_107);
    }

    void OnFailureResponse_107(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_107() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsDefaultValue_108()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_108,
                                                                                                      OnFailureCallback_108);
    }

    void OnFailureResponse_108(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_108(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMaxValue_109()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_109, OnFailureCallback_109);
    }

    void OnFailureResponse_109(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_109() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMaxValue_110()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_110,
                                                                                                      OnFailureCallback_110);
    }

    void OnFailureResponse_110(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_110(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 18446744073709551615ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochUsMinValue_111()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint64_t epochUsArgument;
        epochUsArgument = 0ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(
            epochUsArgument, this, OnSuccessCallback_111, OnFailureCallback_111);
    }

    void OnFailureResponse_111(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_111() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochUsMinValue_112()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochUs::TypeInfo>(this, OnSuccessCallback_112,
                                                                                                      OnFailureCallback_112);
    }

    void OnFailureResponse_112(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_112(uint64_t epochUs)
    {
        VerifyOrReturn(CheckValue<uint64_t>("epochUs", epochUs, 0ULL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeEpochSDefaultValue_113()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_113,
                                                                                                     OnFailureCallback_113);
    }

    void OnFailureResponse_113(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_113(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 0UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMaxValue_114()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint32_t epochSArgument;
        epochSArgument = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_114, OnFailureCallback_114);
    }

    void OnFailureResponse_114(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_114() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMaxValue_115()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_115,
                                                                                                     OnFailureCallback_115);
    }

    void OnFailureResponse_115(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_115(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 4294967295UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeEpochSMinValue_116()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint32_t epochSArgument;
        epochSArgument = 0UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(
            epochSArgument, this, OnSuccessCallback_116, OnFailureCallback_116);
    }

    void OnFailureResponse_116(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_116() { NextTest(); }

    CHIP_ERROR TestReadAttributeEpochSMinValue_117()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::EpochS::TypeInfo>(this, OnSuccessCallback_117,
                                                                                                     OnFailureCallback_117);
    }

    void OnFailureResponse_117(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_117(uint32_t epochS)
    {
        VerifyOrReturn(CheckValue<uint32_t>("epochS", epochS, 0UL));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeUnsupported_118()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo>(
            this, OnSuccessCallback_118, OnFailureCallback_118);
    }

    void OnFailureResponse_118(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_118(bool unsupported)
    {
        VerifyOrReturn(CheckValue<bool>("unsupported", unsupported, 0));
        NextTest();
    }

    CHIP_ERROR TestWriteattributeUnsupported_119()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        bool unsupportedArgument;
        unsupportedArgument = 0;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Unsupported::TypeInfo>(
            unsupportedArgument, this, OnSuccessCallback_119, OnFailureCallback_119);
    }

    void OnFailureResponse_119(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_119() { NextTest(); }

    CHIP_ERROR TestSendTestCommandToUnsupportedEndpoint_120()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 200;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::Test::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_120();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_120(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_120(uint8_t status) { NextTest(); }

    void OnSuccessResponse_120() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeVendorIdDefaultValue_121()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(this, OnSuccessCallback_121,
                                                                                                       OnFailureCallback_121);
    }

    void OnFailureResponse_121(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_121(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue<chip::VendorId>("vendorId", vendorId, 0U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeVendorId_122()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(17);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_122, OnFailureCallback_122);
    }

    void OnFailureResponse_122(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_122() { NextTest(); }

    CHIP_ERROR TestReadAttributeVendorId_123()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(this, OnSuccessCallback_123,
                                                                                                       OnFailureCallback_123);
    }

    void OnFailureResponse_123(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_123(chip::VendorId vendorId)
    {
        VerifyOrReturn(CheckValue<chip::VendorId>("vendorId", vendorId, 17U));
        NextTest();
    }

    CHIP_ERROR TestRestoreAttributeVendorId_124()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::VendorId vendorIdArgument;
        vendorIdArgument = static_cast<chip::VendorId>(0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::VendorId::TypeInfo>(
            vendorIdArgument, this, OnSuccessCallback_124, OnFailureCallback_124);
    }

    void OnFailureResponse_124(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_124() { NextTest(); }

    CHIP_ERROR TestSendACommandWithAVendorIdAndEnum_125()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestEnumsRequest::Type;

        RequestType request;
        request.arg1 = static_cast<chip::VendorId>(20003);
        request.arg2 = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(101);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_125(data.arg1, data.arg2);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_125(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_125(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_125(chip::VendorId arg1, chip::app::Clusters::TestCluster::SimpleEnum arg2)
    {
        VerifyOrReturn(CheckValue<chip::VendorId>("arg1", arg1, 20003U));

        VerifyOrReturn(CheckValue<uint8_t>("arg2", arg2, 101));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsTrue_126()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = true;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_126(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_126(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_126(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_126(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, true));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithStructArgumentAndArg1bIsFalse_127()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestStructArgumentRequest::Type;

        RequestType request;

        request.arg1.a = 0;
        request.arg1.b = false;
        request.arg1.c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        request.arg1.d = chip::ByteSpan(chip::Uint8::from_const_char("octet_stringgarbage: not in length on purpose"), 12);
        request.arg1.e = chip::Span<const char>("char_stringgarbage: not in length on purpose", 11);
        request.arg1.f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_127(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_127(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_127(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_127(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, false));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndNoneOfThemIsSetTo0_128()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;

        RequestType request;

        uint8_t arg1List[9];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_128(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_128(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_128(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_128(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, true));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndOneOfThemIsSetTo0_129()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UArgumentRequest::Type;

        RequestType request;

        uint8_t arg1List[10];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        arg1List[9]  = 0;
        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_129(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_129(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_129(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_129(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, false));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfInt8uAndGetItReversed_130()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;

        RequestType request;

        uint8_t arg1List[9];
        arg1List[0]  = 1;
        arg1List[1]  = 2;
        arg1List[2]  = 3;
        arg1List[3]  = 4;
        arg1List[4]  = 5;
        arg1List[5]  = 6;
        arg1List[6]  = 7;
        arg1List[7]  = 8;
        arg1List[8]  = 9;
        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_130(data.arg1);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_130(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_130(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_130(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        auto iter = arg1.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 0));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[0]", iter.GetValue(), 9));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 1));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[1]", iter.GetValue(), 8));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 2));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[2]", iter.GetValue(), 7));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 3));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[3]", iter.GetValue(), 6));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 4));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[4]", iter.GetValue(), 5));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 5));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[5]", iter.GetValue(), 4));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 6));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[6]", iter.GetValue(), 3));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 7));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[7]", iter.GetValue(), 2));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(arg1)>("arg1", iter, 8));
        VerifyOrReturn(CheckValue<uint8_t>("arg1[8]", iter.GetValue(), 1));
        VerifyOrReturn(CheckNoMoreListItems<decltype(arg1)>("arg1", iter, 9));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithEmptyListOfInt8uAndGetAnEmptyListBack_131()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListInt8UReverseRequest::Type;

        RequestType request;

        request.arg1 = chip::app::DataModel::List<uint8_t>();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_131(data.arg1);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_131(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_131(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_131(const chip::app::DataModel::DecodableList<uint8_t> & arg1)
    {
        auto iter = arg1.begin();
        VerifyOrReturn(CheckNoMoreListItems<decltype(arg1)>("arg1", iter, 0));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsTrue_132()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;

        RequestType request;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type arg1List[2];

        arg1List[0].a = 0;
        arg1List[0].b = true;
        arg1List[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[0].d = chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
        arg1List[0].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
        arg1List[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        arg1List[1].a = 1;
        arg1List[1].b = true;
        arg1List[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        arg1List[1].d = chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
        arg1List[1].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
        arg1List[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_132(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_132(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_132(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_132(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, true));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithListOfStructArgumentAndArg1bOfFirstItemIsFalse_133()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestListStructArgumentRequest::Type;

        RequestType request;

        chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type arg1List[2];

        arg1List[0].a = 1;
        arg1List[0].b = true;
        arg1List[0].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(3);
        arg1List[0].d = chip::ByteSpan(chip::Uint8::from_const_char("second_octet_stringgarbage: not in length on purpose"), 19);
        arg1List[0].e = chip::Span<const char>("second_char_stringgarbage: not in length on purpose", 18);
        arg1List[0].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        arg1List[1].a = 0;
        arg1List[1].b = false;
        arg1List[1].c = static_cast<chip::app::Clusters::TestCluster::SimpleEnum>(2);
        arg1List[1].d = chip::ByteSpan(chip::Uint8::from_const_char("first_octet_stringgarbage: not in length on purpose"), 18);
        arg1List[1].e = chip::Span<const char>("first_char_stringgarbage: not in length on purpose", 17);
        arg1List[1].f = static_cast<chip::BitFlags<chip::app::Clusters::TestCluster::SimpleBitmap>>(1);

        request.arg1 = arg1List;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))->OnSuccessResponse_133(data.value);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_133(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_133(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_133(bool value)
    {
        VerifyOrReturn(CheckValue<bool>("value", value, false));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithOptionalArgSet_134()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;
        request.arg1.Emplace().SetNonNull() = 5;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))
                ->OnSuccessResponse_134(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_134(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_134(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_134(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                               const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue<bool>("wasPresent", wasPresent, true));

        VerifyOrReturn(CheckValuePresent("wasNull", wasNull));
        VerifyOrReturn(CheckValue<bool>("wasNull.Value()", wasNull.Value(), false));

        VerifyOrReturn(CheckValuePresent("value", value));
        VerifyOrReturn(CheckValue<uint8_t>("value.Value()", value.Value(), 5));

        VerifyOrReturn(CheckValuePresent("originalValue", originalValue));
        VerifyOrReturn(CheckValueNonNull("originalValue.Value()", originalValue.Value()));
        VerifyOrReturn(CheckValue<uint8_t>("originalValue.Value().Value()", originalValue.Value().Value(), 5));
        NextTest();
    }

    CHIP_ERROR TestSendTestCommandWithoutItsOptionalArg_135()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestCluster *>(context))
                ->OnSuccessResponse_135(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestCluster *>(context))->OnFailureResponse_135(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_135(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_135(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                               const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue<bool>("wasPresent", wasPresent, false));

        NextTest();
    }
};

class TestClusterComplexTypes : public TestCommand
{
public:
    TestClusterComplexTypes() : TestCommand("TestClusterComplexTypes"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestClusterComplexTypes\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestClusterComplexTypes\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Test Command with optional arg set to null.\n");
            err = TestSendTestCommandWithOptionalArgSetToNull_0();
            break;
        case 1:
            ChipLogProgress(chipTool,
                            " ***** Test Step 1 : Write attribute LIST With List of INT8U and none of them is set to 0\n");
            err = TestWriteAttributeListWithListOfInt8uAndNoneOfThemIsSetTo0_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute LIST With List of INT8U\n");
            err = TestReadAttributeListWithListOfInt8u_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Write attribute LIST With List of OCTET_STRING\n");
            err = TestWriteAttributeListWithListOfOctetString_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read attribute LIST With List of OCTET_STRING\n");
            err = TestReadAttributeListWithListOfOctetString_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Write attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            err = TestWriteAttributeListWithListOfListStructOctetString_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Read attribute LIST With List of LIST_STRUCT_OCTET_STRING\n");
            err = TestReadAttributeListWithListOfListStructOctetString_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Write attribute NULLABLE_BOOLEAN null\n");
            err = TestWriteAttributeNullableBooleanNull_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Read attribute NULLABLE_BOOLEAN null\n");
            err = TestReadAttributeNullableBooleanNull_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : Write attribute NULLABLE_BOOLEAN True\n");
            err = TestWriteAttributeNullableBooleanTrue_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : Read attribute NULLABLE_BOOLEAN True\n");
            err = TestReadAttributeNullableBooleanTrue_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Write attribute NULLABLE_BITMAP8 Max Value\n");
            err = TestWriteAttributeNullableBitmap8MaxValue_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : Read attribute NULLABLE_BITMAP8 Max Value\n");
            err = TestReadAttributeNullableBitmap8MaxValue_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : Write attribute NULLABLE_BITMAP8 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap8InvalidValue_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : Read attribute NULLABLE_BITMAP8 unchanged Value\n");
            err = TestReadAttributeNullableBitmap8UnchangedValue_14();
            break;
        case 15:
            ChipLogProgress(chipTool, " ***** Test Step 15 : Write attribute NULLABLE_BITMAP8 null Value\n");
            err = TestWriteAttributeNullableBitmap8NullValue_15();
            break;
        case 16:
            ChipLogProgress(chipTool, " ***** Test Step 16 : Read attribute NULLABLE_BITMAP8 null Value\n");
            err = TestReadAttributeNullableBitmap8NullValue_16();
            break;
        case 17:
            ChipLogProgress(chipTool, " ***** Test Step 17 : Write attribute NULLABLE_BITMAP16 Max Value\n");
            err = TestWriteAttributeNullableBitmap16MaxValue_17();
            break;
        case 18:
            ChipLogProgress(chipTool, " ***** Test Step 18 : Read attribute NULLABLE_BITMAP16 Max Value\n");
            err = TestReadAttributeNullableBitmap16MaxValue_18();
            break;
        case 19:
            ChipLogProgress(chipTool, " ***** Test Step 19 : Write attribute NULLABLE_BITMAP16 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap16InvalidValue_19();
            break;
        case 20:
            ChipLogProgress(chipTool, " ***** Test Step 20 : Read attribute NULLABLE_BITMAP16 unchanged Value\n");
            err = TestReadAttributeNullableBitmap16UnchangedValue_20();
            break;
        case 21:
            ChipLogProgress(chipTool, " ***** Test Step 21 : Write attribute NULLABLE_BITMAP16 null Value\n");
            err = TestWriteAttributeNullableBitmap16NullValue_21();
            break;
        case 22:
            ChipLogProgress(chipTool, " ***** Test Step 22 : Read attribute NULLABLE_BITMAP16 null Value\n");
            err = TestReadAttributeNullableBitmap16NullValue_22();
            break;
        case 23:
            ChipLogProgress(chipTool, " ***** Test Step 23 : Write attribute NULLABLE_BITMAP32 Max Value\n");
            err = TestWriteAttributeNullableBitmap32MaxValue_23();
            break;
        case 24:
            ChipLogProgress(chipTool, " ***** Test Step 24 : Read attribute NULLABLE_BITMAP32 Max Value\n");
            err = TestReadAttributeNullableBitmap32MaxValue_24();
            break;
        case 25:
            ChipLogProgress(chipTool, " ***** Test Step 25 : Write attribute NULLABLE_BITMAP32 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap32InvalidValue_25();
            break;
        case 26:
            ChipLogProgress(chipTool, " ***** Test Step 26 : Read attribute NULLABLE_BITMAP32 unchanged Value\n");
            err = TestReadAttributeNullableBitmap32UnchangedValue_26();
            break;
        case 27:
            ChipLogProgress(chipTool, " ***** Test Step 27 : Write attribute NULLABLE_BITMAP32 null Value\n");
            err = TestWriteAttributeNullableBitmap32NullValue_27();
            break;
        case 28:
            ChipLogProgress(chipTool, " ***** Test Step 28 : Read attribute NULLABLE_BITMAP32 null Value\n");
            err = TestReadAttributeNullableBitmap32NullValue_28();
            break;
        case 29:
            ChipLogProgress(chipTool, " ***** Test Step 29 : Write attribute NULLABLE_BITMAP64 Max Value\n");
            err = TestWriteAttributeNullableBitmap64MaxValue_29();
            break;
        case 30:
            ChipLogProgress(chipTool, " ***** Test Step 30 : Read attribute NULLABLE_BITMAP64 Max Value\n");
            err = TestReadAttributeNullableBitmap64MaxValue_30();
            break;
        case 31:
            ChipLogProgress(chipTool, " ***** Test Step 31 : Write attribute NULLABLE_BITMAP64 Invalid Value\n");
            err = TestWriteAttributeNullableBitmap64InvalidValue_31();
            break;
        case 32:
            ChipLogProgress(chipTool, " ***** Test Step 32 : Read attribute NULLABLE_BITMAP64 unchanged Value\n");
            err = TestReadAttributeNullableBitmap64UnchangedValue_32();
            break;
        case 33:
            ChipLogProgress(chipTool, " ***** Test Step 33 : Write attribute NULLABLE_BITMAP64 null Value\n");
            err = TestWriteAttributeNullableBitmap64NullValue_33();
            break;
        case 34:
            ChipLogProgress(chipTool, " ***** Test Step 34 : Read attribute NULLABLE_BITMAP64 null Value\n");
            err = TestReadAttributeNullableBitmap64NullValue_34();
            break;
        case 35:
            ChipLogProgress(chipTool, " ***** Test Step 35 : Write attribute NULLABLE_INT8U Max Value\n");
            err = TestWriteAttributeNullableInt8uMaxValue_35();
            break;
        case 36:
            ChipLogProgress(chipTool, " ***** Test Step 36 : Read attribute NULLABLE_INT8U Max Value\n");
            err = TestReadAttributeNullableInt8uMaxValue_36();
            break;
        case 37:
            ChipLogProgress(chipTool, " ***** Test Step 37 : Write attribute NULLABLE_INT8U Invalid Value\n");
            err = TestWriteAttributeNullableInt8uInvalidValue_37();
            break;
        case 38:
            ChipLogProgress(chipTool, " ***** Test Step 38 : Read attribute NULLABLE_INT8U unchanged Value\n");
            err = TestReadAttributeNullableInt8uUnchangedValue_38();
            break;
        case 39:
            ChipLogProgress(chipTool, " ***** Test Step 39 : Write attribute NULLABLE_INT8U null Value\n");
            err = TestWriteAttributeNullableInt8uNullValue_39();
            break;
        case 40:
            ChipLogProgress(chipTool, " ***** Test Step 40 : Read attribute NULLABLE_INT8U null Value\n");
            err = TestReadAttributeNullableInt8uNullValue_40();
            break;
        case 41:
            ChipLogProgress(chipTool, " ***** Test Step 41 : Write attribute NULLABLE_INT16U Max Value\n");
            err = TestWriteAttributeNullableInt16uMaxValue_41();
            break;
        case 42:
            ChipLogProgress(chipTool, " ***** Test Step 42 : Read attribute NULLABLE_INT16U Max Value\n");
            err = TestReadAttributeNullableInt16uMaxValue_42();
            break;
        case 43:
            ChipLogProgress(chipTool, " ***** Test Step 43 : Write attribute NULLABLE_INT16U Invalid Value\n");
            err = TestWriteAttributeNullableInt16uInvalidValue_43();
            break;
        case 44:
            ChipLogProgress(chipTool, " ***** Test Step 44 : Read attribute NULLABLE_INT16U unchanged Value\n");
            err = TestReadAttributeNullableInt16uUnchangedValue_44();
            break;
        case 45:
            ChipLogProgress(chipTool, " ***** Test Step 45 : Write attribute NULLABLE_INT16U null Value\n");
            err = TestWriteAttributeNullableInt16uNullValue_45();
            break;
        case 46:
            ChipLogProgress(chipTool, " ***** Test Step 46 : Read attribute NULLABLE_INT16U null Value\n");
            err = TestReadAttributeNullableInt16uNullValue_46();
            break;
        case 47:
            ChipLogProgress(chipTool, " ***** Test Step 47 : Write attribute NULLABLE_INT32U Max Value\n");
            err = TestWriteAttributeNullableInt32uMaxValue_47();
            break;
        case 48:
            ChipLogProgress(chipTool, " ***** Test Step 48 : Read attribute NULLABLE_INT32U Max Value\n");
            err = TestReadAttributeNullableInt32uMaxValue_48();
            break;
        case 49:
            ChipLogProgress(chipTool, " ***** Test Step 49 : Write attribute NULLABLE_INT32U Invalid Value\n");
            err = TestWriteAttributeNullableInt32uInvalidValue_49();
            break;
        case 50:
            ChipLogProgress(chipTool, " ***** Test Step 50 : Read attribute NULLABLE_INT32U unchanged Value\n");
            err = TestReadAttributeNullableInt32uUnchangedValue_50();
            break;
        case 51:
            ChipLogProgress(chipTool, " ***** Test Step 51 : Write attribute NULLABLE_INT32U null Value\n");
            err = TestWriteAttributeNullableInt32uNullValue_51();
            break;
        case 52:
            ChipLogProgress(chipTool, " ***** Test Step 52 : Read attribute NULLABLE_INT32U null Value\n");
            err = TestReadAttributeNullableInt32uNullValue_52();
            break;
        case 53:
            ChipLogProgress(chipTool, " ***** Test Step 53 : Write attribute NULLABLE_INT64U Max Value\n");
            err = TestWriteAttributeNullableInt64uMaxValue_53();
            break;
        case 54:
            ChipLogProgress(chipTool, " ***** Test Step 54 : Read attribute NULLABLE_INT64U Max Value\n");
            err = TestReadAttributeNullableInt64uMaxValue_54();
            break;
        case 55:
            ChipLogProgress(chipTool, " ***** Test Step 55 : Write attribute NULLABLE_INT64U Invalid Value\n");
            err = TestWriteAttributeNullableInt64uInvalidValue_55();
            break;
        case 56:
            ChipLogProgress(chipTool, " ***** Test Step 56 : Read attribute NULLABLE_INT64U unchanged Value\n");
            err = TestReadAttributeNullableInt64uUnchangedValue_56();
            break;
        case 57:
            ChipLogProgress(chipTool, " ***** Test Step 57 : Write attribute NULLABLE_INT64U null Value\n");
            err = TestWriteAttributeNullableInt64uNullValue_57();
            break;
        case 58:
            ChipLogProgress(chipTool, " ***** Test Step 58 : Read attribute NULLABLE_INT64U null Value\n");
            err = TestReadAttributeNullableInt64uNullValue_58();
            break;
        case 59:
            ChipLogProgress(chipTool, " ***** Test Step 59 : Write attribute NULLABLE_INT8S Min Value\n");
            err = TestWriteAttributeNullableInt8sMinValue_59();
            break;
        case 60:
            ChipLogProgress(chipTool, " ***** Test Step 60 : Read attribute NULLABLE_INT8S Min Value\n");
            err = TestReadAttributeNullableInt8sMinValue_60();
            break;
        case 61:
            ChipLogProgress(chipTool, " ***** Test Step 61 : Write attribute NULLABLE_INT8S Invalid Value\n");
            err = TestWriteAttributeNullableInt8sInvalidValue_61();
            break;
        case 62:
            ChipLogProgress(chipTool, " ***** Test Step 62 : Read attribute NULLABLE_INT8S unchanged Value\n");
            err = TestReadAttributeNullableInt8sUnchangedValue_62();
            break;
        case 63:
            ChipLogProgress(chipTool, " ***** Test Step 63 : Write attribute NULLABLE_INT8S null Value\n");
            err = TestWriteAttributeNullableInt8sNullValue_63();
            break;
        case 64:
            ChipLogProgress(chipTool, " ***** Test Step 64 : Read attribute NULLABLE_INT8S null Value\n");
            err = TestReadAttributeNullableInt8sNullValue_64();
            break;
        case 65:
            ChipLogProgress(chipTool, " ***** Test Step 65 : Write attribute NULLABLE_INT16S Min Value\n");
            err = TestWriteAttributeNullableInt16sMinValue_65();
            break;
        case 66:
            ChipLogProgress(chipTool, " ***** Test Step 66 : Read attribute NULLABLE_INT16S Min Value\n");
            err = TestReadAttributeNullableInt16sMinValue_66();
            break;
        case 67:
            ChipLogProgress(chipTool, " ***** Test Step 67 : Write attribute NULLABLE_INT16S Invalid Value\n");
            err = TestWriteAttributeNullableInt16sInvalidValue_67();
            break;
        case 68:
            ChipLogProgress(chipTool, " ***** Test Step 68 : Read attribute NULLABLE_INT16S unchanged Value\n");
            err = TestReadAttributeNullableInt16sUnchangedValue_68();
            break;
        case 69:
            ChipLogProgress(chipTool, " ***** Test Step 69 : Write attribute NULLABLE_INT16S null Value\n");
            err = TestWriteAttributeNullableInt16sNullValue_69();
            break;
        case 70:
            ChipLogProgress(chipTool, " ***** Test Step 70 : Read attribute NULLABLE_INT16S null Value\n");
            err = TestReadAttributeNullableInt16sNullValue_70();
            break;
        case 71:
            ChipLogProgress(chipTool, " ***** Test Step 71 : Write attribute NULLABLE_INT32S Min Value\n");
            err = TestWriteAttributeNullableInt32sMinValue_71();
            break;
        case 72:
            ChipLogProgress(chipTool, " ***** Test Step 72 : Read attribute NULLABLE_INT32S Min Value\n");
            err = TestReadAttributeNullableInt32sMinValue_72();
            break;
        case 73:
            ChipLogProgress(chipTool, " ***** Test Step 73 : Write attribute NULLABLE_INT32S Invalid Value\n");
            err = TestWriteAttributeNullableInt32sInvalidValue_73();
            break;
        case 74:
            ChipLogProgress(chipTool, " ***** Test Step 74 : Read attribute NULLABLE_INT32S unchanged Value\n");
            err = TestReadAttributeNullableInt32sUnchangedValue_74();
            break;
        case 75:
            ChipLogProgress(chipTool, " ***** Test Step 75 : Write attribute NULLABLE_INT32S null Value\n");
            err = TestWriteAttributeNullableInt32sNullValue_75();
            break;
        case 76:
            ChipLogProgress(chipTool, " ***** Test Step 76 : Read attribute NULLABLE_INT32S null Value\n");
            err = TestReadAttributeNullableInt32sNullValue_76();
            break;
        case 77:
            ChipLogProgress(chipTool, " ***** Test Step 77 : Write attribute NULLABLE_INT64S Min Value\n");
            err = TestWriteAttributeNullableInt64sMinValue_77();
            break;
        case 78:
            ChipLogProgress(chipTool, " ***** Test Step 78 : Read attribute NULLABLE_INT64S Min Value\n");
            err = TestReadAttributeNullableInt64sMinValue_78();
            break;
        case 79:
            ChipLogProgress(chipTool, " ***** Test Step 79 : Write attribute NULLABLE_INT64S Invalid Value\n");
            err = TestWriteAttributeNullableInt64sInvalidValue_79();
            break;
        case 80:
            ChipLogProgress(chipTool, " ***** Test Step 80 : Read attribute NULLABLE_INT64S unchanged Value\n");
            err = TestReadAttributeNullableInt64sUnchangedValue_80();
            break;
        case 81:
            ChipLogProgress(chipTool, " ***** Test Step 81 : Write attribute NULLABLE_INT64S null Value\n");
            err = TestWriteAttributeNullableInt64sNullValue_81();
            break;
        case 82:
            ChipLogProgress(chipTool, " ***** Test Step 82 : Read attribute NULLABLE_INT64S null Value\n");
            err = TestReadAttributeNullableInt64sNullValue_82();
            break;
        case 83:
            ChipLogProgress(chipTool, " ***** Test Step 83 : Write attribute NULLABLE_ENUM8 Max Value\n");
            err = TestWriteAttributeNullableEnum8MaxValue_83();
            break;
        case 84:
            ChipLogProgress(chipTool, " ***** Test Step 84 : Read attribute NULLABLE_ENUM8 Max Value\n");
            err = TestReadAttributeNullableEnum8MaxValue_84();
            break;
        case 85:
            ChipLogProgress(chipTool, " ***** Test Step 85 : Write attribute NULLABLE_ENUM8 Invalid Value\n");
            err = TestWriteAttributeNullableEnum8InvalidValue_85();
            break;
        case 86:
            ChipLogProgress(chipTool, " ***** Test Step 86 : Read attribute NULLABLE_ENUM8 unchanged Value\n");
            err = TestReadAttributeNullableEnum8UnchangedValue_86();
            break;
        case 87:
            ChipLogProgress(chipTool, " ***** Test Step 87 : Write attribute NULLABLE_ENUM8 null Value\n");
            err = TestWriteAttributeNullableEnum8NullValue_87();
            break;
        case 88:
            ChipLogProgress(chipTool, " ***** Test Step 88 : Read attribute NULLABLE_ENUM8 null Value\n");
            err = TestReadAttributeNullableEnum8NullValue_88();
            break;
        case 89:
            ChipLogProgress(chipTool, " ***** Test Step 89 : Write attribute NULLABLE_ENUM16 Max Value\n");
            err = TestWriteAttributeNullableEnum16MaxValue_89();
            break;
        case 90:
            ChipLogProgress(chipTool, " ***** Test Step 90 : Read attribute NULLABLE_ENUM16 Max Value\n");
            err = TestReadAttributeNullableEnum16MaxValue_90();
            break;
        case 91:
            ChipLogProgress(chipTool, " ***** Test Step 91 : Write attribute NULLABLE_ENUM16 Invalid Value\n");
            err = TestWriteAttributeNullableEnum16InvalidValue_91();
            break;
        case 92:
            ChipLogProgress(chipTool, " ***** Test Step 92 : Read attribute NULLABLE_ENUM16 unchanged Value\n");
            err = TestReadAttributeNullableEnum16UnchangedValue_92();
            break;
        case 93:
            ChipLogProgress(chipTool, " ***** Test Step 93 : Write attribute NULLABLE_ENUM16 null Value\n");
            err = TestWriteAttributeNullableEnum16NullValue_93();
            break;
        case 94:
            ChipLogProgress(chipTool, " ***** Test Step 94 : Read attribute NULLABLE_ENUM16 null Value\n");
            err = TestReadAttributeNullableEnum16NullValue_94();
            break;
        case 95:
            ChipLogProgress(chipTool, " ***** Test Step 95 : Read attribute NULLABLE_OCTET_STRING Default Value\n");
            err = TestReadAttributeNullableOctetStringDefaultValue_95();
            break;
        case 96:
            ChipLogProgress(chipTool, " ***** Test Step 96 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_96();
            break;
        case 97:
            ChipLogProgress(chipTool, " ***** Test Step 97 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_97();
            break;
        case 98:
            ChipLogProgress(chipTool, " ***** Test Step 98 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_98();
            break;
        case 99:
            ChipLogProgress(chipTool, " ***** Test Step 99 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_99();
            break;
        case 100:
            ChipLogProgress(chipTool, " ***** Test Step 100 : Write attribute NULLABLE_OCTET_STRING\n");
            err = TestWriteAttributeNullableOctetString_100();
            break;
        case 101:
            ChipLogProgress(chipTool, " ***** Test Step 101 : Read attribute NULLABLE_OCTET_STRING\n");
            err = TestReadAttributeNullableOctetString_101();
            break;
        case 102:
            ChipLogProgress(chipTool, " ***** Test Step 102 : Read attribute NULLABLE_CHAR_STRING Default Value\n");
            err = TestReadAttributeNullableCharStringDefaultValue_102();
            break;
        case 103:
            ChipLogProgress(chipTool, " ***** Test Step 103 : Write attribute NULLABLE_CHAR_STRING\n");
            err = TestWriteAttributeNullableCharString_103();
            break;
        case 104:
            ChipLogProgress(chipTool, " ***** Test Step 104 : Write attribute NULLABLE_CHAR_STRING - Value too long\n");
            err = TestWriteAttributeNullableCharStringValueTooLong_104();
            break;
        case 105:
            ChipLogProgress(chipTool, " ***** Test Step 105 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_105();
            break;
        case 106:
            ChipLogProgress(chipTool, " ***** Test Step 106 : Write attribute NULLABLE_CHAR_STRING - Empty\n");
            err = TestWriteAttributeNullableCharStringEmpty_106();
            break;
        case 107:
            ChipLogProgress(chipTool, " ***** Test Step 107 : Read attribute NULLABLE_CHAR_STRING\n");
            err = TestReadAttributeNullableCharString_107();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 108;

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_2(listInt8u);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_3(); }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(void * context, const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_4(listOctetString);
    }

    static void OnFailureCallback_5(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_5(chip::to_underlying(status));
    }

    static void OnSuccessCallback_5(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_5(); }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_6(listStructOctetString);
    }

    static void OnFailureCallback_7(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_7(chip::to_underlying(status));
    }

    static void OnSuccessCallback_7(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_7(); }

    static void OnFailureCallback_8(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_8(chip::to_underlying(status));
    }

    static void OnSuccessCallback_8(void * context, const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_8(nullableBoolean);
    }

    static void OnFailureCallback_9(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_9(chip::to_underlying(status));
    }

    static void OnSuccessCallback_9(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_9(); }

    static void OnFailureCallback_10(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_10(chip::to_underlying(status));
    }

    static void OnSuccessCallback_10(void * context, const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_10(nullableBoolean);
    }

    static void OnFailureCallback_11(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_11(chip::to_underlying(status));
    }

    static void OnSuccessCallback_11(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_11(); }

    static void OnFailureCallback_12(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_12(chip::to_underlying(status));
    }

    static void OnSuccessCallback_12(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_12(nullableBitmap8);
    }

    static void OnFailureCallback_13(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_13(chip::to_underlying(status));
    }

    static void OnSuccessCallback_13(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_13(); }

    static void OnFailureCallback_14(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_14(chip::to_underlying(status));
    }

    static void OnSuccessCallback_14(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_14(nullableBitmap8);
    }

    static void OnFailureCallback_15(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_15(chip::to_underlying(status));
    }

    static void OnSuccessCallback_15(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_15(); }

    static void OnFailureCallback_16(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_16(chip::to_underlying(status));
    }

    static void OnSuccessCallback_16(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_16(nullableBitmap8);
    }

    static void OnFailureCallback_17(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_17(chip::to_underlying(status));
    }

    static void OnSuccessCallback_17(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_17(); }

    static void OnFailureCallback_18(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_18(chip::to_underlying(status));
    }

    static void OnSuccessCallback_18(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_18(nullableBitmap16);
    }

    static void OnFailureCallback_19(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_19(chip::to_underlying(status));
    }

    static void OnSuccessCallback_19(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_19(); }

    static void OnFailureCallback_20(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_20(chip::to_underlying(status));
    }

    static void OnSuccessCallback_20(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_20(nullableBitmap16);
    }

    static void OnFailureCallback_21(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_21(chip::to_underlying(status));
    }

    static void OnSuccessCallback_21(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_21(); }

    static void OnFailureCallback_22(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_22(chip::to_underlying(status));
    }

    static void OnSuccessCallback_22(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_22(nullableBitmap16);
    }

    static void OnFailureCallback_23(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_23(chip::to_underlying(status));
    }

    static void OnSuccessCallback_23(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_23(); }

    static void OnFailureCallback_24(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_24(chip::to_underlying(status));
    }

    static void OnSuccessCallback_24(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_24(nullableBitmap32);
    }

    static void OnFailureCallback_25(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_25(chip::to_underlying(status));
    }

    static void OnSuccessCallback_25(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_25(); }

    static void OnFailureCallback_26(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_26(chip::to_underlying(status));
    }

    static void OnSuccessCallback_26(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_26(nullableBitmap32);
    }

    static void OnFailureCallback_27(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_27(chip::to_underlying(status));
    }

    static void OnSuccessCallback_27(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_27(); }

    static void OnFailureCallback_28(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_28(chip::to_underlying(status));
    }

    static void OnSuccessCallback_28(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_28(nullableBitmap32);
    }

    static void OnFailureCallback_29(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_29(chip::to_underlying(status));
    }

    static void OnSuccessCallback_29(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_29(); }

    static void OnFailureCallback_30(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_30(chip::to_underlying(status));
    }

    static void OnSuccessCallback_30(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_30(nullableBitmap64);
    }

    static void OnFailureCallback_31(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_31(chip::to_underlying(status));
    }

    static void OnSuccessCallback_31(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_31(); }

    static void OnFailureCallback_32(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_32(chip::to_underlying(status));
    }

    static void OnSuccessCallback_32(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_32(nullableBitmap64);
    }

    static void OnFailureCallback_33(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_33(chip::to_underlying(status));
    }

    static void OnSuccessCallback_33(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_33(); }

    static void OnFailureCallback_34(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_34(chip::to_underlying(status));
    }

    static void OnSuccessCallback_34(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_34(nullableBitmap64);
    }

    static void OnFailureCallback_35(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_35(chip::to_underlying(status));
    }

    static void OnSuccessCallback_35(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_35(); }

    static void OnFailureCallback_36(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_36(chip::to_underlying(status));
    }

    static void OnSuccessCallback_36(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_36(nullableInt8u);
    }

    static void OnFailureCallback_37(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_37(chip::to_underlying(status));
    }

    static void OnSuccessCallback_37(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_37(); }

    static void OnFailureCallback_38(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_38(chip::to_underlying(status));
    }

    static void OnSuccessCallback_38(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_38(nullableInt8u);
    }

    static void OnFailureCallback_39(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_39(chip::to_underlying(status));
    }

    static void OnSuccessCallback_39(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_39(); }

    static void OnFailureCallback_40(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_40(chip::to_underlying(status));
    }

    static void OnSuccessCallback_40(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_40(nullableInt8u);
    }

    static void OnFailureCallback_41(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_41(chip::to_underlying(status));
    }

    static void OnSuccessCallback_41(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_41(); }

    static void OnFailureCallback_42(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_42(chip::to_underlying(status));
    }

    static void OnSuccessCallback_42(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_42(nullableInt16u);
    }

    static void OnFailureCallback_43(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_43(chip::to_underlying(status));
    }

    static void OnSuccessCallback_43(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_43(); }

    static void OnFailureCallback_44(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_44(chip::to_underlying(status));
    }

    static void OnSuccessCallback_44(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_44(nullableInt16u);
    }

    static void OnFailureCallback_45(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_45(chip::to_underlying(status));
    }

    static void OnSuccessCallback_45(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_45(); }

    static void OnFailureCallback_46(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_46(chip::to_underlying(status));
    }

    static void OnSuccessCallback_46(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_46(nullableInt16u);
    }

    static void OnFailureCallback_47(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_47(chip::to_underlying(status));
    }

    static void OnSuccessCallback_47(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_47(); }

    static void OnFailureCallback_48(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_48(chip::to_underlying(status));
    }

    static void OnSuccessCallback_48(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_48(nullableInt32u);
    }

    static void OnFailureCallback_49(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_49(chip::to_underlying(status));
    }

    static void OnSuccessCallback_49(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_49(); }

    static void OnFailureCallback_50(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_50(chip::to_underlying(status));
    }

    static void OnSuccessCallback_50(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_50(nullableInt32u);
    }

    static void OnFailureCallback_51(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_51(chip::to_underlying(status));
    }

    static void OnSuccessCallback_51(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_51(); }

    static void OnFailureCallback_52(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_52(chip::to_underlying(status));
    }

    static void OnSuccessCallback_52(void * context, const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_52(nullableInt32u);
    }

    static void OnFailureCallback_53(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_53(chip::to_underlying(status));
    }

    static void OnSuccessCallback_53(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_53(); }

    static void OnFailureCallback_54(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_54(chip::to_underlying(status));
    }

    static void OnSuccessCallback_54(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_54(nullableInt64u);
    }

    static void OnFailureCallback_55(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_55(chip::to_underlying(status));
    }

    static void OnSuccessCallback_55(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_55(); }

    static void OnFailureCallback_56(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_56(chip::to_underlying(status));
    }

    static void OnSuccessCallback_56(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_56(nullableInt64u);
    }

    static void OnFailureCallback_57(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_57(chip::to_underlying(status));
    }

    static void OnSuccessCallback_57(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_57(); }

    static void OnFailureCallback_58(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_58(chip::to_underlying(status));
    }

    static void OnSuccessCallback_58(void * context, const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_58(nullableInt64u);
    }

    static void OnFailureCallback_59(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_59(chip::to_underlying(status));
    }

    static void OnSuccessCallback_59(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_59(); }

    static void OnFailureCallback_60(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_60(chip::to_underlying(status));
    }

    static void OnSuccessCallback_60(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_60(nullableInt8s);
    }

    static void OnFailureCallback_61(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_61(chip::to_underlying(status));
    }

    static void OnSuccessCallback_61(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_61(); }

    static void OnFailureCallback_62(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_62(chip::to_underlying(status));
    }

    static void OnSuccessCallback_62(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_62(nullableInt8s);
    }

    static void OnFailureCallback_63(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_63(chip::to_underlying(status));
    }

    static void OnSuccessCallback_63(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_63(); }

    static void OnFailureCallback_64(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_64(chip::to_underlying(status));
    }

    static void OnSuccessCallback_64(void * context, const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_64(nullableInt8s);
    }

    static void OnFailureCallback_65(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_65(chip::to_underlying(status));
    }

    static void OnSuccessCallback_65(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_65(); }

    static void OnFailureCallback_66(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_66(chip::to_underlying(status));
    }

    static void OnSuccessCallback_66(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_66(nullableInt16s);
    }

    static void OnFailureCallback_67(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_67(chip::to_underlying(status));
    }

    static void OnSuccessCallback_67(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_67(); }

    static void OnFailureCallback_68(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_68(chip::to_underlying(status));
    }

    static void OnSuccessCallback_68(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_68(nullableInt16s);
    }

    static void OnFailureCallback_69(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_69(chip::to_underlying(status));
    }

    static void OnSuccessCallback_69(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_69(); }

    static void OnFailureCallback_70(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_70(chip::to_underlying(status));
    }

    static void OnSuccessCallback_70(void * context, const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_70(nullableInt16s);
    }

    static void OnFailureCallback_71(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_71(chip::to_underlying(status));
    }

    static void OnSuccessCallback_71(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_71(); }

    static void OnFailureCallback_72(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_72(chip::to_underlying(status));
    }

    static void OnSuccessCallback_72(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_72(nullableInt32s);
    }

    static void OnFailureCallback_73(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_73(chip::to_underlying(status));
    }

    static void OnSuccessCallback_73(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_73(); }

    static void OnFailureCallback_74(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_74(chip::to_underlying(status));
    }

    static void OnSuccessCallback_74(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_74(nullableInt32s);
    }

    static void OnFailureCallback_75(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_75(chip::to_underlying(status));
    }

    static void OnSuccessCallback_75(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_75(); }

    static void OnFailureCallback_76(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_76(chip::to_underlying(status));
    }

    static void OnSuccessCallback_76(void * context, const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_76(nullableInt32s);
    }

    static void OnFailureCallback_77(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_77(chip::to_underlying(status));
    }

    static void OnSuccessCallback_77(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_77(); }

    static void OnFailureCallback_78(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_78(chip::to_underlying(status));
    }

    static void OnSuccessCallback_78(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_78(nullableInt64s);
    }

    static void OnFailureCallback_79(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_79(chip::to_underlying(status));
    }

    static void OnSuccessCallback_79(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_79(); }

    static void OnFailureCallback_80(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_80(chip::to_underlying(status));
    }

    static void OnSuccessCallback_80(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_80(nullableInt64s);
    }

    static void OnFailureCallback_81(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_81(chip::to_underlying(status));
    }

    static void OnSuccessCallback_81(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_81(); }

    static void OnFailureCallback_82(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_82(chip::to_underlying(status));
    }

    static void OnSuccessCallback_82(void * context, const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_82(nullableInt64s);
    }

    static void OnFailureCallback_83(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_83(chip::to_underlying(status));
    }

    static void OnSuccessCallback_83(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_83(); }

    static void OnFailureCallback_84(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_84(chip::to_underlying(status));
    }

    static void OnSuccessCallback_84(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_84(nullableEnum8);
    }

    static void OnFailureCallback_85(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_85(chip::to_underlying(status));
    }

    static void OnSuccessCallback_85(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_85(); }

    static void OnFailureCallback_86(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_86(chip::to_underlying(status));
    }

    static void OnSuccessCallback_86(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_86(nullableEnum8);
    }

    static void OnFailureCallback_87(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_87(chip::to_underlying(status));
    }

    static void OnSuccessCallback_87(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_87(); }

    static void OnFailureCallback_88(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_88(chip::to_underlying(status));
    }

    static void OnSuccessCallback_88(void * context, const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_88(nullableEnum8);
    }

    static void OnFailureCallback_89(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_89(chip::to_underlying(status));
    }

    static void OnSuccessCallback_89(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_89(); }

    static void OnFailureCallback_90(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_90(chip::to_underlying(status));
    }

    static void OnSuccessCallback_90(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_90(nullableEnum16);
    }

    static void OnFailureCallback_91(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_91(chip::to_underlying(status));
    }

    static void OnSuccessCallback_91(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_91(); }

    static void OnFailureCallback_92(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_92(chip::to_underlying(status));
    }

    static void OnSuccessCallback_92(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_92(nullableEnum16);
    }

    static void OnFailureCallback_93(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_93(chip::to_underlying(status));
    }

    static void OnSuccessCallback_93(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_93(); }

    static void OnFailureCallback_94(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_94(chip::to_underlying(status));
    }

    static void OnSuccessCallback_94(void * context, const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_94(nullableEnum16);
    }

    static void OnFailureCallback_95(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_95(chip::to_underlying(status));
    }

    static void OnSuccessCallback_95(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_95(nullableOctetString);
    }

    static void OnFailureCallback_96(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_96(chip::to_underlying(status));
    }

    static void OnSuccessCallback_96(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_96(); }

    static void OnFailureCallback_97(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_97(chip::to_underlying(status));
    }

    static void OnSuccessCallback_97(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_97(nullableOctetString);
    }

    static void OnFailureCallback_98(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_98(chip::to_underlying(status));
    }

    static void OnSuccessCallback_98(void * context) { (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_98(); }

    static void OnFailureCallback_99(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_99(chip::to_underlying(status));
    }

    static void OnSuccessCallback_99(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_99(nullableOctetString);
    }

    static void OnFailureCallback_100(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_100(chip::to_underlying(status));
    }

    static void OnSuccessCallback_100(void * context)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_100();
    }

    static void OnFailureCallback_101(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_101(chip::to_underlying(status));
    }

    static void OnSuccessCallback_101(void * context, const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_101(nullableOctetString);
    }

    static void OnFailureCallback_102(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_102(chip::to_underlying(status));
    }

    static void OnSuccessCallback_102(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_102(nullableCharString);
    }

    static void OnFailureCallback_103(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_103(chip::to_underlying(status));
    }

    static void OnSuccessCallback_103(void * context)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_103();
    }

    static void OnFailureCallback_104(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_104(chip::to_underlying(status));
    }

    static void OnSuccessCallback_104(void * context)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_104();
    }

    static void OnFailureCallback_105(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_105(chip::to_underlying(status));
    }

    static void OnSuccessCallback_105(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_105(nullableCharString);
    }

    static void OnFailureCallback_106(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_106(chip::to_underlying(status));
    }

    static void OnSuccessCallback_106(void * context)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_106();
    }

    static void OnFailureCallback_107(void * context, EmberAfStatus status)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_107(chip::to_underlying(status));
    }

    static void OnSuccessCallback_107(void * context, const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        (static_cast<TestClusterComplexTypes *>(context))->OnSuccessResponse_107(nullableCharString);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestSendTestCommandWithOptionalArgSetToNull_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::TestCluster::Commands::TestNullableOptionalRequest::Type;

        RequestType request;
        request.arg1.Emplace().SetNull();

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestClusterComplexTypes *>(context))
                ->OnSuccessResponse_0(data.wasPresent, data.wasNull, data.value, data.originalValue);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestClusterComplexTypes *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(bool wasPresent, const chip::Optional<bool> & wasNull, const chip::Optional<uint8_t> & value,
                             const chip::Optional<chip::app::DataModel::Nullable<uint8_t>> & originalValue)
    {
        VerifyOrReturn(CheckValue<bool>("wasPresent", wasPresent, true));

        VerifyOrReturn(CheckValuePresent("wasNull", wasNull));
        VerifyOrReturn(CheckValue<bool>("wasNull.Value()", wasNull.Value(), true));

        VerifyOrReturn(CheckValuePresent("originalValue", originalValue));
        VerifyOrReturn(CheckValueNull("originalValue.Value()", originalValue.Value()));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfInt8uAndNoneOfThemIsSetTo0_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::List<const uint8_t> listInt8uArgument;

        uint8_t listInt8uList[4];
        listInt8uList[0]  = 1;
        listInt8uList[1]  = 2;
        listInt8uList[2]  = 3;
        listInt8uList[3]  = 4;
        listInt8uArgument = listInt8uList;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(
            listInt8uArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfInt8u_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListInt8u::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                        OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(const chip::app::DataModel::DecodableList<uint8_t> & listInt8u)
    {
        auto iter = listInt8u.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 0));
        VerifyOrReturn(CheckValue<uint8_t>("listInt8u[0]", iter.GetValue(), 1));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 1));
        VerifyOrReturn(CheckValue<uint8_t>("listInt8u[1]", iter.GetValue(), 2));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 2));
        VerifyOrReturn(CheckValue<uint8_t>("listInt8u[2]", iter.GetValue(), 3));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listInt8u)>("listInt8u", iter, 3));
        VerifyOrReturn(CheckValue<uint8_t>("listInt8u[3]", iter.GetValue(), 4));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listInt8u)>("listInt8u", iter, 4));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfOctetString_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::List<const chip::ByteSpan> listOctetStringArgument;

        chip::ByteSpan listOctetStringList[4];
        listOctetStringList[0]  = chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);
        listOctetStringList[1]  = chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);
        listOctetStringList[2]  = chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);
        listOctetStringList[3]  = chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);
        listOctetStringArgument = listOctetStringList;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListOctetString::TypeInfo>(
            listOctetStringArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfOctetString_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListOctetString::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(const chip::app::DataModel::DecodableList<chip::ByteSpan> & listOctetString)
    {
        auto iter = listOctetString.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 0));
        VerifyOrReturn(
            CheckValueAsString("listOctetString[0]", iter.GetValue(), chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 1));
        VerifyOrReturn(
            CheckValueAsString("listOctetString[1]", iter.GetValue(), chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 2));
        VerifyOrReturn(
            CheckValueAsString("listOctetString[2]", iter.GetValue(), chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listOctetString)>("listOctetString", iter, 3));
        VerifyOrReturn(
            CheckValueAsString("listOctetString[3]", iter.GetValue(), chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listOctetString)>("listOctetString", iter, 4));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeListWithListOfListStructOctetString_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>
            listStructOctetStringArgument;

        chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type listStructOctetStringList[4];

        listStructOctetStringList[0].fabricIndex = 0ULL;
        listStructOctetStringList[0].operationalCert =
            chip::ByteSpan(chip::Uint8::from_const_char("Test0garbage: not in length on purpose"), 5);

        listStructOctetStringList[1].fabricIndex = 1ULL;
        listStructOctetStringList[1].operationalCert =
            chip::ByteSpan(chip::Uint8::from_const_char("Test1garbage: not in length on purpose"), 5);

        listStructOctetStringList[2].fabricIndex = 2ULL;
        listStructOctetStringList[2].operationalCert =
            chip::ByteSpan(chip::Uint8::from_const_char("Test2garbage: not in length on purpose"), 5);

        listStructOctetStringList[3].fabricIndex = 3ULL;
        listStructOctetStringList[3].operationalCert =
            chip::ByteSpan(chip::Uint8::from_const_char("Test3garbage: not in length on purpose"), 5);

        listStructOctetStringArgument = listStructOctetStringList;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::ListStructOctetString::TypeInfo>(
            listStructOctetStringArgument, this, OnSuccessCallback_5, OnFailureCallback_5);
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestReadAttributeListWithListOfListStructOctetString_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::ListStructOctetString::TypeInfo>(
            this, OnSuccessCallback_6, OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &
            listStructOctetString)
    {
        auto iter = listStructOctetString.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 0));
        VerifyOrReturn(CheckValue<>("listStructOctetString[0].fabricIndex", iter.GetValue().fabricIndex, 0ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[0].operationalCert", iter.GetValue().operationalCert,
                                          chip::ByteSpan(chip::Uint8::from_const_char("Test0"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 1));
        VerifyOrReturn(CheckValue<>("listStructOctetString[1].fabricIndex", iter.GetValue().fabricIndex, 1ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[1].operationalCert", iter.GetValue().operationalCert,
                                          chip::ByteSpan(chip::Uint8::from_const_char("Test1"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 2));
        VerifyOrReturn(CheckValue<>("listStructOctetString[2].fabricIndex", iter.GetValue().fabricIndex, 2ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[2].operationalCert", iter.GetValue().operationalCert,
                                          chip::ByteSpan(chip::Uint8::from_const_char("Test2"), 5)));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(listStructOctetString)>("listStructOctetString", iter, 3));
        VerifyOrReturn(CheckValue<>("listStructOctetString[3].fabricIndex", iter.GetValue().fabricIndex, 3ULL));
        VerifyOrReturn(CheckValueAsString("listStructOctetString[3].operationalCert", iter.GetValue().operationalCert,
                                          chip::ByteSpan(chip::Uint8::from_const_char("Test3"), 5)));
        VerifyOrReturn(CheckNoMoreListItems<decltype(listStructOctetString)>("listStructOctetString", iter, 4));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBooleanNull_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<bool> nullableBooleanArgument;
        nullableBooleanArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            nullableBooleanArgument, this, OnSuccessCallback_7, OnFailureCallback_7);
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBooleanNull_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            this, OnSuccessCallback_8, OnFailureCallback_8);
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        VerifyOrReturn(CheckValueNull("nullableBoolean", nullableBoolean));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBooleanTrue_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<bool> nullableBooleanArgument;
        nullableBooleanArgument.SetNonNull() = true;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            nullableBooleanArgument, this, OnSuccessCallback_9, OnFailureCallback_9);
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBooleanTrue_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBoolean::TypeInfo>(
            this, OnSuccessCallback_10, OnFailureCallback_10);
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(const chip::app::DataModel::Nullable<bool> & nullableBoolean)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBoolean", nullableBoolean));
        VerifyOrReturn(CheckValue<bool>("nullableBoolean.Value()", nullableBoolean.Value(), true));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8MaxValue_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNonNull() = 254;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_11, OnFailureCallback_11);
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8MaxValue_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_12, OnFailureCallback_12);
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap8", nullableBitmap8));
        VerifyOrReturn(CheckValue<uint8_t>("nullableBitmap8.Value()", nullableBitmap8.Value(), 254));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8InvalidValue_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNonNull() = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_13, OnFailureCallback_13);
    }

    void OnFailureResponse_13(uint8_t status) { NextTest(); }

    void OnSuccessResponse_13() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8UnchangedValue_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_14, OnFailureCallback_14);
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap8", nullableBitmap8));
        VerifyOrReturn(CheckValue<uint8_t>("nullableBitmap8.Value()", nullableBitmap8.Value(), 254));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap8NullValue_15()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableBitmap8Argument;
        nullableBitmap8Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            nullableBitmap8Argument, this, OnSuccessCallback_15, OnFailureCallback_15);
    }

    void OnFailureResponse_15(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_15() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap8NullValue_16()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap8::TypeInfo>(
            this, OnSuccessCallback_16, OnFailureCallback_16);
    }

    void OnFailureResponse_16(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_16(const chip::app::DataModel::Nullable<uint8_t> & nullableBitmap8)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap8", nullableBitmap8));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16MaxValue_17()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNonNull() = 65534U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_17, OnFailureCallback_17);
    }

    void OnFailureResponse_17(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_17() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16MaxValue_18()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_18, OnFailureCallback_18);
    }

    void OnFailureResponse_18(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_18(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap16", nullableBitmap16));
        VerifyOrReturn(CheckValue<uint16_t>("nullableBitmap16.Value()", nullableBitmap16.Value(), 65534U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16InvalidValue_19()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNonNull() = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_19, OnFailureCallback_19);
    }

    void OnFailureResponse_19(uint8_t status) { NextTest(); }

    void OnSuccessResponse_19() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16UnchangedValue_20()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_20, OnFailureCallback_20);
    }

    void OnFailureResponse_20(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_20(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap16", nullableBitmap16));
        VerifyOrReturn(CheckValue<uint16_t>("nullableBitmap16.Value()", nullableBitmap16.Value(), 65534U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap16NullValue_21()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableBitmap16Argument;
        nullableBitmap16Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            nullableBitmap16Argument, this, OnSuccessCallback_21, OnFailureCallback_21);
    }

    void OnFailureResponse_21(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_21() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap16NullValue_22()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap16::TypeInfo>(
            this, OnSuccessCallback_22, OnFailureCallback_22);
    }

    void OnFailureResponse_22(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_22(const chip::app::DataModel::Nullable<uint16_t> & nullableBitmap16)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap16", nullableBitmap16));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32MaxValue_23()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNonNull() = 4294967294UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_23, OnFailureCallback_23);
    }

    void OnFailureResponse_23(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_23() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32MaxValue_24()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_24, OnFailureCallback_24);
    }

    void OnFailureResponse_24(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_24(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap32", nullableBitmap32));
        VerifyOrReturn(CheckValue<uint32_t>("nullableBitmap32.Value()", nullableBitmap32.Value(), 4294967294UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32InvalidValue_25()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNonNull() = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_25, OnFailureCallback_25);
    }

    void OnFailureResponse_25(uint8_t status) { NextTest(); }

    void OnSuccessResponse_25() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32UnchangedValue_26()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_26, OnFailureCallback_26);
    }

    void OnFailureResponse_26(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_26(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap32", nullableBitmap32));
        VerifyOrReturn(CheckValue<uint32_t>("nullableBitmap32.Value()", nullableBitmap32.Value(), 4294967294UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap32NullValue_27()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableBitmap32Argument;
        nullableBitmap32Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            nullableBitmap32Argument, this, OnSuccessCallback_27, OnFailureCallback_27);
    }

    void OnFailureResponse_27(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_27() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap32NullValue_28()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap32::TypeInfo>(
            this, OnSuccessCallback_28, OnFailureCallback_28);
    }

    void OnFailureResponse_28(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_28(const chip::app::DataModel::Nullable<uint32_t> & nullableBitmap32)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap32", nullableBitmap32));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64MaxValue_29()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNonNull() = 18446744073709551614ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_29, OnFailureCallback_29);
    }

    void OnFailureResponse_29(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_29() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64MaxValue_30()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_30, OnFailureCallback_30);
    }

    void OnFailureResponse_30(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_30(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap64", nullableBitmap64));
        VerifyOrReturn(CheckValue<uint64_t>("nullableBitmap64.Value()", nullableBitmap64.Value(), 18446744073709551614ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64InvalidValue_31()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNonNull() = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_31, OnFailureCallback_31);
    }

    void OnFailureResponse_31(uint8_t status) { NextTest(); }

    void OnSuccessResponse_31() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64UnchangedValue_32()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_32, OnFailureCallback_32);
    }

    void OnFailureResponse_32(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_32(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNonNull("nullableBitmap64", nullableBitmap64));
        VerifyOrReturn(CheckValue<uint64_t>("nullableBitmap64.Value()", nullableBitmap64.Value(), 18446744073709551614ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableBitmap64NullValue_33()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableBitmap64Argument;
        nullableBitmap64Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            nullableBitmap64Argument, this, OnSuccessCallback_33, OnFailureCallback_33);
    }

    void OnFailureResponse_33(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_33() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableBitmap64NullValue_34()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableBitmap64::TypeInfo>(
            this, OnSuccessCallback_34, OnFailureCallback_34);
    }

    void OnFailureResponse_34(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_34(const chip::app::DataModel::Nullable<uint64_t> & nullableBitmap64)
    {
        VerifyOrReturn(CheckValueNull("nullableBitmap64", nullableBitmap64));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uMaxValue_35()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNonNull() = 254;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_35, OnFailureCallback_35);
    }

    void OnFailureResponse_35(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_35() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8uMaxValue_36()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_36, OnFailureCallback_36);
    }

    void OnFailureResponse_36(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_36(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8u", nullableInt8u));
        VerifyOrReturn(CheckValue<uint8_t>("nullableInt8u.Value()", nullableInt8u.Value(), 254));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uInvalidValue_37()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNonNull() = 255;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_37, OnFailureCallback_37);
    }

    void OnFailureResponse_37(uint8_t status) { NextTest(); }

    void OnSuccessResponse_37() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt8uUnchangedValue_38()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_38, OnFailureCallback_38);
    }

    void OnFailureResponse_38(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_38(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8u", nullableInt8u));
        VerifyOrReturn(CheckValue<uint8_t>("nullableInt8u.Value()", nullableInt8u.Value(), 254));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8uNullValue_39()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableInt8uArgument;
        nullableInt8uArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            nullableInt8uArgument, this, OnSuccessCallback_39, OnFailureCallback_39);
    }

    void OnFailureResponse_39(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_39() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8uNullValue_40()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8u::TypeInfo>(
            this, OnSuccessCallback_40, OnFailureCallback_40);
    }

    void OnFailureResponse_40(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_40(const chip::app::DataModel::Nullable<uint8_t> & nullableInt8u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt8u", nullableInt8u));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uMaxValue_41()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNonNull() = 65534U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_41, OnFailureCallback_41);
    }

    void OnFailureResponse_41(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_41() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16uMaxValue_42()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_42, OnFailureCallback_42);
    }

    void OnFailureResponse_42(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_42(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16u", nullableInt16u));
        VerifyOrReturn(CheckValue<uint16_t>("nullableInt16u.Value()", nullableInt16u.Value(), 65534U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uInvalidValue_43()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNonNull() = 65535U;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_43, OnFailureCallback_43);
    }

    void OnFailureResponse_43(uint8_t status) { NextTest(); }

    void OnSuccessResponse_43() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt16uUnchangedValue_44()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_44, OnFailureCallback_44);
    }

    void OnFailureResponse_44(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_44(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16u", nullableInt16u));
        VerifyOrReturn(CheckValue<uint16_t>("nullableInt16u.Value()", nullableInt16u.Value(), 65534U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16uNullValue_45()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableInt16uArgument;
        nullableInt16uArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            nullableInt16uArgument, this, OnSuccessCallback_45, OnFailureCallback_45);
    }

    void OnFailureResponse_45(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_45() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16uNullValue_46()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16u::TypeInfo>(
            this, OnSuccessCallback_46, OnFailureCallback_46);
    }

    void OnFailureResponse_46(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_46(const chip::app::DataModel::Nullable<uint16_t> & nullableInt16u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt16u", nullableInt16u));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uMaxValue_47()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNonNull() = 4294967294UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_47, OnFailureCallback_47);
    }

    void OnFailureResponse_47(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_47() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32uMaxValue_48()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_48, OnFailureCallback_48);
    }

    void OnFailureResponse_48(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_48(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32u", nullableInt32u));
        VerifyOrReturn(CheckValue<uint32_t>("nullableInt32u.Value()", nullableInt32u.Value(), 4294967294UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uInvalidValue_49()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNonNull() = 4294967295UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_49, OnFailureCallback_49);
    }

    void OnFailureResponse_49(uint8_t status) { NextTest(); }

    void OnSuccessResponse_49() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt32uUnchangedValue_50()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_50, OnFailureCallback_50);
    }

    void OnFailureResponse_50(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_50(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32u", nullableInt32u));
        VerifyOrReturn(CheckValue<uint32_t>("nullableInt32u.Value()", nullableInt32u.Value(), 4294967294UL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32uNullValue_51()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint32_t> nullableInt32uArgument;
        nullableInt32uArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            nullableInt32uArgument, this, OnSuccessCallback_51, OnFailureCallback_51);
    }

    void OnFailureResponse_51(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_51() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32uNullValue_52()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32u::TypeInfo>(
            this, OnSuccessCallback_52, OnFailureCallback_52);
    }

    void OnFailureResponse_52(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_52(const chip::app::DataModel::Nullable<uint32_t> & nullableInt32u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt32u", nullableInt32u));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uMaxValue_53()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNonNull() = 18446744073709551614ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_53, OnFailureCallback_53);
    }

    void OnFailureResponse_53(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_53() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64uMaxValue_54()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_54, OnFailureCallback_54);
    }

    void OnFailureResponse_54(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_54(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64u", nullableInt64u));
        VerifyOrReturn(CheckValue<uint64_t>("nullableInt64u.Value()", nullableInt64u.Value(), 18446744073709551614ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uInvalidValue_55()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNonNull() = 18446744073709551615ULL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_55, OnFailureCallback_55);
    }

    void OnFailureResponse_55(uint8_t status) { NextTest(); }

    void OnSuccessResponse_55() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt64uUnchangedValue_56()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_56, OnFailureCallback_56);
    }

    void OnFailureResponse_56(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_56(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64u", nullableInt64u));
        VerifyOrReturn(CheckValue<uint64_t>("nullableInt64u.Value()", nullableInt64u.Value(), 18446744073709551614ULL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64uNullValue_57()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint64_t> nullableInt64uArgument;
        nullableInt64uArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            nullableInt64uArgument, this, OnSuccessCallback_57, OnFailureCallback_57);
    }

    void OnFailureResponse_57(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_57() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64uNullValue_58()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64u::TypeInfo>(
            this, OnSuccessCallback_58, OnFailureCallback_58);
    }

    void OnFailureResponse_58(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_58(const chip::app::DataModel::Nullable<uint64_t> & nullableInt64u)
    {
        VerifyOrReturn(CheckValueNull("nullableInt64u", nullableInt64u));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sMinValue_59()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNonNull() = -127;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_59, OnFailureCallback_59);
    }

    void OnFailureResponse_59(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_59() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8sMinValue_60()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_60, OnFailureCallback_60);
    }

    void OnFailureResponse_60(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_60(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8s", nullableInt8s));
        VerifyOrReturn(CheckValue<int8_t>("nullableInt8s.Value()", nullableInt8s.Value(), -127));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sInvalidValue_61()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNonNull() = -128;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_61, OnFailureCallback_61);
    }

    void OnFailureResponse_61(uint8_t status) { NextTest(); }

    void OnSuccessResponse_61() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt8sUnchangedValue_62()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_62, OnFailureCallback_62);
    }

    void OnFailureResponse_62(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_62(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt8s", nullableInt8s));
        VerifyOrReturn(CheckValue<int8_t>("nullableInt8s.Value()", nullableInt8s.Value(), -127));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt8sNullValue_63()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int8_t> nullableInt8sArgument;
        nullableInt8sArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            nullableInt8sArgument, this, OnSuccessCallback_63, OnFailureCallback_63);
    }

    void OnFailureResponse_63(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_63() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt8sNullValue_64()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt8s::TypeInfo>(
            this, OnSuccessCallback_64, OnFailureCallback_64);
    }

    void OnFailureResponse_64(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_64(const chip::app::DataModel::Nullable<int8_t> & nullableInt8s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt8s", nullableInt8s));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sMinValue_65()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNonNull() = -32767;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_65, OnFailureCallback_65);
    }

    void OnFailureResponse_65(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_65() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16sMinValue_66()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_66, OnFailureCallback_66);
    }

    void OnFailureResponse_66(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_66(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16s", nullableInt16s));
        VerifyOrReturn(CheckValue<int16_t>("nullableInt16s.Value()", nullableInt16s.Value(), -32767));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sInvalidValue_67()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNonNull() = -32768;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_67, OnFailureCallback_67);
    }

    void OnFailureResponse_67(uint8_t status) { NextTest(); }

    void OnSuccessResponse_67() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt16sUnchangedValue_68()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_68, OnFailureCallback_68);
    }

    void OnFailureResponse_68(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_68(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt16s", nullableInt16s));
        VerifyOrReturn(CheckValue<int16_t>("nullableInt16s.Value()", nullableInt16s.Value(), -32767));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt16sNullValue_69()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int16_t> nullableInt16sArgument;
        nullableInt16sArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            nullableInt16sArgument, this, OnSuccessCallback_69, OnFailureCallback_69);
    }

    void OnFailureResponse_69(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_69() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt16sNullValue_70()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt16s::TypeInfo>(
            this, OnSuccessCallback_70, OnFailureCallback_70);
    }

    void OnFailureResponse_70(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_70(const chip::app::DataModel::Nullable<int16_t> & nullableInt16s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt16s", nullableInt16s));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sMinValue_71()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNonNull() = -2147483647L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_71, OnFailureCallback_71);
    }

    void OnFailureResponse_71(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_71() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32sMinValue_72()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_72, OnFailureCallback_72);
    }

    void OnFailureResponse_72(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_72(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32s", nullableInt32s));
        VerifyOrReturn(CheckValue<int32_t>("nullableInt32s.Value()", nullableInt32s.Value(), -2147483647L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sInvalidValue_73()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNonNull() = -2147483648L;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_73, OnFailureCallback_73);
    }

    void OnFailureResponse_73(uint8_t status) { NextTest(); }

    void OnSuccessResponse_73() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt32sUnchangedValue_74()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_74, OnFailureCallback_74);
    }

    void OnFailureResponse_74(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_74(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt32s", nullableInt32s));
        VerifyOrReturn(CheckValue<int32_t>("nullableInt32s.Value()", nullableInt32s.Value(), -2147483647L));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt32sNullValue_75()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int32_t> nullableInt32sArgument;
        nullableInt32sArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            nullableInt32sArgument, this, OnSuccessCallback_75, OnFailureCallback_75);
    }

    void OnFailureResponse_75(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_75() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt32sNullValue_76()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt32s::TypeInfo>(
            this, OnSuccessCallback_76, OnFailureCallback_76);
    }

    void OnFailureResponse_76(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_76(const chip::app::DataModel::Nullable<int32_t> & nullableInt32s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt32s", nullableInt32s));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sMinValue_77()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNonNull() = -9223372036854775807LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_77, OnFailureCallback_77);
    }

    void OnFailureResponse_77(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_77() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64sMinValue_78()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_78, OnFailureCallback_78);
    }

    void OnFailureResponse_78(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_78(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64s", nullableInt64s));
        VerifyOrReturn(CheckValue<int64_t>("nullableInt64s.Value()", nullableInt64s.Value(), -9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sInvalidValue_79()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNonNull() = -9223372036854775807LL - 1LL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_79, OnFailureCallback_79);
    }

    void OnFailureResponse_79(uint8_t status) { NextTest(); }

    void OnSuccessResponse_79() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableInt64sUnchangedValue_80()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_80, OnFailureCallback_80);
    }

    void OnFailureResponse_80(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_80(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNonNull("nullableInt64s", nullableInt64s));
        VerifyOrReturn(CheckValue<int64_t>("nullableInt64s.Value()", nullableInt64s.Value(), -9223372036854775807LL));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableInt64sNullValue_81()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<int64_t> nullableInt64sArgument;
        nullableInt64sArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            nullableInt64sArgument, this, OnSuccessCallback_81, OnFailureCallback_81);
    }

    void OnFailureResponse_81(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_81() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableInt64sNullValue_82()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableInt64s::TypeInfo>(
            this, OnSuccessCallback_82, OnFailureCallback_82);
    }

    void OnFailureResponse_82(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_82(const chip::app::DataModel::Nullable<int64_t> & nullableInt64s)
    {
        VerifyOrReturn(CheckValueNull("nullableInt64s", nullableInt64s));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8MaxValue_83()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNonNull() = static_cast<uint8_t>(254);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_83, OnFailureCallback_83);
    }

    void OnFailureResponse_83(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_83() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum8MaxValue_84()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_84, OnFailureCallback_84);
    }

    void OnFailureResponse_84(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_84(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum8", nullableEnum8));
        VerifyOrReturn(CheckValue<uint8_t>("nullableEnum8.Value()", nullableEnum8.Value(), 254));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8InvalidValue_85()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNonNull() = static_cast<uint8_t>(255);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_85, OnFailureCallback_85);
    }

    void OnFailureResponse_85(uint8_t status) { NextTest(); }

    void OnSuccessResponse_85() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableEnum8UnchangedValue_86()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_86, OnFailureCallback_86);
    }

    void OnFailureResponse_86(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_86(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum8", nullableEnum8));
        VerifyOrReturn(CheckValue<uint8_t>("nullableEnum8.Value()", nullableEnum8.Value(), 254));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum8NullValue_87()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint8_t> nullableEnum8Argument;
        nullableEnum8Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            nullableEnum8Argument, this, OnSuccessCallback_87, OnFailureCallback_87);
    }

    void OnFailureResponse_87(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_87() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum8NullValue_88()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum8::TypeInfo>(
            this, OnSuccessCallback_88, OnFailureCallback_88);
    }

    void OnFailureResponse_88(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_88(const chip::app::DataModel::Nullable<uint8_t> & nullableEnum8)
    {
        VerifyOrReturn(CheckValueNull("nullableEnum8", nullableEnum8));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16MaxValue_89()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNonNull() = static_cast<uint16_t>(65534);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_89, OnFailureCallback_89);
    }

    void OnFailureResponse_89(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_89() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum16MaxValue_90()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_90, OnFailureCallback_90);
    }

    void OnFailureResponse_90(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_90(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum16", nullableEnum16));
        VerifyOrReturn(CheckValue<uint16_t>("nullableEnum16.Value()", nullableEnum16.Value(), 65534U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16InvalidValue_91()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNonNull() = static_cast<uint16_t>(65535);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_91, OnFailureCallback_91);
    }

    void OnFailureResponse_91(uint8_t status) { NextTest(); }

    void OnSuccessResponse_91() { ThrowSuccessResponse(); }

    CHIP_ERROR TestReadAttributeNullableEnum16UnchangedValue_92()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_92, OnFailureCallback_92);
    }

    void OnFailureResponse_92(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_92(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNonNull("nullableEnum16", nullableEnum16));
        VerifyOrReturn(CheckValue<uint16_t>("nullableEnum16.Value()", nullableEnum16.Value(), 65534U));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableEnum16NullValue_93()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<uint16_t> nullableEnum16Argument;
        nullableEnum16Argument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            nullableEnum16Argument, this, OnSuccessCallback_93, OnFailureCallback_93);
    }

    void OnFailureResponse_93(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_93() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableEnum16NullValue_94()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableEnum16::TypeInfo>(
            this, OnSuccessCallback_94, OnFailureCallback_94);
    }

    void OnFailureResponse_94(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_94(const chip::app::DataModel::Nullable<uint16_t> & nullableEnum16)
    {
        VerifyOrReturn(CheckValueNull("nullableEnum16", nullableEnum16));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableOctetStringDefaultValue_95()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_95, OnFailureCallback_95);
    }

    void OnFailureResponse_95(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_95(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_96()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNonNull() =
            chip::ByteSpan(chip::Uint8::from_const_char("TestValuegarbage: not in length on purpose"), 9);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_96, OnFailureCallback_96);
    }

    void OnFailureResponse_96(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_96() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_97()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_97, OnFailureCallback_97);
    }

    void OnFailureResponse_97(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_97(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char("TestValue"), 9)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_98()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_98, OnFailureCallback_98);
    }

    void OnFailureResponse_98(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_98() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_99()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_99, OnFailureCallback_99);
    }

    void OnFailureResponse_99(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_99(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNull("nullableOctetString", nullableOctetString));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableOctetString_100()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetStringArgument;
        nullableOctetStringArgument.SetNonNull() =
            chip::ByteSpan(chip::Uint8::from_const_char("garbage: not in length on purpose"), 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            nullableOctetStringArgument, this, OnSuccessCallback_100, OnFailureCallback_100);
    }

    void OnFailureResponse_100(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_100() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableOctetString_101()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableOctetString::TypeInfo>(
            this, OnSuccessCallback_101, OnFailureCallback_101);
    }

    void OnFailureResponse_101(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_101(const chip::app::DataModel::Nullable<chip::ByteSpan> & nullableOctetString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableOctetString", nullableOctetString));
        VerifyOrReturn(CheckValueAsString("nullableOctetString.Value()", nullableOctetString.Value(),
                                          chip::ByteSpan(chip::Uint8::from_const_char(""), 0)));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeNullableCharStringDefaultValue_102()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_102, OnFailureCallback_102);
    }

    void OnFailureResponse_102(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_102(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableCharString", nullableCharString));
        VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", nullableCharString.Value(), chip::CharSpan("", 0)));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableCharString_103()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNonNull() = chip::Span<const char>("Tgarbage: not in length on purpose", 3);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_103, OnFailureCallback_103);
    }

    void OnFailureResponse_103(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_103() { NextTest(); }

    CHIP_ERROR TestWriteAttributeNullableCharStringValueTooLong_104()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNull();

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_104, OnFailureCallback_104);
    }

    void OnFailureResponse_104(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_104() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableCharString_105()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_105, OnFailureCallback_105);
    }

    void OnFailureResponse_105(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_105(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNull("nullableCharString", nullableCharString));
        NextTest();
    }

    CHIP_ERROR TestWriteAttributeNullableCharStringEmpty_106()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::app::DataModel::Nullable<chip::CharSpan> nullableCharStringArgument;
        nullableCharStringArgument.SetNonNull() = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            nullableCharStringArgument, this, OnSuccessCallback_106, OnFailureCallback_106);
    }

    void OnFailureResponse_106(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_106() { NextTest(); }

    CHIP_ERROR TestReadAttributeNullableCharString_107()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::NullableCharString::TypeInfo>(
            this, OnSuccessCallback_107, OnFailureCallback_107);
    }

    void OnFailureResponse_107(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_107(const chip::app::DataModel::Nullable<chip::CharSpan> & nullableCharString)
    {
        VerifyOrReturn(CheckValueNonNull("nullableCharString", nullableCharString));
        VerifyOrReturn(CheckValueAsString("nullableCharString.Value()", nullableCharString.Value(), chip::CharSpan("", 0)));
        NextTest();
    }
};

class TestConstraints : public TestCommand
{
public:
    TestConstraints() : TestCommand("TestConstraints"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestConstraints\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestConstraints\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Write attribute INT32U Value\n");
            err = TestWriteAttributeInt32uValue_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute INT32U Value MinValue Constraints\n");
            err = TestReadAttributeInt32uValueMinValueConstraints_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute INT32U Value MaxValue Constraints\n");
            err = TestReadAttributeInt32uValueMaxValueConstraints_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute INT32U Value NotValue Constraints\n");
            err = TestReadAttributeInt32uValueNotValueConstraints_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<TestConstraints *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_1(int32u);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_2(int32u);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestConstraints *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, uint32_t int32u)
    {
        (static_cast<TestConstraints *>(context))->OnSuccessResponse_3(int32u);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestWriteAttributeInt32uValue_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint32_t int32uArgument;
        int32uArgument = 5UL;

        return cluster.WriteAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(
            int32uArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReadAttributeInt32uValueMinValueConstraints_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                     OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMinValue<uint32_t>("int32u", int32u, 5));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueMaxValueConstraints_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                     OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintMaxValue<uint32_t>("int32u", int32u, 5));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeInt32uValueNotValueConstraints_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::TestClusterClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::TestCluster::Attributes::Int32u::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                     OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint32_t int32u)
    {
        VerifyOrReturn(CheckConstraintNotValue<uint32_t>("int32u", int32u, 6));
        NextTest();
    }
};

class TestDelayCommands : public TestCommand
{
public:
    TestDelayCommands() : TestCommand("TestDelayCommands"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDelayCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDelayCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Wait 100ms\n");
            err = TestWait100ms_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestWait100ms_0() { return WaitForMs(100); }
};

class TestLogCommands : public TestCommand
{
public:
    TestLogCommands() : TestCommand("TestLogCommands"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestLogCommands\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestLogCommands\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Log a simple message\n");
            err = TestLogASimpleMessage_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestLogASimpleMessage_0() { return Log("This is a simple message"); }
};

class TestDescriptorCluster : public TestCommand
{
public:
    TestDescriptorCluster() : TestCommand("TestDescriptorCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestDescriptorCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestDescriptorCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read attribute Device list\n");
            err = TestReadAttributeDeviceList_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read attribute Server list\n");
            err = TestReadAttributeServerList_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read attribute Client list\n");
            err = TestReadAttributeClientList_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read attribute Parts list\n");
            err = TestReadAttributePartsList_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_0(deviceList);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_1(serverList);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_2(clientList);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        (static_cast<TestDescriptorCluster *>(context))->OnSuccessResponse_3(partsList);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadAttributeDeviceList_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::DeviceList::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                        OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> & deviceList)
    {
        auto iter = deviceList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(deviceList)>("deviceList", iter, 0));
        VerifyOrReturn(CheckValue<>("deviceList[0].type", iter.GetValue().type, 0UL));
        VerifyOrReturn(CheckValue<>("deviceList[0].revision", iter.GetValue().revision, 1U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(deviceList)>("deviceList", iter, 1));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeServerList_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::ServerList::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                        OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(const chip::app::DataModel::DecodableList<chip::ClusterId> & serverList)
    {
        auto iter = serverList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 0));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[0]", iter.GetValue(), 3UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 1));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[1]", iter.GetValue(), 29UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 2));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[2]", iter.GetValue(), 40UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 3));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[3]", iter.GetValue(), 41UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 4));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[4]", iter.GetValue(), 42UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 5));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[5]", iter.GetValue(), 48UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 6));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[6]", iter.GetValue(), 49UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 7));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[7]", iter.GetValue(), 50UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 8));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[8]", iter.GetValue(), 51UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 9));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[9]", iter.GetValue(), 52UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 10));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[10]", iter.GetValue(), 53UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 11));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[11]", iter.GetValue(), 54UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 12));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[12]", iter.GetValue(), 55UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 13));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[13]", iter.GetValue(), 60UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 14));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[14]", iter.GetValue(), 62UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 15));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[15]", iter.GetValue(), 1029UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 16));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[16]", iter.GetValue(), 61440UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(serverList)>("serverList", iter, 17));
        VerifyOrReturn(CheckValue<chip::ClusterId>("serverList[17]", iter.GetValue(), 61444UL));
        VerifyOrReturn(CheckNoMoreListItems<decltype(serverList)>("serverList", iter, 18));
        NextTest();
    }

    CHIP_ERROR TestReadAttributeClientList_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::ClientList::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                        OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(const chip::app::DataModel::DecodableList<chip::ClusterId> & clientList)
    {
        auto iter = clientList.begin();
        VerifyOrReturn(CheckNoMoreListItems<decltype(clientList)>("clientList", iter, 0));
        NextTest();
    }

    CHIP_ERROR TestReadAttributePartsList_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::DescriptorClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Descriptor::Attributes::PartsList::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                       OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(const chip::app::DataModel::DecodableList<chip::EndpointId> & partsList)
    {
        auto iter = partsList.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(partsList)>("partsList", iter, 0));
        VerifyOrReturn(CheckValue<chip::EndpointId>("partsList[0]", iter.GetValue(), 1U));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(partsList)>("partsList", iter, 1));
        VerifyOrReturn(CheckValue<chip::EndpointId>("partsList[1]", iter.GetValue(), 2U));
        VerifyOrReturn(CheckNoMoreListItems<decltype(partsList)>("partsList", iter, 2));
        NextTest();
    }
};

class TestBasicInformation : public TestCommand
{
public:
    TestBasicInformation() : TestCommand("TestBasicInformation"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestBasicInformation\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestBasicInformation\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read location\n");
            err = TestReadLocation_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Write location\n");
            err = TestWriteLocation_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read back location\n");
            err = TestReadBackLocation_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Restore initial location value\n");
            err = TestRestoreInitialLocationValue_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, chip::CharSpan location)
    {
        (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_0(location);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context) { (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_1(); }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, chip::CharSpan location)
    {
        (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_2(location);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestBasicInformation *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context) { (static_cast<TestBasicInformation *>(context))->OnSuccessResponse_3(); }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadLocation_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                 OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("", 0)));
        NextTest();
    }

    CHIP_ERROR TestWriteLocation_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("usgarbage: not in length on purpose", 2);

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1() { NextTest(); }

    CHIP_ERROR TestReadBackLocation_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                 OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("us", 2)));
        NextTest();
    }

    CHIP_ERROR TestRestoreInitialLocationValue_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_3, OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }
};

class TestIdentifyCluster : public TestCommand
{
public:
    TestIdentifyCluster() : TestCommand("TestIdentifyCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestIdentifyCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestIdentifyCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Send Identify command and expect success response\n");
            err = TestSendIdentifyCommandAndExpectSuccessResponse_0();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 1;

    //
    // Tests methods
    //

    CHIP_ERROR TestSendIdentifyCommandAndExpectSuccessResponse_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        using RequestType               = chip::app::Clusters::Identify::Commands::Identify::Type;

        RequestType request;
        request.identifyTime = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestIdentifyCluster *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestIdentifyCluster *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }
};

class TestGroupsCluster : public TestCommand
{
public:
    TestGroupsCluster() : TestCommand("TestGroupsCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : View Group 0 (invalid)\n");
            err = TestViewGroup0Invalid_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : View Group 1 (not found)\n");
            err = TestViewGroup1NotFound_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Add Group 1 (new)\n");
            err = TestAddGroup1New_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : View Group 1 (new)\n");
            err = TestViewGroup1New_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : View Group 2 (not found)\n");
            err = TestViewGroup2NotFound_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : View Group 3 (not found)\n");
            err = TestViewGroup3NotFound_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : View Group 1 (existing)\n");
            err = TestViewGroup1Existing_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Remove Group 0 (invalid)\n");
            err = TestRemoveGroup0Invalid_7();
            break;
        case 8:
            ChipLogProgress(chipTool, " ***** Test Step 8 : Remove Group 4 (not found)\n");
            err = TestRemoveGroup4NotFound_8();
            break;
        case 9:
            ChipLogProgress(chipTool, " ***** Test Step 9 : View Group 1 (not removed)\n");
            err = TestViewGroup1NotRemoved_9();
            break;
        case 10:
            ChipLogProgress(chipTool, " ***** Test Step 10 : View Group 2 (removed)\n");
            err = TestViewGroup2Removed_10();
            break;
        case 11:
            ChipLogProgress(chipTool, " ***** Test Step 11 : Remove All\n");
            err = TestRemoveAll_11();
            break;
        case 12:
            ChipLogProgress(chipTool, " ***** Test Step 12 : View Group 1 (removed)\n");
            err = TestViewGroup1Removed_12();
            break;
        case 13:
            ChipLogProgress(chipTool, " ***** Test Step 13 : View Group 2 (still removed)\n");
            err = TestViewGroup2StillRemoved_13();
            break;
        case 14:
            ChipLogProgress(chipTool, " ***** Test Step 14 : View Group 3 (removed)\n");
            err = TestViewGroup3Removed_14();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 15;

    //
    // Tests methods
    //

    CHIP_ERROR TestViewGroup0Invalid_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_0(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 135));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 0U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1NotFound_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_1(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_1(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 139));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 1U));

        NextTest();
    }

    CHIP_ERROR TestAddGroup1New_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::AddGroup::Type;

        RequestType request;
        request.groupId   = 1U;
        request.groupName = chip::Span<const char>("Group #1garbage: not in length on purpose", 8);

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_2(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_2(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 0));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 1U));
        NextTest();
    }

    CHIP_ERROR TestViewGroup1New_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_3(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 0));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));
        NextTest();
    }

    CHIP_ERROR TestViewGroup2NotFound_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_4(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_4(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 139));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup3NotFound_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 32767U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_5(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 139));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 32767U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup1Existing_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_6(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_6(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 0));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));
        NextTest();
    }

    CHIP_ERROR TestRemoveGroup0Invalid_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveGroup::Type;

        RequestType request;
        request.groupId = 0U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_7(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_7(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 135));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 0U));
        NextTest();
    }

    CHIP_ERROR TestRemoveGroup4NotFound_8()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveGroup::Type;

        RequestType request;
        request.groupId = 4U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_8(data.status, data.groupId);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_8(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_8(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_8(uint8_t status, uint16_t groupId)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 139));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 4U));
        NextTest();
    }

    CHIP_ERROR TestViewGroup1NotRemoved_9()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_9(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_9(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_9(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_9(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 0));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 1U));

        VerifyOrReturn(CheckValueAsString("groupName", groupName, chip::CharSpan("Group #1", 8)));
        NextTest();
    }

    CHIP_ERROR TestViewGroup2Removed_10()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_10(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_10(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_10(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_10(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 139));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestRemoveAll_11()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::RemoveAllGroups::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_11();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_11(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_11(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_11() { NextTest(); }

    CHIP_ERROR TestViewGroup1Removed_12()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 1U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_12(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_12(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_12(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_12(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 139));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 1U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup2StillRemoved_13()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 4369U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_13(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_13(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_13(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_13(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 139));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 4369U));

        NextTest();
    }

    CHIP_ERROR TestViewGroup3Removed_14()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::Groups::Commands::ViewGroup::Type;

        RequestType request;
        request.groupId = 32767U;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestGroupsCluster *>(context))->OnSuccessResponse_14(data.status, data.groupId, data.groupName);
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestGroupsCluster *>(context))->OnFailureResponse_14(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_14(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_14(uint8_t status, uint16_t groupId, chip::CharSpan groupName)
    {
        VerifyOrReturn(CheckValue<uint8_t>("status", status, 139));

        VerifyOrReturn(CheckValue<uint16_t>("groupId", groupId, 32767U));

        NextTest();
    }
};

class TestOperationalCredentialsCluster : public TestCommand
{
public:
    TestOperationalCredentialsCluster() : TestCommand("TestOperationalCredentialsCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestOperationalCredentialsCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestOperationalCredentialsCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read number of supported fabrics\n");
            err = TestReadNumberOfSupportedFabrics_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read number of commissioned fabrics\n");
            err = TestReadNumberOfCommissionedFabrics_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read current fabric index\n");
            err = TestReadCurrentFabricIndex_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t supportedFabrics)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_0(supportedFabrics);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t commissionedFabrics)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_1(commissionedFabrics);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, chip::FabricIndex currentFabricIndex)
    {
        (static_cast<TestOperationalCredentialsCluster *>(context))->OnSuccessResponse_2(currentFabricIndex);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadNumberOfSupportedFabrics_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::SupportedFabrics::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t supportedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("supportedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("supportedFabrics", supportedFabrics, 4));
        NextTest();
    }

    CHIP_ERROR TestReadNumberOfCommissionedFabrics_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CommissionedFabrics::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t commissionedFabrics)
    {
        VerifyOrReturn(CheckConstraintType("commissionedFabrics", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<uint8_t>("commissionedFabrics", commissionedFabrics, 1));
        NextTest();
    }

    CHIP_ERROR TestReadCurrentFabricIndex_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::OperationalCredentialsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::OperationalCredentials::Attributes::CurrentFabricIndex::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(chip::FabricIndex currentFabricIndex)
    {
        VerifyOrReturn(CheckConstraintType("currentFabricIndex", "", "uint8"));
        VerifyOrReturn(CheckConstraintMinValue<chip::FabricIndex>("currentFabricIndex", currentFabricIndex, 1));
        NextTest();
    }
};

class TestModeSelectCluster : public TestCommand
{
public:
    TestModeSelectCluster() : TestCommand("TestModeSelectCluster"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestModeSelectCluster\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestModeSelectCluster\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Read CurrentMode\n");
            err = TestReadCurrentMode_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read OnMode\n");
            err = TestReadOnMode_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Read StartUpMode\n");
            err = TestReadStartUpMode_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read Description\n");
            err = TestReadDescription_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Read SupportedModes\n");
            err = TestReadSupportedModes_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Change to Supported Mode\n");
            err = TestChangeToSupportedMode_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Verify Current Mode Change\n");
            err = TestVerifyCurrentModeChange_6();
            break;
        case 7:
            ChipLogProgress(chipTool, " ***** Test Step 7 : Change to Unsupported Mode\n");
            err = TestChangeToUnsupportedMode_7();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 8;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint8_t currentMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_0(currentMode);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint8_t onMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_1(onMode);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint8_t startUpMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_2(startUpMode);
    }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan description)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_3(description);
    }

    static void OnFailureCallback_4(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_4(chip::to_underlying(status));
    }

    static void OnSuccessCallback_4(
        void * context,
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_4(supportedModes);
    }

    static void OnFailureCallback_6(void * context, EmberAfStatus status)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_6(chip::to_underlying(status));
    }

    static void OnSuccessCallback_6(void * context, uint8_t currentMode)
    {
        (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_6(currentMode);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadCurrentMode_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::CurrentMode::TypeInfo>(this, OnSuccessCallback_0,
                                                                                                         OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0(uint8_t currentMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentMode", currentMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadOnMode_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::OnMode::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                    OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(uint8_t onMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("onMode", onMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadStartUpMode_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::StartUpMode::TypeInfo>(this, OnSuccessCallback_2,
                                                                                                         OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(uint8_t startUpMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("startUpMode", startUpMode, 0));
        NextTest();
    }

    CHIP_ERROR TestReadDescription_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::Description::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                         OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::CharSpan description)
    {
        VerifyOrReturn(CheckValueAsString("description", description, chip::CharSpan("Coffee", 6)));
        NextTest();
    }

    CHIP_ERROR TestReadSupportedModes_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::SupportedModes::TypeInfo>(
            this, OnSuccessCallback_4, OnFailureCallback_4);
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &
            supportedModes)
    {
        auto iter = supportedModes.begin();
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 0));
        VerifyOrReturn(CheckValueAsString("supportedModes[0].label", iter.GetValue().label, chip::CharSpan("Black", 5)));
        VerifyOrReturn(CheckValue<>("supportedModes[0].mode", iter.GetValue().mode, 0));
        VerifyOrReturn(CheckValue<>("supportedModes[0].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 1));
        VerifyOrReturn(CheckValueAsString("supportedModes[1].label", iter.GetValue().label, chip::CharSpan("Cappuccino", 10)));
        VerifyOrReturn(CheckValue<>("supportedModes[1].mode", iter.GetValue().mode, 4));
        VerifyOrReturn(CheckValue<>("supportedModes[1].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNextListItemDecodes<decltype(supportedModes)>("supportedModes", iter, 2));
        VerifyOrReturn(CheckValueAsString("supportedModes[2].label", iter.GetValue().label, chip::CharSpan("Espresso", 8)));
        VerifyOrReturn(CheckValue<>("supportedModes[2].mode", iter.GetValue().mode, 7));
        VerifyOrReturn(CheckValue<>("supportedModes[2].semanticTag", iter.GetValue().semanticTag, 0UL));
        VerifyOrReturn(CheckNoMoreListItems<decltype(supportedModes)>("supportedModes", iter, 3));
        NextTest();
    }

    CHIP_ERROR TestChangeToSupportedMode_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type;

        RequestType request;
        request.newMode = 4;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestVerifyCurrentModeChange_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::ModeSelectClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::ModeSelect::Attributes::CurrentMode::TypeInfo>(this, OnSuccessCallback_6,
                                                                                                         OnFailureCallback_6);
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(uint8_t currentMode)
    {
        VerifyOrReturn(CheckValue<uint8_t>("currentMode", currentMode, 4));
        NextTest();
    }

    CHIP_ERROR TestChangeToUnsupportedMode_7()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::ModeSelect::Commands::ChangeToMode::Type;

        RequestType request;
        request.newMode = 2;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestModeSelectCluster *>(context))->OnSuccessResponse_7();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestModeSelectCluster *>(context))->OnFailureResponse_7(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_7(uint8_t status) { NextTest(); }

    void OnSuccessResponse_7() { ThrowSuccessResponse(); }
};

class TestGroupMessaging : public TestCommand
{
public:
    TestGroupMessaging() : TestCommand("TestGroupMessaging"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestGroupMessaging\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestGroupMessaging\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Group Write Attribute\n");
            err = TestGroupWriteAttribute_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Read back Attribute\n");
            err = TestReadBackAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Restore initial location value\n");
            err = TestRestoreInitialLocationValue_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Read back Attribute\n");
            err = TestReadBackAttribute_3();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 4;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<TestGroupMessaging *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context) { (static_cast<TestGroupMessaging *>(context))->OnSuccessResponse_0(); }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<TestGroupMessaging *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, chip::CharSpan location)
    {
        (static_cast<TestGroupMessaging *>(context))->OnSuccessResponse_1(location);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<TestGroupMessaging *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context) { (static_cast<TestGroupMessaging *>(context))->OnSuccessResponse_2(); }

    static void OnFailureCallback_3(void * context, EmberAfStatus status)
    {
        (static_cast<TestGroupMessaging *>(context))->OnFailureResponse_3(chip::to_underlying(status));
    }

    static void OnSuccessCallback_3(void * context, chip::CharSpan location)
    {
        (static_cast<TestGroupMessaging *>(context))->OnSuccessResponse_3(location);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestGroupWriteAttribute_0()
    {
        const chip::GroupId groupId = 1234;
        chip::Controller::BasicClusterTest cluster;
        cluster.AssociateWithGroup(mDevice, groupId);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("usgarbage: not in length on purpose", 2);

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReadBackAttribute_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_1,
                                                                                                 OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("us", 2)));
        NextTest();
    }

    CHIP_ERROR TestRestoreInitialLocationValue_2()
    {
        const chip::GroupId groupId = 1234;
        chip::Controller::BasicClusterTest cluster;
        cluster.AssociateWithGroup(mDevice, groupId);

        chip::CharSpan locationArgument;
        locationArgument = chip::Span<const char>("garbage: not in length on purpose", 0);

        return cluster.WriteAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(
            locationArgument, this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2() { NextTest(); }

    CHIP_ERROR TestReadBackAttribute_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 0;
        chip::Controller::BasicClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::Basic::Attributes::Location::TypeInfo>(this, OnSuccessCallback_3,
                                                                                                 OnFailureCallback_3);
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3(chip::CharSpan location)
    {
        VerifyOrReturn(CheckValueAsString("location", location, chip::CharSpan("", 0)));
        NextTest();
    }
};

class Test_TC_DIAGSW_1_1 : public TestCommand
{
public:
    Test_TC_DIAGSW_1_1() : TestCommand("Test_TC_DIAGSW_1_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGSW_1_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGSW_1_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Reads CurrentHeapFree non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Reads CurrentHeapUsed non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Reads CurrentHeapHighWaterMark non-global attribute value from DUT\n");
            err = TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_2();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 3;

    static void OnFailureCallback_0(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_0(chip::to_underlying(status));
    }

    static void OnSuccessCallback_0(void * context, uint64_t currentHeapFree)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_0(currentHeapFree);
    }

    static void OnFailureCallback_1(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_1(chip::to_underlying(status));
    }

    static void OnSuccessCallback_1(void * context, uint64_t currentHeapUsed)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_1(currentHeapUsed);
    }

    static void OnFailureCallback_2(void * context, EmberAfStatus status)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnFailureResponse_2(chip::to_underlying(status));
    }

    static void OnSuccessCallback_2(void * context, uint64_t currentHeapHighWatermark)
    {
        (static_cast<Test_TC_DIAGSW_1_1 *>(context))->OnSuccessResponse_2(currentHeapHighWatermark);
    }

    //
    // Tests methods
    //

    CHIP_ERROR TestReadsCurrentHeapFreeNonGlobalAttributeValueFromDut_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapFree::TypeInfo>(
            this, OnSuccessCallback_0, OnFailureCallback_0);
    }

    void OnFailureResponse_0(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_0(uint64_t currentHeapFree)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapFree", "", "uint64"));
        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapUsedNonGlobalAttributeValueFromDut_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapUsed::TypeInfo>(
            this, OnSuccessCallback_1, OnFailureCallback_1);
    }

    void OnFailureResponse_1(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_1(uint64_t currentHeapUsed)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapUsed", "", "uint64"));
        NextTest();
    }

    CHIP_ERROR TestReadsCurrentHeapHighWaterMarkNonGlobalAttributeValueFromDut_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::SoftwareDiagnosticsClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReadAttribute<chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::TypeInfo>(
            this, OnSuccessCallback_2, OnFailureCallback_2);
    }

    void OnFailureResponse_2(uint8_t status)
    {
        (status == EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE) ? NextTest() : ThrowFailureResponse();
    }

    void OnSuccessResponse_2(uint64_t currentHeapHighWatermark)
    {
        VerifyOrReturn(CheckConstraintType("currentHeapHighWatermark", "", "uint64"));
        NextTest();
    }
};

class Test_TC_DIAGSW_2_1 : public TestCommand
{
public:
    Test_TC_DIAGSW_2_1() : TestCommand("Test_TC_DIAGSW_2_1"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGSW_2_1\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGSW_2_1\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class Test_TC_DIAGSW_3_2 : public TestCommand
{
public:
    Test_TC_DIAGSW_3_2() : TestCommand("Test_TC_DIAGSW_3_2"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: Test_TC_DIAGSW_3_2\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: Test_TC_DIAGSW_3_2\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 0;

    //
    // Tests methods
    //
};

class TestSubscribe_OnOff : public TestCommand
{
public:
    TestSubscribe_OnOff() : TestCommand("TestSubscribe_OnOff"), mTestIndex(0) {}

    /////////// TestCommand Interface /////////
    void NextTest() override
    {
        CHIP_ERROR err = CHIP_NO_ERROR;

        if (0 == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Start: TestSubscribe_OnOff\n");
        }

        if (mTestCount == mTestIndex)
        {
            ChipLogProgress(chipTool, " **** Test Complete: TestSubscribe_OnOff\n");
            SetCommandExitStatus(CHIP_NO_ERROR);
            return;
        }

        Wait();

        // Ensure we increment mTestIndex before we start running the relevant
        // command.  That way if we lose the timeslice after we send the message
        // but before our function call returns, we won't end up with an
        // incorrect mTestIndex value observed when we get the response.
        switch (mTestIndex++)
        {
        case 0:
            ChipLogProgress(chipTool, " ***** Test Step 0 : Set OnOff Attribute to false\n");
            err = TestSetOnOffAttributeToFalse_0();
            break;
        case 1:
            ChipLogProgress(chipTool, " ***** Test Step 1 : Report: Subscribe OnOff Attribute\n");
            err = TestReportSubscribeOnOffAttribute_1();
            break;
        case 2:
            ChipLogProgress(chipTool, " ***** Test Step 2 : Subscribe OnOff Attribute\n");
            err = TestSubscribeOnOffAttribute_2();
            break;
        case 3:
            ChipLogProgress(chipTool, " ***** Test Step 3 : Turn On the light to see attribute change\n");
            err = TestTurnOnTheLightToSeeAttributeChange_3();
            break;
        case 4:
            ChipLogProgress(chipTool, " ***** Test Step 4 : Check for attribute report\n");
            err = TestCheckForAttributeReport_4();
            break;
        case 5:
            ChipLogProgress(chipTool, " ***** Test Step 5 : Turn Off the light to see attribute change\n");
            err = TestTurnOffTheLightToSeeAttributeChange_5();
            break;
        case 6:
            ChipLogProgress(chipTool, " ***** Test Step 6 : Check for attribute report\n");
            err = TestCheckForAttributeReport_6();
            break;
        }

        if (CHIP_NO_ERROR != err)
        {
            ChipLogError(chipTool, " ***** Test Failure: %s\n", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }
    }

private:
    std::atomic_uint16_t mTestIndex;
    const uint16_t mTestCount = 7;

    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_1{ OnFailureCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_1{ OnSuccessCallback_1, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_2{ OnFailureCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_2{ OnSuccessCallback_2, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_4{ OnFailureCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_4{ OnSuccessCallback_4, this };
    chip::Callback::Callback<void (*)(void * context, uint8_t status)> mOnFailureCallback_6{ OnFailureCallback_6, this };
    chip::Callback::Callback<void (*)(void * context, bool onOff)> mOnSuccessCallback_6{ OnSuccessCallback_6, this };

    static void OnFailureCallback_1(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_1(status);
    }

    static void OnSuccessCallback_1(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_1(onOff);
    }

    bool mReceivedReport_1 = false;

    static void OnFailureCallback_2(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_2(status);
    }

    static void OnSuccessCallback_2(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_2(onOff);
    }

    static void OnFailureCallback_4(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_4(status);
    }

    static void OnSuccessCallback_4(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_4(onOff);
    }

    bool mReceivedReport_4 = false;

    static void OnFailureCallback_6(void * context, uint8_t status)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_6(status);
    }

    static void OnSuccessCallback_6(void * context, bool onOff)
    {
        (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_6(onOff);
    }

    bool mReceivedReport_6 = false;

    //
    // Tests methods
    //

    CHIP_ERROR TestSetOnOffAttributeToFalse_0()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_0();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_0(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_0(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_0() { NextTest(); }

    CHIP_ERROR TestReportSubscribeOnOffAttribute_1()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        ReturnErrorOnFailure(cluster.ReportAttributeOnOff(mOnSuccessCallback_1.Cancel()));

        return WaitForMs(0);
    }

    void OnFailureResponse_1(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_1(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_1 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_1 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, false));
    }

    CHIP_ERROR TestSubscribeOnOffAttribute_2()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        uint16_t minIntervalArgument;
        minIntervalArgument = 2U;
        uint16_t maxIntervalArgument;
        maxIntervalArgument = 10U;

        return cluster.SubscribeAttributeOnOff(mOnSuccessCallback_2.Cancel(), mOnFailureCallback_2.Cancel(), minIntervalArgument,
                                               maxIntervalArgument);
    }

    void OnFailureResponse_2(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_2(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_1, Exit("Initial report not received!"));

        NextTest();
    }

    CHIP_ERROR TestTurnOnTheLightToSeeAttributeChange_3()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::On::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_3();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_3(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_3(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_3() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_4()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReportAttributeOnOff(mOnSuccessCallback_4.Cancel());
    }

    void OnFailureResponse_4(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_4(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_4 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_4 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, true));
        NextTest();
    }

    CHIP_ERROR TestTurnOffTheLightToSeeAttributeChange_5()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        using RequestType               = chip::app::Clusters::OnOff::Commands::Off::Type;

        RequestType request;

        auto success = [](void * context, const typename RequestType::ResponseType & data) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnSuccessResponse_5();
        };

        auto failure = [](void * context, EmberAfStatus status) {
            (static_cast<TestSubscribe_OnOff *>(context))->OnFailureResponse_5(status);
        };

        ReturnErrorOnFailure(chip::Controller::InvokeCommand(mDevice, this, success, failure, endpoint, request));
        return CHIP_NO_ERROR;
    }

    void OnFailureResponse_5(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_5() { NextTest(); }

    CHIP_ERROR TestCheckForAttributeReport_6()
    {
        const chip::EndpointId endpoint = mEndpointId.HasValue() ? mEndpointId.Value() : 1;
        chip::Controller::OnOffClusterTest cluster;
        cluster.Associate(mDevice, endpoint);

        return cluster.ReportAttributeOnOff(mOnSuccessCallback_6.Cancel());
    }

    void OnFailureResponse_6(uint8_t status) { ThrowFailureResponse(); }

    void OnSuccessResponse_6(bool onOff)
    {
        VerifyOrReturn(mReceivedReport_6 == false, ChipLogError(chipTool, "Not Fatal: on report called more than once."));
        mReceivedReport_6 = true;

        VerifyOrReturn(CheckValue<bool>("onOff", onOff, false));
        NextTest();
    }
};

void registerCommandsTests(Commands & commands)
{
    const char * clusterName = "Tests";

    commands_list clusterCommands = {
        make_unique<Test_TC_BI_1_1>(),
        make_unique<Test_TC_BI_2_1>(),
        make_unique<Test_TC_BI_2_2>(),
        make_unique<Test_TC_BOOL_1_1>(),
        make_unique<Test_TC_BOOL_2_1>(),
        make_unique<Test_TC_CC_1_1>(),
        make_unique<Test_TC_CC_2_1>(),
        make_unique<Test_TC_CC_3_1>(),
        make_unique<Test_TC_CC_3_2>(),
        make_unique<Test_TC_CC_3_3>(),
        make_unique<Test_TC_CC_4_1>(),
        make_unique<Test_TC_CC_4_2>(),
        make_unique<Test_TC_CC_4_3>(),
        make_unique<Test_TC_CC_4_4>(),
        make_unique<Test_TC_CC_5_1>(),
        make_unique<Test_TC_CC_5_2>(),
        make_unique<Test_TC_CC_5_3>(),
        make_unique<Test_TC_CC_6_1>(),
        make_unique<Test_TC_CC_6_2>(),
        make_unique<Test_TC_CC_6_3>(),
        make_unique<Test_TC_CC_7_1>(),
        make_unique<Test_TC_CC_7_2>(),
        make_unique<Test_TC_CC_7_3>(),
        make_unique<Test_TC_CC_7_4>(),
        make_unique<Test_TC_CC_8_1>(),
        make_unique<Test_TC_CC_9_1>(),
        make_unique<Test_TC_CC_9_2>(),
        make_unique<Test_TC_CC_9_3>(),
        make_unique<Test_TC_DM_1_1>(),
        make_unique<Test_TC_DM_3_1>(),
        make_unique<Test_TC_DM_2_2>(),
        make_unique<Test_TC_EMR_1_1>(),
        make_unique<Test_TC_FLW_1_1>(),
        make_unique<Test_TC_FLW_2_1>(),
        make_unique<Test_TC_FLW_2_2>(),
        make_unique<Test_TC_ILL_1_1>(),
        make_unique<Test_TC_LVL_1_1>(),
        make_unique<Test_TC_LVL_2_1>(),
        make_unique<Test_TC_LVL_3_1>(),
        make_unique<Test_TC_LVL_4_1>(),
        make_unique<Test_TC_LVL_5_1>(),
        make_unique<Test_TC_MC_1_1>(),
        make_unique<Test_TC_MC_2_1>(),
        make_unique<Test_TC_MC_3_1>(),
        make_unique<Test_TC_MC_3_2>(),
        make_unique<Test_TC_MC_3_3>(),
        make_unique<Test_TC_MC_3_4>(),
        make_unique<Test_TC_MC_3_5>(),
        make_unique<Test_TC_MC_3_6>(),
        make_unique<Test_TC_MC_3_7>(),
        make_unique<Test_TC_MC_3_8>(),
        make_unique<Test_TC_MC_3_9>(),
        make_unique<Test_TC_MC_3_10>(),
        make_unique<Test_TC_MC_3_11>(),
        make_unique<Test_TC_OCC_1_1>(),
        make_unique<Test_TC_OCC_2_1>(),
        make_unique<Test_TC_OCC_2_2>(),
        make_unique<Test_TC_OO_1_1>(),
        make_unique<Test_TC_OO_2_1>(),
        make_unique<Test_TC_OO_2_2>(),
        make_unique<Test_TC_OO_2_3>(),
        make_unique<Test_TC_PRS_1_1>(),
        make_unique<Test_TC_PRS_2_1>(),
        make_unique<Test_TC_PCC_1_1>(),
        make_unique<Test_TC_PCC_2_1>(),
        make_unique<Test_TC_PCC_2_2>(),
        make_unique<Test_TC_PCC_2_3>(),
        make_unique<Test_TC_RH_1_1>(),
        make_unique<Test_TC_RH_2_1>(),
        make_unique<Test_TC_RH_2_2>(),
        make_unique<Test_TC_TM_1_1>(),
        make_unique<Test_TC_TM_2_1>(),
        make_unique<Test_TC_TM_2_2>(),
        make_unique<Test_TC_TSTAT_1_1>(),
        make_unique<Test_TC_TSTAT_2_1>(),
        make_unique<Test_TC_TSTAT_2_2>(),
        make_unique<Test_TC_TSUIC_1_1>(),
        make_unique<Test_TC_TSUIC_2_1>(),
        make_unique<Test_TC_TSUIC_2_2>(),
        make_unique<Test_TC_DIAGTH_1_1>(),
        make_unique<Test_TC_WNCV_1_1>(),
        make_unique<Test_TC_WNCV_2_1>(),
        make_unique<Test_TC_WNCV_2_2>(),
        make_unique<Test_TC_WNCV_2_4>(),
        make_unique<Test_TC_WNCV_2_5>(),
        make_unique<Test_TC_WNCV_3_1>(),
        make_unique<Test_TC_WNCV_3_2>(),
        make_unique<Test_TC_WNCV_3_3>(),
        make_unique<TV_TargetNavigatorCluster>(),
        make_unique<TV_AudioOutputCluster>(),
        make_unique<TV_ApplicationLauncherCluster>(),
        make_unique<TV_KeypadInputCluster>(),
        make_unique<TV_AccountLoginCluster>(),
        make_unique<TV_WakeOnLanCluster>(),
        make_unique<TV_ApplicationBasicCluster>(),
        make_unique<TV_MediaPlaybackCluster>(),
        make_unique<TV_TvChannelCluster>(),
        make_unique<TV_LowPowerCluster>(),
        make_unique<TV_MediaInputCluster>(),
        make_unique<TestCluster>(),
        make_unique<TestClusterComplexTypes>(),
        make_unique<TestConstraints>(),
        make_unique<TestDelayCommands>(),
        make_unique<TestLogCommands>(),
        make_unique<TestDescriptorCluster>(),
        make_unique<TestBasicInformation>(),
        make_unique<TestIdentifyCluster>(),
        make_unique<TestGroupsCluster>(),
        make_unique<TestOperationalCredentialsCluster>(),
        make_unique<TestModeSelectCluster>(),
        make_unique<TestGroupMessaging>(),
        make_unique<Test_TC_DIAGSW_1_1>(),
        make_unique<Test_TC_DIAGSW_2_1>(),
        make_unique<Test_TC_DIAGSW_3_2>(),
        make_unique<TestSubscribe_OnOff>(),
    };

    commands.Register(clusterName, clusterCommands);
}
